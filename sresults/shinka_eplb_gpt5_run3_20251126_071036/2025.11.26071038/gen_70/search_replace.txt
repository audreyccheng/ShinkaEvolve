<NAME>
adaptive_tail_cv
</NAME>

<DESCRIPTION>
Introduce an adaptive tail length for replica allocation based on the dispersion of expert loads. Instead of a fixed 10% Sainte-Laguë/Huntington–Hill tail, compute a coefficient of variation (CV) across experts per row, clamp it to [0.7, 1.3], and average across rows to get a dispersion factor s. Set tail = round(alpha · num_redundant · s) with alpha=0.10, clamped to [1, num_redundant]. This keeps the algorithm fast (a couple of reductions) while better adapting replica allocation to imbalance severity, improving balancedness without affecting speed or determinism.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Hybrid allocation: D'Hondt for bulk, then tail A/B between Sainte-Laguë and Huntington–Hill
    tail = max(1, (num_redundant + 9) // 10)
    bulk = num_redundant - tail
=======
    # Hybrid allocation: D'Hondt for bulk, then tail A/B between Sainte-Laguë and Huntington–Hill
    # Make the tail length adaptive to dispersion of loads across experts.
    # Compute per-row coefficient of variation and clamp to [0.7, 1.3], then average.
    alpha = 0.10
    row_mean = weight.mean(dim=-1)
    row_std = weight.std(dim=-1, unbiased=False)
    cv_row = torch.where(row_mean > 0, row_std / row_mean, torch.zeros_like(row_mean))
    s = cv_row.clamp(0.7, 1.3).mean().item()
    tail = 0
    if num_redundant > 0:
        tail = int(round(alpha * num_redundant * s))
        tail = max(1, min(num_redundant, tail))
    bulk = num_redundant - tail
>>>>>>> REPLACE

</DIFF>