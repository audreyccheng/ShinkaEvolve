<NAME>
broaden_feasibility_variants_and_diversify_candidates
</NAME>

<DESCRIPTION>
This edit improves the KVPR minimization by (1) broadening the feasibility checks during the T-search to include minmax and hybrid policies with multiple orderings, which can find feasible placements at lower T than the residual-only checks; (2) slightly enlarging the neighborhood of T values used to build final candidates; and (3) adding a ratio-desc best-fit memory packing candidate to diversify initial solutions. These targeted changes are lightweight, preserve correctness, and can reduce the final maximum KVPR without significantly impacting runtime.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # For feasibility checks during search (keep minimal to stay fast)
        def try_any(T, need_plc=False):
            if need_plc:
                feas = []
                ok0, p0 = try_pack(T, 0, "resid", True)
                ok1, p1 = try_pack(T, 1, "resid", True)
                if ok0: feas.append(p0)
                if ok1: feas.append(p1)
                return (len(feas) > 0), feas
            else:
                return try_pack(T, 0, "resid", False) or try_pack(T, 1, "resid", False)
=======
        # For feasibility checks during search (broaden variants to find smaller feasible T)
        def try_any(T, need_plc=False):
            variants = [
                (0, "resid"), (1, "resid"), (2, "resid"),
                (0, "minmax"), (1, "minmax"),
                (0, "hybrid"), (1, "hybrid")
            ]
            if need_plc:
                feas = []
                for ov, pol in variants:
                    ok, p = try_pack(T, ov, pol, True)
                    if ok:
                        feas.append(p)
                return (len(feas) > 0), feas
            else:
                for ov, pol in variants:
                    if try_pack(T, ov, pol, False):
                        return True
                return False
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Build placements at near-optimal T across multiple orderings and a tiny T-neighborhood
        all_plcs = []
        Ts = [high, high * 0.995, high * 1.005, high * 0.99, high * 1.01]
        combos = [
            (0, "resid"), (1, "resid"), (2, "resid"),
            (0, "minmax"), (1, "minmax"), (2, "minmax"),
            (0, "hybrid"), (1, "hybrid"), (2, "hybrid")
        ]
        for Tv in Ts:
            for ov, pol in combos:
                ok, plc = try_pack(Tv, ov, pol, True)
                if ok:
                    all_plcs.append(plc)
=======
        # Build placements at near-optimal T across multiple orderings and a tiny T-neighborhood
        all_plcs = []
        Ts = [high * 0.985, high * 0.99, high * 0.995, high, high * 1.005, high * 1.01]
        combos = [
            (0, "resid"), (1, "resid"), (2, "resid"),
            (0, "minmax"), (1, "minmax"), (2, "minmax"),
            (0, "hybrid"), (1, "hybrid"), (2, "hybrid")
        ]
        for Tv in Ts:
            for ov, pol in combos:
                ok, plc = try_pack(Tv, ov, pol, True)
                if ok:
                    all_plcs.append(plc)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Candidate B: memory-balanced dual strategy
    plc_dual = memory_pack(order="size_desc", strategy="dual")
    if plc_dual is not None:
        candidates.append(plc_dual)
=======
    # Candidate B: memory-balanced dual strategy
    plc_dual = memory_pack(order="size_desc", strategy="dual")
    if plc_dual is not None:
        candidates.append(plc_dual)

    # Candidate C: ratio-desc best-fit to diversify memory-rate density packing
    plc_ratio = memory_pack(order="ratio_desc", strategy="bestfit")
    if plc_ratio is not None:
        candidates.append(plc_ratio)
>>>>>>> REPLACE

</DIFF>