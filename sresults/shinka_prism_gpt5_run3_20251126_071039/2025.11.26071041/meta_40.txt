# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy KVPR-Minimizing Model Placement**
- **Implementation**: Greedily sorts models by r_j/s_j (req_rate/SLO) descending and assigns each to the GPU with the lowest current weighted_req_rate/remaining_mem among those with enough free memory (80GB per GPU), updating per-GPU totals after placement. It fails fast by raising an error when a model cannot fit, and does not implement a τ-feasibility check or post-placement ratio evaluation.
- **Performance**: Combined score 21.89; max_kvpr 20.892; success_rate 1.000; execution_time 0.000s.
- **Feedback**: The simple ratio-based balancing yields consistently feasible placements with near-zero runtime and strong KVPR results on the evaluator. Potential improvements include choosing GPUs based on the projected ratio after placement, adding τ checks, and avoiding a fixed 80GB assumption to better generalize and further reduce peak KV pressure.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Greedy Min-Max KVPR GPU Placement**
- **Implementation**: Greedy assignment after sorting models by (req_rate/slo)/(80−size), placing each on the GPU that minimizes the resulting global max KVPR with tie-breakers (lower target KVPR, more remaining memory). A bounded local improvement then moves single models from the most-pressured GPU if it strictly reduces the max KVPR; memory fit is enforced and KVPR is R/rem_mem (inf at zero).
- **Performance**: Combined score 23.13; max_kvpr 22.127; success_rate 1.000; execution_time 0.000s.
- **Feedback**: Passed all validations; the sorting heuristic plus lookahead and local hill-climb effectively balances KV cache pressure across GPUs. Infinity handling is minimal when remaining memory hits zero, but this did not affect the provided tests.
**Program Identifier:** Generation 1 - Patch Name balanced_minmax_kvpr - Correct Program: True

**Program Name: Greedy KV Cache Pressure Balancer**
- **Implementation**: Sorts models by (req_rate/slo) per GB and greedily assigns each to the GPU that minimizes the projected maximum KVPR across all GPUs, with tie-breakers on local KVPR, remaining memory, and GPU id. Enforces 80 GB per-GPU memory, avoids overcommit via hard-fit checks, and guards against zero SLO/size with infinities and epsilons.
- **Performance**: Combined score 20.74; max_kvpr 19.743; success_rate 1.000; execution_time ~0.000s.
- **Feedback**: Passes all validation tests; the global-max KVPR lookahead and tie-breakers yield balanced placements without overcommit. Numerical edge-case handling (zero SLO/size) improves stability and consistency across test cases.
**Program Identifier:** Generation 2 - Patch Name minimax_greedy_kvpr - Correct Program: True

**Program Name: Greedy + Local Search KVPR Balancer**
- **Implementation**: Greedy min-max placement guided by multiple model orderings; for each placement step, it picks the GPU that minimizes the resulting global max KVPR with memory-aware tie-breaks. It then applies bounded local improvement (best-improving single moves from the max-pressure GPU and capped pairwise swaps) using per-GPU sum(r/s) and remaining memory tracking, with infeasible fits rejected.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.002s.
- **Feedback**: Correct and passed all validations; multi-ordering plus local refinement consistently produced balanced placements with low peak pressure. The fixed 80 GB per-GPU assumption and capped improvement iterations trade some optimality for speed and robustness.
**Program Identifier:** Generation 3 - Patch Name multi_heuristic_and_swap_improvement - Correct Program: True

**Program Name: Greedy-MinMax KVPR Placement with Parametric Search**
- **Implementation**: Uses multi-ordering greedy min–max assignment with lookahead and tie-breakers, then bounded local improvement (single-move and capped pairwise swaps), assuming 80 GB/GPU. It further runs a binary search over target KVPR using a transformed capacity model and best-fit-decreasing packing (w = dR + T*size; capacity = T*S), adopting the refined placement if it improves the max KVPR.
- **Performance**: Achieved combined score 26.17 with max_kvpr 25.168, 100% success rate, and 0.002s runtime.
- **Feedback**: The diverse orderings, lookahead placement, and capped local search provided robust, fast placements that passed all validation tests. Parametric refinement effectively tightened worst-case KVPR when feasible, while safety checks (infinite-rememory handling and feasibility bounds) prevented invalid placements.
**Program Identifier:** Generation 4 - Patch Name parametric_bsearch_bfd - Correct Program: True

**Program Name: Binary-searched best-fit KVPR placement**
- **Implementation**: Uses a transformed-capacity formulation w_i(T)=n_i+T*m_i with per-GPU cap 80*T, performing exponential search to find a feasible T and binary search to minimize it, then packs via best-fit decreasing under two orderings (transformed weight and intrinsic pressure). Includes strict input validation, global/individual lower bounds, small numerical slack, a quality-based post-selection, and a greedy fallback, returning a complete GPU-id mapping.
- **Performance**: Combined score 26.23; max_kvpr 25.233; success_rate 1.000; execution_time 0.001s.
- **Feedback**: Dual ordering plus post-selection by measured KVPR yields consistently feasible, near-optimal placements with excellent speed. The fixed 80 GB constraint and robust feasibility checks improved stability and prevented invalid allocations, contributing to perfect success across tests.
**Program Identifier:** Generation 5 - Patch Name kvpr_bisect_packing - Correct Program: True

**Program Name: KVPR-Minimizing GPU Model Placement**
- **Implementation**: Uses a transformed-capacity bin packing with KVPR threshold T (exponential search for feasibility, binary search to tighten), packing via five ordering variants with tie-breakers to minimize global max KVPR, plus candidate scoring, a greedy fallback, and a local hill-climbing improvement pass. Enforces single-GPU fit, safe divisions, and returns a full GPU-indexed placement map.
- **Performance**: Combined score 25.43; max_kvpr 24.426; success_rate 1.000; execution_time 0.009s.
- **Feedback**: The mix of ordering variants and local improvement reliably finds feasible, balanced placements quickly, yielding perfect success and very low runtime. Evaluation indicates the strategy effectively controls worst-case KVPR across GPUs.
**Program Identifier:** Generation 6 - Patch Name kvpr_bisect_pack_local_search - Correct Program: True

**Program Name: Greedy-Refined KVPR Balancer**
- **Implementation**: Uses a greedy min–max assignment with lookahead and tie-breakers across multiple orderings (pressure weight, r/s, size asc/desc, density), followed by capped local move/swap improvements. It then binary-searches a target KVPR and applies Best-Fit-Decreasing with transformed weights w = dR + T*size to further tighten placement, with 80 GB/GPU and safety checks enforced.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.002s.
- **Feedback**: Consistently finds feasible, low-pressure placements and passes all validation tests, indicating correctness and robustness. The layered greedy+local+parametric refinement and thoughtful tie-breakers likely drive both quality and speed.
**Program Identifier:** Generation 7 - Patch Name parametric_refinement_bsearch - Correct Program: True

**Program Name: KVPR-Aware GPU Placement with Local Search**
- **Implementation**: Computes per-model demand (req_rate/slo) and defines KVPR as demand over remaining GPU memory. Builds initial placements via KVPR-focused regret-based insertion and a memory-oriented dual packing (max-free then best-fit), then applies bounded move/swap local search to minimize the global max KVPR and selects the best candidate.
- **Performance**: Achieved combined score 26.01 with max_kvpr 25.012, 100% success rate, and 0.001s execution time.
- **Feedback**: KVPR-aware initialization plus local improvement effectively balances load and keeps pressure low across GPUs, with strict memory feasibility checks. The method is fast and robust across test cases; KVPR-based tie-breaking improves stability in edge placements.
**Program Identifier:** Generation 8 - Patch Name regret_waterfill_swaps - Correct Program: True

**Program Name: KVPR-optimized bin packing with binary search**
- **Implementation**: Uses per-item/global lower bounds and an exponential+binary search on a KVPR threshold T, reducing placement to a transformed bin-packing (cap=T*80, weight=n_i+T*m_i) under memory constraints. Applies best-fit-decreasing with two ordering variants and selects the placement with the lowest measured max KVPR; includes strict input validation and safe division.
- **Performance**: Combined score 26.23; max_kvpr 25.233; success_rate 1.000; execution_time 0.001s.
- **Feedback**: The dual-ordering heuristic plus near-optimal T search consistently found feasible placements with low KVPR while remaining extremely fast. Robust validation (e.g., per-GPU memory, SLO > 0, oversized models) improved stability and ensured all tests passed.
**Program Identifier:** Generation 9 - Patch Name dual_bisect_bfd - Correct Program: True

**Program Name: Minimax KVPR GPU Placement with BFD Refinement**
- **Implementation**: Multi-ordering greedy min-max placement with lookahead and tie-breakers, followed by local improvement via capped single-item moves and pairwise swaps. A final binary search on target KVPR uses BFD over transformed weights (dR + T·size) with validation, adopting improvements.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.021s.
- **Feedback**: Passed all validation tests; the layered heuristics plus parametric BFD tightening produced balanced, feasible placements with very low runtime. Robustness benefited from multiple orderings, careful tie-breaking, and explicit handling of infeasible single-model cases.
**Program Identifier:** Generation 10 - Patch Name kvpr_minimax_param_refine - Correct Program: True

**Program Name: KVPR-Minimizing GPU Model Placer**
- **Implementation**: Performs binary search on a KVPR threshold T and reduces feasibility to transformed-capacity bin packing (weight n + T*m, capacity T*80) with two-phase seeding and best/first-fit variants. Establishes strong lower bounds (per-item, global, pairwise, k-prefix), generates multiple candidate placements around T, and applies local move/swap search to reduce the max per-GPU KVPR.
- **Performance**: Combined score 24.55; max_kvpr 23.551; success_rate 1.000; execution_time 0.003s.
- **Feedback**: The multi-bound initialization, diversified packing variants, and local search achieved low maximum KVPR with perfect feasibility and very low latency. Potential minor improvements could come from broader candidate diversification or adaptive seeding, but the current implementation already passes all validation tests.
**Program Identifier:** Generation 11 - Patch Name kvpr_parametric_hybrid_ls - Correct Program: True

**Program Name: KVPR-minimizing placement with LB and packing**
- **Implementation**: Computes tight lower bounds (per-item, global, pair, k-bin) on target KVPR T, then performs transformed bin packing with weights w = dR + T*size using BFD/FFD variants, seeding by intrinsic pressure, and deterministic tie-breaking, with a greedy KVPR fallback. Selects among candidate T values by measured max-KVPR and applies bounded local refinement (targeted moves and swaps) plus safety checks.
- **Performance**: Combined score 25.73 (max_kvpr 24.730), success_rate 1.000, execution_time 0.001s.
- **Feedback**: Passed all validations with excellent speed; LB-guided sweeping and local refinement effectively reduce the worst-case KVPR. Additional variant exploration or deeper local search could yield marginal improvements while maintaining low latency.
**Program Identifier:** Generation 12 - Patch Name pairbound_threshold_sweep - Correct Program: True

**Program Name: KVPR-aware GPU placement with binary search and refinement**
- **Implementation**: Computes a lower bound on KVPR threshold T, then performs exponential+binary search with feasibility packing using transformed weights w(T)=n+T*m across multiple item orderings and policies. It generates diverse candidates, selects the lowest measured max-KVPR placement, and applies a local move-based improvement; includes strict memory/SLO checks and fills all GPU keys.
- **Performance**: Combined score 26.23; max_kvpr 25.233; success_rate 1.000; execution_time 0.004s.
- **Feedback**: Multi-variant packing plus local refinement consistently finds near-optimal placements with perfect success and very low runtime. The w(T)-based search with tight lower bounds is stable, and the greedy min-max fallback boosts robustness.
**Program Identifier:** Generation 13 - Patch Name hybrid_tsearch_minmax_local - Correct Program: True

**Program Name: Balanced-slack KVPR Minimization**
- **Implementation**: Computes tight lower bounds for the KVPR threshold T (per-item, global, pairwise, k-bin) and finds a feasible T via a multiplicative sweep while packing with a slack-equalization bin packer (weight w=dR+T*size), seeded ordering, and min-K_after/min-KVPR tie-breaks with slight randomization. Around the first feasible T it explores multiple orderings, applies targeted move/swap local refinement, and uses strict memory/KVPR checks with a deterministic greedy fallback for feasibility.
- **Performance**: Combined score 36.51; success_rate 1.000; execution_time 0.002s; reported max_kvpr metric 35.512.
- **Feedback**: Lower-bound-guided T search plus equalized-slack packing quickly yields balanced placements, with local refinement providing incremental improvements. Robust handling of edge cases (e.g., slo==0), deterministic seeding, and validation checks led to reliable, passing results across all tests.
**Program Identifier:** Generation 14 - Patch Name slack_equalization_t_search - Correct Program: True

**Program Name: KVPR-Minimizing GPU Model Placement with Slack Equalization**
- **Implementation**: Computes tight lower bounds (per-item, global, pairwise, k-bin) on target KV pressure, then packs via a slack-equalization scheduler with weight w=dR+T*size, exploring multiple orderings, tie-breakers, and deterministic randomness. Feasible T is found by a multiplicative sweep, followed by variant trials and a local refine phase (moves/swaps) plus a greedy fallback and strict safety checks.
- **Performance**: Combined score 25.99 (max_kvpr 24.988; success_rate 1.000; execution_time 0.003s).
- **Feedback**: Lower-bound-guided T selection and K-slack equalization with local refinement effectively balances memory and request rates, yielding low max KVPR and perfect feasibility at very low runtime. The greedy fallback robustly covers slo==0/infeasible cases, and deterministic seeding ensures reproducibility.
**Program Identifier:** Generation 15 - Patch Name kvpr_balanced_param_local - Correct Program: True

**Program Name: KVPR-Minimizing GPU Placement**
- **Implementation**: Lower-bound–guided search on a KVPR threshold combined with transformed bin packing (w_i = n_i + T*m_i, cap = T*80) under strict per-GPU memory constraints, using two ordering heuristics and exponential warm-up followed by binary search. Near-optimal candidates are measured by actual KVPR and refined via local moves and first-improving swaps to reduce the worst GPU pressure.
- **Performance**: Combined score 24.44; max_kvpr 23.442; success_rate 1.000; execution_time 0.001s.
- **Feedback**: Strong bounds (per-item, global, pair, k-prefix) tighten the initial feasible region and speed convergence, while dual orderings and local refinement improve packings around the optimal threshold. The approach is robust (100% success) and extremely fast; remaining improvements would likely come from enhanced local search or additional ordering strategies.
**Program Identifier:** Generation 16 - Patch Name tighter_bounds_and_local_refine - Correct Program: True

**Program Name: Balanced-Slack KVPR Placement**
- **Implementation**: Uses strong lower bounds (per-item, global, pairwise, k-bin) to seed a balanced-slack bin packing that minimizes max KVPR by packing weights w = dR + T*s with multiple orderings, light deterministic randomization, and strict validation. It then applies localized move/swap refinement and selects the best among refined, search-based, and greedy fallback placements (fallback also covers dR=inf cases).
- **Performance**: Combined score 25.99 with max_kvpr 24.988, success_rate 1.000, execution_time 0.003s.
- **Feedback**: Bound-guided search plus local refinement consistently yields low max KVPR while remaining very fast, and the greedy fallback ensures robustness in edge cases (e.g., SLO=0 or tight memory). Final memory checks and candidate selection contribute to reliability without noticeable runtime cost.
**Program Identifier:** Generation 17 - Patch Name tsearch_local_refine_fix - Correct Program: True

**Program Name: Min-Max KV Cache Pressure Placement**
- **Implementation**: Computes tight lower bounds (per-item, global, heavy-pair, k-prefix) on the KVPR threshold T, then performs exponential+binary search with a T-aware best-fit/min-max packer across multiple orderings. Diversifies candidates around near-optimal T, adds a demand-per-GB greedy baseline, and applies single-move and swap local search to reduce the measured max KVPR.
- **Performance**: Combined score 25.70; max_kvpr 24.702; success_rate 1.000; execution_time 0.004s.
- **Feedback**: The program is correct and passes all validation tests. Strong bounds plus candidate diversification and local improvement yield robust, low-pressure placements while remaining extremely fast.
**Program Identifier:** Generation 18 - Patch Name pair_kprefix_t_perturb_and_swaps - Correct Program: True

**Program Name: KVPR-Minimizing GPU Placement via Search and Local Moves**
- **Implementation**: Computes tight lower bounds (individual, global, pair-based, k-bin), then uses exponential+binary search on a KVPR threshold T, packing with transformed weights w(T)=n+T*m under multiple ordering/policy heuristics. It selects the best measured placement, adds a greedy min-max candidate, and performs bounded local improvements via moves and swaps.
- **Performance**: Combined score 25.67 with max_kvpr 24.667, 100% success rate, and 0.004s execution time.
- **Feedback**: The method is correct and robust, consistently finding feasible placements that balance KV cache pressure with very low latency. The mix of diverse heuristics and local refinement likely drives the strong KVPR; exploring more variants or deeper local search could yield marginal gains.
**Program Identifier:** Generation 19 - Patch Name t_perturb_kbin_pairbounds_swap_local - Correct Program: True

**Program Name: Greedy-Search KVPR Balancer for GPU Placement**
- **Implementation**: Greedy min–max assignment with lookahead and tie-breaking (favoring lower resulting max KVPR, lower per-GPU KVPR, then more remaining memory), followed by bounded local improvements (single-model moves and capped pairwise swaps). Seeds with multiple model orderings, picks the best, then runs a parametric binary search on target KVPR using best-fit-decreasing in a transformed space, with optional final refinement and robust feasibility checks.
- **Performance**: Achieved combined score 26.17 with max_kvpr 25.168, 100% success rate, and 0.002s execution time.
- **Feedback**: Ensemble seeding plus the parametric feasibility pass yielded consistent, fast placements that passed all validations. Further gains may come from expanding swap neighborhoods or adaptive iteration budgets, but the current approach is already efficient and robust.
**Program Identifier:** Generation 20 - Patch Name add_parametric_refinement - Correct Program: True

**Program Name: Min-Max KVPR GPU Model Placement**
- **Implementation**: Greedy min-max placement with lookahead and deterministic tie-breaking is followed by local improvement (move/swap) and multiple candidate orderings. It then runs a parametric binary search on T using a transformed capacity model (w = dR + T*size) with a best-fit decreasing assigner, bounded by several lower bounds, and optional refinement.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.003s.
- **Feedback**: The layered approach (heuristics + parametric search) effectively reduces worst-case KVPR while keeping runtime low, and it consistently produced feasible placements. Strong feasibility checks, careful tie-breaking, and capped local search iterations improved stability and robustness across test cases.
**Program Identifier:** Generation 21 - Patch Name hybrid_bfd_and_bounds - Correct Program: True

**Program Name: KVPR-Aware Multi-Stage GPU Placement**
- **Implementation**: Uses a multi-stage heuristic: greedy min-max assignment with KVPR lookahead and deterministic tie-breaking, followed by local improvements (single moves, pairwise swaps, and length-2 eject chains). It explores multiple model orderings, selects the best by (max, second, avg) KVPR, then applies a parametric Best-Fit-Decreasing with binary search on a KVPR target using several lower bounds, and optionally refines the result.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.002s.
- **Feedback**: The multi-start ordering plus targeted local search and parametric refinement effectively reduces peak KVPR while maintaining speed, yielding robust placements and 100% success. Iteration caps, careful tie-breaking, and bound-guided binary search contribute to stability and fast convergence, and the solution passed all validation tests.
**Program Identifier:** Generation 22 - Patch Name bfd_kbounds_ejectchain_tielex - Correct Program: True

**Program Name: Threshold-guided KVPR min-max placement**
- **Implementation**: Computes tight lower bounds (individual/global/pair/triplet/k-prefix) to initialize an exponential+binary search over a KVPR threshold T, then packs using multiple orderings (w(T)=n+T·m, intrinsic KVPR, demand/GB) and policies (residual, minmax, hybrid) under a transformed capacity model. Generates diverse candidates near-optimal T, adds a greedy min-max baseline, selects by measured KVPR, and applies local improvements (moves, swaps, two-opt); enforces 80 GB per-GPU and input validity.
- **Performance**: Combined score 25.76; max_kvpr 24.760; success_rate 1.000; execution_time 0.006s.
- **Feedback**: The program is correct and passes all validation tests. Candidate diversity plus local search consistently achieves low max KVPR with very fast runtime; bounded combinatorics in LB and swap stages maintain efficiency.
**Program Identifier:** Generation 23 - Patch Name triplet_bound_hybrid_policy_2opt_tiebreak - Correct Program: True

**Program Name: KVPR-Aware Multi-Strategy Placement**
- **Implementation**: Combines a parametric T-based bin packing (with lower bounds, exponential/binary search, and two orderings) with KVPR-aware regret insertion and memory heuristics, then applies local move/swap search to minimize the global max KVPR. It generates multiple candidates, evaluates by measured max KVPR, and uses strict validations, tie-breakers, and feasibility fallbacks.
- **Performance**: Combined score 26.19; max_kvpr 25.192; success_rate 1.000; execution_time 0.003s.
- **Feedback**: Delivers consistently feasible, low-KVPR placements at very low runtime; the parametric initialization plus local search notably improves quality. Passed all validation tests, and numerical guards/fallback strategies enhance robustness across diverse cases.
**Program Identifier:** Generation 24 - Patch Name add_parametric_T_candidates - Correct Program: True

**Program Name: Min-Max KVPR GPU Placement**
- **Implementation**: Uses greedy lookahead assignment across multiple model orderings with strict tie-breaking, then applies a capped local improvement phase (move/swap) to reduce the maximum KV cache pressure. It further performs a binary search on a KVPR target using transformed weights and several analytic lower bounds to tighten solutions, while enforcing memory feasibility.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.030s.
- **Feedback**: Multi-heuristic seeding plus limited local search provides robust, fast placements, and the parametric refinement reliably lowers worst-case pressure. The approach balances solution quality and speed well, though the fixed 80 GB GPU memory assumption should be parameterized for broader applicability.
**Program Identifier:** Generation 25 - Patch Name hybrid_bfd_and_tighter_bounds - Correct Program: True

**Program Name: Slack-Equalized KVPR GPU Placement**
- **Implementation**: Uses tight lower bounds (single/global/pair/triplet/k-prefix) and a multiplicative sweep over T to drive a slack-equalization assignment (w = dR + T*size) with seeding, ordering variants, dynamic T updates, and a local move/swap refinement; includes a greedy KVPR-minimizing fallback for infeasible cases.
- **Performance**: Combined score 24.52; max_kvpr 23.518; success_rate 1.000; execution_time 0.004s.
- **Feedback**: The multi-bound initialization and dynamic slack updating quickly find feasible low-KVPR placements, while local refinement reduces peak pressure further. Greedy fallback for slo=0 models safeguards feasibility, contributing to 100% success with very low runtime.
**Program Identifier:** Generation 26 - Patch Name kvpr_two_phase_slack - Correct Program: True

**Program Name: Slack-Equalized KVPR-Minimizing Model Placement**
- **Implementation**: Computes strong lower bounds for T (max KVPR), then performs a multiplicative sweep to a feasible T and packs using KV-slack equalization with weights w=dR+T*s and K_g=T*S−(sumR_g+T*mem_g), trying multiple orderings and tie-breakers. Includes a deterministic greedy fallback for infeasible/infinite-demand cases and a bounded local move/swap refinement to reduce the worst-GPU KVPR.
- **Performance**: Combined score 36.51; max_kvpr 35.512; success_rate 1.000; execution_time 0.002s.
- **Feedback**: The lower-bound-guided search plus local refinement produced consistently feasible, high-quality placements with very low latency and perfect success. Edge cases with zero-SLO/infinite demand are handled via the greedy path, which zeroes their pressure in sums—robust for feasibility but potentially conservative for optimality.
**Program Identifier:** Generation 27 - Patch Name slack_bsearch_hybrid - Correct Program: True

**Program Name: Min-Max KVPR GPU Model Placement**
- **Implementation**: Uses a greedy, lookahead min-max placement with lexicographic KVPR scoring across multiple model orderings, followed by local move/swap improvements. Adds a parametric binary search on target KVPR using transformed best-fit packing with multiple lower bounds, then selects the best candidate and optionally refines it.
- **Performance**: Combined score 26.17; max_kvpr 25.168; success_rate 1.000; execution_time 0.004s.
- **Feedback**: The multi-heuristic pipeline and careful tie-breaking yield low worst-case KVPR with perfect feasibility and very fast runtime. Lower-bound seeding stabilizes the binary search, and clear fallbacks make the solver robust across test cases.
**Program Identifier:** Generation 28 - Patch Name lex_triplet_hybrid - Correct Program: True

**Program Name: Balanced-slack KVPR minimization with local search**
- **Implementation**: Uses lower-bound-guided target-KVPR (T) search with a balanced-slack bin packer (weight = dR + T*size), multiple orderings/tie-breaks, and seeding of high-pressure items. Augments with multi-order greedy placement, bounded move/swap local refinements, a binary search to tighten T, deterministic RNG, and strict memory/KVPR validation with a greedy fallback.
- **Performance**: Combined score 29.35 (max_kvpr 28.347, success_rate 1.000) with 0.003s execution time.
- **Feedback**: The multi-heuristic T-sweep plus local refinement reliably reduces peak KVPR while maintaining feasibility; fallback paths handle edge cases (e.g., infinite dR or tight memory). Passed all validation tests, indicating correctness and robustness.
**Program Identifier:** Generation 29 - Patch Name kvpr_balanced_bsearch - Correct Program: True

**Program Name: KVPR-Minimizing GPU Placement with Dynamic Bounds**
- **Implementation**: Uses multiple analytical lower bounds (individual, global, pair, triplet, k-prefix) to bound T, then performs exponential search plus binary search for a feasible threshold with multi-order, multi-policy packers (residual, minmax, hybrid) and a dynamic mid-pack T refinement. Generates diverse candidates and applies local improvement (single-item moves, swaps, and 2-opt between worst GPUs) to minimize the measured max KVPR under strict memory checks.
- **Performance**: Combined score 25.76, success_rate 1.000, max_kvpr 24.760, execution_time 0.008s.
- **Feedback**: The combination of strong bounds, diversified packing heuristics, and targeted local search yields robust, high-quality placements and very fast runtime, passing all validations. Minor tuning (e.g., hybrid weights or expanded swap neighborhoods) might further tighten the max KVPR, but current results are already strong.
**Program Identifier:** Generation 30 - Patch Name two_phase_t_update - Correct Program: True

**Program Name: KVPR-Minimizing GPU Placement with Bounds and Heuristics**
- **Implementation**: Computes tight lower bounds on the KVPR threshold T (individual, global, pair, triplet, k-prefix), searches T via exponential then binary search, and packs with multiple orderings/policies (residual/minmax/hybrid) including a two-phase reordering; selects among diverse candidates (plus a greedy min-max) and applies local improvements (single moves, swaps, targeted 2-opt).
- **Performance**: Combined score 25.76 with max_kvpr 24.760, 100% success rate, and 0.033s execution time.
- **Feedback**: Diverse heuristics and local refinement produce strong balance (low max KVPR) and robustness across cases, while tight bounds accelerate feasibility checks and reduce search iterations; the solution is correct and passes all tests.
**Program Identifier:** Generation 31 - Patch Name two_phase_t_update_and_t_neighborhood - Correct Program: True

**Program Name: Balanced-Slack KVPR GPU Placement**
- **Implementation**: Computes multiple lower bounds and applies a balanced-slack packer using w = dR + T*s and K_g = T*S - (sumR + T*used) to test feasibility while sweeping/binary-searching T with varied orderings, seeding, and light randomization. Augments with a greedy constructor plus local move/swap refinements and a safe greedy fallback to guarantee feasibility under memory constraints.
- **Performance**: Combined score 29.35; max_kvpr 28.347; success_rate 1.000; execution_time 0.006s.
- **Feedback**: Passed all validation tests; the bound-guided search and local refinement achieved low max KVPR efficiently. The fallback and stochastic tie-breaking improved robustness across diverse inputs.
**Program Identifier:** Generation 32 - Patch Name two_phase_t_and_bounds_hybrid - Correct Program: True

**Program Name: KVPR-Minimizing Multi-GPU Model Placement Planner**
- **Implementation**: Uses a parametric KVPR threshold T with strong lower bounds (per-item, global, heavy pair/triplet, k-prefix), searching T via exponential then binary search. Packing employs three selection rules (tight, min_kvpr, hybrid), explores a T-neighborhood of candidates, scores by (max, second, avg KVPR), and applies bounded local refinements (moves, swaps, short eject chains).
- **Performance**: Combined score 24.14; max_kvpr 23.137; success_rate 1.000; execution_time 0.007s.
- **Feedback**: The diversified candidate generation plus local refinement effectively reduces peak KVPR while maintaining balance, achieving perfect feasibility and very fast execution. Robust validation and the two-phase in-placement T bump improve stability and packing tightness; the program is correct and passes all tests.
**Program Identifier:** Generation 33 - Patch Name kvpr_balanced_parametric_planner - Correct Program: True

**Program Name: Min-Max KV Cache Placement**
- **Implementation**: Uses analytic lower bounds to bracket a KVPR threshold T, then performs exponential/binary search while packing with transformed weights w = n + T*m under 80GB per-GPU memory. Explores multiple ordering/policy variants, selects the best by KVPR profile, and applies local move/swap refinements targeting the worst GPU.
- **Performance**: Combined score 25.74; max_kvpr 24.741; success_rate 1.000; execution_time 0.012s.
- **Feedback**: Bound-guided search plus diverse heuristic candidates yielded consistently feasible, near-optimal placements with very low runtime. Local improvements further balanced peak pressure, and robust checks (memory fit, non-co-resident bounds) ensured correctness and stability.
**Program Identifier:** Generation 34 - Patch Name tighten_bounds_and_candidates_plus_swaps - Correct Program: True

**Program Name: Min-Max KVPR GPU Placement**
- **Implementation**: Combines a parametric T-based bin-packing transform (with indiv/global/pair/k-prefix lower bounds and binary search) and a KVPR-aware regret insertion, followed by local move/swap search to minimize the global max KVPR; also builds memory-oriented packings as fallbacks and selects the best candidate by measured KVPR. Input validation and safe division guard feasibility and numerical stability.
- **Performance**: Achieved combined score 26.22 (max_kvpr 25.220; success_rate 1.000; execution_time 0.016s).
- **Feedback**: Multi-start candidates plus local improvement deliver consistent feasibility and low peak pressure, reflected in 100% success and fast runtime; the T-search and KVPR-aware scoring appear to drive most of the gains. Further gains may be possible by tuning candidate ordering/policies or adapting GPU_MEM_SIZE dynamically, but current implementation already passes all validations.
**Program Identifier:** Generation 35 - Patch Name t_neighborhood_minmax_pack - Correct Program: True

**Program Name: KVPR-Minimizing GPU Model Placement**
- **Implementation**: Builds multiple candidate placements using parametric T-based transformed packing (with individual/global/pair/k-prefix lower bounds and best-fit/min-max policies), regret-based insertion, and memory-oriented heuristics, then refines via local search (move/swap and targeted 2-opt) to reduce global max KVPR. Enforces 80 GB GPU memory constraints, uses safe division and tie-breaking by local KVPR/residuals, and selects the best placement by measured max KVPR.
- **Performance**: Combined score 26.23 with max_kvpr 25.231, 100% success rate, and 0.008s runtime.
- **Feedback**: Passed all validation tests with robust, fast performance; near-optimal T search plus multi-candidate seeding and local improvements drive low KVPR and high reliability. The approach scales efficiently while maintaining feasibility under tight memory constraints.
**Program Identifier:** Generation 36 - Patch Name t_neighborhood_and_hybrid_policy - Correct Program: True

**Program Name: Dual-fit KVPR Minimization for GPU Placement**
- **Implementation**: Computes tight lower bounds, then searches the minimal feasible KVPR threshold via exponential plus binary search, packing with a Lagrangian dual “water-filling” heuristic (multiple orderings, subgradient updates) and light repair; near-optimal candidates are locally refined, with greedy and best-fit fallbacks for guaranteed feasibility. Robust input validation and safe divisions handle edge cases.
- **Performance**: Combined score 25.11; max_kvpr 24.110; success_rate 1.000; execution_time 0.067s.
- **Feedback**: Consistently produced feasible, low-pressure placements, indicating the dual-based packing, candidate diversification, and local refinement effectively reduce peak KVPR. Tight bounds and limited dual iterations delivered strong efficiency without sacrificing solution quality.
**Program Identifier:** Generation 37 - Patch Name dual_waterfill_minmax - Correct Program: True

**Program Name: Balanced-Slack KVPR-Minimizing GPU Placement**
- **Implementation**: Computes strong lower bounds (per-item, global, pairwise, k-bin) then does a multiplicative search over T with a balanced-slack bin packing (w = dR + T*size) using multiple orderings, seeding, and slight randomization, followed by local move/swap refinement. Includes a memory-safe greedy fallback minimizing local KVPR increases, with special handling for slo=0 and infeasible cases; assumes GPU_MEM_SIZE=80 GB.
- **Performance**: Combined score 36.51; max_kvpr 35.512; success_rate 1.000; execution_time 0.002s.
- **Feedback**: Consistently finds feasible, low-KVPR placements and passes all validation tests. The lower-bound-guided T sweep plus local refinement effectively reduces worst-GPU pressure, while the greedy fallback ensures robustness on edge cases (e.g., infinite dR from slo=0).
**Program Identifier:** Generation 38 - Patch Name balanced_slack_refine_simple - Correct Program: True

**Program Name: Softmax-guided KVPR-balanced GPU placement**
- **Implementation**: Uses exponentiated-gradient soft assignment minimizing a softmax potential of KVPR, followed by deterministic rounding that minimizes objective increase, with a memory-first greedy fallback and local move/swap refinement. Assumes 80 GB GPUs, treats SLO=0 with a large surrogate rate (1e9), and enforces post-refinement memory safety.
- **Performance**: Achieved combined score 22.50 with success_rate 1.000, max_kvpr 21.498, and execution_time 0.002s.
- **Feedback**: Soft assignment plus targeted refinement effectively balances peak KVPR while maintaining feasibility, leading to consistent success across tests; fallback was rarely needed. Parameter choices (beta=7.0, eta=0.12, bounded move/swap budgets) provide a solid speed-quality tradeoff.
**Program Identifier:** Generation 39 - Patch Name softmax_dual_balance - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Slack-equalization around a KVPR threshold T is the standout winner. The current best program, Balanced-Slack KVPR-Minimizing GPU Placement (Generation 38, combined score 36.51, 0.002s), explicitly equalizes per-GPU KV slack K_g = T·S − (ΣR_g + T·mem_g) using weights w = dR + T·size and selects placements that minimize nonnegative K_after. This mirrors the previously identified top approach (Gen 27, slack_bsearch_hybrid, 36.51) and clearly outperforms transformed-space BFD pipelines.
- Compact multiplicative T search plus a small T-neighborhood delivers large gains at negligible cost. The best program finds the first feasible T via multiplicative growth (1.08), then evaluates a tight neighborhood {0.99, 1.0, 1.005, 1.02}·T_feas plus the midpoint. This reduces iterations and stabilizes quality, improving on earlier balanced-slack variants (e.g., Gen 32 at 29.35) and outscoring extensive binary-search-based pipelines (e.g., Gens 30–31 at 25.76).
- Tight lower bounds (per-item, global, pair, k-prefix) consistently accelerate feasibility checks. Programs that compute these bounds repeatedly show strong speed and reliability (e.g., Gen 30 at 25.76, Gen 31 at 25.76, Gen 34 at 25.74, Gen 37 at 25.11). The current best uses these bounds to seed T and prune search effectively.
- Targeted, bounded local refinement focused on the worst GPU reliably trims peak KVPR with minimal overhead. The best program applies capped moves and swaps (move_budget=20, swap_budget=10) after packing, echoing prior successes. Similar bounded refinements appear in strong mid-tier performers (e.g., Gen 33 at 24.14).

## Ineffective Approaches
- Non-slack-based soft assignment underperforms despite speed. Softmax-guided KVPR-balanced GPU placement (Gen 39) achieves a low combined score of 22.50 (0.002s), indicating that exponentiated-gradient soft assignment plus rounding does not align tightly with the T-feasibility structure of KVPR and fails to minimize the true peak pressure.
- Heuristic diversity without direct slack equalization plateaus. Extensive bound sets and multi-order/multi-policy packers with binary or exponential search (e.g., Gen 30 at 25.76; Gen 31 at 25.76 with two-phase T update and neighborhood; Gen 34 at 25.74) do not break past the 25–26 range, even with local swaps/2-opt.
- Increased complexity without proportional objective alignment hurts efficiency and doesn’t improve quality. The dual water-filling method (Gen 37, 25.11) is the slowest (0.067s) yet scores below the 26 cluster, suggesting that subgradient/dual machinery adds overhead without translating to lower max KVPR.
- Transformed-space best-fit alone (w = dR + T·size) tops out around the mid-20s. Programs relying primarily on BFD-style transforms and binary search (e.g., Gen 35 at 26.22; Gen 36 at 26.23) remain behind slack-equalization even with regret insertion, hybrid policies, and local improvements.

## Implementation Insights
- Why the current best works:
  - It integrates slack equalization directly into the feasibility check: per-item weights w = dR + T·size, per-GPU slack K_g, and selection by minimal nonnegative K_after, with tie-breakers by memory slack and local KVPR. This makes each placement decision T-aware and globally consistent with the objective.
  - It uses a multiplicative feasibility sweep (growth=1.08) from tight lower bounds to find T_feas, then tests a compact T-neighborhood around T_feas. This replaces heavier binary search with faster convergence while preserving solution quality.
  - It diversifies packings with multiple orderings/rules (w_desc/intrinsic/density/size; choose_rule tight vs min_kvpr), light randomized tie-breaking among top-2 close candidates, and deterministic seeding of high intrinsic-pressure items. This enhances robustness without bloating runtime.
  - It applies a short, worst-GPU-focused local search (moves then swaps, bounded budgets) to reduce the global max KVPR, followed by strict memory/KVPR validations and a safe greedy fallback for edge cases (e.g., slo=0).
- Concrete coding patterns tied to performance:
  - Precompute dR and sizes, treat slo=0 carefully (infeasible in slack packer; guarded in fallback/local search) to avoid division issues.
  - Lower bounds include per-item, global, pair (filtered to top-200 by size), and k-prefix (k up to 4), which reliably prune T. These appear across high-performers (Gens 30–31, 34, 37) and in the best program.
  - Deterministic small randomness (seeded rng) is used only for near-ties, improving tie-breaking without sacrificing reproducibility or speed.
  - Feasibility-first design: packers enforce memory/T constraints during assignment and verify post-conditions, preventing expensive repair cycles observed in more complex pipelines.

## Performance Analysis
- The current best program (Gen 38) achieves the top combined score 36.51 with the fastest runtime (0.002s), matching the previously reported best (Gen 27, 36.51). This establishes slack-equalization + multiplicative T sweep + bounded local refinement as both the most accurate and most efficient approach in this cohort.
- Balanced-slack variants show clear upward trajectory: Gen 32 scored 29.35 before converging to 36.51 in Gen 38 via tighter T search (multiplicative + small T-neighborhood), streamlined packer choices, and bounded refinement.
- Non-slack pipelines cluster substantially lower despite rich heuristics and bounds: Gen 30 and 31 at 25.76, Gen 34 at 25.74, Gen 35 at 26.22, Gen 36 at 26.23, and Gen 37 at 25.11. These commonly use exponential/binary T search and transformed-space packing, confirming the plateau previously observed.
- Method complexity does not correlate positively with score: the dual water-filling method (Gen 37) is slower (0.067s) and scores lower (25.11) than simpler, slack-equalized methods. Conversely, the best method is also among the fastest (0.002s), indicating that direct alignment with the KVPR threshold model yields both quality and speed.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Pre-place slo==0 (memory-only) models before slack packing. Distribute all models with slo==0 by largest-size-first to the GPUs with the largest remaining memory (pure memory balancing), freeze them, reduce per-GPU capacity S accordingly, then run the balanced-slack packer on the remaining items. Recompute all lower bounds on the residual instance to avoid rejecting placements due to the current “dR=inf” guard.

2. Add adaptive in-placement T retuning with residual bounds. After placing roughly 40% of items, recompute a residual lower bound using the remaining items and the current per-GPU residual capacities; set T’ = max(T, residual_lb), rebuild weights w = dR + T’·size, re-sort, and continue. If K-variance across GPUs remains high after 75% of items, do a second, lighter retune (no reordering, just update T and use the existing order) to correct mid-pack discretization.

3. Strengthen and reuse lower bounds during the multiplicative sweep. Implement a light triplet bound on the top P=120 items by size by checking O(P^2) pairs with k from the top-8, and extend the k-prefix bound to k up to min(gpu_num, 6); set T ≥ (ri+rj+rk)/(3S − (si+sj+sk)) when applicable. During find_first_feasible_T, early-jump T to the current maximum bound whenever the sweep falls below it, reducing iterations and stabilizing T_feas.

4. Introduce a hybrid slack-aware choose_rule J and evaluate it alongside existing rules. Use J = K_after_norm + α·kv_new_norm + β·mem_imbalance, where K_after_norm = max(0, K_after)/(T·S), kv_new_norm = kv_new/max(T, 1e-12), mem_imbalance = |(used_mem_g + size)/S − avg_mem_frac|, with α=0.15, β=0.05 and raise α→0.25 when var(K) drops below a small threshold (e.g., 0.02·(T·S)^2). Run this rule in both the feasibility search and T-neighborhood evaluation to harvest residual KVPR gains without abandoning slack equalization