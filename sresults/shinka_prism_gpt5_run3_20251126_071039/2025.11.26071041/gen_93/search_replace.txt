<NAME>
fix_t_bracket_triplet_bound
</NAME>

<DESCRIPTION>
I improve the T bracketing and lower bounds to better minimize the maximum KVPR. Specifically:
1) Correct the binary search bracketing by setting the upper bound to the first feasible T (T_feas) instead of using the current best measured KVPR, which has mismatched units. This aligns the search on T strictly with feasibility and reduces the maximum KVPR.
2) Add a narrow neighborhood probing around the tightened feasible T to pick the best measured KVPR.
3) Strengthen lower bounds by extending the k-prefix bound to k â‰¤ min(gpu_num, 6) and adding a lightweight triplet bound over top-by-size items. These bounds reduce unnecessary T growth, providing tighter starting points.
These targeted changes are simple, consistent with existing code, and should safely improve placement quality without significant runtime overhead.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Pair bound: for pairs that cannot co-reside (s_i + s_j > S)
        lb_pair = 0.0
        P = min(len(items), 200)
        by_size = sorted(items, key=lambda x: x['size'], reverse=True)[:P]
        for i in range(len(by_size)):
            si = by_size[i]['size']; ri = by_size[i]['dR']
            for j in range(i + 1, len(by_size)):
                sj = by_size[j]['size']; rj = by_size[j]['dR']
                if si + sj > S:
                    denom = 2 * S - (si + sj)
                    if denom > 0:
                        ri_f = 0.0 if ri == float('inf') else ri
                        rj_f = 0.0 if rj == float('inf') else rj
                        cand = (ri_f + rj_f) / denom
                        if cand > lb_pair:
                            lb_pair = cand

        # k-bin prefix bound for k in {1..min(gpu_num,4)}
        lb_k = 0.0
        sorted_by_size = sorted(items, key=lambda x: x['size'], reverse=True)
        prefix_sizes = []
        prefix_rates = []
        cs = 0.0; cr = 0.0
        for it in sorted_by_size:
            cs += it['size']; cr += (0.0 if it['dR'] == float('inf') else it['dR'])
            prefix_sizes.append(cs); prefix_rates.append(cr)
        for k in range(1, min(gpu_num, 4) + 1):
            threshold = (k - 1) * S
            idx = -1
            for t in range(len(prefix_sizes)):
                if prefix_sizes[t] > threshold:
                    idx = t
                    break
            if idx >= 0:
                numer = prefix_rates[idx]
                denom = k * S - prefix_sizes[idx]
                if denom > 0 and numer > 0:
                    cand = numer / denom
                    if cand > lb_k:
                        lb_k = cand

        lower = max(0.0, lb1, lb2, lb_pair, lb_k)
        return lower, False, infeasible_single
=======
        # Pair bound: for pairs that cannot co-reside (s_i + s_j > S)
        lb_pair = 0.0
        P = min(len(items), 200)
        by_size = sorted(items, key=lambda x: x['size'], reverse=True)[:P]
        for i in range(len(by_size)):
            si = by_size[i]['size']; ri = by_size[i]['dR']
            for j in range(i + 1, len(by_size)):
                sj = by_size[j]['size']; rj = by_size[j]['dR']
                if si + sj > S:
                    denom = 2 * S - (si + sj)
                    if denom > 0:
                        ri_f = 0.0 if ri == float('inf') else ri
                        rj_f = 0.0 if rj == float('inf') else rj
                        cand = (ri_f + rj_f) / denom
                        if cand > lb_pair:
                            lb_pair = cand

        # Lightweight triplet bound over top-by-size items
        lb_triplet = 0.0
        if len(by_size) >= 3:
            topK = min(8, len(by_size))
            top_items = by_size[:topK]
            for i in range(len(by_size)):
                si = by_size[i]['size']; ri = by_size[i]['dR']
                for j in range(i + 1, len(by_size)):
                    sj = by_size[j]['size']; rj = by_size[j]['dR']
                    for mk in top_items:
                        if mk is by_size[i] or mk is by_size[j]:
                            continue
                        sk = mk['size']; rk = mk['dR']
                        ssum = si + sj + sk
                        if ssum > 2 * S:
                            denom = 3 * S - ssum
                            if denom > 0:
                                ri_f = 0.0 if ri == float('inf') else ri
                                rj_f = 0.0 if rj == float('inf') else rj
                                rk_f = 0.0 if rk == float('inf') else rk
                                cand = (ri_f + rj_f + rk_f) / denom
                                if cand > lb_triplet:
                                    lb_triplet = cand

        # k-bin prefix bound for k in {1..min(gpu_num,6)}
        lb_k = 0.0
        sorted_by_size = sorted(items, key=lambda x: x['size'], reverse=True)
        prefix_sizes = []
        prefix_rates = []
        cs = 0.0; cr = 0.0
        for it in sorted_by_size:
            cs += it['size']; cr += (0.0 if it['dR'] == float('inf') else it['dR'])
            prefix_sizes.append(cs); prefix_rates.append(cr)
        for k in range(1, min(gpu_num, 6) + 1):
            threshold = (k - 1) * S
            idx = -1
            for t in range(len(prefix_sizes)):
                if prefix_sizes[t] > threshold:
                    idx = t
                    break
            if idx >= 0:
                numer = prefix_rates[idx]
                denom = k * S - prefix_sizes[idx]
                if denom > 0 and numer > 0:
                    cand = numer / denom
                    if cand > lb_k:
                        lb_k = cand

        lower = max(0.0, lb1, lb2, lb_pair, lb_triplet, lb_k)
        return lower, False, infeasible_single
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Light binary search on T to tighten the feasible threshold further
    def _feasible_assign_for_T(T):
        best = None
        bestv = float('inf')
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 1),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 1),
            ('intrinsic_desc', 'min_kvpr', 0, 1),
        ]:
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < bestv:
                    bestv = v
                    best = cand
        return best

    lo, hi = max(0.0, lower), max(lower, best_val)
    if hi < float('inf'):
        for _ in range(10):
            mid = (lo + hi) / 2.0
            cand = _feasible_assign_for_T(mid)
            if cand is not None:
                hi = mid
                v = eval_max_kvpr(cand)
                if v < best_val:
                    best_val = v
                    best_placement = cand
            else:
                lo = mid
=======
    # Tightened binary search on T to tighten the feasible threshold further
    def _feasible_assign_for_T(T):
        best = None
        bestv = float('inf')
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 1),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 2),
            ('intrinsic_desc', 'min_kvpr', 0, 1),
        ]:
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < bestv:
                    bestv = v
                    best = cand
        return best

    # Proper bracketing: use the first feasible T as upper bound
    lo, hi = max(0.0, lower), max(0.0, T_feas if T_feas is not None else lower)
    for _ in range(8):
        mid = (lo + hi) / 2.0
        cand = _feasible_assign_for_T(mid)
        if cand is not None:
            hi = mid
            v = eval_max_kvpr(cand)
            if v < best_val:
                best_val = v
                best_placement = cand
        else:
            lo = mid

    # Probe a narrow neighborhood around the tightened feasible T
    for mul in [0.99, 1.0, 1.01]:
        T_probe = max(lower, hi * mul)
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 2),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 2),
        ]:
            cand = assign_balanced_slack(T_probe, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < best_val:
                    best_val = v
                    best_placement = cand
>>>>>>> REPLACE

</DIFF>