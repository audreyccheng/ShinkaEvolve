<NAME>
treat_slo0_as_memory_only_and_expand_variants
</NAME>

<DESCRIPTION>
The current algorithm treats slo==0 models as infinite KV demand, which blocks the balanced-slack placement and forces fallbacks. This hurts optimization quality. I change slo==0 to contribute zero KVPR (memory-only) by setting dR=0.0 and remove the inf guard in the balanced slack assigner. This allows the main optimizer to handle memory-only models properly. Additionally, I expand the packing variants by increasing seeds for the main ordering and adding an intrinsic_desc with min_kvpr variant, which improves exploration and typically reduces the max KVPR. These are minimal, safe changes that align with the earlier high-performing versions and should improve the combined score without introducing complexity.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    for m in models:
        slo = float(m.slo)
        dR = float(m.req_rate) / slo if slo != 0 else float('inf')
        s = float(m.model_size)
        items.append({'obj': m, 'dR': dR, 'size': s})
        total_R += 0.0 if dR == float('inf') else dR
        total_size += s
=======
    for m in models:
        slo = float(m.slo)
        # Treat slo==0 as memory-only: contributes no KVPR but consumes memory
        dR = float(m.req_rate) / slo if slo != 0 else 0.0
        s = float(m.model_size)
        items.append({'obj': m, 'dR': dR, 'size': s})
        total_R += dR
        total_size += s
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        for it in items:
            dR = it['dR']; sz = it['size']
            if dR == float('inf'):
                return None  # cannot handle infinite demand ratios
            w = dR + T * sz
            if w < 0:
                w = 0.0
            enriched.append([w, dR, sz, it['obj']])
=======
        for it in items:
            dR = it['dR']; sz = it['size']
            w = dR + T * sz
            if w < 0:
                w = 0.0
            enriched.append([w, dR, sz, it['obj']])
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    variants = [
        ('w_desc', 'tight', min(4, max(1, gpu_num)), 2),
        ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1))),
        ('density_desc', 'tight', 0),
        ('w_desc', 'min_kvpr', 0),
        ('size_desc', 'tight', 0),
    ]
=======
    variants = [
        ('w_desc', 'tight', min(4, max(1, gpu_num)), 3),
        ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1))),
        ('intrinsic_desc', 'min_kvpr', 0),
        ('density_desc', 'tight', 0),
        ('w_desc', 'min_kvpr', 0),
        ('size_desc', 'tight', 0),
    ]
>>>>>>> REPLACE

</DIFF>