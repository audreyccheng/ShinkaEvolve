<NAME>
t_bracket_triplet_bound
</NAME>

<DESCRIPTION>
I improve the optimization of maximum KVPR by (1) strengthening the lower bound with a lightweight triplet bound and extending the k-prefix bound to k ≤ 6, resulting in a tighter starting point for T; and (2) replacing the flawed “light binary search on T” (which incorrectly used KVPR as a T upper bound) with a proper feasibility-bracketed binary search using the first feasible T (T_feas), followed by a narrow neighborhood probe. These changes maintain simplicity while aligning the search with T-feasibility and consistently reduce peak KVPR without adding significant complexity or runtime.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Lower bounds on optimal T
    def compute_lower_bound():
        # Per-item bound: T >= dR / (S - s)
        lb1 = 0.0
        infeasible_single = False
        for it in items:
            dR = it['dR']; s = it['size']
            denom = S - s
            if denom <= 0:
                if dR > 0 and dR != float('inf'):
                    infeasible_single = True
                elif dR == float('inf'):
                    infeasible_single = True
                continue
            if dR > 0 and dR != float('inf'):
                cand = dR / denom
                if cand > lb1:
                    lb1 = cand

        # Global bound: T >= total_R / (gpu_num*S - total_size)
        denom2 = gpu_num * S - total_size
        if denom2 <= 0 and total_R > 0:
            return float('inf'), True, infeasible_single
        lb2 = 0.0 if total_R <= 0 or denom2 <= 0 else (total_R / denom2)

        # Pair bound: for pairs that cannot co-reside (s_i + s_j > S)
        lb_pair = 0.0
        P = min(len(items), 200)
        by_size = sorted(items, key=lambda x: x['size'], reverse=True)[:P]
        for i in range(len(by_size)):
            si = by_size[i]['size']; ri = by_size[i]['dR']
            for j in range(i + 1, len(by_size)):
                sj = by_size[j]['size']; rj = by_size[j]['dR']
                if si + sj > S:
                    denom = 2 * S - (si + sj)
                    if denom > 0:
                        ri_f = 0.0 if ri == float('inf') else ri
                        rj_f = 0.0 if rj == float('inf') else rj
                        cand = (ri_f + rj_f) / denom
                        if cand > lb_pair:
                            lb_pair = cand

        # k-bin prefix bound for k in {1..min(gpu_num,4)}
        lb_k = 0.0
        sorted_by_size = sorted(items, key=lambda x: x['size'], reverse=True)
        prefix_sizes = []
        prefix_rates = []
        cs = 0.0; cr = 0.0
        for it in sorted_by_size:
            cs += it['size']; cr += (0.0 if it['dR'] == float('inf') else it['dR'])
            prefix_sizes.append(cs); prefix_rates.append(cr)
        for k in range(1, min(gpu_num, 4) + 1):
            threshold = (k - 1) * S
            idx = -1
            for t in range(len(prefix_sizes)):
                if prefix_sizes[t] > threshold:
                    idx = t
                    break
            if idx >= 0:
                numer = prefix_rates[idx]
                denom = k * S - prefix_sizes[idx]
                if denom > 0 and numer > 0:
                    cand = numer / denom
                    if cand > lb_k:
                        lb_k = cand

        lower = max(0.0, lb1, lb2, lb_pair, lb_k)
        return lower, False, infeasible_single
=======
    # Lower bounds on optimal T
    def compute_lower_bound():
        # Per-item bound: T >= dR / (S - s)
        lb1 = 0.0
        infeasible_single = False
        for it in items:
            dR = it['dR']; s = it['size']
            denom = S - s
            if denom <= 0:
                if dR > 0 and dR != float('inf'):
                    infeasible_single = True
                elif dR == float('inf'):
                    infeasible_single = True
                continue
            if dR > 0 and dR != float('inf'):
                cand = dR / denom
                if cand > lb1:
                    lb1 = cand

        # Global bound: T >= total_R / (gpu_num*S - total_size)
        denom2 = gpu_num * S - total_size
        if denom2 <= 0 and total_R > 0:
            return float('inf'), True, infeasible_single
        lb2 = 0.0 if total_R <= 0 or denom2 <= 0 else (total_R / denom2)

        # Pair bound: for pairs that cannot co-reside (s_i + s_j > S)
        lb_pair = 0.0
        P = min(len(items), 200)
        by_size = sorted(items, key=lambda x: x['size'], reverse=True)[:P]
        for i in range(len(by_size)):
            si = by_size[i]['size']; ri = by_size[i]['dR']
            for j in range(i + 1, len(by_size)):
                sj = by_size[j]['size']; rj = by_size[j]['dR']
                if si + sj > S:
                    denom = 2 * S - (si + sj)
                    if denom > 0:
                        ri_f = 0.0 if ri == float('inf') else ri
                        rj_f = 0.0 if rj == float('inf') else rj
                        cand = (ri_f + rj_f) / denom
                        if cand > lb_pair:
                            lb_pair = cand

        # Lightweight triplet bound over top-by-size items
        lb_triplet = 0.0
        if len(by_size) >= 3:
            topK = min(8, len(by_size))
            top_items = by_size[:topK]
            for i in range(len(by_size)):
                si = by_size[i]['size']; ri = by_size[i]['dR']
                for j in range(i + 1, len(by_size)):
                    sj = by_size[j]['size']; rj = by_size[j]['dR']
                    for mk in top_items:
                        if mk is by_size[i] or mk is by_size[j]:
                            continue
                        sk = mk['size']; rk = mk['dR']
                        ssum = si + sj + sk
                        if ssum > 2 * S:
                            denom = 3 * S - ssum
                            if denom > 0:
                                ri_f = 0.0 if ri == float('inf') else ri
                                rj_f = 0.0 if rj == float('inf') else rj
                                rk_f = 0.0 if rk == float('inf') else rk
                                cand = (ri_f + rj_f + rk_f) / denom
                                if cand > lb_triplet:
                                    lb_triplet = cand

        # k-bin prefix bound for k in {1..min(gpu_num,6)}
        lb_k = 0.0
        sorted_by_size = sorted(items, key=lambda x: x['size'], reverse=True)
        prefix_sizes = []
        prefix_rates = []
        cs = 0.0; cr = 0.0
        for it in sorted_by_size:
            cs += it['size']; cr += (0.0 if it['dR'] == float('inf') else it['dR'])
            prefix_sizes.append(cs); prefix_rates.append(cr)
        for k in range(1, min(gpu_num, 6) + 1):
            threshold = (k - 1) * S
            idx = -1
            for t in range(len(prefix_sizes)):
                if prefix_sizes[t] > threshold:
                    idx = t
                    break
            if idx >= 0:
                numer = prefix_rates[idx]
                denom = k * S - prefix_sizes[idx]
                if denom > 0 and numer > 0:
                    cand = numer / denom
                    if cand > lb_k:
                        lb_k = cand

        lower = max(0.0, lb1, lb2, lb_pair, lb_triplet, lb_k)
        return lower, False, infeasible_single
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Light binary search on T to tighten the feasible threshold further
    def _feasible_assign_for_T(T):
        best = None
        bestv = float('inf')
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 1),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 1),
            ('intrinsic_desc', 'min_kvpr', 0, 1),
        ]:
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < bestv:
                    bestv = v
                    best = cand
        return best

    lo, hi = max(0.0, lower), max(lower, best_val)
    if hi < float('inf'):
        for _ in range(10):
            mid = (lo + hi) / 2.0
            cand = _feasible_assign_for_T(mid)
            if cand is not None:
                hi = mid
                v = eval_max_kvpr(cand)
                if v < best_val:
                    best_val = v
                    best_placement = cand
            else:
                lo = mid
=======
    # Tighten T around the feasibility threshold with proper bracketing
    def _feasible_assign_for_T(T):
        best = None
        bestv = float('inf')
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 1),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 2),
            ('intrinsic_desc', 'min_kvpr', 0, 1),
        ]:
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < bestv:
                    bestv = v
                    best = cand
        return best

    # Bracket using the first feasible T found by the sweep
    lo, hi = max(0.0, lower), max(0.0, T_feas if T_feas is not None else lower)
    for _ in range(8):
        mid = (lo + hi) / 2.0
        cand = _feasible_assign_for_T(mid)
        if cand is not None:
            hi = mid
            v = eval_max_kvpr(cand)
            if v < best_val:
                best_val = v
                best_placement = cand
        else:
            lo = mid

    # Probe a narrow neighborhood around the tightened feasible T
    for mul in [0.99, 1.0, 1.01]:
        T_probe = max(lower, hi * mul)
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 2),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 2),
        ]:
            cand = assign_balanced_slack(T_probe, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < best_val:
                    best_val = v
                    best_placement = cand
>>>>>>> REPLACE

</DIFF>