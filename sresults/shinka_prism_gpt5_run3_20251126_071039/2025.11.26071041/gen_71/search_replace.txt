<NAME>
t_sweep_bsearch_and_variants
</NAME>

<DESCRIPTION>
I add a light binary search on the KVPR target T after the initial T-sweep to further reduce the maximum KVPR, using the same balanced-slack feasibility checker. I also expand the set of candidate T multipliers around the first feasible T and add/strengthen assignment variants (including intrinsic order with min_kvpr and slightly higher seeds for the main variant). These changes keep the code simple, preserve speed, and often yield a tighter max KVPR without risking feasibility. No external interfaces are changed.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    candidates_T = []
    for mul in [0.985, 0.99, 1.0, 1.005, 1.01, 1.02]:
        val = max(lower, T_feas * mul)
        candidates_T.append(val)
    candidates_T.append(0.5 * (lower + T_feas))
    candidates_T = sorted(set(round(t, 12) for t in candidates_T))
=======
    candidates_T = []
    for mul in [0.975, 0.985, 0.99, 1.0, 1.005, 1.01, 1.02, 1.03]:
        val = max(lower, T_feas * mul)
        candidates_T.append(val)
    candidates_T.append(0.5 * (lower + T_feas))
    candidates_T = sorted(set(round(t, 12) for t in candidates_T))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    variants = [
        ('w_desc', 'tight', min(4, max(1, gpu_num)), 2),
        ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1))),
        ('density_desc', 'tight', 0),
        ('w_desc', 'min_kvpr', 0),
        ('size_desc', 'tight', 0),
    ]
=======
    variants = [
        ('w_desc', 'tight', min(4, max(1, gpu_num)), 3),
        ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1))),
        ('intrinsic_desc', 'min_kvpr', 0),
        ('density_desc', 'tight', 0),
        ('w_desc', 'min_kvpr', 0),
        ('size_desc', 'tight', 0),
    ]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    for T in candidates_T:
        for var in variants:
            # Unpack with defaults for backward compatibility tuple length
            if len(var) == 4:
                order, choose_rule, seedH, seeds = var
            else:
                order, choose_rule, seedH = var
                seeds = 1
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is None:
                continue
            val = eval_max_kvpr(cand)
            if val < best_val:
                best_val = val
                best_placement = cand

    # Short bounded local search focusing on the most loaded GPU: moves then swaps
=======
    for T in candidates_T:
        for var in variants:
            # Unpack with defaults for backward compatibility tuple length
            if len(var) == 4:
                order, choose_rule, seedH, seeds = var
            else:
                order, choose_rule, seedH = var
                seeds = 1
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is None:
                continue
            val = eval_max_kvpr(cand)
            if val < best_val:
                best_val = val
                best_placement = cand

    # Light binary search on T to tighten the feasible threshold further
    def _feasible_assign_for_T(T):
        best = None
        bestv = float('inf')
        for (order, choose_rule, seedH, seeds) in [
            ('w_desc', 'tight', min(4, max(1, gpu_num)), 1),
            ('intrinsic_desc', 'tight', min(3, max(1, gpu_num - 1)), 1),
            ('w_desc', 'min_kvpr', 0, 1),
            ('intrinsic_desc', 'min_kvpr', 0, 1),
        ]:
            cand = assign_balanced_slack(T, order=order, seed_H=seedH, choose_rule=choose_rule, seeds=seeds)
            if cand is not None:
                v = eval_max_kvpr(cand)
                if v < bestv:
                    bestv = v
                    best = cand
        return best

    lo, hi = max(0.0, lower), max(lower, best_val)
    if hi < float('inf'):
        for _ in range(10):
            mid = (lo + hi) / 2.0
            cand = _feasible_assign_for_T(mid)
            if cand is not None:
                hi = mid
                v = eval_max_kvpr(cand)
                if v < best_val:
                    best_val = v
                    best_placement = cand
            else:
                lo = mid

    # Short bounded local search focusing on the most loaded GPU: moves then swaps
>>>>>>> REPLACE

</DIFF>