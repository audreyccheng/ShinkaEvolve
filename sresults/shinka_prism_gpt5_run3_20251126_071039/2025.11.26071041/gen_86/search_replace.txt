<NAME>
treat_slo_zero_as_memory_only
</NAME>

<DESCRIPTION>
The current algorithm incorrectly treats models with slo==0 as having infinite KV demand, which propagates infinities through feasibility checks, evaluation, and the greedy fallback. This leads to poor placements and inflated KVPR. I modify the code to treat slo==0 models as memory-only (zero KV demand) consistently:

- In item extraction, set dR=0.0 for slo==0 and sum it normally.
- In the greedy fallback, order and account for models with slo==0 using dR=0.0 and remove inf handling.
- In the slack assignment, remove the early return on infinite dR (now impossible) and keep processing.
- In eval_max_kvpr, compute R treating slo==0 as 0.0.

These focused changes align with the earlier higher-scoring variants and should significantly improve feasibility and reduce the maximum KVPR without increasing code complexity or runtime.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        sorted_models = sorted(
            models,
            key=lambda m: ((m.req_rate / m.slo) if m.slo != 0 else float('inf'), m.model_size),
            reverse=True
        )
=======
        sorted_models = sorted(
            models,
            key=lambda m: ((m.req_rate / m.slo) if m.slo != 0 else 0.0, m.model_size),
            reverse=True
        )
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            dR = (m.req_rate / m.slo) if m.slo != 0 else float('inf')
=======
            dR = (m.req_rate / m.slo) if m.slo != 0 else 0.0
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            sum_R[best_gid] +=  dR if dR != float('inf') else 0.0
=======
            sum_R[best_gid] += dR
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    for m in models:
        slo = float(m.slo)
        dR = float(m.req_rate) / slo if slo != 0 else float('inf')
        s = float(m.model_size)
        items.append({'obj': m, 'dR': dR, 'size': s})
        total_R += 0.0 if dR == float('inf') else dR
        total_size += s
=======
    for m in models:
        slo = float(m.slo)
        dR = float(m.req_rate) / slo if slo != 0 else 0.0
        s = float(m.model_size)
        items.append({'obj': m, 'dR': dR, 'size': s})
        total_R += dR
        total_size += s
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if dR == float('inf'):
                return None  # cannot handle infinite demand ratios
=======
            # slo==0 models are treated as memory-only with dR==0.0; no infinite ratios expected
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                R += float(m.req_rate / m.slo) if m.slo != 0 else float('inf')
=======
                R += float(m.req_rate / m.slo) if m.slo != 0 else 0.0
>>>>>>> REPLACE

</DIFF>