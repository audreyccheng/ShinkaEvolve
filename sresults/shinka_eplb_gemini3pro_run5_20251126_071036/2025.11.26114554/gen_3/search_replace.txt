<NAME>
improved_refinement_max_any_v2
</NAME>

<DESCRIPTION>
This change improves the `_refine_packing` function by implementing a "Max-Any" swapping strategy instead of the previous "Max-Min" strategy.

The previous algorithm only attempted to swap items between the pack with the maximum load and the pack with the minimum load. While this reduces variance, it often fails to reduce the maximum load (makespan) if the best swap is between the max-load pack and a "medium-load" pack.

The new algorithm:
1. Identifies the max-load pack.
2. Evaluates swaps between items in the max-load pack and items in *all* other packs.
3. Selects the swap that minimizes the resulting maximum load of the two participating packs.
4. Uses efficient vectorized operations to check all swap combinations.
5. Increases `max_iters` to 50 to allow for more refinement steps, as the operation is vectorized and fast.

This directly targets the makespan objective, which is the primary metric for load balancing.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def _refine_packing(weights: torch.Tensor,
                    pack_indices: torch.Tensor,
                    pack_weights: torch.Tensor,
                    num_packs: int,
                    groups_per_pack: int,
                    max_iters: int = 20) -> torch.Tensor:
    """
    Iteratively refines the packing by swapping items between the max-load
    and min-load packs to reduce variance.

    Args:
        weights: [num_groups] weights of items
        pack_indices: [num_packs, groups_per_pack] indices of items in each pack
        pack_weights: [num_packs] total weight of each pack

    Returns:
        pack_indices: Refined item assignments
    """
    for _ in range(max_iters):
        # Identify extreme packs
        max_load, max_pid = torch.max(pack_weights, dim=0)
        min_load, min_pid = torch.min(pack_weights, dim=0)

        diff = max_load - min_load
        if diff < 1e-6:
            break

        # Get items currently in these packs
        items_max = pack_indices[max_pid] # [groups_per_pack]
        items_min = pack_indices[min_pid] # [groups_per_pack]

        w_max_items = weights[items_max] # [groups_per_pack]
        w_min_items = weights[items_min] # [groups_per_pack]

        # Calculate potential deltas for all pairs: w_i (from max) - w_j (from min)
        # Broadcast: [G, 1] - [1, G] -> [G, G]
        deltas = w_max_items.unsqueeze(1) - w_min_items.unsqueeze(0)

        # We want to perform a swap if it reduces the difference between packs.
        # New diff = |(max - d) - (min + d)| = |diff - 2d|
        # Improvement = diff - |diff - 2d|
        # We also prefer larger reductions.

        scores = diff - torch.abs(diff - 2 * deltas)

        best_score_flat, best_idx_flat = torch.max(scores.flatten(), dim=0)

        if best_score_flat <= 1e-5:
            # No beneficial swap found between these two packs
            break

        # Decode indices
        r_idx = best_idx_flat // groups_per_pack
        c_idx = best_idx_flat % groups_per_pack

        # Execute swap
        item_from_max = items_max[r_idx].item()
        item_from_min = items_min[c_idx].item()

        pack_indices[max_pid, r_idx] = item_from_min
        pack_indices[min_pid, c_idx] = item_from_max

        # Update weights
        delta_val = deltas[r_idx, c_idx]
        pack_weights[max_pid] -= delta_val
        pack_weights[min_pid] += delta_val

    return pack_indices
=======
def _refine_packing(weights: torch.Tensor,
                    pack_indices: torch.Tensor,
                    pack_weights: torch.Tensor,
                    num_packs: int,
                    groups_per_pack: int,
                    max_iters: int = 50) -> torch.Tensor:
    """
    Iteratively refines the packing by swapping items between the max-load
    pack and any other pack to reduce the maximum load.

    Args:
        weights: [num_groups] weights of items
        pack_indices: [num_packs, groups_per_pack] indices of items in each pack
        pack_weights: [num_packs] total weight of each pack

    Returns:
        pack_indices: Refined item assignments
    """
    for _ in range(max_iters):
        # Identify max pack
        max_load, max_pid = torch.max(pack_weights, dim=0)

        # Get items currently in max pack
        items_max = pack_indices[max_pid] # [groups_per_pack]
        w_max_items = weights[items_max] # [groups_per_pack]

        # Get items in all packs
        all_items = pack_indices # [num_packs, groups_per_pack]
        w_all_items = weights[all_items] # [num_packs, groups_per_pack]

        # Calculate deltas for swapping item i from max pack with item j from any pack k
        # delta = w_max_i - w_k_j
        # Positive delta means max pack weight decreases by delta
        # Pack k weight increases by delta

        # [1, 1, G] - [P, G, 1] -> [P, G, G]
        # Dimensions: [Pack k, Item j (in k), Item i (in max)]
        deltas = w_max_items.view(1, 1, -1) - w_all_items.view(num_packs, groups_per_pack, 1)

        # Calculate new loads if swap happens
        # New max pack load: max_load - delta
        # New pack k load: current_k_load + delta

        new_max_load = max_load - deltas
        new_k_load = pack_weights.view(num_packs, 1, 1) + deltas

        # We want to minimize the larger of the two resulting loads
        # Objective: max(new_max_load, new_k_load)
        objectives = torch.max(new_max_load, new_k_load)

        # Mask out swaps with self (k == max_pid)
        objectives[max_pid] = float('inf')

        # Find best swap
        min_obj, flat_idx = torch.min(objectives.flatten(), dim=0)

        # If the best swap doesn't improve the max load significantly, stop
        # We look for strictly better than current max_load
        if min_obj >= max_load - 1e-6:
            break

        # Decode indices
        # flat_idx is index into [P, G, G]
        best_pid = flat_idx // (groups_per_pack * groups_per_pack)
        rem = flat_idx % (groups_per_pack * groups_per_pack)
        best_k_item_idx = rem // groups_per_pack
        best_max_item_idx = rem % groups_per_pack

        # Execute swap
        item_from_max = items_max[best_max_item_idx].item()
        item_from_k = all_items[best_pid, best_k_item_idx].item()

        pack_indices[max_pid, best_max_item_idx] = item_from_k
        pack_indices[best_pid, best_k_item_idx] = item_from_max

        # Update weights
        delta_val = deltas[best_pid, best_k_item_idx, best_max_item_idx]
        pack_weights[max_pid] -= delta_val
        pack_weights[best_pid] += delta_val

    return pack_indices
>>>>>>> REPLACE
</DIFF>