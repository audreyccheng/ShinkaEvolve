<NAME>
k_way_refinement
</NAME>

<DESCRIPTION>
Upgrade the local search refinement in balanced_packing to consider swaps between the heaviest pack and the top-K lightest packs (instead of just the single lightest pack). This helps escape local optima where the heaviest and lightest packs have no valid beneficial swaps, but other light packs do. This vectorized "1-to-K" comparison leverages the GPU's parallelism to explore a larger neighborhood of the solution space efficiently.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Refinement iterations (Max vs Min pack)
    for _ in range(20):
        # Current weights
        p_weights = pack_contents.sum(dim=-1)

        max_val, max_pack = p_weights.max(dim=1)
        min_val, min_pack = p_weights.min(dim=1)
        diff = max_val - min_val

        active_mask = diff > 1e-4
        if not active_mask.any():
            break

        # Extract items from max and min packs: [B, G]
        items_max = pack_contents[row_indices, max_pack]
        items_min = pack_contents[row_indices, min_pack]

        # Compute delta for all pairs: w_max - w_min
        # [B, G, G]
        delta = items_max.unsqueeze(2) - items_min.unsqueeze(1)

        # Improvement: minimize |new_diff| where new_diff = diff - 2*delta
        # Maximize gain = diff - |diff - 2*delta|
        diff_view = diff.view(-1, 1, 1)
        gain = diff_view - (diff_view - 2 * delta).abs()

        # Find best swap
        best_gain, best_idx_flat = gain.view(batch_size, -1).max(dim=1)

        # Determine who swaps
        do_swap = (best_gain > 1e-5) & active_mask

        if not do_swap.any():
            break

        swap_indices = best_idx_flat[do_swap]
        batch_indices_swap = row_indices[do_swap]

        idx_max = swap_indices // groups_per_pack
        idx_min = swap_indices % groups_per_pack

        p_max_swap = max_pack[do_swap]
        p_min_swap = min_pack[do_swap]

        # Execute swaps
        val_max = pack_contents[batch_indices_swap, p_max_swap, idx_max]
        val_min = pack_contents[batch_indices_swap, p_min_swap, idx_min]

        pack_contents[batch_indices_swap, p_max_swap, idx_max] = val_min
        pack_contents[batch_indices_swap, p_min_swap, idx_min] = val_max

        id_max = pack_item_ids[batch_indices_swap, p_max_swap, idx_max]
        id_min = pack_item_ids[batch_indices_swap, p_min_swap, idx_min]

        pack_item_ids[batch_indices_swap, p_max_swap, idx_max] = id_min
        pack_item_ids[batch_indices_swap, p_min_swap, idx_min] = id_max
=======
    # Refinement iterations (Max vs Top-K Lightest packs)
    k_candidates = min(4, num_packs - 1)

    for _ in range(20):
        # Current weights
        p_weights = pack_contents.sum(dim=-1)

        max_val, max_pack = p_weights.max(dim=1)
        # Find K lightest packs
        min_vals, min_packs = p_weights.topk(k_candidates, dim=1, largest=False)

        diffs = max_val.unsqueeze(1) - min_vals  # [B, K]

        active_mask = (diffs.max(dim=1).values > 1e-4)
        if not active_mask.any():
            break

        # Extract items
        items_max = pack_contents[row_indices, max_pack]  # [B, G]

        # Gather items from min packs: [B, K, G]
        gather_idx = min_packs.unsqueeze(2).expand(-1, -1, groups_per_pack)
        items_cands = pack_contents.gather(1, gather_idx)

        # Compute delta for all pairs: w_max - w_cand
        # delta: [B, K, G_max, G_cand]
        delta = items_max.unsqueeze(1).unsqueeze(3) - items_cands.unsqueeze(2)

        # Improvement calculation
        # diffs: [B, K, 1, 1]
        diff_view = diffs.unsqueeze(2).unsqueeze(3)
        gain = diff_view - (diff_view - 2 * delta).abs()

        # Mask invalid swaps (must reduce max)
        gain = torch.where(delta > 0, gain, -1.0)

        # Flatten to find best swap
        gain_flat = gain.view(batch_size, -1)
        best_gain, best_idx_flat = gain_flat.max(dim=1)

        do_swap = (best_gain > 1e-5) & active_mask

        if not do_swap.any():
            break

        swap_flat_idx = best_idx_flat[do_swap]
        b_idx = row_indices[do_swap]

        # Decode indices
        gg = groups_per_pack * groups_per_pack
        k_idx = swap_flat_idx // gg
        rem = swap_flat_idx % gg
        idx_max = rem // groups_per_pack
        idx_min = rem % groups_per_pack

        p_max_swap = max_pack[do_swap]
        p_min_swap = min_packs[do_swap, k_idx]

        # Execute swaps
        val_max = pack_contents[b_idx, p_max_swap, idx_max]
        val_min = pack_contents[b_idx, p_min_swap, idx_min]

        pack_contents[b_idx, p_max_swap, idx_max] = val_min
        pack_contents[b_idx, p_min_swap, idx_min] = val_max

        id_max = pack_item_ids[b_idx, p_max_swap, idx_max]
        id_min = pack_item_ids[b_idx, p_min_swap, idx_min]

        pack_item_ids[b_idx, p_max_swap, idx_max] = id_min
        pack_item_ids[b_idx, p_min_swap, idx_min] = id_max
>>>>>>> REPLACE
</DIFF>