<NAME>
two_item_refinement_v2
</NAME>

<DESCRIPTION>
Enhance the balanced_packing function by adding a "2-for-2" item swap refinement stage.
Currently, the algorithm performs 1-for-1 swaps between heavy and light packs. This can lead to local optima where no single item swap improves balance, but swapping a pair of items would.
The new stage runs after the 1-for-1 refinement. It targets the globally heaviest and lightest packs for each candidate solution. It computes all pairs of items within these packs and evaluates swapping a pair from the heavy pack with a pair from the light pack.
This effectively resolves "2-for-2" imbalances (and "2-for-1" implicitly if one item is zero, though items here are usually non-zero).
We restrict this step to cases where group size is small enough (<= 32) to keep complexity manageable.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        id_h = pack_ids[valid, real_p_h, h_item]
        id_l = pack_ids[valid, real_p_l, l_item]
        pack_ids[valid, real_p_h, h_item] = id_l
        pack_ids[valid, real_p_l, l_item] = id_h

    # 5. Final Selection
=======
        id_h = pack_ids[valid, real_p_h, h_item]
        id_l = pack_ids[valid, real_p_l, l_item]
        pack_ids[valid, real_p_h, h_item] = id_l
        pack_ids[valid, real_p_l, l_item] = id_h

    # 2-for-2 Swap Refinement
    if groups_per_pack >= 2 and groups_per_pack <= 32:
        for _ in range(20):
            pw = pack_contents.sum(dim=2)
            val_max, idx_max = pw.max(dim=1)
            val_min, idx_min = pw.min(dim=1)
            diff = val_max - val_min

            if diff.max() < 1e-4:
                break

            gather_idx_max = idx_max.view(-1, 1, 1).expand(-1, 1, groups_per_pack)
            gather_idx_min = idx_min.view(-1, 1, 1).expand(-1, 1, groups_per_pack)
            items_max = pack_contents.gather(1, gather_idx_max).squeeze(1)
            items_min = pack_contents.gather(1, gather_idx_min).squeeze(1)

            p_sum_max = items_max.unsqueeze(2) + items_max.unsqueeze(1)
            p_sum_min = items_min.unsqueeze(2) + items_min.unsqueeze(1)

            delta = p_sum_max.view(B, groups_per_pack, groups_per_pack, 1, 1) - \
                    p_sum_min.view(B, 1, 1, groups_per_pack, groups_per_pack)

            target = diff.view(B, 1, 1, 1, 1)
            improvement = target - (target - 2 * delta).abs()

            diag_mask_max = torch.eye(groups_per_pack, device=device).bool().view(1, groups_per_pack, groups_per_pack, 1, 1)
            diag_mask_min = torch.eye(groups_per_pack, device=device).bool().view(1, 1, 1, groups_per_pack, groups_per_pack)
            improvement.masked_fill_(diag_mask_max, -float('inf'))
            improvement.masked_fill_(diag_mask_min, -float('inf'))

            imp_flat = improvement.view(B, -1)
            best_imp, best_idx = imp_flat.max(dim=1)

            do_swap = best_imp > 1e-5
            if not do_swap.any():
                break

            valid = torch.where(do_swap)[0]
            flat = best_idx[valid]

            G = groups_per_pack
            G2 = G * G
            G3 = G2 * G

            i = flat // G3
            rem = flat % G3
            j = rem // G2
            rem = rem % G2
            k = rem // G
            l = rem % G

            p_h = idx_max[valid]
            p_l = idx_min[valid]

            val_h_i = pack_contents[valid, p_h, i]
            val_h_j = pack_contents[valid, p_h, j]
            val_l_k = pack_contents[valid, p_l, k]
            val_l_l = pack_contents[valid, p_l, l]

            pack_contents[valid, p_h, i] = val_l_k
            pack_contents[valid, p_h, j] = val_l_l
            pack_contents[valid, p_l, k] = val_h_i
            pack_contents[valid, p_l, l] = val_h_j

            id_h_i = pack_ids[valid, p_h, i]
            id_h_j = pack_ids[valid, p_h, j]
            id_l_k = pack_ids[valid, p_l, k]
            id_l_l = pack_ids[valid, p_l, l]

            pack_ids[valid, p_h, i] = id_l_k
            pack_ids[valid, p_h, j] = id_l_l
            pack_ids[valid, p_l, k] = id_h_i
            pack_ids[valid, p_l, l] = id_h_j

    # 5. Final Selection
>>>>>>> REPLACE
</DIFF>