<NAME>
init_and_dual_ruin
</NAME>

<DESCRIPTION>
1. **Enhanced Initialization**: Widens the search range for the linearization parameter $K$ (0.85-1.15x best_k) and increases noise (0.08) during candidate generation. This promotes structural diversity in the initial population by exploring different balances between packing efficiency and load distribution.
2. **Increased Iterations**: Increases `max_iter` from 150 to 300 to utilize available computational budget for deeper local search.
3. **Dual Ruin Perturbation**: Replaces the single-GPU perturbation with a robust "Dual Ruin" strategy. It empties both the bottleneck GPU and (probabilistically) the lightest GPU to create a larger optimization space. The reconstruction phase uses an alternating sorting strategy (Size vs. Load) to break out of local optima, protected by a rollback mechanism to ensure solution validity.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Generate candidates with noise around best_k
    if best_k < 1e8:
        for _ in range(10):
            k_noisy = best_k * random.uniform(0.95, 1.05)
            res = solve_linearized_bp(k_noisy, noise=0.05)
            if res: candidates.append(res)
=======
    # Generate candidates with noise around best_k
    if best_k < 1e8:
        for _ in range(15):
            k_noisy = best_k * random.uniform(0.85, 1.15)
            res = solve_linearized_bp(k_noisy, noise=0.08)
            if res: candidates.append(res)
>>>>>>> REPLACE
<<<<<<< SEARCH
    # -------------------------------------------------------------------------
    # 2. Iterated Local Search (ILS)
    # -------------------------------------------------------------------------
    iter_cnt = 0
    max_iter = 150

    while iter_cnt < max_iter:
=======
    # -------------------------------------------------------------------------
    # 2. Iterated Local Search (ILS)
    # -------------------------------------------------------------------------
    iter_cnt = 0
    max_iter = 300

    while iter_cnt < max_iter:
>>>>>>> REPLACE
<<<<<<< SEARCH
        # --- Perturbation (Ruin and Recreate) ---
        iter_cnt += 1
        if iter_cnt > max_iter - 10: break

        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break

        # Ruin: Evict all
        evicted = []
        while worst_gpu.models:
            evicted.append(worst_gpu.remove(0))

        # Shuffle for randomness
        random.shuffle(evicted)

        # Recreate: Best Fit
        for m in evicted:
            best_dest = None
            best_val = float('inf')
            # Consider all including worst_gpu (which is now empty/lighter)
            # Actually, let's try to put them elsewhere first.
            # If worst_gpu is empty, its load is 0, so it will be a candidate.

            for dest in current_gpus:
                if dest.can_fit(m.model_size):
                    rem = GPU_MEM_SIZE - (dest.used_mem + m.model_size)
                    val = (dest.load + m.req_rate/m.slo) / rem if rem > 1e-7 else float('inf')
                    if val < best_val:
                        best_val = val
                        best_dest = dest

            if best_dest:
                best_dest.add(m)
            else:
                # Must put back in original if no fit (should not happen if it came from there)
                worst_gpu.add(m)

        current_vector = get_vector(current_gpus)
        if current_vector < best_vector:
            best_vector = current_vector
            for k in range(gpu_num): best_gpus[k].copy_from(current_gpus[k])
=======
        # --- Perturbation (Dual Ruin and Recreate) ---
        iter_cnt += 1
        if iter_cnt > max_iter - 10: break

        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break

        # Snapshot for rollback
        backup_state = []
        for g in current_gpus:
            g_copy = GPUState(g.id)
            g_copy.copy_from(g)
            backup_state.append(g_copy)

        evicted = []
        # Ruin Bottleneck
        while worst_gpu.models: evicted.append(worst_gpu.remove(0))

        # Probabilistically Ruin Lightest GPU (Dual Ruin)
        if len(current_gpus) > 1 and random.random() < 0.75:
            lightest_gpu = sorted_gpus[-1]
            if lightest_gpu.id != worst_gpu.id:
                while lightest_gpu.models: evicted.append(lightest_gpu.remove(0))

        # Alternating Sort Strategy for Recreate
        # Even: Pack by Size (Size-centric), Odd: Balance by Load (Load-centric)
        if iter_cnt % 2 == 0:
            evicted.sort(key=lambda m: m.model_size * random.uniform(0.95, 1.05), reverse=True)
        else:
            evicted.sort(key=lambda m: m.req_rate / m.slo, reverse=True)

        # Recreate: Minimum KVPR Fit
        success = True
        for m in evicted:
            best_dest = None
            best_val = float('inf')
            for dest in current_gpus:
                if dest.can_fit(m.model_size):
                    rem = GPU_MEM_SIZE - (dest.used_mem + m.model_size)
                    if rem > 1e-7:
                        val = (dest.load + m.req_rate/m.slo) / rem
                        if val < best_val:
                            best_val = val
                            best_dest = dest

            if best_dest:
                best_dest.add(m)
            else:
                success = False
                break

        if success:
            current_vector = get_vector(current_gpus)
            if current_vector < best_vector:
                best_vector = current_vector
                for k in range(gpu_num): best_gpus[k].copy_from(current_gpus[k])
        else:
            # Rollback if failed to place models
            for i in range(gpu_num): current_gpus[i].copy_from(backup_state[i])
>>>>>>> REPLACE
</DIFF>