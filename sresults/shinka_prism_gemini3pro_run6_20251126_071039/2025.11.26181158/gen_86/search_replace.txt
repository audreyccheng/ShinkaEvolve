<NAME>
aggressive_ruin_and_extended_init
</NAME>

<DESCRIPTION>
This edit implements three key improvements based on the recommendations to maximize the KV cache pressure minimization:
1.  **Extended Initialization**: The range of 'K' multipliers in the randomized multi-start initialization is expanded (adding 1.02, 1.08, 1.25, 1.3) and the number of seeds increased. This allows the algorithm to explore a wider variety of packing tightnesses, finding initial solutions that better balance load distribution versus packing efficiency (Recommendation 1).
2.  **Expanded Local Search**: The `Swap 2-1` operator's check limit is increased from 150 to 600. Since this operator is powerful but expensive, increasing the budget allows it to find more complex moves that relieve bottleneck GPUs.
3.  **Aggressive Dual-Target Ruin**: The perturbation phase is modified to remove more items (2-4 instead of 1-2) from both the bottleneck GPU and the benefactor (lowest load) GPU. This creates a larger pool of floating items and free space, enabling the reconstruction heuristic to effectively redistribute heavy items from the bottleneck to the benefactor, escaping deep local optima (Recommendation 2).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Attempt deterministic + multiple randomized starts with varying K
    # Varying K helps find packing that balances load vs size better
    k_multipliers = [1.0, 1.05, 1.1, 1.15, 1.2]
    seeds = list(range(25))
    random.shuffle(seeds)
=======
    # Attempt deterministic + multiple randomized starts with varying K
    # Varying K helps find packing that balances load vs size better
    k_multipliers = [1.0, 1.02, 1.05, 1.08, 1.1, 1.15, 1.2, 1.25, 1.3]
    seeds = list(range(40))
    random.shuffle(seeds)
>>>>>>> REPLACE
<<<<<<< SEARCH
                    # Sort indices by size descending to prioritize removing large items
                    sorted_indices = sorted(range(len(src_items)), key=lambda k: src_items[k]['s'], reverse=True)
                    limit_checks = 150
                    checks = 0

                    for idx1 in range(len(sorted_indices)):
                        if checks > limit_checks: break
=======
                    # Sort indices by size descending to prioritize removing large items
                    sorted_indices = sorted(range(len(src_items)), key=lambda k: src_items[k]['s'], reverse=True)
                    limit_checks = 600
                    checks = 0

                    for idx1 in range(len(sorted_indices)):
                        if checks > limit_checks: break
>>>>>>> REPLACE
<<<<<<< SEARCH
        # Remove from bottleneck (Randomly, 1-2 items)
        if plc[b_idx]:
            num_remove = min(len(plc[b_idx]), random.randint(1, 2))
            for _ in range(num_remove):
                if not plc[b_idx]: break
                idx = random.randrange(len(plc[b_idx]))
                item = plc[b_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[b_idx]['l'] -= item['l']
                gpu_stats[b_idx]['s'] -= item['s']

        # Remove from benefactor (Create space, 1 item)
        if min_idx != -1 and plc[min_idx]:
            # Try to remove a smaller item to make space for a bigger one from bottleneck?
            # Or just random. Random is safer.
            if plc[min_idx]:
                idx = random.randrange(len(plc[min_idx]))
                item = plc[min_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[min_idx]['l'] -= item['l']
                gpu_stats[min_idx]['s'] -= item['s']
=======
        # Remove from bottleneck (Aggressive: 2-4 items)
        if plc[b_idx]:
            n_b = len(plc[b_idx])
            num_remove = min(n_b, random.randint(2, 4))
            for _ in range(num_remove):
                if not plc[b_idx]: break
                idx = random.randrange(len(plc[b_idx]))
                item = plc[b_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[b_idx]['l'] -= item['l']
                gpu_stats[b_idx]['s'] -= item['s']

        # Remove from benefactor (Aggressive: 2-4 items to create space)
        if min_idx != -1 and plc[min_idx]:
            n_m = len(plc[min_idx])
            num_remove = min(n_m, random.randint(2, 4))
            for _ in range(num_remove):
                if not plc[min_idx]: break
                idx = random.randrange(len(plc[min_idx]))
                item = plc[min_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[min_idx]['l'] -= item['l']
                gpu_stats[min_idx]['s'] -= item['s']
>>>>>>> REPLACE
</DIFF>