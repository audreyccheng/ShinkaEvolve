# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Load-Density Minimization Placement**
- **Implementation**: The algorithm sorts models by load intensity (request rate/SLO) and places them on the GPU that minimizes the current ratio of accumulated load to remaining memory.
- **Performance**: Achieved a high combined score of 21.89 and a 100% success rate, efficiently minimizing maximum KV cache pressure.
- **Feedback**: The strategy of dynamically balancing accumulated load against available capacity effectively prevents hotspots, resulting in a superior distribution of cache pressure compared to standard packing methods.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Multi-start Greedy with Lexicographical Local Search**
- **Implementation**: The algorithm generates initial solutions using three sorting heuristics (size, load, density) and refines the best one using a local search that applies moves and swaps to the bottleneck GPU, accepting changes that improve the lexicographical vector of pressures.
- **Performance**: It achieved a high combined score of 25.75 with extremely fast execution (0.004s) and a 100% success rate.
- **Feedback**: The lexicographical comparison enables the local search to optimize the overall load distribution rather than just the maximum peak, while the multi-start approach robustly handles varying model characteristics.
**Program Identifier:** Generation 1 - Patch Name greedy_multistart_localsearch - Correct Program: True

**Program Name: Greedy Resulting-Pressure Minimization with Size-Descent Sort**
- **Implementation**: The algorithm sorts models by size and load (descending) and iteratively assigns them to the GPU that minimizes the resulting KV cache pressure (total load divided by remaining memory).
- **Performance**: Achieved a high combined score of 20.43 with a 100% success rate and very low execution time (0.013s).
- **Feedback**: Sorting by size primarily ensures large models are placed before memory becomes fragmented, while the greedy look-ahead strategy for specific pressure reduction effectively balances the load across resources.
**Program Identifier:** Generation 2 - Patch Name greedy_resulting_kvpr_bfd - Correct Program: True

**Program Name: Multi-start Greedy with Lexicographical Local Search**
- **Implementation**: The solution employs a multi-start greedy strategy initialized by various sorting metrics (size, load, density) and random shuffles, followed by a local search refinement. It optimizes the lexicographically sorted vector of GPU pressures using move and swap operators targeted specifically at the top three bottleneck GPUs.
- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and fast execution time of 0.103s.
- **Feedback**: The use of lexicographical comparison allows the algorithm to improve secondary bottlenecks when the maximum pressure cannot be immediately reduced, preventing premature convergence. Focusing the local search on high-pressure GPUs ensures the solution remains computationally efficient while effectively balancing the load.
**Program Identifier:** Generation 3 - Patch Name randomized_multi_start_local_search - Correct Program: True

**Program Name: Binary Search KVPR with Linearized Weight Bin Packing**
- **Implementation**: The algorithm minimizes maximum KV cache pressure by binary searching for a target threshold, converting the feasibility check into a bin packing problem using First Fit Decreasing on linearized weights ($req\_rate/slo + threshold \times size$).
- **Performance**: It achieved a high score of 26.23 and a 100% success rate, efficiently balancing load and memory constraints with negligible execution time.
- **Feedback**: The transformation of the fractional objective into a linear bin-packing constraint allows the heuristic to adaptively prioritize heavy or large models based on the current target pressure, resulting in optimal placements.
**Program Identifier:** Generation 4 - Patch Name kvpr_binary_search_packing - Correct Program: True

**Program Name: Linearized Bin Packing with Best Fit and Local Search**
- **Implementation**: The algorithm linearizes the KVPR objective to enable binary search for the optimal target value, utilizing Best Fit bin packing with dual sorting heuristics (linearized weight and model size) to check feasibility. A post-processing local search greedily moves models from the highest-pressure GPU to others to refine the global maximum pressure.
- **Performance**: The solution achieved a combined score of 26.23 with a max KVPR metric of 25.233, maintaining a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Transforming the non-linear KVPR metric into a linear constraint allows for efficient approximation via binary search, solving the core allocation problem effectively. The addition of local search refinement ensures the initial packing is optimized further, correcting any imbalances left by the heuristic packing.
**Program Identifier:** Generation 5 - Patch Name bs_bestfit_localsearch - Correct Program: True

**Program Name: Binary Search with Transformed First-Fit Decreasing Bin Packing**
- **Implementation**: The solution minimizes maximum KV cache pressure by binary searching for an optimal target value, transforming the non-linear ratio constraint into linear item weights and validating feasibility using a First-Fit Decreasing heuristic.
- **Performance**: The approach performed exceptionally well, achieving a combined score of 26.10 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Converting the min-max objective into a feasibility problem via binary search allows efficient application of standard bin packing heuristics, effectively balancing computational speed with solution quality.
**Program Identifier:** Generation 6 - Patch Name binary_search_bin_packing - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Best Fit Packing**
- **Implementation**: The algorithm minimizes KV cache pressure using binary search on the pressure ratio, validating feasibility via Best Fit Decreasing with three alternate sorting strategies (linearized weight, model size, and load).
- **Performance**: Achieves a high score of 26.10 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The use of multiple sorting heuristics within the packing check allows the solution to adapt dynamically to whether memory or load is the dominant constraint, resulting in highly efficient placements.
**Program Identifier:** Generation 7 - Patch Name improved_packing_heuristics - Correct Program: True

**Program Name: Binary Search Best Fit with Multi-Strategy Sorting**
- **Implementation**: The solution minimizes maximum KVPR by binary searching for the optimal pressure threshold, initializing with a theoretical lower bound derived from fluid packing. The feasibility check uses a Best Fit Decreasing algorithm that attempts three distinct sorting strategies (Linearized Weight, Size, and Load) to robustly fit models into GPUs.
- **Performance**: The algorithm achieved a high combined score of 26.23 and a 100% success rate with extremely fast execution times (0.002s).
- **Feedback**: The use of multiple sorting strategies allows the packer to adapt dynamically to both memory-bound and load-bound scenarios, significantly improving packing density. Additionally, calculating a precise lower bound for the binary search range ensures the algorithm converges quickly on the optimal solution.
**Program Identifier:** Generation 8 - Patch Name adaptive_multi_strategy_packing - Correct Program: True

**Program Name: Binary Search Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm performs a binary search on the target KVPR to solve a linearized bin packing problem using Best Fit with multiple sorting heuristics, followed by a greedy local search that moves or swaps models to relieve the bottleneck GPU.
- **Performance**: It achieves a high score of 26.23 and perfect success rate with negligible execution time (0.001s).
- **Feedback**: The hybrid approach effectively balances global constraints via linearization and local non-linear optimization, providing a robust solution for the rational objective function without heavy computational overhead.
**Program Identifier:** Generation 9 - Patch Name improved_packing_and_local_search - Correct Program: True

**Program Name: Binary Search with Linearized Bin Packing and Local Search**
- **Implementation**: Implements binary search on the target KVPR by transforming the non-linear constraint into a linear bin packing problem solved via Best Fit with multiple sorting heuristics. A post-placement local search refines the result by greedily moving or swapping models from the highest-pressure GPU.
- **Performance**: Achieved a high combined score of 26.23 with a perfect success rate and minimal execution time (0.001s).
- **Feedback**: Transforming the KVPR metric into a linear weight constraint allows the use of efficient bin packing algorithms, while the local search effectively resolves residual imbalances in tight packing scenarios.
**Program Identifier:** Generation 10 - Patch Name local_search_swaps - Correct Program: True

**Program Name: Linearized Bin Packing with Multi-Operator Local Search**
- **Implementation**: The algorithm initializes by transforming the non-linear KVPR objective into a weighted Bin Packing problem solved via binary search, followed by a local search using Move, Swap(1-1), and Swap(1-2) operators. It prioritizes bottleneck GPUs and utilizes lexicographical vector comparison to ensure strict improvement during refinement.
- **Performance**: The solution achieved a high combined score of 27.48 with a max KVPR score of 26.48 and extremely fast execution (0.012s).
- **Feedback**: The linearization strategy effectively creates a high-quality initial placement, significantly reducing the workload for the local search. The inclusion of the 1-to-2 swap operator was critical for resolving memory fragmentation issues where standard 1-to-1 swaps often get stuck.
**Program Identifier:** Generation 11 - Patch Name bsearch_linearization_ils - Correct Program: True

**Program Name: Binary Search with Linearized Best Fit and Local Refinement**
- **Implementation**: The algorithm linearizes the non-linear KVPR constraint to perform a binary search for the optimal target value using a Best Fit Decreasing packing heuristic with dual sorting strategies. It refines the initial placement using a local search that iteratively moves or swaps models from the bottleneck GPU to strictly lower the maximum pressure.
- **Performance**: The solution achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The combination of linearized weights for global approximation and bottleneck-aware local search provides a highly effective balance of speed and solution quality. The dual sorting strategies (linearized weight vs. size) significantly improve robustness when memory constraints are tight.
**Program Identifier:** Generation 12 - Patch Name hybrid_placement_search - Correct Program: True

**Program Name: Binary Search Packing with Iterated Local Search**
- **Implementation**: Implements binary search on the target pressure ratio using multi-heuristic Best Fit bin packing, followed by Iterated Local Search with greedy moves and swaps to optimize placement.
- **Performance**: The solution achieved a combined score of 26.23, a 100% success rate, and a fast execution time of 0.002s.
- **Feedback**: The approach of refining a binary-search-derived baseline with local search proved highly effective, balancing memory and load constraints to minimize the maximum KV cache pressure.
**Program Identifier:** Generation 13 - Patch Name iterated_local_search_and_density_sort - Correct Program: True

**Program Name: Linearized Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm binary searches for the optimal target KVPR by converting the problem into a linearized bin packing task solved via Best Fit with multiple sorting heuristics (weight, size, load, density). It refines the placement using a local search that iteratively relieves the bottleneck GPU through greedy moves, 1-for-1 swaps, and 2-for-1 swaps.
- **Performance**: Achieves a high combined score of 26.23 with a 100% success rate and negligible execution time (0.002s).
- **Feedback**: The linearization of the non-linear KVPR constraint enables the effective application of standard packing heuristics, while the specific inclusion of 2-for-1 swaps allows the local search to better balance fragmentation and capacity constraints.
**Program Identifier:** Generation 14 - Patch Name packing_density_heuristic - Correct Program: True

**Program Name: Linearized Bin-Packing Search with Perturbation-based Local Search**
- **Implementation**: The algorithm initializes using binary search on a linearized constraint (`load + K*size`) to balance load and memory usage, followed by Iterated Local Search targeting bottleneck GPUs. It employs Move, Swap(1-1), and Swap(1-2) operators, using random perturbation to escape local optima when descent stagnates.
- **Performance**: Achieved a combined score of 38.38 with a 0.96 success rate and 0.035s execution time.
- **Feedback**: The linearized initialization effectively approximates the non-linear KVPR objective for a strong starting solution, while the 1-2 swap and perturbation mechanisms robustly handle fragmentation and local optima better than simple greedy approaches.
**Program Identifier:** Generation 15 - Patch Name ils_linearized_kvpr - Correct Program: True

**Program Name: Binary Search Initialization with Lexicographical Local Search Refinement**
- **Implementation**: Uses binary search on a linearized bin-packing constraint to find an initial placement, then refines via local search using move, 1-to-1 swap, and 1-to-2 swap operators minimizing lexicographical pressure vectors.
- **Performance**: Achieved a high combined score of 27.48 with 100% success rate and very fast execution (0.012s).
- **Feedback**: The 1-to-2 swap operator effectively addresses memory fragmentation, while the binary search initialization provides a robust starting point significantly closer to the global optimum than standard greedy methods.
**Program Identifier:** Generation 16 - Patch Name binary_search_linearization_restore_v2 - Correct Program: True

**Program Name: Linearized Binary Search Construction with Iterated Local Search**
- **Implementation**: The algorithm initializes via binary search over the target KVPR using linearized bin-packing constraints with multiple sorting heuristics, followed by Iterated Local Search targeting bottleneck GPUs using move, swap, and 2-1 swap operators.
- **Performance**: It achieved a robust combined score of 26.26 with a 100% success rate and negligible execution time (0.002s).
- **Feedback**: The linearization of the objective function allowed for a high-quality initial placement, while the specific focus on bottleneck GPUs in the local search phase effectively leveled the load across devices.
**Program Identifier:** Generation 17 - Patch Name iterated_ils_swap21_bs - Correct Program: True

**Program Name: Binary Search BFD with Multi-Operator Local Search Refinement**
- **Implementation**: The algorithm minimizes max KVPR by binary searching for a target threshold using Best Fit Decreasing with multiple sorting heuristics, followed by a local search refinement using shift, 1-1 swap, and 2-1 swap operators on the bottleneck GPU.
- **Performance**: It achieves a strong combined score of 26.23 and perfect success rate with negligible execution time (0.002s).
- **Feedback**: The use of diverse sorting heuristics in the packing phase provides a robust initialization, while the specific 2-1 swap operator in the local search effectively resolves fragmentation issues that simple swaps miss.
**Program Identifier:** Generation 18 - Patch Name binsearch_ils_hybrid - Correct Program: True

**Program Name: Linearized Binary Search Packing with Local Search Refinement**
- **Implementation**: Transforms the non-linear KVPR objective into a linear bin-packing constraint solved via binary search and multi-heuristic Best Fit Decreasing, followed by iterative move and swap operations on the bottleneck GPU.
- **Performance**: Achieved a strong combined score of 26.23 with negligible execution time (0.017s) and 100% success rate.
- **Feedback**: The linearization strategy effectively converted the complex ratio optimization into a solvable packing problem, providing a high-quality initial solution that required minimal refinement.
**Program Identifier:** Generation 19 - Patch Name hybrid_bs_local_search - Correct Program: True

**Program Name: Hybrid Binary Search Initialization with Lexicographic Local Search**
- **Implementation**: The algorithm combines binary search-based linearization for initial bin packing with greedy fallbacks, followed by a local search utilizing move, 1-1 swap, and 2-1 swap operators to optimize the KV pressure vector lexicographically. An escape mechanism redistributes models from the worst-off GPU to overcome local optima.
- **Performance**: It achieved a strong combined score of 25.89, maintaining a 100% success rate with very fast execution (0.077s).
- **Feedback**: The binary search initialization effectively sets a high-quality global baseline, while lexicographic comparison prevents oscillation between bottlenecks; the multi-item swap operator specifically helps resolve fragmentation issues that simple swaps miss.
**Program Identifier:** Generation 20 - Patch Name hierarchical_linearization_search - Correct Program: True

**Program Name: Binary Search Initialization with Multi-Operator Local Search**
- **Implementation**: Utilizes binary search on target pressure to map the problem to linear bin packing for initialization, followed by local search using move, 1-to-1, and 1-to-2 swap operators to optimize the pressure distribution.
- **Performance**: Achieved a high score of 27.48 with a 1.000 success rate and minimal execution time (0.016s).
- **Feedback**: The linearization of the KVPR constraint allowed for effective heuristic initialization, while the inclusion of the 1-to-2 swap operator successfully addressed memory fragmentation issues that limit simpler algorithms.
**Program Identifier:** Generation 21 - Patch Name init_cached_rem - Correct Program: True

**Program Name: Multi-Start Perturbation-Based Iterated Local Search**
- **Implementation**: Initializes via randomized bin packing with linearized weights, followed by steepest descent using transfer, 1-1, and 2-1 swaps focused on the bottleneck GPU, and perturbation logic to escape local optima.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution (0.053s).
- **Feedback**: The inclusion of 2-1 swaps and targeted perturbations significantly enhances the ability to balance load across GPUs compared to standard greedy methods, effectively minimizing maximum KV cache pressure.
**Program Identifier:** Generation 22 - Patch Name ils_multistart_steepest - Correct Program: True

**Program Name: Multi-Start ILS with Binary Search Linearization**
- **Implementation**: Initializes solutions using both Binary Search Linearization (approximating the non-linear objective via weighted bin packing) and Greedy Size heuristics, followed by Iterated Local Search with variable neighborhood descent (move, swap 1-1/1-2) and random perturbation kicks.
- **Performance**: Achieved a competitive combined score of 38.29 with a 98% success rate and rapid execution time (0.031s).
- **Feedback**: The binary search linearization provides a sophisticated starting placement that closely approximates the target metric, while the perturbation mechanism allows the algorithm to effectively escape local optima during the refinement phase.
**Program Identifier:** Generation 23 - Patch Name hybrid_ils_placement - Correct Program: True

**Program Name: Multi-Start Iterated Local Search with Complex Swaps**
- **Implementation**: The algorithm initializes placements using randomized bin packing and refines them via steepest descent hill climbing, employing comprehensive moves (transfer, 1-1, 2-1, 2-2 swaps) targeting the bottleneck GPU and directed perturbations to escape local optima.
- **Performance**: It achieved an exceptional combined score of 26.25 and 100% success rate with rapid execution (0.056s).
- **Feedback**: The inclusion of higher-order swap operations (2-1, 2-2) and a multi-start framework allows the solver to effectively resolve fragmentation and minimize peak KV cache pressure better than simpler heuristics.
**Program Identifier:** Generation 24 - Patch Name swap22_and_robust_perturbation - Correct Program: True

**Program Name: Hybrid ILS with Multi-Start Greedy Initialization**
- **Implementation**: Utilizes binary search bin packing and multiple greedy heuristics for initialization, followed by Iterated Local Search using move, 1-1 swap, and 1-2 swap operators targeting bottleneck GPUs.
- **Performance**: Achieved a high combined score of 39.22 with 100% success rate and extremely fast execution (0.025s).
- **Feedback**: The lexicographical comparison of GPU pressure vectors ensures robust min-max optimization, while the 1-2 swap operator effectively navigates tight memory constraints that block simpler local moves.
**Program Identifier:** Generation 25 - Patch Name hybrid_ils_placement - Correct Program: True

**Program Name: Multi-Start Iterated Local Search with Complex Swap Neighborhoods**
- **Implementation**: The solution uses Best Fit Decreasing with binary search for initialization, followed by multi-start steepest descent local search utilizing Shift, 1-1, 2-1, and 2-2 swap neighborhoods to refine placements.
- **Performance**: It achieved a score of 26.23 with 0.001s execution time, demonstrating excellent efficiency and solution quality.
- **Feedback**: The inclusion of higher-order swaps (2-1, 2-2) allows the algorithm to resolve bottlenecks that simple moves miss, while heuristic pruning ensures the larger search space does not negatively impact execution speed.
**Program Identifier:** Generation 26 - Patch Name multistart_ils_swap22 - Correct Program: True

**Program Name: Linearized Bin Packing with Iterated Local Search**
- **Implementation**: The solution employs binary search to linearize the objective into a parameter-weighted bin packing problem for initialization, followed by Iterated Local Search (ILS) utilizing Move, Swap(1-1), and Swap(1-2) operators with perturbation to refine bottleneck GPUs.
- **Performance**: Achieved a high combined score of 40.10 with a 100% success rate and extremely fast execution (0.032s).
- **Feedback**: The linearization strategy effectively approximates the optimal distribution for the initial state, significantly reducing the search space required by the local search to reach high-quality solutions.
**Program Identifier:** Generation 27 - Patch Name init_multistart_guided_perturbation - Correct Program: True

**Program Name: ILS with Linearized Bin Packing and Multi-Item Swaps**
- **Implementation**: Uses binary search on linearized bin packing for initialization, followed by Iterated Local Search (ILS) utilizing steepest descent moves and complex swaps (1-1, 2-1, 1-2).
- **Performance**: Achieved a high score of 36.62 with a 98% success rate and fast execution time (0.081s).
- **Feedback**: The advanced initialization coupled with diverse swap operators allows for effective load balancing and escape from local optima, significantly improving distribution quality.
**Program Identifier:** Generation 28 - Patch Name ils_smart_perturb_steepest - Correct Program: True

**Program Name: Hybrid ILS with Multi-Start Linearized Bin Packing**
- **Implementation**: This approach utilizes a multi-start initialization strategy combining binary search linearized bin packing and various greedy heuristics to find a robust starting point. It refines the solution using Iterated Local Search (ILS) with Variable Neighborhood Descent, employing move, 1-1 swap, and 1-2 swap operators to specifically relieve the highest-pressure GPUs.
- **Performance**: The algorithm achieves a high combined score of 38.19 with a 100% success rate and very fast execution (0.035s).
- **Feedback**: The implementation of the 1-2 swap operator proves highly effective for optimizing memory packing against large models, while the linearized bin packing initialization ensures the search begins from a high-quality basin of attraction.
**Program Identifier:** Generation 29 - Patch Name steepest_descent_and_targeted_perturbation - Correct Program: True

**Program Name: Linearized Bin Packing with Iterated Local Search and Multi-Swaps**
- **Implementation**: The solution initializes placements using a binary search to solve a linearized parameter-weighted bin packing problem, followed by an Iterated Local Search (ILS) that utilizes advanced moves (1-1, 1-2, 2-1 swaps) and random perturbations to escape local optima.
- **Performance**: The algorithm achieved a high combined score of 37.14 with a 98% success rate and extremely rapid execution (0.059s).
- **Feedback**: The linearization strategy provides excellent initial placements by approximating the non-linear objective function, while the specialized multi-item swaps effectively resolve memory fragmentation issues that simple moves cannot address.
**Program Identifier:** Generation 30 - Patch Name ils_steepest_descent_swap21_random_init - Correct Program: True

**Program Name: Linearized Bin Packing with Iterated Local Search**
- **Implementation**: Initializes using a binary search to solve a linearized weighted bin packing problem, followed by Iterated Local Search using 1-1, 1-2, and 2-1 swap operators guided by lexicographical KVPR vector comparison.
- **Performance**: Achieved a high combined score (41.43) with exceptional speed (0.026s), though the 92% success rate indicates occasional packing failures.
- **Feedback**: The complex swap moves (1-2, 2-1) significantly improved load balancing by handling small model fragmentation, but the initialization fallbacks were occasionally insufficient for finding valid solutions in memory-constrained scenarios.
**Program Identifier:** Generation 31 - Patch Name ils_hybrid_linearized_bp_optimized_swap21 - Correct Program: True

**Program Name: Linearized Bin Packing with Variable Neighborhood Descent**
- **Implementation:** Utilizes a binary search linearization strategy to convert the fractional objective into a weighted bin packing problem, followed by Variable Neighborhood Descent with multi-item swaps (1-1, 1-2, 2-1) and a ruin-and-recreate perturbation mechanism.
- **Performance:** Achieves a strong combined score of 38.99 with rapid 0.048s execution, though with a 92% success rate.
- **Feedback:** The linearization approach offers a mathematically grounded initialization that outperforms standard greedy heuristics, while the specialized swap moves allows the algorithm to effectively handle fragmentation and rebalance loads to minimize pressure.
**Program Identifier:** Generation 32 - Patch Name randomized_init_and_ruins_perturbation - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Packing and Steepest Descent**
- **Implementation**: The solution utilizes binary search over the target rate, verifying feasibility via Best Fit Decreasing with three sorting strategies (linearized weight, size, load), followed by a steepest descent local search that swaps or moves models to relieve the bottleneck GPU.
- **Performance**: It achieved a strong combined score of 26.23 (Max KVPR: 25.23) with extremely fast execution (0.002s) and perfect reliability.
- **Feedback**: The use of multiple sorting heuristics makes the initial packing robust across different constraint regimes, while the greedy local search effectively refines the coarse solution found by binary search.
**Program Identifier:** Generation 33 - Patch Name add_steepest_descent_local_search - Correct Program: True

**Program Name: Hybrid ILS with Binary Search and Complex Swap Operators**
- **Implementation**: The solution initializes using binary search-based weighted bin packing and refined greedy strategies, followed by Iterated Local Search (ILS) employing advanced 2-1 and 1-2 model swap operators.
- **Performance**: It achieved a high combined score of 38.54 with a 94% success rate and fast execution time (0.053s).
- **Feedback**: The addition of complex swap operators allows the algorithm to escape local optima involving model size mismatches, significantly improving load balancing compared to standard pairwise swaps.
**Program Identifier:** Generation 34 - Patch Name hybrid_ils_with_swap21_and_randomized_greedy - Correct Program: True

**Program Name: Iterated Local Search with Linearized Bin Packing Initialization**
- **Implementation**: Uses linearized bin packing with binary search for initialization, followed by iterated local search utilizing best-improvement moves, complex swaps (1-1, 1-2, 2-1), and a ruins-and-recreate perturbation strategy.
- **Performance**: Achieved a combined score of 38.38 with a 0.84 success rate and fast execution (0.007s).
- **Feedback**: The targeted bottleneck optimization effectively minimizes peak pressure, though the sub-100% success rate indicates that feasibility checks for extremely tight constraints could be further robustified.
**Program Identifier:** Generation 35 - Patch Name ils_linearized_best_move_ruin_recreate - Correct Program: True

**Program Name: Multi-Start Linearized Packing with Complex Swap Iterated Local Search**
- **Implementation**: Initializes using a binary-search weighted bin packing strategy and greedy heuristics, followed by an Iterated Local Search employing Move and complex Swap (1-1, 1-2, 2-1) operators on a lexicographical objective vector.
- **Performance**: Achieves a high combined score of 39.80 and 92% success rate with very low latency (0.037s).
- **Feedback**: The inclusion of multi-item swaps (1-2, 2-1) effectively addresses memory fragmentation in bottleneck GPUs, while the lexicographical vector comparison ensures robust optimization beyond just the maximum value.
**Program Identifier:** Generation 36 - Patch Name linearized_random - Correct Program: True

**Program Name: Linearized Bin-Packing Initialization with Iterated Local Search**
- **Implementation**: Uses binary search to tune a linearized $Load + K \cdot Size$ objective for initial bin packing, followed by local search with multi-item swaps (2-1, 1-2) and a "ruins and recreate" perturbation strategy.
- **Performance**: High performance with a score of 38.44 (37.50 KVPR) and fast execution (0.04s), though the 94% success rate indicates occasional packing failures.
- **Feedback**: The linearization approach effectively approximates the non-linear pressure objective for initialization, while the perturbation logic successfully breaks bottlenecks by redistributing models from the most pressured GPU.
**Program Identifier:** Generation 37 - Patch Name randomized_multistart_ils_ruins - Correct Program: True

**Program Name: Multi-Start Randomized ILS with Complex Swap Neighborhoods**
- **Implementation**: The solution employs a multi-start framework initializing with randomized Best-Fit Decreasing based on a binary-searched load factor. It refines placements using steepest descent local search targeting the bottleneck GPU with Shift, Swap 1-1, Swap 2-1, and Swap 2-2 moves.
- **Performance**: It achieved a high combined score of 26.23 with rapid execution (0.002s) and a 100% success rate.
- **Feedback**: The addition of complex neighborhood moves (Swap 2-2) effectively resolves tight packing deadlocks that simpler moves cannot handle, while the randomized restart strategy ensures diverse exploration of the solution space.
**Program Identifier:** Generation 38 - Patch Name randomized_multistart_ils_swap22 - Correct Program: True

**Program Name: Linearized Bin Packing with Iterated Local Search**
- **Implementation**: Initializes placements using Linearized Bin Packing with binary search to find the optimal size-load tradeoff parameter, then refines the solution via Iterated Local Search using lexicographical optimization, multiple swap operators (1-1, 2-1, 1-2), and a ruins-and-recreate perturbation.
- **Performance**: Achieved a high combined score of 25.72 (max KVPR 24.72) with extremely fast execution (0.081s).
- **Feedback**: The dynamic parameter tuning ensures robust initial placements across different distributions, while the specialized swap operators and perturbation strategy effectively break local optima to minimize bottleneck KV pressure.
**Program Identifier:** Generation 39 - Patch Name stochastic_ils_gpu_placement - Correct Program: True

**Program Name: Multi-Start Linearized Packing with Iterated Local Search**
- **Implementation**: Features a binary search to optimize load-size weighting for initialization, followed by Iterated Local Search employing diverse swap operators (1-1, 2-1, 1-2, 2-2) and a "ruins and recreate" perturbation strategy.
- **Performance**: Achieved a combined score of 38.57 with a 94% success rate and fast 0.049s execution time.
- **Feedback**: The comprehensive local search operators effectively minimize cache pressure, though the 6% failure rate suggests the need for a stronger fallback mechanism for tight packing constraints.
**Program Identifier:** Generation 40 - Patch Name init_random_greedy - Correct Program: True

**Program Name: Multi-Start Linearized Bin Packing with Tabu Search**
- **Implementation**: Combines linearized bin packing with binary search for initialization and an Iterated Local Search employing steepest descent, tabu lists, and comprehensive swap operators (1-1, 1-2, 2-1).
- **Performance**: Achieved a score of 0.00 with a 0% success rate, indicating the program failed to execute successfully or pass validation tests.
- **Feedback**: The explicit raising of a `ValueError` when heuristics fail and the hardcoded memory limit likely caused crashes on valid test cases; a more robust fallback strategy is required to ensure a solution is always returned.
**Program Identifier:** Generation 41 - Patch Name ils_steepest_descent_with_tabu - Correct Program: False

**Program Name: Multi-Strategy Binary Search with Complex Neighborhood Local Search**
- **Implementation**: Initializes placements using binary search over a linearized weighting factor with multiple sorting heuristics, then refines via steepest descent local search employing shift, swap-1-1, swap-2-1, and swap-2-2 moves.
- **Performance**: Achieves a high efficiency score of 25.91 and very low latency (0.011s), though the 88% success rate indicates occasional validity issues.
- **Feedback**: The use of higher-order swaps (2-1, 2-2) allows the algorithm to effectively rebalance heavy/large models from bottleneck GPUs, significantly improving solution quality, though the heuristic packing sometimes fails to find valid starting solutions in tight constraints.
**Program Identifier:** Generation 42 - Patch Name multistrategy_ils_placement - Correct Program: True

**Program Name: Binary Search Packing with Iterated Local Search**
- **Implementation**: The algorithm uses binary search to optimize a target KVPR by solving feasibility bin packing problems using randomized Best Fit heuristics, followed by Iterated Local Search employing 1-0, 1-1, and 2-1 swaps targeting bottleneck GPUs.
- **Performance**: Achieved a score of 26.26 with a 100% success rate and extremely low latency (0.007s).
- **Feedback**: The binary search approach effectively linearizes the non-linear objective to generate strong initial placements, while the complex swap moves (specifically 2-1) in the local search phase efficiently resolve residual high-pressure bottlenecks.
**Program Identifier:** Generation 43 - Patch Name none - Correct Program: True

**Program Name: Hybrid ILS with Binary Search Linearization and Multi-Model Swaps**
- **Implementation**: Combines stochastic binary search linearization for diverse initialization with an Iterated Local Search using 1-1, 2-1, and 1-2 swaps alongside a "ruins and recreate" perturbation.
- **Performance**: Achieved a high combined score of 37.90 with fast execution (0.042s), optimizing maximum KV cache pressure effectively.
- **Feedback**: The specialized 2-1 and 1-2 swap operators successfully mitigate memory fragmentation, though the 98% success rate indicates potential stability issues in extremely constrained scenarios.
**Program Identifier:** Generation 44 - Patch Name none - Correct Program: True

**Program Name: Binary Search Packing with Bottleneck-Guided Multi-Start Local Search**
- **Implementation**: The algorithm combines binary search-based randomized bin packing to generate initial solutions with a steepest descent local search that targets the bottleneck GPU using Move, Swap(1-1), and complex Swap(2-1/1-2) operators.
- **Performance**: Achieved a score of 26.23 with negligible execution time (0.001s), demonstrating high efficiency and optimal placement.
- **Feedback**: The transformation of the ratio objective into a linear bin-packing weight allows for excellent constructive bounds, while the asymmetric swap operators (2-1, 1-2) effectively handle model size disparities during local refinement.
**Program Identifier:** Generation 45 - Patch Name stochastic_multistart_ils - Correct Program: True

**Program Name: Multi-Start Iterated Local Search with Bottleneck-Focused Moves**
- **Implementation**: The algorithm utilizes randomized bin packing with linearized weights ($L + K \cdot S$) for initialization, followed by steepest descent local search that targets the bottleneck GPU using transfers, 1-1 swaps, and 2-1 swaps. An iterated perturbation mechanism reallocates models from bottleneck to underloaded GPUs to escape local optima across multiple restarts.
- **Performance**: The solution achieved a high combined score of 24.28 (max KVPR 23.282) with a 100% success rate and rapid 0.075s execution time.
- **Feedback**: Targeting the bottleneck GPU with diverse move operators (including 2-1 swaps) effectively minimizes maximum pressure, while the adaptive randomized restarts ensure robustness against poor initial configurations. The low execution time indicates efficient pruning and evaluation of move candidates.
**Program Identifier:** Generation 46 - Patch Name optimize_ls_and_perturbation_v2 - Correct Program: True

**Program Name: Iterated Local Search with Randomized Binary Search Initialization**
- **Implementation**: The algorithm combines multi-start randomized binary search using dynamic weights ($L + K \cdot S$) for initialization with a steepest descent local search (Move, Swap 1-1, Swap 2-1) specifically targeting bottleneck GPUs. It employs a perturbation mechanism to escape local optima within a strict 0.2-second time budget.
- **Performance**: Achieved a high score of 26.26 with a 1.000 success rate and efficient 0.213s runtime.
- **Feedback**: The multi-start strategy effectively identifies high-quality initial basins, while the targeted local search on max-pressure GPUs significantly refines the solution by addressing specific load imbalances through complex swap operations.
**Program Identifier:** Generation 47 - Patch Name stochastic_ils_kvpr - Correct Program: True

**Program Name: Multi-Start Randomized Packing with Steepest Descent Iterated Local Search**
- **Implementation**: Uses randomized Best Fit Decreasing with linearized weights ($Load + K \cdot Size$) for initialization, followed by Iterated Local Search applying Move, Swap 1-1, and Swap 2-1 operations on bottleneck GPUs.
- **Performance**: Achieved a high score of 22.87 (metric 21.87) with rapid execution (0.057s).
- **Feedback**: The binary search for the weighting factor $K$ provides a strong initial solution, and the diverse swap operators in the local search effectively refine the load balance to minimize peak pressure.
**Program Identifier:** Generation 48 - Patch Name stochastic_multistart_ils_placement - Correct Program: True

**Program Name: Multi-Start Iterated Local Search with Fragmentation-Aware Swaps**
- **Implementation:** The solution combines binary search-weighted bin packing initialization with an Iterated Local Search that utilizes move, 1-1 swap, and complex 1-2/2-1 swap operators to optimize model placement.
- **Performance:** The algorithm delivers a high score of 40.41 and very fast execution (0.023s), with a solid 92% success rate.
- **Feedback:** The inclusion of 1-2 and 2-1 swap operators effectively addresses memory fragmentation issues that typically block simple moves, while the multi-strategy initialization ensures robust performance across varied inputs.
**Program Identifier:** Generation 49 - Patch Name hybrid_ils_swap21_sorted_dests - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

Based on the analysis of the individual program summaries (Generations 40-49), previous insights, and the code for the current best program (Generation 31), here are the extracted optimization insights:

## Successful Algorithmic Patterns
- **Comprehensive Asymmetric Swap Portfolio (1-2 and 2-1):** The highest-performing programs (Current Best Gen 31, Score 41.43; Gen 49, Score 40.41) implement *both* **Swap 1-2** (1 item from bottleneck $\to$ 2 from dest) and **Swap 2-1** (2 items from bottleneck $\to$ 1 from dest). Evaluations show that programs missing one of these directions (e.g., Gen 43, Score 26.26, which lacked 1-2 swaps) stagnate because they cannot resolve specific fragmentation patterns where model counts differ significantly between GPUs.
- **Linearized Binary Search Initialization:** A consistent feature in top programs (Gen 31, 40, 49) is optimizing the initialization via a binary search for a parameter $K$ in the objective function $Load + K \cdot Size$. This places the initial solution in a superior basin of attraction compared to standard greedy heuristics or random initialization.
- **Iterated Local Search (ILS) with Perturbation:** While Steepest Descent approaches (Gen 45, Gen 47) consistently plateau around a score of 26.2, ILS algorithms that employ a "ruins and recreate" or random kick perturbation (Gen 31, Gen 40) successfully escape these local optima to reach scores above 38.
- **Lexicographical Vector Optimization:** The current best program (Gen 31) optimizes the entire sorted vector of GPU pressures `(max_pressure, 2nd_max, ...)` rather than just the maximum. This prevents the "ping-pong" effect—where reducing the peak on one GPU simply creates a new, equal peak on another—allowing for deeper optimization of the cluster balance.

## Ineffective Approaches
- **Symmetric High-Order Swaps (2-2):** Generation 42 implemented **Swap 2-2** operators but only achieved a score of 25.91. The evaluation indicates that 2-2 swaps are computationally expensive and less effective at solving the primary problem of memory fragmentation (which is inherently asymmetric) compared to 1-2/2-1 moves.
- **Pure Steepest Descent:** Programs relying solely on steepest descent without perturbation (Gen 45, Gen 47) consistently fail to surpass the ~26.26 score barrier. The feedback highlights that once the algorithm reaches a local optimum where no single move improves the objective, it terminates prematurely without exploring neighboring basins.
- **Hardcoded Heuristic Limits:** Generation 41 failed completely (Score 0.00) because it raised explicit `ValueError` exceptions when heuristics couldn't find a perfect fit, rather than having a robust fallback. This fragility makes the approach unsuitable for constrained test cases.

## Implementation Insights
- **Heuristic Neighborhood Pruning:** The current best program (Gen 31) achieves remarkable efficiency (0.026s) by strictly limiting the local search search space. It creates candidates only from the **top 4 highest-pressure GPUs** (sources) and targets the **least loaded GPUs** (destinations). This prevents wasting cycles on moves that do not directly alleviate the bottleneck.
- **Cached State Management:** Successful implementations utilize a state class (e.g., `GPUState` in Gen 31) that caches derived metrics like remaining memory and KVPR. This avoids recomputing these values inside the tight inner loops of the swap operators, which are called $O(N^2)$ or $O(N^3)$ times.
- **Vectorized Comparison Tuples:** Instead of complex conditional logic to determine if a move is better, the best implementation simply compares tuples: `new_vector < current_vector`. This Pythonic approach handles the lexicographical requirement naturally and efficiently.

## Performance Analysis
- **The "40+ Club" vs. The "26 Plateau":** There is a distinct performance gap between algorithms using the full suite of ILS + Asymmetric Swaps (Gen 31: 41.43, Gen 49: 40.41) and those using partial swap sets or steepest descent (Gen 42, 43, 45, 47: ~26.2). This suggests that the combination of 1-2 AND 2-1 swaps is a critical threshold feature for this problem.
- **Latency vs. Complexity:** Despite adding complex $O(N^3)$ swap operators (like 1-2 and 2-1), the top programs maintain extremely low latency (Gen 31: 0.026s, Gen 49: 0.023s). This is achieved through the pruning described above; unpruned complex neighborhoods would likely exceed time limits.
- **Robustness Trade-offs:** The most aggressive optimization strategies (Gen 40, 49) show slightly lower success rates (92-94%) compared to the conservative 26.26 scorers (100%). The current best (Gen 31) manages a 92% success rate, accepting a small risk of failure on extremely tight constraints for a massive +57% improvement in placement quality on valid cases.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the analysis of the current best program (Generation 31) and the global insights, here are 5 actionable recommendations for future program mutations:

1.  **Stochastic Multi-Start Initialization**
    Leverage the program's extremely fast execution time (0.026s) by wrapping the **Linearized Binary Search** initialization in a stochastic loop (e.g., 20 iterations). In each iteration, apply random noise (e.g., $\pm 5\%$) to the item weights ($w = load + K \cdot size$) before packing. This simple variation allows the algorithm to explore multiple basins of attraction and select the best starting lexicographical vector, significantly improving the baseline before local search begins.

2.  **Transition to "Best Improvement" for Bottlenecks**
    Modify the **Move** and **Swap 1-1** operators to use a "Best Improvement" strategy specifically when processing the highest-pressure GPU. Instead of accepting the *first* valid move that improves the state (current behavior), scan all possible valid destinations for the bottleneck items and select the one that yields the maximal reduction in the lexicographical vector. This prevents the algorithm from making greedy, suboptimal moves that trap it in shallow local optima.

3.  **Destructive "Ruins-and-Recreate" Perturbation**
    Replace the current weak perturbation (moving a single random model) with a stronger **Large Neighborhood Search (LNS)** operator. When the local search stagnates, remove *all* (or the top 3-5 largest) models from the bottleneck GPU and re-insert them into the cluster using a "Best Fit" heuristic. This major structural change is necessary to escape the deep local optima found at the 41.43 score level, which single-move perturbations cannot resolve.

4.  **Expanded Scope for Asymmetric Swaps (2-1)**
    The current program unnecessarily restricts the powerful **Swap 2-1** operator (moving 2 items out, taking 1 in) to only the single absolute worst GPU (`sources[:1]`). Expand this scope to the top 3 or 4 bottleneck GPUs (`sources[:4]`), matching the scope of the other operators. Secondary bottlenecks often lock the system state; resolving fragmentation on the 2nd or 3rd worst GPU can create the slack needed to eventually relieve the primary bottleneck.

5.  **Short-Term Tabu Memory**
    Implement a simple cyclic **Tabu List** (size 5-10) that records recent moves as `(model_id, source_gpu_id)` tuples. Prevent the local search from reversing these moves for a set number of iterations. This low-overhead mechanism is critical for preventing "ping-pong" behavior—where the algorithm endlessly swaps load between two high-pressure GPUs without making global progress—thereby forcing the search to explore novel configurations.