<NAME>
adaptive_reweighting
</NAME>

<DESCRIPTION>
Introduces an adaptive reweighting mechanism (Guided Local Search) to the multi-start framework. Models on the bottleneck GPU of a local optimum have their weights increased for the subsequent construction phases. This prioritizes these "troublesome" models in the First-Fit Decreasing heuristic, encouraging them to be placed earlier in more optimal bins, thereby diversifying the search and escaping local optima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Pre-calculate model properties
    model_data = []
    for i, m in enumerate(models):
        model_data.append({
            'model': m,
            'l': m.req_rate / m.slo,
            's': m.model_size
        })

    def get_kvpr(l, s):
=======
    # Pre-calculate model properties
    model_data = []
    model_to_id = {}
    for i, m in enumerate(models):
        model_to_id[id(m)] = i
        model_data.append({
            'id': i,
            'model': m,
            'l': m.req_rate / m.slo,
            's': m.model_size
        })

    # Multipliers for adaptive reweighting
    model_multipliers = [1.0] * len(models)

    def get_kvpr(l, s):
>>>>>>> REPLACE
<<<<<<< SEARCH
    def solve_packing(target_k, randomize=False):
        capacity = target_k * GPU_MEM_SIZE

        # Prepare items
        items = []
        for d in model_data:
            w = d['l'] + target_k * d['s']
            if randomize:
                w *= random.uniform(0.9, 1.1)
            items.append((w, d))

        items.sort(key=lambda x: x[0], reverse=True)
=======
    def solve_packing(target_k, randomize=False):
        capacity = target_k * GPU_MEM_SIZE

        # Prepare items
        items = []
        for d in model_data:
            w = (d['l'] + target_k * d['s']) * model_multipliers[d['id']]
            if randomize:
                w *= random.uniform(0.9, 1.1)
            items.append((w, d))

        items.sort(key=lambda x: x[0], reverse=True)
>>>>>>> REPLACE
<<<<<<< SEARCH
        if cur_max_k < best_global_score:
            best_global_score = cur_max_k
            best_global_plc = {i: list(current_plc[i]) for i in range(gpu_num)}

    if best_global_plc is None:
=======
        if cur_max_k < best_global_score:
            best_global_score = cur_max_k
            best_global_plc = {i: list(current_plc[i]) for i in range(gpu_num)}

        # Adaptive Reweighting: Penalize models on the bottleneck GPU
        bn_val = -1.0
        bn_gpu = -1
        for g in range(gpu_num):
            val = get_kvpr(l_vec[g], s_vec[g])
            if val > bn_val:
                bn_val = val
                bn_gpu = g

        if bn_gpu != -1:
            for m in current_plc[bn_gpu]:
                mid = model_to_id.get(id(m))
                if mid is not None:
                    model_multipliers[mid] *= 1.2

    if best_global_plc is None:
>>>>>>> REPLACE
</DIFF>