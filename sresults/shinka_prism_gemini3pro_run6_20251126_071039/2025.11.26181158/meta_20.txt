# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Load-Density Minimization Placement**
- **Implementation**: The algorithm sorts models by load intensity (request rate/SLO) and places them on the GPU that minimizes the current ratio of accumulated load to remaining memory.
- **Performance**: Achieved a high combined score of 21.89 and a 100% success rate, efficiently minimizing maximum KV cache pressure.
- **Feedback**: The strategy of dynamically balancing accumulated load against available capacity effectively prevents hotspots, resulting in a superior distribution of cache pressure compared to standard packing methods.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Multi-start Greedy with Lexicographical Local Search**
- **Implementation**: The algorithm generates initial solutions using three sorting heuristics (size, load, density) and refines the best one using a local search that applies moves and swaps to the bottleneck GPU, accepting changes that improve the lexicographical vector of pressures.
- **Performance**: It achieved a high combined score of 25.75 with extremely fast execution (0.004s) and a 100% success rate.
- **Feedback**: The lexicographical comparison enables the local search to optimize the overall load distribution rather than just the maximum peak, while the multi-start approach robustly handles varying model characteristics.
**Program Identifier:** Generation 1 - Patch Name greedy_multistart_localsearch - Correct Program: True

**Program Name: Greedy Resulting-Pressure Minimization with Size-Descent Sort**
- **Implementation**: The algorithm sorts models by size and load (descending) and iteratively assigns them to the GPU that minimizes the resulting KV cache pressure (total load divided by remaining memory).
- **Performance**: Achieved a high combined score of 20.43 with a 100% success rate and very low execution time (0.013s).
- **Feedback**: Sorting by size primarily ensures large models are placed before memory becomes fragmented, while the greedy look-ahead strategy for specific pressure reduction effectively balances the load across resources.
**Program Identifier:** Generation 2 - Patch Name greedy_resulting_kvpr_bfd - Correct Program: True

**Program Name: Multi-start Greedy with Lexicographical Local Search**
- **Implementation**: The solution employs a multi-start greedy strategy initialized by various sorting metrics (size, load, density) and random shuffles, followed by a local search refinement. It optimizes the lexicographically sorted vector of GPU pressures using move and swap operators targeted specifically at the top three bottleneck GPUs.
- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and fast execution time of 0.103s.
- **Feedback**: The use of lexicographical comparison allows the algorithm to improve secondary bottlenecks when the maximum pressure cannot be immediately reduced, preventing premature convergence. Focusing the local search on high-pressure GPUs ensures the solution remains computationally efficient while effectively balancing the load.
**Program Identifier:** Generation 3 - Patch Name randomized_multi_start_local_search - Correct Program: True

**Program Name: Binary Search KVPR with Linearized Weight Bin Packing**
- **Implementation**: The algorithm minimizes maximum KV cache pressure by binary searching for a target threshold, converting the feasibility check into a bin packing problem using First Fit Decreasing on linearized weights ($req\_rate/slo + threshold \times size$).
- **Performance**: It achieved a high score of 26.23 and a 100% success rate, efficiently balancing load and memory constraints with negligible execution time.
- **Feedback**: The transformation of the fractional objective into a linear bin-packing constraint allows the heuristic to adaptively prioritize heavy or large models based on the current target pressure, resulting in optimal placements.
**Program Identifier:** Generation 4 - Patch Name kvpr_binary_search_packing - Correct Program: True

**Program Name: Linearized Bin Packing with Best Fit and Local Search**
- **Implementation**: The algorithm linearizes the KVPR objective to enable binary search for the optimal target value, utilizing Best Fit bin packing with dual sorting heuristics (linearized weight and model size) to check feasibility. A post-processing local search greedily moves models from the highest-pressure GPU to others to refine the global maximum pressure.
- **Performance**: The solution achieved a combined score of 26.23 with a max KVPR metric of 25.233, maintaining a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Transforming the non-linear KVPR metric into a linear constraint allows for efficient approximation via binary search, solving the core allocation problem effectively. The addition of local search refinement ensures the initial packing is optimized further, correcting any imbalances left by the heuristic packing.
**Program Identifier:** Generation 5 - Patch Name bs_bestfit_localsearch - Correct Program: True

**Program Name: Binary Search with Transformed First-Fit Decreasing Bin Packing**
- **Implementation**: The solution minimizes maximum KV cache pressure by binary searching for an optimal target value, transforming the non-linear ratio constraint into linear item weights and validating feasibility using a First-Fit Decreasing heuristic.
- **Performance**: The approach performed exceptionally well, achieving a combined score of 26.10 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Converting the min-max objective into a feasibility problem via binary search allows efficient application of standard bin packing heuristics, effectively balancing computational speed with solution quality.
**Program Identifier:** Generation 6 - Patch Name binary_search_bin_packing - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Best Fit Packing**
- **Implementation**: The algorithm minimizes KV cache pressure using binary search on the pressure ratio, validating feasibility via Best Fit Decreasing with three alternate sorting strategies (linearized weight, model size, and load).
- **Performance**: Achieves a high score of 26.10 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The use of multiple sorting heuristics within the packing check allows the solution to adapt dynamically to whether memory or load is the dominant constraint, resulting in highly efficient placements.
**Program Identifier:** Generation 7 - Patch Name improved_packing_heuristics - Correct Program: True

**Program Name: Binary Search Best Fit with Multi-Strategy Sorting**
- **Implementation**: The solution minimizes maximum KVPR by binary searching for the optimal pressure threshold, initializing with a theoretical lower bound derived from fluid packing. The feasibility check uses a Best Fit Decreasing algorithm that attempts three distinct sorting strategies (Linearized Weight, Size, and Load) to robustly fit models into GPUs.
- **Performance**: The algorithm achieved a high combined score of 26.23 and a 100% success rate with extremely fast execution times (0.002s).
- **Feedback**: The use of multiple sorting strategies allows the packer to adapt dynamically to both memory-bound and load-bound scenarios, significantly improving packing density. Additionally, calculating a precise lower bound for the binary search range ensures the algorithm converges quickly on the optimal solution.
**Program Identifier:** Generation 8 - Patch Name adaptive_multi_strategy_packing - Correct Program: True

**Program Name: Binary Search Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm performs a binary search on the target KVPR to solve a linearized bin packing problem using Best Fit with multiple sorting heuristics, followed by a greedy local search that moves or swaps models to relieve the bottleneck GPU.
- **Performance**: It achieves a high score of 26.23 and perfect success rate with negligible execution time (0.001s).
- **Feedback**: The hybrid approach effectively balances global constraints via linearization and local non-linear optimization, providing a robust solution for the rational objective function without heavy computational overhead.
**Program Identifier:** Generation 9 - Patch Name improved_packing_and_local_search - Correct Program: True

**Program Name: Binary Search with Linearized Bin Packing and Local Search**
- **Implementation**: Implements binary search on the target KVPR by transforming the non-linear constraint into a linear bin packing problem solved via Best Fit with multiple sorting heuristics. A post-placement local search refines the result by greedily moving or swapping models from the highest-pressure GPU.
- **Performance**: Achieved a high combined score of 26.23 with a perfect success rate and minimal execution time (0.001s).
- **Feedback**: Transforming the KVPR metric into a linear weight constraint allows the use of efficient bin packing algorithms, while the local search effectively resolves residual imbalances in tight packing scenarios.
**Program Identifier:** Generation 10 - Patch Name local_search_swaps - Correct Program: True

**Program Name: Linearized Bin Packing with Multi-Operator Local Search**
- **Implementation**: The algorithm initializes by transforming the non-linear KVPR objective into a weighted Bin Packing problem solved via binary search, followed by a local search using Move, Swap(1-1), and Swap(1-2) operators. It prioritizes bottleneck GPUs and utilizes lexicographical vector comparison to ensure strict improvement during refinement.
- **Performance**: The solution achieved a high combined score of 27.48 with a max KVPR score of 26.48 and extremely fast execution (0.012s).
- **Feedback**: The linearization strategy effectively creates a high-quality initial placement, significantly reducing the workload for the local search. The inclusion of the 1-to-2 swap operator was critical for resolving memory fragmentation issues where standard 1-to-1 swaps often get stuck.
**Program Identifier:** Generation 11 - Patch Name bsearch_linearization_ils - Correct Program: True

**Program Name: Binary Search with Linearized Best Fit and Local Refinement**
- **Implementation**: The algorithm linearizes the non-linear KVPR constraint to perform a binary search for the optimal target value using a Best Fit Decreasing packing heuristic with dual sorting strategies. It refines the initial placement using a local search that iteratively moves or swaps models from the bottleneck GPU to strictly lower the maximum pressure.
- **Performance**: The solution achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The combination of linearized weights for global approximation and bottleneck-aware local search provides a highly effective balance of speed and solution quality. The dual sorting strategies (linearized weight vs. size) significantly improve robustness when memory constraints are tight.
**Program Identifier:** Generation 12 - Patch Name hybrid_placement_search - Correct Program: True

**Program Name: Binary Search Packing with Iterated Local Search**
- **Implementation**: Implements binary search on the target pressure ratio using multi-heuristic Best Fit bin packing, followed by Iterated Local Search with greedy moves and swaps to optimize placement.
- **Performance**: The solution achieved a combined score of 26.23, a 100% success rate, and a fast execution time of 0.002s.
- **Feedback**: The approach of refining a binary-search-derived baseline with local search proved highly effective, balancing memory and load constraints to minimize the maximum KV cache pressure.
**Program Identifier:** Generation 13 - Patch Name iterated_local_search_and_density_sort - Correct Program: True

**Program Name: Linearized Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm binary searches for the optimal target KVPR by converting the problem into a linearized bin packing task solved via Best Fit with multiple sorting heuristics (weight, size, load, density). It refines the placement using a local search that iteratively relieves the bottleneck GPU through greedy moves, 1-for-1 swaps, and 2-for-1 swaps.
- **Performance**: Achieves a high combined score of 26.23 with a 100% success rate and negligible execution time (0.002s).
- **Feedback**: The linearization of the non-linear KVPR constraint enables the effective application of standard packing heuristics, while the specific inclusion of 2-for-1 swaps allows the local search to better balance fragmentation and capacity constraints.
**Program Identifier:** Generation 14 - Patch Name packing_density_heuristic - Correct Program: True

**Program Name: Linearized Bin-Packing Search with Perturbation-based Local Search**
- **Implementation**: The algorithm initializes using binary search on a linearized constraint (`load + K*size`) to balance load and memory usage, followed by Iterated Local Search targeting bottleneck GPUs. It employs Move, Swap(1-1), and Swap(1-2) operators, using random perturbation to escape local optima when descent stagnates.
- **Performance**: Achieved a combined score of 38.38 with a 0.96 success rate and 0.035s execution time.
- **Feedback**: The linearized initialization effectively approximates the non-linear KVPR objective for a strong starting solution, while the 1-2 swap and perturbation mechanisms robustly handle fragmentation and local optima better than simple greedy approaches.
**Program Identifier:** Generation 15 - Patch Name ils_linearized_kvpr - Correct Program: True

**Program Name: Binary Search Initialization with Lexicographical Local Search Refinement**
- **Implementation**: Uses binary search on a linearized bin-packing constraint to find an initial placement, then refines via local search using move, 1-to-1 swap, and 1-to-2 swap operators minimizing lexicographical pressure vectors.
- **Performance**: Achieved a high combined score of 27.48 with 100% success rate and very fast execution (0.012s).
- **Feedback**: The 1-to-2 swap operator effectively addresses memory fragmentation, while the binary search initialization provides a robust starting point significantly closer to the global optimum than standard greedy methods.
**Program Identifier:** Generation 16 - Patch Name binary_search_linearization_restore_v2 - Correct Program: True

**Program Name: Linearized Binary Search Construction with Iterated Local Search**
- **Implementation**: The algorithm initializes via binary search over the target KVPR using linearized bin-packing constraints with multiple sorting heuristics, followed by Iterated Local Search targeting bottleneck GPUs using move, swap, and 2-1 swap operators.
- **Performance**: It achieved a robust combined score of 26.26 with a 100% success rate and negligible execution time (0.002s).
- **Feedback**: The linearization of the objective function allowed for a high-quality initial placement, while the specific focus on bottleneck GPUs in the local search phase effectively leveled the load across devices.
**Program Identifier:** Generation 17 - Patch Name iterated_ils_swap21_bs - Correct Program: True

**Program Name: Binary Search BFD with Multi-Operator Local Search Refinement**
- **Implementation**: The algorithm minimizes max KVPR by binary searching for a target threshold using Best Fit Decreasing with multiple sorting heuristics, followed by a local search refinement using shift, 1-1 swap, and 2-1 swap operators on the bottleneck GPU.
- **Performance**: It achieves a strong combined score of 26.23 and perfect success rate with negligible execution time (0.002s).
- **Feedback**: The use of diverse sorting heuristics in the packing phase provides a robust initialization, while the specific 2-1 swap operator in the local search effectively resolves fragmentation issues that simple swaps miss.
**Program Identifier:** Generation 18 - Patch Name binsearch_ils_hybrid - Correct Program: True

**Program Name: Linearized Binary Search Packing with Local Search Refinement**
- **Implementation**: Transforms the non-linear KVPR objective into a linear bin-packing constraint solved via binary search and multi-heuristic Best Fit Decreasing, followed by iterative move and swap operations on the bottleneck GPU.
- **Performance**: Achieved a strong combined score of 26.23 with negligible execution time (0.017s) and 100% success rate.
- **Feedback**: The linearization strategy effectively converted the complex ratio optimization into a solvable packing problem, providing a high-quality initial solution that required minimal refinement.
**Program Identifier:** Generation 19 - Patch Name hybrid_bs_local_search - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

Based on the analysis of the individual program summaries and the code of the current best program (Generation 15), here are the specific insights:

## Successful Algorithmic Patterns
- **Perturbation-Based Iterated Local Search (ILS)**: The current best program (Generation 15, Score 38.38) achieves a massive performance leap by implementing a "perturbation" mechanism. When standard local search stagnates, the algorithm forcefully moves a model from the bottleneck GPU to a random feasible GPU—even if it temporarily degrades the score—to escape local optima.
- **1-to-2 Swap Operator**: Programs that implemented a 1-to-2 swap operator (Generation 11, 16, and 15; Scores 27.48-38.38) successfully broke the 26.23 score plateau. This operator effectively resolves memory fragmentation where a large model on a bottleneck GPU cannot fit on another GPU unless two smaller models are displaced.
- **Linearized Binary Search Initialization**: Transforming the non-linear KVPR objective into a linear bin packing constraint (`load + K*size <= K*Capacity`) solved via binary search proved to be the most robust initialization strategy. Generations 10-19 consistently used this to achieve a high baseline score (~26.23) with negligible execution time (~0.002s).
- **Lexicographical Vector Optimization**: Programs like Generation 11 and 16 improved over the baseline by optimizing the sorted vector of all GPU pressures rather than just the single maximum peak. This ensures the algorithm continues to improve secondary bottlenecks, preventing premature convergence.

## Ineffective Approaches
- **Standard Greedy Local Search**: Programs relying solely on greedy hill-climbing (e.g., Generation 10, 12, 19) consistently plateaued at a score of 26.23. Without a mechanism to accept temporary degradation (perturbation), these algorithms could not navigate the non-convex solution landscape to find the global optimum.
- **Limited Operator Sets**: Implementations restricted to only `Move` and `Swap (1-to-1)` operations (e.g., Generation 10, 12) failed to improve beyond the baseline. They were unable to handle scenarios where model size disparities prevented simple direct swaps.
- **Greedy 2-to-1 Swaps without Vector Comparison**: Generation 14 implemented 2-for-1 swaps but only achieved 26.23. This suggests that without the pairing of lexicographical vector comparison (used in Gen 11/16) to guide the search, the complex swap operator is not fully utilized.

## Implementation Insights
- **Explicit Perturbation Logic**: The best program (Generation 15) implements perturbation by selecting the worst GPU and moving a random model to a random feasible destination (`dest.add(model_to_move)`), specifically bypassing the improvement check. This coding pattern is the key differentiator for the 38.38 score.
- **Efficient State Caching**: To support the intensive Iterated Local Search, the best program's `GPUState` class caches `_cached_kvpr` and `_cached_rem`. This avoids recomputing the expensive ratio calculation during the thousands of tentative moves and swaps.
- **Native Tuple Comparison for Vectors**: The successful programs implement lexicographical optimization efficiently using Python's native tuple comparison: `current_vector = tuple(sorted((g.kvpr() for g in gs), reverse=True))`. This allows simple `new_vec < current_vec` checks to drive the optimization of the entire system distribution.
- **Dynamic Constraint Linearization**: The initialization function `solve_linearized_bin_packing` dynamically calculates weights as `(req_rate / slo) + target_k * model_size`, effectively collapsing the multi-dimensional constraint into a scalar for standard Best Fit heuristics.

## Performance Analysis
- **Three Performance Tiers**: The results show three distinct score tiers:
    1.  **Baseline (~26.23)**: Standard Binary Search + Simple Local Search (Gen 10, 12, 13, 14, 18, 19).
    2.  **fragmentation-Aware (~27.48)**: Added 1-to-2 Swaps + Lexicographical Comparison (Gen 11, 16).
    3.  **Global Optimization (38.38)**: Added Perturbation/ILS (Gen 15).
- **Impact of Perturbation**: The jump from ~27.48 to 38.38 in Generation 15 demonstrates that the problem space is highly prone to local optima. A purely descent-based approach (even with advanced swaps) is insufficient compared to an approach that allows temporary worsening of the solution.
- **Efficiency of Hybrid Approaches**: Despite the complexity of ILS, Generation 15 executes in 0.035s. This confirms that combining a fast, mathematically grounded initialization (Linearized BS) with an aggressive, targeted local search is far more efficient than slower, purely constructive or evolutionary methods.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the analysis of the current best program (Generation 15) and its successful implementation of Perturbation-Based Iterated Local Search, here are 5 actionable recommendations for future mutations:

1.  **Targeted Perturbation Strategy**: Refine the perturbation logic to move the model from the bottleneck GPU to the **least loaded feasible GPU** (lowest KVPR) rather than a *random* feasible one. This maintains the "kick" required to escape local optima while placing the displaced model in a location that minimizes immediate damage to the system's balance, potentially speeding up convergence.
2.  **2-to-2 Swap Operator**: Extend the successful "1-to-2 Swap" pattern to include **"2-to-2 Swaps"**, where two models from the bottleneck GPU are exchanged for two models from a target GPU. This operator can resolve complex fragmentation scenarios and load imbalances that 1-to-1 or 1-to-2 swaps cannot address, particularly when both GPUs are near capacity but have different model count densities.
3.  **Randomized Multi-Start Initialization**: Leverage the extremely low execution time (0.035s) by wrapping the entire algorithm in a multi-start loop. Introduce randomization into the `solve_linearized_bin_packing` function (e.g., by adding small random noise to the weights `w`) to generate 5-10 diverse starting seeds, running the Iterated Local Search on each and returning the global best.
4.  **Tabu Search Integration**: Add a short-term memory (Tabu list) to the local search that prevents a model moved *out* of a bottleneck GPU from being moved *back* to it for a fixed number of iterations (e.g., 5-10). This prevents the algorithm from cycling between two states (undoing/redoing the same move) and forces it to explore new configurations deeper in the search space.
5.  **Steepest Descent Move Selection**: Modify the local search `Move` operator to scan **all** valid moves for the bottleneck GPU and select the **best** one (lexicographically minimizing the pressure vector) rather than accepting the *first* improvement found. While computationally more expensive, the current speed margin allows for this more aggressive optimization to maximize the gain at each step.