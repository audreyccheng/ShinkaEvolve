<NAME>
diverse_init
</NAME>

<DESCRIPTION>
Improve the initialization phase by diversifying the target packing parameter 'K' (KVPR linearization slope) during random restarts. Instead of a fixed K derived from binary search, we iterate through a small range of multipliers (1.0 to 1.2) to find a packing that offers a better starting point for load balancing. This helps avoid "tight" packings that minimize capacity usage but create local hotspots.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # 2. Multi-Start Initialization
    best_init_plc = None
    best_init_max_kvpr = float('inf')

    # Attempt deterministic + multiple randomized starts slightly above base_k
    search_k = base_k * 1.001

    seeds = [None] + list(range(19)) # 20 total starts
    for seed in seeds:
        if time.time() - start_time > 0.15: break # Cap initialization budget

        res = solve_packing(search_k, random_seed=seed)
        if res:
            current_max = 0.0
            for g in range(gpu_num):
                l = sum(x['l'] for x in res[g])
                s = sum(x['s'] for x in res[g])
                k_val = get_kvpr(l, s)
                if k_val > current_max: current_max = k_val

            if current_max < best_init_max_kvpr:
                best_init_max_kvpr = current_max
                best_init_plc = res
=======
    # 2. Multi-Start Initialization
    best_init_plc = None
    best_init_max_kvpr = float('inf')

    # Attempt deterministic + multiple randomized starts with varying K
    # Varying K helps find packing that balances load vs size better
    k_multipliers = [1.0, 1.05, 1.1, 1.15, 1.2]
    seeds = list(range(25))
    random.shuffle(seeds)

    for i, seed in enumerate(seeds):
        if time.time() - start_time > 0.20: break # Increased budget slightly

        # Cycle K multipliers
        mult = k_multipliers[i % len(k_multipliers)]
        curr_k = base_k * mult

        res = solve_packing(curr_k, random_seed=seed)
        if res:
            current_max = 0.0
            for g in range(gpu_num):
                l = sum(x['l'] for x in res[g])
                s = sum(x['s'] for x in res[g])
                k_val = get_kvpr(l, s)
                if k_val > current_max: current_max = k_val

            if current_max < best_init_max_kvpr:
                best_init_max_kvpr = current_max
                best_init_plc = res
>>>>>>> REPLACE
</DIFF>

<NAME>
optimized_swap21_search
</NAME>

<DESCRIPTION>
Optimize the 'Swap 2-1' local search operator by prioritizing the removal of the largest items from the bottleneck GPU. By sorting candidate items by size descending, we can check the most promising swaps (those that free up the most memory) earlier. This allows us to use the limited check budget more effectively.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                # 3. Swap 2-1 (2 from bottleneck)
                if len(src_items) >= 2:
                    limit_checks = 100
                    checks = 0
                    for i1 in range(len(src_items)):
                        if checks > limit_checks: break
                        for i2 in range(i1 + 1, len(src_items)):
                            m1 = src_items[i1]
                            m2 = src_items[i2]
                            pair_l = m1['l'] + m2['l']
                            pair_s = m1['s'] + m2['s']

                            for t in valid_targets:
                                tgt_items = plc[t]
                                for j, m3 in enumerate(tgt_items):
                                    if b_s - pair_s + m3['s'] >= GPU_MEM_SIZE: continue
                                    if gpu_stats[t]['s'] - m3['s'] + pair_s >= GPU_MEM_SIZE: continue

                                    nk_src = get_kvpr(b_l - pair_l + m3['l'], b_s - pair_s + m3['s'])
                                    nk_tgt = get_kvpr(gpu_stats[t]['l'] - m3['l'] + pair_l, gpu_stats[t]['s'] - m3['s'] + pair_s)

                                    new_global = max(nk_src, nk_tgt)
                                    if new_global < cur_max - 1e-7:
                                        imp = cur_max - new_global
                                        if imp > best_imp:
                                            best_imp = imp
                                            best_move = ('swap21', b_idx, i1, i2, t, j)
                                    checks += 1
=======
                # 3. Swap 2-1 (2 from bottleneck)
                if len(src_items) >= 2:
                    # Sort indices by size descending to prioritize removing large items
                    sorted_indices = sorted(range(len(src_items)), key=lambda k: src_items[k]['s'], reverse=True)
                    limit_checks = 150
                    checks = 0

                    for idx1 in range(len(sorted_indices)):
                        if checks > limit_checks: break
                        i1 = sorted_indices[idx1]
                        # Only check pairs
                        for idx2 in range(idx1 + 1, len(sorted_indices)):
                            i2 = sorted_indices[idx2]

                            m1 = src_items[i1]
                            m2 = src_items[i2]
                            pair_l = m1['l'] + m2['l']
                            pair_s = m1['s'] + m2['s']

                            for t in valid_targets:
                                tgt_items = plc[t]
                                for j, m3 in enumerate(tgt_items):
                                    # Capacity checks
                                    if b_s - pair_s + m3['s'] >= GPU_MEM_SIZE - 1e-7: continue
                                    if gpu_stats[t]['s'] - m3['s'] + pair_s >= GPU_MEM_SIZE - 1e-7: continue

                                    nk_src = get_kvpr(b_l - pair_l + m3['l'], b_s - pair_s + m3['s'])
                                    nk_tgt = get_kvpr(gpu_stats[t]['l'] - m3['l'] + pair_l, gpu_stats[t]['s'] - m3['s'] + pair_s)

                                    new_global = max(nk_src, nk_tgt)
                                    if new_global < cur_max - 1e-7:
                                        imp = cur_max - new_global
                                        if imp > best_imp:
                                            best_imp = imp
                                            best_move = ('swap21', b_idx, i1, i2, t, j)
                                    checks += 1
>>>>>>> REPLACE
</DIFF>

<NAME>
safe_swap21_exec
</NAME>

<DESCRIPTION>
Update the 'Swap 2-1' execution logic to safely handle item removal. Since the optimized search loop now uses sorted indices (where i1 and i2 are not guaranteed to be ordered i2 > i1), we must explicitly pop the larger index first to avoid index shifting issues.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                elif mtype == 'swap21':
                    _, b, i1, i2, t, j = best_move
                    it2 = plc[b].pop(i2)
                    it1 = plc[b].pop(i1)
                    it3 = plc[t].pop(j)
                    plc[b].append(it3)
                    plc[t].extend([it1, it2])
                    pl = it1['l'] + it2['l']; ps = it1['s'] + it2['s']
                    gpu_stats[b]['l'] += it3['l'] - pl; gpu_stats[b]['s'] += it3['s'] - ps
                    gpu_stats[t]['l'] += pl - it3['l']; gpu_stats[t]['s'] += ps - it3['s']
=======
                elif mtype == 'swap21':
                    _, b, i1, i2, t, j = best_move
                    # Pop larger index first to avoid shifting
                    idx_first, idx_second = sorted((i1, i2), reverse=True)
                    it_first = plc[b].pop(idx_first)
                    it_second = plc[b].pop(idx_second)

                    it3 = plc[t].pop(j)
                    plc[b].append(it3)
                    plc[t].extend([it_first, it_second])

                    pl = it_first['l'] + it_second['l']; ps = it_first['s'] + it_second['s']
                    gpu_stats[b]['l'] += it3['l'] - pl; gpu_stats[b]['s'] += it3['s'] - ps
                    gpu_stats[t]['l'] += pl - it3['l']; gpu_stats[t]['s'] += ps - it3['s']
>>>>>>> REPLACE
</DIFF>

<NAME>
dual_target_perturb
</NAME>

<DESCRIPTION>
Implement 'Dual-Target' perturbation. Instead of only removing items from the bottleneck GPU, we also remove items from the GPU with the lowest KVPR (lightest load). This creates empty space in the system that allows the bottleneck's heavy items to be redistributed more effectively during the greedy reconstruction phase.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # --- Perturbation (Ruins & Recreate) ---
        if not bottlenecks: break

        b_idx = random.choice(bottlenecks)
        if not plc[b_idx]: break

        # Remove items (try to remove largest to shake things up)
        candidates_to_remove = sorted(enumerate(plc[b_idx]), key=lambda x: x[1]['s'], reverse=True)
        num_remove = min(len(candidates_to_remove), random.randint(1, 2))

        removed_items = []
        # We need to pop by index, so we must be careful about index shifting or just pick random to be safe/fast
        # Random removal is robust
        for _ in range(num_remove):
            if not plc[b_idx]: break
            idx = random.randrange(len(plc[b_idx]))
            item = plc[b_idx].pop(idx)
            removed_items.append(item)
            gpu_stats[b_idx]['l'] -= item['l']
            gpu_stats[b_idx]['s'] -= item['s']

        # Recreate: Best Fit
        for item in removed_items:
=======
        # --- Perturbation (Ruins & Recreate) ---
        if not bottlenecks: break

        # 1. Select Bottleneck
        b_idx = random.choice(bottlenecks)

        # 2. Select Benefactor (GPU with lowest KVPR to dump load into)
        min_k = float('inf')
        min_idx = -1
        for g in range(gpu_num):
            if g == b_idx: continue
            k_val = get_kvpr(gpu_stats[g]['l'], gpu_stats[g]['s'])
            if k_val < min_k:
                min_k = k_val
                min_idx = g

        removed_items = []

        # Remove from bottleneck (Randomly, 1-2 items)
        if plc[b_idx]:
            num_remove = min(len(plc[b_idx]), random.randint(1, 2))
            for _ in range(num_remove):
                if not plc[b_idx]: break
                idx = random.randrange(len(plc[b_idx]))
                item = plc[b_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[b_idx]['l'] -= item['l']
                gpu_stats[b_idx]['s'] -= item['s']

        # Remove from benefactor (Create space, 1 item)
        if min_idx != -1 and plc[min_idx]:
            # Try to remove a smaller item to make space for a bigger one from bottleneck?
            # Or just random. Random is safer.
            if plc[min_idx]:
                idx = random.randrange(len(plc[min_idx]))
                item = plc[min_idx].pop(idx)
                removed_items.append(item)
                gpu_stats[min_idx]['l'] -= item['l']
                gpu_stats[min_idx]['s'] -= item['s']

        random.shuffle(removed_items)

        # Recreate: Best Fit (Greedy K-minimization)
        for item in removed_items:
>>>>>>> REPLACE
</DIFF>