<NAME>
hybrid_perturbation_sweep
</NAME>

<DESCRIPTION>
1.  **Initialization**: Widened the initialization search by sweeping a range of K-multipliers (1.0 to 1.5) instead of just relying on noise around the minimum K. This helps find starting configurations that might be less tightly packed (higher K) but have better load distribution properties.
2.  **ILS Tuning**: Increased the iteration budget to 250 and expanded the bottleneck identification depth from top-3 to top-6 GPUs for swap operators, allowing the algorithm to address secondary bottlenecks more aggressively.
3.  **Dual-Pivot Perturbation**: Replaced the single-GPU ruin strategy with a Dual-Pivot approach that simultaneously empties the worst bottleneck GPU and the best (lightest loaded) GPU. This creates a "sink" for heavy models to move into. Additionally, implemented an alternating sorting strategy (Size vs Load) for the recreation phase to improve packing efficiency compared to random shuffling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Find best K
    best_k = high
    for _ in range(15):
        mid = (low + high) / 2
        res = solve_linearized_bp(mid)
        if res:
            best_k = mid
            high = mid
        else:
            low = mid

    # Generate candidates with noise around best_k
    if best_k < 1e8:
        for _ in range(10):
            k_noisy = best_k * random.uniform(0.95, 1.05)
            res = solve_linearized_bp(k_noisy, noise=0.05)
            if res: candidates.append(res)
    else:
        # Fallback if no valid K found (unlikely)
        res = solve_linearized_bp(best_k)
        if res: candidates.append(res)
=======
    # Find best K
    best_k = high
    for _ in range(20):
        mid = (low + high) / 2
        res = solve_linearized_bp(mid)
        if res:
            best_k = mid
            high = mid
        else:
            low = mid

    # Generate candidates with broader sweep around best_k
    if best_k < 1e8:
        multipliers = [1.0, 1.05, 1.1, 1.2, 1.3, 1.5]
        for mult in multipliers:
            for _ in range(2):
                k_target = best_k * mult
                res = solve_linearized_bp(k_target, noise=0.08)
                if res: candidates.append(res)
    else:
        res = solve_linearized_bp(best_k)
        if res: candidates.append(res)
>>>>>>> REPLACE
<<<<<<< SEARCH
    # -------------------------------------------------------------------------
    # 2. Iterated Local Search (ILS)
    # -------------------------------------------------------------------------
    iter_cnt = 0
    max_iter = 150

    while iter_cnt < max_iter:
        improved_step = False

        # Sort GPUs: Bottlenecks (highest KVPR) to Sources
        sorted_gpus = sorted(current_gpus, key=lambda g: g.kvpr(), reverse=True)
        sources = sorted_gpus[:4]
=======
    # -------------------------------------------------------------------------
    # 2. Iterated Local Search (ILS)
    # -------------------------------------------------------------------------
    iter_cnt = 0
    max_iter = 250

    while iter_cnt < max_iter:
        improved_step = False

        # Sort GPUs: Bottlenecks (highest KVPR) to Sources
        sorted_gpus = sorted(current_gpus, key=lambda g: g.kvpr(), reverse=True)
        sources = sorted_gpus[:6]
>>>>>>> REPLACE
<<<<<<< SEARCH
        # --- Operator 3: Swap 2-1 ---
        for source in sources[:3]:
            if len(source.models) < 2: continue
=======
        # --- Operator 3: Swap 2-1 ---
        for source in sources[:6]:
            if len(source.models) < 2: continue
>>>>>>> REPLACE
<<<<<<< SEARCH
        # --- Operator 4: Swap 1-2 ---
        for source in sources[:3]:
            for i, m_a in enumerate(source.models):
=======
        # --- Operator 4: Swap 1-2 ---
        for source in sources[:6]:
            for i, m_a in enumerate(source.models):
>>>>>>> REPLACE
<<<<<<< SEARCH
        # --- Perturbation (Ruin and Recreate) ---
        iter_cnt += 1
        if iter_cnt > max_iter - 10: break

        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break

        # Ruin: Evict all
        evicted = []
        while worst_gpu.models:
            evicted.append(worst_gpu.remove(0))

        # Shuffle for randomness
        random.shuffle(evicted)

        # Recreate: Best Fit
        for m in evicted:
            best_dest = None
            best_val = float('inf')
            # Consider all including worst_gpu (which is now empty/lighter)
            # Actually, let's try to put them elsewhere first.
            # If worst_gpu is empty, its load is 0, so it will be a candidate.

            for dest in current_gpus:
                if dest.can_fit(m.model_size):
                    rem = GPU_MEM_SIZE - (dest.used_mem + m.model_size)
                    val = (dest.load + m.req_rate/m.slo) / rem if rem > 1e-7 else float('inf')
                    if val < best_val:
                        best_val = val
                        best_dest = dest

            if best_dest:
                best_dest.add(m)
            else:
                # Must put back in original if no fit (should not happen if it came from there)
                worst_gpu.add(m)
=======
        # --- Perturbation (Dual Ruin and Recreate) ---
        iter_cnt += 1
        if iter_cnt > max_iter - 10: break

        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break

        evicted = []

        # 1. Ruin Bottleneck
        while worst_gpu.models:
            evicted.append(worst_gpu.remove(0))

        # 2. Ruin Lightest GPU (Sink) to create space
        if len(sorted_gpus) > 1:
            best_gpu = sorted_gpus[-1]
            if best_gpu.id != worst_gpu.id:
                 while best_gpu.models:
                    evicted.append(best_gpu.remove(0))

        # Recreate Strategy: Alternating Sort (Size vs Load)
        if iter_cnt % 2 == 0:
             evicted.sort(key=lambda m: m.model_size, reverse=True)
        else:
             evicted.sort(key=lambda m: m.req_rate / m.slo, reverse=True)

        # Recreate: Best Fit
        for m in evicted:
            best_dest = None
            best_val = float('inf')

            for dest in current_gpus:
                if dest.can_fit(m.model_size):
                    rem = GPU_MEM_SIZE - (dest.used_mem + m.model_size)
                    val = (dest.load + m.req_rate/m.slo) / rem if rem > 1e-7 else float('inf')
                    if val < best_val:
                        best_val = val
                        best_dest = dest

            if best_dest:
                best_dest.add(m)
            else:
                if worst_gpu.can_fit(m.model_size):
                    worst_gpu.add(m)
                else:
                    for g in current_gpus:
                        if g.can_fit(m.model_size): g.add(m); break
>>>>>>> REPLACE
</DIFF>