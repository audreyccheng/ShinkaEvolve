{
  "unprocessed_programs": [],
  "meta_summary": "**Program Name: Greedy Load-Density Minimization Placement**\n- **Implementation**: The algorithm sorts models by load intensity (request rate/SLO) and places them on the GPU that minimizes the current ratio of accumulated load to remaining memory.\n- **Performance**: Achieved a high combined score of 21.89 and a 100% success rate, efficiently minimizing maximum KV cache pressure.\n- **Feedback**: The strategy of dynamically balancing accumulated load against available capacity effectively prevents hotspots, resulting in a superior distribution of cache pressure compared to standard packing methods.\n**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True\n\n**Program Name: Multi-start Greedy with Lexicographical Local Search**\n- **Implementation**: The algorithm generates initial solutions using three sorting heuristics (size, load, density) and refines the best one using a local search that applies moves and swaps to the bottleneck GPU, accepting changes that improve the lexicographical vector of pressures.\n- **Performance**: It achieved a high combined score of 25.75 with extremely fast execution (0.004s) and a 100% success rate.\n- **Feedback**: The lexicographical comparison enables the local search to optimize the overall load distribution rather than just the maximum peak, while the multi-start approach robustly handles varying model characteristics.\n**Program Identifier:** Generation 1 - Patch Name greedy_multistart_localsearch - Correct Program: True\n\n**Program Name: Greedy Resulting-Pressure Minimization with Size-Descent Sort**\n- **Implementation**: The algorithm sorts models by size and load (descending) and iteratively assigns them to the GPU that minimizes the resulting KV cache pressure (total load divided by remaining memory).\n- **Performance**: Achieved a high combined score of 20.43 with a 100% success rate and very low execution time (0.013s).\n- **Feedback**: Sorting by size primarily ensures large models are placed before memory becomes fragmented, while the greedy look-ahead strategy for specific pressure reduction effectively balances the load across resources.\n**Program Identifier:** Generation 2 - Patch Name greedy_resulting_kvpr_bfd - Correct Program: True\n\n**Program Name: Multi-start Greedy with Lexicographical Local Search**\n- **Implementation**: The solution employs a multi-start greedy strategy initialized by various sorting metrics (size, load, density) and random shuffles, followed by a local search refinement. It optimizes the lexicographically sorted vector of GPU pressures using move and swap operators targeted specifically at the top three bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and fast execution time of 0.103s.\n- **Feedback**: The use of lexicographical comparison allows the algorithm to improve secondary bottlenecks when the maximum pressure cannot be immediately reduced, preventing premature convergence. Focusing the local search on high-pressure GPUs ensures the solution remains computationally efficient while effectively balancing the load.\n**Program Identifier:** Generation 3 - Patch Name randomized_multi_start_local_search - Correct Program: True\n\n**Program Name: Binary Search KVPR with Linearized Weight Bin Packing**\n- **Implementation**: The algorithm minimizes maximum KV cache pressure by binary searching for a target threshold, converting the feasibility check into a bin packing problem using First Fit Decreasing on linearized weights ($req\\_rate/slo + threshold \\times size$).\n- **Performance**: It achieved a high score of 26.23 and a 100% success rate, efficiently balancing load and memory constraints with negligible execution time.\n- **Feedback**: The transformation of the fractional objective into a linear bin-packing constraint allows the heuristic to adaptively prioritize heavy or large models based on the current target pressure, resulting in optimal placements.\n**Program Identifier:** Generation 4 - Patch Name kvpr_binary_search_packing - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Best Fit and Local Search**\n- **Implementation**: The algorithm linearizes the KVPR objective to enable binary search for the optimal target value, utilizing Best Fit bin packing with dual sorting heuristics (linearized weight and model size) to check feasibility. A post-processing local search greedily moves models from the highest-pressure GPU to others to refine the global maximum pressure.\n- **Performance**: The solution achieved a combined score of 26.23 with a max KVPR metric of 25.233, maintaining a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: Transforming the non-linear KVPR metric into a linear constraint allows for efficient approximation via binary search, solving the core allocation problem effectively. The addition of local search refinement ensures the initial packing is optimized further, correcting any imbalances left by the heuristic packing.\n**Program Identifier:** Generation 5 - Patch Name bs_bestfit_localsearch - Correct Program: True\n\n**Program Name: Binary Search with Transformed First-Fit Decreasing Bin Packing**\n- **Implementation**: The solution minimizes maximum KV cache pressure by binary searching for an optimal target value, transforming the non-linear ratio constraint into linear item weights and validating feasibility using a First-Fit Decreasing heuristic.\n- **Performance**: The approach performed exceptionally well, achieving a combined score of 26.10 with a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: Converting the min-max objective into a feasibility problem via binary search allows efficient application of standard bin packing heuristics, effectively balancing computational speed with solution quality.\n**Program Identifier:** Generation 6 - Patch Name binary_search_bin_packing - Correct Program: True\n\n**Program Name: Binary Search with Multi-Strategy Best Fit Packing**\n- **Implementation**: The algorithm minimizes KV cache pressure using binary search on the pressure ratio, validating feasibility via Best Fit Decreasing with three alternate sorting strategies (linearized weight, model size, and load).\n- **Performance**: Achieves a high score of 26.10 with a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: The use of multiple sorting heuristics within the packing check allows the solution to adapt dynamically to whether memory or load is the dominant constraint, resulting in highly efficient placements.\n**Program Identifier:** Generation 7 - Patch Name improved_packing_heuristics - Correct Program: True\n\n**Program Name: Binary Search Best Fit with Multi-Strategy Sorting**\n- **Implementation**: The solution minimizes maximum KVPR by binary searching for the optimal pressure threshold, initializing with a theoretical lower bound derived from fluid packing. The feasibility check uses a Best Fit Decreasing algorithm that attempts three distinct sorting strategies (Linearized Weight, Size, and Load) to robustly fit models into GPUs.\n- **Performance**: The algorithm achieved a high combined score of 26.23 and a 100% success rate with extremely fast execution times (0.002s).\n- **Feedback**: The use of multiple sorting strategies allows the packer to adapt dynamically to both memory-bound and load-bound scenarios, significantly improving packing density. Additionally, calculating a precise lower bound for the binary search range ensures the algorithm converges quickly on the optimal solution.\n**Program Identifier:** Generation 8 - Patch Name adaptive_multi_strategy_packing - Correct Program: True\n\n**Program Name: Binary Search Bin Packing with Local Search Refinement**\n- **Implementation**: The algorithm performs a binary search on the target KVPR to solve a linearized bin packing problem using Best Fit with multiple sorting heuristics, followed by a greedy local search that moves or swaps models to relieve the bottleneck GPU.\n- **Performance**: It achieves a high score of 26.23 and perfect success rate with negligible execution time (0.001s).\n- **Feedback**: The hybrid approach effectively balances global constraints via linearization and local non-linear optimization, providing a robust solution for the rational objective function without heavy computational overhead.\n**Program Identifier:** Generation 9 - Patch Name improved_packing_and_local_search - Correct Program: True\n\n**Program Name: Binary Search with Linearized Bin Packing and Local Search**\n- **Implementation**: Implements binary search on the target KVPR by transforming the non-linear constraint into a linear bin packing problem solved via Best Fit with multiple sorting heuristics. A post-placement local search refines the result by greedily moving or swapping models from the highest-pressure GPU.\n- **Performance**: Achieved a high combined score of 26.23 with a perfect success rate and minimal execution time (0.001s).\n- **Feedback**: Transforming the KVPR metric into a linear weight constraint allows the use of efficient bin packing algorithms, while the local search effectively resolves residual imbalances in tight packing scenarios.\n**Program Identifier:** Generation 10 - Patch Name local_search_swaps - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Multi-Operator Local Search**\n- **Implementation**: The algorithm initializes by transforming the non-linear KVPR objective into a weighted Bin Packing problem solved via binary search, followed by a local search using Move, Swap(1-1), and Swap(1-2) operators. It prioritizes bottleneck GPUs and utilizes lexicographical vector comparison to ensure strict improvement during refinement.\n- **Performance**: The solution achieved a high combined score of 27.48 with a max KVPR score of 26.48 and extremely fast execution (0.012s).\n- **Feedback**: The linearization strategy effectively creates a high-quality initial placement, significantly reducing the workload for the local search. The inclusion of the 1-to-2 swap operator was critical for resolving memory fragmentation issues where standard 1-to-1 swaps often get stuck.\n**Program Identifier:** Generation 11 - Patch Name bsearch_linearization_ils - Correct Program: True\n\n**Program Name: Binary Search with Linearized Best Fit and Local Refinement**\n- **Implementation**: The algorithm linearizes the non-linear KVPR constraint to perform a binary search for the optimal target value using a Best Fit Decreasing packing heuristic with dual sorting strategies. It refines the initial placement using a local search that iteratively moves or swaps models from the bottleneck GPU to strictly lower the maximum pressure.\n- **Performance**: The solution achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: The combination of linearized weights for global approximation and bottleneck-aware local search provides a highly effective balance of speed and solution quality. The dual sorting strategies (linearized weight vs. size) significantly improve robustness when memory constraints are tight.\n**Program Identifier:** Generation 12 - Patch Name hybrid_placement_search - Correct Program: True\n\n**Program Name: Binary Search Packing with Iterated Local Search**\n- **Implementation**: Implements binary search on the target pressure ratio using multi-heuristic Best Fit bin packing, followed by Iterated Local Search with greedy moves and swaps to optimize placement.\n- **Performance**: The solution achieved a combined score of 26.23, a 100% success rate, and a fast execution time of 0.002s.\n- **Feedback**: The approach of refining a binary-search-derived baseline with local search proved highly effective, balancing memory and load constraints to minimize the maximum KV cache pressure.\n**Program Identifier:** Generation 13 - Patch Name iterated_local_search_and_density_sort - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Local Search Refinement**\n- **Implementation**: The algorithm binary searches for the optimal target KVPR by converting the problem into a linearized bin packing task solved via Best Fit with multiple sorting heuristics (weight, size, load, density). It refines the placement using a local search that iteratively relieves the bottleneck GPU through greedy moves, 1-for-1 swaps, and 2-for-1 swaps.\n- **Performance**: Achieves a high combined score of 26.23 with a 100% success rate and negligible execution time (0.002s).\n- **Feedback**: The linearization of the non-linear KVPR constraint enables the effective application of standard packing heuristics, while the specific inclusion of 2-for-1 swaps allows the local search to better balance fragmentation and capacity constraints.\n**Program Identifier:** Generation 14 - Patch Name packing_density_heuristic - Correct Program: True\n\n**Program Name: Linearized Bin-Packing Search with Perturbation-based Local Search**\n- **Implementation**: The algorithm initializes using binary search on a linearized constraint (`load + K*size`) to balance load and memory usage, followed by Iterated Local Search targeting bottleneck GPUs. It employs Move, Swap(1-1), and Swap(1-2) operators, using random perturbation to escape local optima when descent stagnates.\n- **Performance**: Achieved a combined score of 38.38 with a 0.96 success rate and 0.035s execution time.\n- **Feedback**: The linearized initialization effectively approximates the non-linear KVPR objective for a strong starting solution, while the 1-2 swap and perturbation mechanisms robustly handle fragmentation and local optima better than simple greedy approaches.\n**Program Identifier:** Generation 15 - Patch Name ils_linearized_kvpr - Correct Program: True\n\n**Program Name: Binary Search Initialization with Lexicographical Local Search Refinement**\n- **Implementation**: Uses binary search on a linearized bin-packing constraint to find an initial placement, then refines via local search using move, 1-to-1 swap, and 1-to-2 swap operators minimizing lexicographical pressure vectors.\n- **Performance**: Achieved a high combined score of 27.48 with 100% success rate and very fast execution (0.012s).\n- **Feedback**: The 1-to-2 swap operator effectively addresses memory fragmentation, while the binary search initialization provides a robust starting point significantly closer to the global optimum than standard greedy methods.\n**Program Identifier:** Generation 16 - Patch Name binary_search_linearization_restore_v2 - Correct Program: True\n\n**Program Name: Linearized Binary Search Construction with Iterated Local Search**\n- **Implementation**: The algorithm initializes via binary search over the target KVPR using linearized bin-packing constraints with multiple sorting heuristics, followed by Iterated Local Search targeting bottleneck GPUs using move, swap, and 2-1 swap operators.\n- **Performance**: It achieved a robust combined score of 26.26 with a 100% success rate and negligible execution time (0.002s).\n- **Feedback**: The linearization of the objective function allowed for a high-quality initial placement, while the specific focus on bottleneck GPUs in the local search phase effectively leveled the load across devices.\n**Program Identifier:** Generation 17 - Patch Name iterated_ils_swap21_bs - Correct Program: True\n\n**Program Name: Binary Search BFD with Multi-Operator Local Search Refinement**\n- **Implementation**: The algorithm minimizes max KVPR by binary searching for a target threshold using Best Fit Decreasing with multiple sorting heuristics, followed by a local search refinement using shift, 1-1 swap, and 2-1 swap operators on the bottleneck GPU.\n- **Performance**: It achieves a strong combined score of 26.23 and perfect success rate with negligible execution time (0.002s).\n- **Feedback**: The use of diverse sorting heuristics in the packing phase provides a robust initialization, while the specific 2-1 swap operator in the local search effectively resolves fragmentation issues that simple swaps miss.\n**Program Identifier:** Generation 18 - Patch Name binsearch_ils_hybrid - Correct Program: True\n\n**Program Name: Linearized Binary Search Packing with Local Search Refinement**\n- **Implementation**: Transforms the non-linear KVPR objective into a linear bin-packing constraint solved via binary search and multi-heuristic Best Fit Decreasing, followed by iterative move and swap operations on the bottleneck GPU.\n- **Performance**: Achieved a strong combined score of 26.23 with negligible execution time (0.017s) and 100% success rate.\n- **Feedback**: The linearization strategy effectively converted the complex ratio optimization into a solvable packing problem, providing a high-quality initial solution that required minimal refinement.\n**Program Identifier:** Generation 19 - Patch Name hybrid_bs_local_search - Correct Program: True\n\n**Program Name: Hybrid Binary Search Initialization with Lexicographic Local Search**\n- **Implementation**: The algorithm combines binary search-based linearization for initial bin packing with greedy fallbacks, followed by a local search utilizing move, 1-1 swap, and 2-1 swap operators to optimize the KV pressure vector lexicographically. An escape mechanism redistributes models from the worst-off GPU to overcome local optima.\n- **Performance**: It achieved a strong combined score of 25.89, maintaining a 100% success rate with very fast execution (0.077s).\n- **Feedback**: The binary search initialization effectively sets a high-quality global baseline, while lexicographic comparison prevents oscillation between bottlenecks; the multi-item swap operator specifically helps resolve fragmentation issues that simple swaps miss.\n**Program Identifier:** Generation 20 - Patch Name hierarchical_linearization_search - Correct Program: True\n\n**Program Name: Binary Search Initialization with Multi-Operator Local Search**\n- **Implementation**: Utilizes binary search on target pressure to map the problem to linear bin packing for initialization, followed by local search using move, 1-to-1, and 1-to-2 swap operators to optimize the pressure distribution.\n- **Performance**: Achieved a high score of 27.48 with a 1.000 success rate and minimal execution time (0.016s).\n- **Feedback**: The linearization of the KVPR constraint allowed for effective heuristic initialization, while the inclusion of the 1-to-2 swap operator successfully addressed memory fragmentation issues that limit simpler algorithms.\n**Program Identifier:** Generation 21 - Patch Name init_cached_rem - Correct Program: True\n\n**Program Name: Multi-Start Perturbation-Based Iterated Local Search**\n- **Implementation**: Initializes via randomized bin packing with linearized weights, followed by steepest descent using transfer, 1-1, and 2-1 swaps focused on the bottleneck GPU, and perturbation logic to escape local optima.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution (0.053s).\n- **Feedback**: The inclusion of 2-1 swaps and targeted perturbations significantly enhances the ability to balance load across GPUs compared to standard greedy methods, effectively minimizing maximum KV cache pressure.\n**Program Identifier:** Generation 22 - Patch Name ils_multistart_steepest - Correct Program: True\n\n**Program Name: Multi-Start ILS with Binary Search Linearization**\n- **Implementation**: Initializes solutions using both Binary Search Linearization (approximating the non-linear objective via weighted bin packing) and Greedy Size heuristics, followed by Iterated Local Search with variable neighborhood descent (move, swap 1-1/1-2) and random perturbation kicks.\n- **Performance**: Achieved a competitive combined score of 38.29 with a 98% success rate and rapid execution time (0.031s).\n- **Feedback**: The binary search linearization provides a sophisticated starting placement that closely approximates the target metric, while the perturbation mechanism allows the algorithm to effectively escape local optima during the refinement phase.\n**Program Identifier:** Generation 23 - Patch Name hybrid_ils_placement - Correct Program: True\n\n**Program Name: Multi-Start Iterated Local Search with Complex Swaps**\n- **Implementation**: The algorithm initializes placements using randomized bin packing and refines them via steepest descent hill climbing, employing comprehensive moves (transfer, 1-1, 2-1, 2-2 swaps) targeting the bottleneck GPU and directed perturbations to escape local optima.\n- **Performance**: It achieved an exceptional combined score of 26.25 and 100% success rate with rapid execution (0.056s).\n- **Feedback**: The inclusion of higher-order swap operations (2-1, 2-2) and a multi-start framework allows the solver to effectively resolve fragmentation and minimize peak KV cache pressure better than simpler heuristics.\n**Program Identifier:** Generation 24 - Patch Name swap22_and_robust_perturbation - Correct Program: True\n\n**Program Name: Hybrid ILS with Multi-Start Greedy Initialization**\n- **Implementation**: Utilizes binary search bin packing and multiple greedy heuristics for initialization, followed by Iterated Local Search using move, 1-1 swap, and 1-2 swap operators targeting bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 39.22 with 100% success rate and extremely fast execution (0.025s).\n- **Feedback**: The lexicographical comparison of GPU pressure vectors ensures robust min-max optimization, while the 1-2 swap operator effectively navigates tight memory constraints that block simpler local moves.\n**Program Identifier:** Generation 25 - Patch Name hybrid_ils_placement - Correct Program: True\n\n**Program Name: Multi-Start Iterated Local Search with Complex Swap Neighborhoods**\n- **Implementation**: The solution uses Best Fit Decreasing with binary search for initialization, followed by multi-start steepest descent local search utilizing Shift, 1-1, 2-1, and 2-2 swap neighborhoods to refine placements.\n- **Performance**: It achieved a score of 26.23 with 0.001s execution time, demonstrating excellent efficiency and solution quality.\n- **Feedback**: The inclusion of higher-order swaps (2-1, 2-2) allows the algorithm to resolve bottlenecks that simple moves miss, while heuristic pruning ensures the larger search space does not negatively impact execution speed.\n**Program Identifier:** Generation 26 - Patch Name multistart_ils_swap22 - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: The solution employs binary search to linearize the objective into a parameter-weighted bin packing problem for initialization, followed by Iterated Local Search (ILS) utilizing Move, Swap(1-1), and Swap(1-2) operators with perturbation to refine bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 40.10 with a 100% success rate and extremely fast execution (0.032s).\n- **Feedback**: The linearization strategy effectively approximates the optimal distribution for the initial state, significantly reducing the search space required by the local search to reach high-quality solutions.\n**Program Identifier:** Generation 27 - Patch Name init_multistart_guided_perturbation - Correct Program: True\n\n**Program Name: ILS with Linearized Bin Packing and Multi-Item Swaps**\n- **Implementation**: Uses binary search on linearized bin packing for initialization, followed by Iterated Local Search (ILS) utilizing steepest descent moves and complex swaps (1-1, 2-1, 1-2).\n- **Performance**: Achieved a high score of 36.62 with a 98% success rate and fast execution time (0.081s).\n- **Feedback**: The advanced initialization coupled with diverse swap operators allows for effective load balancing and escape from local optima, significantly improving distribution quality.\n**Program Identifier:** Generation 28 - Patch Name ils_smart_perturb_steepest - Correct Program: True\n\n**Program Name: Hybrid ILS with Multi-Start Linearized Bin Packing**\n- **Implementation**: This approach utilizes a multi-start initialization strategy combining binary search linearized bin packing and various greedy heuristics to find a robust starting point. It refines the solution using Iterated Local Search (ILS) with Variable Neighborhood Descent, employing move, 1-1 swap, and 1-2 swap operators to specifically relieve the highest-pressure GPUs.\n- **Performance**: The algorithm achieves a high combined score of 38.19 with a 100% success rate and very fast execution (0.035s).\n- **Feedback**: The implementation of the 1-2 swap operator proves highly effective for optimizing memory packing against large models, while the linearized bin packing initialization ensures the search begins from a high-quality basin of attraction.\n**Program Identifier:** Generation 29 - Patch Name steepest_descent_and_targeted_perturbation - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search and Multi-Swaps**\n- **Implementation**: The solution initializes placements using a binary search to solve a linearized parameter-weighted bin packing problem, followed by an Iterated Local Search (ILS) that utilizes advanced moves (1-1, 1-2, 2-1 swaps) and random perturbations to escape local optima.\n- **Performance**: The algorithm achieved a high combined score of 37.14 with a 98% success rate and extremely rapid execution (0.059s).\n- **Feedback**: The linearization strategy provides excellent initial placements by approximating the non-linear objective function, while the specialized multi-item swaps effectively resolve memory fragmentation issues that simple moves cannot address.\n**Program Identifier:** Generation 30 - Patch Name ils_steepest_descent_swap21_random_init - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Initializes using a binary search to solve a linearized weighted bin packing problem, followed by Iterated Local Search using 1-1, 1-2, and 2-1 swap operators guided by lexicographical KVPR vector comparison.\n- **Performance**: Achieved a high combined score (41.43) with exceptional speed (0.026s), though the 92% success rate indicates occasional packing failures.\n- **Feedback**: The complex swap moves (1-2, 2-1) significantly improved load balancing by handling small model fragmentation, but the initialization fallbacks were occasionally insufficient for finding valid solutions in memory-constrained scenarios.\n**Program Identifier:** Generation 31 - Patch Name ils_hybrid_linearized_bp_optimized_swap21 - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Variable Neighborhood Descent**\n- **Implementation:** Utilizes a binary search linearization strategy to convert the fractional objective into a weighted bin packing problem, followed by Variable Neighborhood Descent with multi-item swaps (1-1, 1-2, 2-1) and a ruin-and-recreate perturbation mechanism.\n- **Performance:** Achieves a strong combined score of 38.99 with rapid 0.048s execution, though with a 92% success rate.\n- **Feedback:** The linearization approach offers a mathematically grounded initialization that outperforms standard greedy heuristics, while the specialized swap moves allows the algorithm to effectively handle fragmentation and rebalance loads to minimize pressure.\n**Program Identifier:** Generation 32 - Patch Name randomized_init_and_ruins_perturbation - Correct Program: True\n\n**Program Name: Binary Search with Multi-Strategy Packing and Steepest Descent**\n- **Implementation**: The solution utilizes binary search over the target rate, verifying feasibility via Best Fit Decreasing with three sorting strategies (linearized weight, size, load), followed by a steepest descent local search that swaps or moves models to relieve the bottleneck GPU.\n- **Performance**: It achieved a strong combined score of 26.23 (Max KVPR: 25.23) with extremely fast execution (0.002s) and perfect reliability.\n- **Feedback**: The use of multiple sorting heuristics makes the initial packing robust across different constraint regimes, while the greedy local search effectively refines the coarse solution found by binary search.\n**Program Identifier:** Generation 33 - Patch Name add_steepest_descent_local_search - Correct Program: True\n\n**Program Name: Hybrid ILS with Binary Search and Complex Swap Operators**\n- **Implementation**: The solution initializes using binary search-based weighted bin packing and refined greedy strategies, followed by Iterated Local Search (ILS) employing advanced 2-1 and 1-2 model swap operators.\n- **Performance**: It achieved a high combined score of 38.54 with a 94% success rate and fast execution time (0.053s).\n- **Feedback**: The addition of complex swap operators allows the algorithm to escape local optima involving model size mismatches, significantly improving load balancing compared to standard pairwise swaps.\n**Program Identifier:** Generation 34 - Patch Name hybrid_ils_with_swap21_and_randomized_greedy - Correct Program: True\n\n**Program Name: Iterated Local Search with Linearized Bin Packing Initialization**\n- **Implementation**: Uses linearized bin packing with binary search for initialization, followed by iterated local search utilizing best-improvement moves, complex swaps (1-1, 1-2, 2-1), and a ruins-and-recreate perturbation strategy.\n- **Performance**: Achieved a combined score of 38.38 with a 0.84 success rate and fast execution (0.007s).\n- **Feedback**: The targeted bottleneck optimization effectively minimizes peak pressure, though the sub-100% success rate indicates that feasibility checks for extremely tight constraints could be further robustified.\n**Program Identifier:** Generation 35 - Patch Name ils_linearized_best_move_ruin_recreate - Correct Program: True\n\n**Program Name: Multi-Start Linearized Packing with Complex Swap Iterated Local Search**\n- **Implementation**: Initializes using a binary-search weighted bin packing strategy and greedy heuristics, followed by an Iterated Local Search employing Move and complex Swap (1-1, 1-2, 2-1) operators on a lexicographical objective vector.\n- **Performance**: Achieves a high combined score of 39.80 and 92% success rate with very low latency (0.037s).\n- **Feedback**: The inclusion of multi-item swaps (1-2, 2-1) effectively addresses memory fragmentation in bottleneck GPUs, while the lexicographical vector comparison ensures robust optimization beyond just the maximum value.\n**Program Identifier:** Generation 36 - Patch Name linearized_random - Correct Program: True\n\n**Program Name: Linearized Bin-Packing Initialization with Iterated Local Search**\n- **Implementation**: Uses binary search to tune a linearized $Load + K \\cdot Size$ objective for initial bin packing, followed by local search with multi-item swaps (2-1, 1-2) and a \"ruins and recreate\" perturbation strategy.\n- **Performance**: High performance with a score of 38.44 (37.50 KVPR) and fast execution (0.04s), though the 94% success rate indicates occasional packing failures.\n- **Feedback**: The linearization approach effectively approximates the non-linear pressure objective for initialization, while the perturbation logic successfully breaks bottlenecks by redistributing models from the most pressured GPU.\n**Program Identifier:** Generation 37 - Patch Name randomized_multistart_ils_ruins - Correct Program: True\n\n**Program Name: Multi-Start Randomized ILS with Complex Swap Neighborhoods**\n- **Implementation**: The solution employs a multi-start framework initializing with randomized Best-Fit Decreasing based on a binary-searched load factor. It refines placements using steepest descent local search targeting the bottleneck GPU with Shift, Swap 1-1, Swap 2-1, and Swap 2-2 moves.\n- **Performance**: It achieved a high combined score of 26.23 with rapid execution (0.002s) and a 100% success rate.\n- **Feedback**: The addition of complex neighborhood moves (Swap 2-2) effectively resolves tight packing deadlocks that simpler moves cannot handle, while the randomized restart strategy ensures diverse exploration of the solution space.\n**Program Identifier:** Generation 38 - Patch Name randomized_multistart_ils_swap22 - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Initializes placements using Linearized Bin Packing with binary search to find the optimal size-load tradeoff parameter, then refines the solution via Iterated Local Search using lexicographical optimization, multiple swap operators (1-1, 2-1, 1-2), and a ruins-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 25.72 (max KVPR 24.72) with extremely fast execution (0.081s).\n- **Feedback**: The dynamic parameter tuning ensures robust initial placements across different distributions, while the specialized swap operators and perturbation strategy effectively break local optima to minimize bottleneck KV pressure.\n**Program Identifier:** Generation 39 - Patch Name stochastic_ils_gpu_placement - Correct Program: True\n\n**Program Name: Multi-Start Linearized Packing with Iterated Local Search**\n- **Implementation**: Features a binary search to optimize load-size weighting for initialization, followed by Iterated Local Search employing diverse swap operators (1-1, 2-1, 1-2, 2-2) and a \"ruins and recreate\" perturbation strategy.\n- **Performance**: Achieved a combined score of 38.57 with a 94% success rate and fast 0.049s execution time.\n- **Feedback**: The comprehensive local search operators effectively minimize cache pressure, though the 6% failure rate suggests the need for a stronger fallback mechanism for tight packing constraints.\n**Program Identifier:** Generation 40 - Patch Name init_random_greedy - Correct Program: True\n\n**Program Name: Multi-Start Linearized Bin Packing with Tabu Search**\n- **Implementation**: Combines linearized bin packing with binary search for initialization and an Iterated Local Search employing steepest descent, tabu lists, and comprehensive swap operators (1-1, 1-2, 2-1).\n- **Performance**: Achieved a score of 0.00 with a 0% success rate, indicating the program failed to execute successfully or pass validation tests.\n- **Feedback**: The explicit raising of a `ValueError` when heuristics fail and the hardcoded memory limit likely caused crashes on valid test cases; a more robust fallback strategy is required to ensure a solution is always returned.\n**Program Identifier:** Generation 41 - Patch Name ils_steepest_descent_with_tabu - Correct Program: False\n\n**Program Name: Multi-Strategy Binary Search with Complex Neighborhood Local Search**\n- **Implementation**: Initializes placements using binary search over a linearized weighting factor with multiple sorting heuristics, then refines via steepest descent local search employing shift, swap-1-1, swap-2-1, and swap-2-2 moves.\n- **Performance**: Achieves a high efficiency score of 25.91 and very low latency (0.011s), though the 88% success rate indicates occasional validity issues.\n- **Feedback**: The use of higher-order swaps (2-1, 2-2) allows the algorithm to effectively rebalance heavy/large models from bottleneck GPUs, significantly improving solution quality, though the heuristic packing sometimes fails to find valid starting solutions in tight constraints.\n**Program Identifier:** Generation 42 - Patch Name multistrategy_ils_placement - Correct Program: True\n\n**Program Name: Binary Search Packing with Iterated Local Search**\n- **Implementation**: The algorithm uses binary search to optimize a target KVPR by solving feasibility bin packing problems using randomized Best Fit heuristics, followed by Iterated Local Search employing 1-0, 1-1, and 2-1 swaps targeting bottleneck GPUs.\n- **Performance**: Achieved a score of 26.26 with a 100% success rate and extremely low latency (0.007s).\n- **Feedback**: The binary search approach effectively linearizes the non-linear objective to generate strong initial placements, while the complex swap moves (specifically 2-1) in the local search phase efficiently resolve residual high-pressure bottlenecks.\n**Program Identifier:** Generation 43 - Patch Name none - Correct Program: True\n\n**Program Name: Hybrid ILS with Binary Search Linearization and Multi-Model Swaps**\n- **Implementation**: Combines stochastic binary search linearization for diverse initialization with an Iterated Local Search using 1-1, 2-1, and 1-2 swaps alongside a \"ruins and recreate\" perturbation.\n- **Performance**: Achieved a high combined score of 37.90 with fast execution (0.042s), optimizing maximum KV cache pressure effectively.\n- **Feedback**: The specialized 2-1 and 1-2 swap operators successfully mitigate memory fragmentation, though the 98% success rate indicates potential stability issues in extremely constrained scenarios.\n**Program Identifier:** Generation 44 - Patch Name none - Correct Program: True\n\n**Program Name: Binary Search Packing with Bottleneck-Guided Multi-Start Local Search**\n- **Implementation**: The algorithm combines binary search-based randomized bin packing to generate initial solutions with a steepest descent local search that targets the bottleneck GPU using Move, Swap(1-1), and complex Swap(2-1/1-2) operators.\n- **Performance**: Achieved a score of 26.23 with negligible execution time (0.001s), demonstrating high efficiency and optimal placement.\n- **Feedback**: The transformation of the ratio objective into a linear bin-packing weight allows for excellent constructive bounds, while the asymmetric swap operators (2-1, 1-2) effectively handle model size disparities during local refinement.\n**Program Identifier:** Generation 45 - Patch Name stochastic_multistart_ils - Correct Program: True\n\n**Program Name: Multi-Start Iterated Local Search with Bottleneck-Focused Moves**\n- **Implementation**: The algorithm utilizes randomized bin packing with linearized weights ($L + K \\cdot S$) for initialization, followed by steepest descent local search that targets the bottleneck GPU using transfers, 1-1 swaps, and 2-1 swaps. An iterated perturbation mechanism reallocates models from bottleneck to underloaded GPUs to escape local optima across multiple restarts.\n- **Performance**: The solution achieved a high combined score of 24.28 (max KVPR 23.282) with a 100% success rate and rapid 0.075s execution time.\n- **Feedback**: Targeting the bottleneck GPU with diverse move operators (including 2-1 swaps) effectively minimizes maximum pressure, while the adaptive randomized restarts ensure robustness against poor initial configurations. The low execution time indicates efficient pruning and evaluation of move candidates.\n**Program Identifier:** Generation 46 - Patch Name optimize_ls_and_perturbation_v2 - Correct Program: True\n\n**Program Name: Iterated Local Search with Randomized Binary Search Initialization**\n- **Implementation**: The algorithm combines multi-start randomized binary search using dynamic weights ($L + K \\cdot S$) for initialization with a steepest descent local search (Move, Swap 1-1, Swap 2-1) specifically targeting bottleneck GPUs. It employs a perturbation mechanism to escape local optima within a strict 0.2-second time budget.\n- **Performance**: Achieved a high score of 26.26 with a 1.000 success rate and efficient 0.213s runtime.\n- **Feedback**: The multi-start strategy effectively identifies high-quality initial basins, while the targeted local search on max-pressure GPUs significantly refines the solution by addressing specific load imbalances through complex swap operations.\n**Program Identifier:** Generation 47 - Patch Name stochastic_ils_kvpr - Correct Program: True\n\n**Program Name: Multi-Start Randomized Packing with Steepest Descent Iterated Local Search**\n- **Implementation**: Uses randomized Best Fit Decreasing with linearized weights ($Load + K \\cdot Size$) for initialization, followed by Iterated Local Search applying Move, Swap 1-1, and Swap 2-1 operations on bottleneck GPUs.\n- **Performance**: Achieved a high score of 22.87 (metric 21.87) with rapid execution (0.057s).\n- **Feedback**: The binary search for the weighting factor $K$ provides a strong initial solution, and the diverse swap operators in the local search effectively refine the load balance to minimize peak pressure.\n**Program Identifier:** Generation 48 - Patch Name stochastic_multistart_ils_placement - Correct Program: True\n\n**Program Name: Multi-Start Iterated Local Search with Fragmentation-Aware Swaps**\n- **Implementation:** The solution combines binary search-weighted bin packing initialization with an Iterated Local Search that utilizes move, 1-1 swap, and complex 1-2/2-1 swap operators to optimize model placement.\n- **Performance:** The algorithm delivers a high score of 40.41 and very fast execution (0.023s), with a solid 92% success rate.\n- **Feedback:** The inclusion of 1-2 and 2-1 swap operators effectively addresses memory fragmentation issues that typically block simple moves, while the multi-strategy initialization ensures robust performance across varied inputs.\n**Program Identifier:** Generation 49 - Patch Name hybrid_ils_swap21_sorted_dests - Correct Program: True\n\n**Program Name: Iterated Local Search with Weighted Bin Packing Initialization**\n- **Implementation**: The algorithm initializes using a binary search weighted bin packing heuristic that balances load and size, followed by an Iterated Local Search (ILS) using Variable Neighborhood Descent with various swap operators (1-1, 2-1, 1-2).\n- **Performance**: Achieves a high score of 38.13 with extremely fast execution (0.046s), though the success rate is 94.0%.\n- **Feedback**: The approach of minimizing the lexicographical vector of cache pressures is highly effective for load balancing, but the non-100% success rate suggests the fallback packing logic could be more robust for tight memory constraints.\n**Program Identifier:** Generation 50 - Patch Name hybrid_ils_guided - Correct Program: True\n\n**Program Name: Hybrid Linearized Packing with Variable Neighborhood Descent**\n- **Implementation**: The algorithm initializes placements using binary-search linearized bin packing and randomized greedy strategies, then refines the solution via Iterated Local Search with Move and multi-item Swap operators (1-1, 1-2, 2-1) targeting bottleneck GPUs.\n- **Performance**: It achieves a high combined score of 49.92 with exceptional speed (0.021s), though the 92% success rate indicates occasional feasibility failures.\n- **Feedback**: The weighted linearization initialization coupled with complex swap operators effectively minimizes cache pressure, but the fallback mechanisms require improvement to ensure valid placements in all constrained scenarios.\n**Program Identifier:** Generation 51 - Patch Name optimize_ils_operators - Correct Program: True\n\n**Program Name: Stochastic Multi-Start ILS with Ruins and Recreate**\n- **Implementation**: Combines randomized linearized bin packing for initialization with Iterated Local Search using best-improvement moves and swaps (1-1, 2-1, 1-2), supplemented by a \"Ruins and Recreate\" perturbation strategy to escape local optima.\n- **Performance**: Achieved a combined score of 45.86 with a 94% success rate and fast execution (0.088s).\n- **Feedback**: The diverse set of local search operators targeting bottleneck GPUs, combined with stochastic restarts and destructive perturbation, effectively balances loads and ensures high solution quality across valid placements.\n**Program Identifier:** Generation 52 - Patch Name stochastic_ils_lns - Correct Program: True\n\n**Program Name: Iterated Local Search with Linearized Bin Packing Initialization**\n- **Implementation**: This approach combines randomized linearized bin packing initialization with an Iterated Local Search (ILS) utilizing Move and Swap (1-1, 1-2, 2-1) operators directed by lexicographical bottleneck reduction.\n- **Performance**: Achieved a strong combined score of 46.82 with a 96% success rate and rapid execution (0.029s).\n- **Feedback**: The specialized swap operators and density-guided perturbation effectively resolve memory fragmentation, while the lexicographical objective ensures balanced load distribution across bottlenecks.\n**Program Identifier:** Generation 53 - Patch Name stochastic_ils_placement - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Multi-Operator Iterated Local Search**\n- **Implementation**: Utilizes a binary search on linearized constraints for initialization and an Iterated Local Search with Move and variable-size Swap operators (1-1, 1-2, 2-1) to optimize GPU load balance.\n- **Performance**: High score of 49.94 and 96% success rate with fast execution (0.032s), demonstrating strong optimization capability.\n- **Feedback**: The variable-size swap operators effectively address memory fragmentation, while the linearized initialization generates diverse, high-quality starting solutions.\n**Program Identifier:** Generation 54 - Patch Name ils_best_improvement_and_stochastic_init - Correct Program: True\n\n**Program Name: Stochastic Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Combines stochastic linearized bin packing initialization with Iterated Local Search using best-improvement moves, complex swaps (2-1, 1-2), and a \"ruins and recreate\" perturbation mechanism to minimize lexicographical KV cache pressure.\n- **Performance**: Achieved a high combined score of 43.50 with very fast execution (0.064s) and a 96% success rate.\n- **Feedback**: The lexicographical objective and multi-item swaps effectively smooth bottlenecks, though the sub-100% success rate suggests initialization constraints could be more robust for edge cases.\n**Program Identifier:** Generation 55 - Patch Name stochastic_ils_lns - Correct Program: True\n\n**Program Name: Hybrid Linearized Packing with Iterated Local Search**\n- **Implementation**: The algorithm initializes using multi-start binary search on a linearized objective ($L + K \\cdot S$) to fit bin-packing constraints, refining the result with steepest descent local search (moves, 1-1 swaps, 2-1 swaps) and a \"Ruins & Recreate\" perturbation strategy.\n- **Performance**: Achieved a combined score of 26.26 with a 100% success rate, maximizing the 0.8s time budget for deep optimization.\n- **Feedback**: Linearizing the non-linear KVPR constraint enables effective initialization via standard packing heuristics, while the targeted local search operations successfully resolve bottlenecks that simpler greedy approaches miss.\n**Program Identifier:** Generation 56 - Patch Name multi_start_lns_placement - Correct Program: True\n\n**Program Name: Multi-Start Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Combines binary search for an optimal load-size linearization factor during initialization with Iterated Local Search employing move, multi-item swap (1-1, 1-2, 2-1), and ruin-and-recreate perturbation.\n- **Performance**: Achieves a combined score of 61.00 and 0.020s execution time, though with a 92% success rate.\n- **Feedback**: The linearization strategy provides strong initial placements by weighing model size against load, while 1-2 and 2-1 swaps effectively mitigate fragmentation, although the non-100% success rate indicates limitations in tightest packing scenarios.\n**Program Identifier:** Generation 57 - Patch Name expand_swaps_and_add_lns_perturbation - Correct Program: True\n\n**Program Name: Multi-Start Randomized Packing with Bottleneck-Targeted Iterated Local Search**\n- **Implementation**: The algorithm initializes via multi-start randomized Best Fit Decreasing using a binary search for capacity constraints, followed by an Iterated Local Search applying steepest descent moves (Move, Swap 1-1, Swap 2-1) specifically on bottleneck GPUs. It escapes local optima using a \"Ruins & Recreate\" perturbation that redistributes items from the most loaded processors.\n- **Performance**: It achieved a combined score of 26.26 with 100% success rate, maximizing performance within the 0.9s time limit.\n- **Feedback**: Targeting only bottleneck GPUs allows the local search to efficiently optimize the min-max objective, while the Swap 2-1 move helps resolve difficult packing configurations that simpler swaps miss.\n**Program Identifier:** Generation 58 - Patch Name stochastic_multistart_ils_lns - Correct Program: True\n\n**Program Name: Hybrid ILS with Linearized Bin Packing and Multi-Swap Operators**\n- **Implementation**: This approach combines randomized binary search weighted bin packing for robust initialization with an Iterated Local Search (ILS) that employs advanced neighborhood operators, including 1-1, 1-2, and 2-1 swaps, to refine model placement.\n- **Performance**: The algorithm achieved a high combined score of 39.05 and a 96% success rate, with a very fast execution time of 0.042s.\n- **Feedback**: The inclusion of complex swap operators (moving two models for one) allows the solver to escape local optima where simple pairwise swaps fail, effectively balancing high-pressure GPUs.\n**Program Identifier:** Generation 59 - Patch Name stochastic_initialization_and_ils_overhaul - Correct Program: True\n\n**Program Name: Linearized Bin Packing Search with Iterated Local Refinement**\n- **Implementation**: Uses binary search on a linearized capacity constraint to solve a weighted bin packing problem for initialization, followed by Iterated Local Search with multi-item swap operators and bottleneck-targeted perturbation.\n- **Performance**: Achieved a high score of 44.51 with a 94% success rate and fast execution (0.057s).\n- **Feedback**: The linearization strategy effectively transforms the non-linear objective into a standard packing problem, while the \"ruin and recreate\" perturbation robustly escapes local optima by redistributing load from bottleneck GPUs.\n**Program Identifier:** Generation 60 - Patch Name ils_best_improvement - Correct Program: True\n\n**Program Name: Hybrid Memetic Algorithm with Linearized Bin Packing and ILS**\n- **Implementation**: The solution employs stochastic initialization via linearized bin packing with noise and greedy heuristics, followed by an Iterated Local Search using move, swap, and ruin-and-recreate operators targeting bottleneck GPUs.\n- **Performance**: Achieving a combined score of 46.01, the algorithm reached a max KVPR of 45.03 with a 98% success rate and 0.059s execution time.\n- **Feedback**: The focus on minimizing the lexicographical vector of GPU loads proved highly effective for reducing peak pressure, though the sub-100% success rate indicates occasional failures in finding valid packings for tight constraints.\n**Program Identifier:** Generation 61 - Patch Name hybrid_memetic_ils_v2 - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Variable Neighborhood Search**\n- **Implementation**: Combines randomized linearized bin packing initialization with an iterated local search employing move and multi-item swap operators (1-1, 1-2, 2-1) to relieve bottleneck GPUs.\n- **Performance**: Achieved a score of 55.08 with 0.025s execution time and a 94.0% success rate.\n- **Feedback**: The lexicographical comparison strategy successfully optimizes secondary bottlenecks, though the sub-perfect success rate suggests the fallback packing heuristic struggles with extremely tight memory constraints.\n**Program Identifier:** Generation 62 - Patch Name hybrid_ils_ruin_recreate - Correct Program: True\n\n**Program Name: Multi-Start Iterated Local Search with Complex Bottleneck Swaps**\n- **Implementation**: The solution implements a multi-start iterated local search initialized by parameter-tuned bin packing, utilizing steepest descent with complex swaps (1-1, 2-1, 2-2) specifically targeting the bottleneck GPU.\n- **Performance**: It achieved a strong combined score of 26.26 with a 100% success rate and rapid execution (0.023s).\n- **Feedback**: The targeted steepest descent on the bottleneck GPU combined with higher-order swaps effectively minimizes peak pressure, while the perturbation strategy robustly escapes local optima without compromising speed.\n**Program Identifier:** Generation 64 - Patch Name improved_ils_swap22_fixed - Correct Program: True\n\n**Program Name: Multi-Heuristic Initialization with Variable Neighborhood Descent**\n- **Implementation**: Features a binary search construction phase using multiple sorting strategies and randomization, followed by a local search with move and complex swap (1-1, 2-1, 1-2) operators targeting bottlenecks.\n- **Performance**: Achieved a robust score of 26.23 and 100% success rate with an execution time of 0.803s.\n- **Feedback**: The inclusion of complex swaps (2-1, 1-2) and a perturbation mechanism allows the algorithm to effectively refine placements and escape local optima within the tight time constraint.\n**Program Identifier:** Generation 65 - Patch Name improved_ils_with_vnd_v2 - Correct Program: True\n\n**Program Name: Multi-Start Linearized Packing with Iterated Local Search**\n- **Implementation**: Combines binary-search linearized bin packing and randomized greedy initialization with an Iterated Local Search (ILS) utilizing 1-1, 1-2, and 2-1 swap operators alongside a ruin-and-recreate perturbation.\n- **Performance**: Achieved a combined score of 61.86 with extremely fast execution (0.053s), though the 92% success rate suggests occasional failures in tight constraint scenarios.\n- **Feedback**: The linearized packing objective (`Load + k*Size`) effectively approximates the non-linear KVPR metric for initialization, while unbalanced swap operators (1-2, 2-1) are crucial for refining placements with heterogeneous model sizes.\n**Program Identifier:** Generation 66 - Patch Name hybrid_ils_packing - Correct Program: True\n\n**Program Name: Bottleneck-Targeted Iterated Local Search with Complex Swaps**\n- **Implementation**: Uses randomized bin packing with a binary-searched weight factor for initialization, followed by iterated local search utilizing complex moves (up to 2-2 swaps) targeted exclusively at the bottleneck GPU.\n- **Performance**: Achieved a combined score of 25.93 with 100% success rate and extremely fast execution (0.065s).\n- **Feedback**: Focusing expensive swap operations solely on the bottleneck GPU enables the use of higher-order moves (like 2-2 swaps) to escape local optima without incurring significant runtime penalties.\n**Program Identifier:** Generation 67 - Patch Name improved_packing_and_swap12 - Correct Program: True\n\n**Program Name: Randomized Linearized Packing with Iterated Local Search**\n- **Implementation**: Uses binary search to tune a linearized packing heuristic with randomized restarts for initialization, followed by Iterated Local Search targeting bottleneck GPUs with move, 1-1 swap, and 2-1 swap operators.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate, utilizing 0.903s of execution time.\n- **Feedback**: The strategy of combining global exploration via randomized linearized packing with intensive local refinement is highly effective for minimizing KVPR, though the complex swap operations push the runtime close to the limit.\n**Program Identifier:** Generation 68 - Patch Name ils_linearized_perturb_v2 - Correct Program: True\n\n**Program Name: Multi-Start Packing with Iterated Local Search**\n- **Implementation**: Uses multi-start randomized Best Fit packing guided by binary search weights for initialization, followed by Iterated Local Search targeting bottleneck GPUs with Move and Swap (1-1, 2-1) operators.\n- **Performance**: Achieved a combined score of 26.23 and 100% success rate, maximizing performance within the 1-second time constraint.\n- **Feedback**: The adaptive weighting strategy (`load + K * size`) derived from binary search provided superior initial placements, while the targeted local search effectively reduced peak pressure on constrained GPUs.\n**Program Identifier:** Generation 69 - Patch Name vnd_ils_model_placement - Correct Program: True\n\n**Program Name: Multi-Start Randomized Construction with Iterated Local Search**\n- **Implementation**: The solution employs multi-start randomized Best Fit packing tuned via binary search, followed by time-bounded iterated local search (ILS) using steepest descent (move, 1-1/2-1 swaps) and ruin-and-recreate perturbation.\n- **Performance**: It achieved a combined score of 26.26 (max KVPR 25.256) with a 100% success rate, effectively utilizing the 0.5s time budget.\n- **Feedback**: The combination of randomized initialization and multi-item swaps (2-1) effectively escapes local optima, while the strict time management ensures consistent performance without timeouts.\n**Program Identifier:** Generation 70 - Patch Name robust_ils_with_time_budget - Correct Program: True\n\n**Program Name: Dual-Ruin Iterated Local Search with Linearized Bin Packing**\n- **Implementation**: Uses binary-search linearized bin packing for initialization, refined by a VND local search (Move, Swap) focusing on high-KVPR sources. A dual-ruin perturbation redistributes models from the heaviest and lightest GPUs using alternating sort strategies to escape local optima.\n- **Performance**: Achieved a high score of 53.08 with 0.047s execution time and 98% success rate.\n- **Feedback**: The targeted perturbation of only the best and worst GPUs efficiently balances the specific KVPR objective (load/memory) without requiring computationally expensive full restarts, resulting in high solution quality.\n**Program Identifier:** Generation 71 - Patch Name ils_dual_ruin - Correct Program: True\n\n**Program Name: Hybrid Grid-Search Initialization with Bottleneck-Focused ILS**\n- **Implementation**: This approach employs a robust initialization via grid search over load-packing weights and greedy heuristics, followed by Iterated Local Search using move, swap, and 2-1 swap operators with a ruin-and-recreate perturbation for bottlenecks.\n- **Performance**: The solution achieved a combined score of 25.70, maintaining a 100% success rate with a fast execution time of 0.096s.\n- **Feedback**: The diverse initialization strategies effectively prevent bin-packing failures, while the perturbation mechanism specifically targeting high-pressure GPUs allows the algorithm to consistently escape local optima.\n**Program Identifier:** Generation 72 - Patch Name robust_ils_grid_search - Correct Program: True\n\n**Program Name: Multi-Strategy Initialization with Iterated Local Search and Perturbation**\n- **Implementation**: Combines randomized linearized bin packing (tuned via binary search) and greedy heuristics for initialization, followed by Iterated Local Search using move, swap, and 1-2 swap operators with random perturbations.\n- **Performance**: Achieves a high combined score of 41.20 with a max KVPR of 40.242 and rapid execution time (0.031s).\n- **Feedback**: The diverse initialization strategies provide robust starting points, while the perturbation mechanism effectively allows the solver to escape local optima in tightly constrained scenarios.\n**Program Identifier:** Generation 73 - Patch Name enhanced_initialization - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Utilizes binary search to linearize the objective into a weighted bin packing problem for initialization, followed by Iterated Local Search with complex moves (Swap 1-1, 2-1, 1-2) and a ruin-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 46.22 with a 96% success rate and very fast execution time (0.055s).\n- **Feedback**: The linearization strategy effectively balances load and capacity constraints for strong initial placements, while the multi-item swap operators successfully relieve bottleneck GPUs during refinement.\n**Program Identifier:** Generation 74 - Patch Name init_scan_and_dual_ruin - Correct Program: True\n\n**Program Name: Multi-Start Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Uses a binary search over a linearized load/size weight factor for initialization, followed by Iterated Local Search with targeted Move and Swap (1-1, 1-2, 2-1) operators on bottleneck GPUs.\n- **Performance**: Achieved a combined score of 51.56 with 96% success rate and 0.052s execution time.\n- **Feedback**: The linearized initialization provides diverse, high-quality starting points, while complex swap operators effectively reduce fragmentation and maximum pressure in the local search phase.\n**Program Identifier:** Generation 75 - Patch Name robust_init_and_ruin - Correct Program: True\n\n**Program Name: Binary Search Initialization with Bottleneck-Focused Iterated Local Search**\n- **Implementation**: The algorithm initializes via binary search to find an optimal target KVPR using multi-start Best Fit packing, followed by Iterated Local Search on the bottleneck GPU employing complex swaps (1-1, 2-1, 2-2) and a ruin-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate, effectively maximizing the allowed 0.9s execution window.\n- **Feedback**: The binary search initialization provides a significantly better starting state than standard greedy methods, and the deep swap neighborhoods allow for fine-grained reduction of the maximum KV cache pressure.\n**Program Identifier:** Generation 76 - Patch Name hybrid_ils_placement - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: The solution initializes via a binary-search linearized bin packing approach and greedy heuristics, followed by Iterated Local Search using complex swaps (1-1, 1-2, 2-1) and a ruin-and-recreate perturbation.\n- **Performance**: It achieved a combined score of 47.50, a 96% success rate, and a fast execution time of 0.060s.\n- **Feedback**: The linearized initialization provides a superior starting point by approximating the objective constraint, while the multi-item swap operators and perturbation mechanism effectively resolve bottlenecks in the non-linear search space.\n**Program Identifier:** Generation 77 - Patch Name Update_Docstring - Correct Program: True\n\n**Program Name: Multi-Start Linearized Packing with Bottleneck-Focused Iterated Local Search**\n- **Implementation**: This approach utilizes binary search to optimize a linearized packing constraint for multi-start initialization, followed by a steepest descent local search using move and swap operators alongside a ruins-and-recreate perturbation strategy.\n- **Performance**: The algorithm achieved a combined score of 26.23, with a max KVPR metric of 25.233 and a 1.000 success rate within 0.8s.\n- **Feedback**: The transformation of the ratio objective into a linearized bin-packing constraint effectively generates high-quality diverse starting points, while targeting bottleneck GPUs during local search robustly minimizes the maximum pressure.\n**Program Identifier:** Generation 78 - Patch Name init_range_perturb_multi - Correct Program: True\n\n**Program Name: Multi-Start Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: The solution combines binary-search linearized bin packing initialization with an Iterated Local Search (ILS) that applies targeted Move and Swap (1-1, 1-2, 2-1) operators to bottleneck GPUs, utilizing a \"ruin and recreate\" perturbation strategy to escape local optima.\n- **Performance**: Achieved a combined score of 49.31 with 100% success rate and 0.036s execution time.\n- **Feedback**: The linearized bin packing initialization provides diverse, high-quality starting points, while the bottleneck-focused local search efficiently reduces maximum KV cache pressure by reshuffling models from the most constrained GPUs.\n**Program Identifier:** Generation 79 - Patch Name init_and_perturb_v2 - Correct Program: True\n\n**Program Name: Hybrid Memetic Algorithm with Linearized Packing and Multi-Swap ILS**\n- **Implementation**: Combines stochastic linearized bin packing (optimizing load/size ratios via binary search) with an iterated local search utilizing move, 1-1, 2-1, and 1-2 swaps, employing a dual ruin-and-recreate perturbation strategy on bottleneck and source GPUs.\n- **Performance**: Achieved a high combined score of 40.38 with extremely low latency (0.034s), though the 96% success rate indicates occasional failures in constrained packing scenarios.\n- **Feedback**: The inclusion of complex swap operators (2-1, 1-2) specifically targeting high-pressure bottlenecks effectively balances load and memory, while the alternating sort strategy during the ruin-and-recreate phase prevents stagnation in local optima.\n**Program Identifier:** Generation 80 - Patch Name hybrid_ils_dual_ruin - Correct Program: True\n\n**Program Name: Randomized Best Fit Decreasing with Iterated Local Search**\n- **Implementation**: Uses a multi-start Best Fit Decreasing heuristic initialized by a binary search for an optimal load/size weighting factor, followed by Iterated Local Search employing `move`, `swap`, and `2-1 swap` operations with a \"ruin and recreate\" perturbation.\n- **Performance**: Achieved a high score of 26.23 and 100% success rate, maximizing the 1-second time limit for optimization.\n- **Feedback**: The combination of parameter sweeping for initialization and targeted perturbation allows robust escape from local optima, while the 2-1 swap specifically addresses packing inefficiencies caused by large model sizes.\n**Program Identifier:** Generation 81 - Patch Name init_param_search_and_helper_perturb - Correct Program: True\n\n**Program Name: Randomized Binary Search Packing with Iterated Local Search**\n- **Implementation**: This approach combines a multi-start randomized construction that tunes packing weights via binary search with an Iterated Local Search (ILS) utilizing Move, Swap(1-1), and Swap(2-1) operations on bottleneck GPUs. A \"Ruins & Recreate\" perturbation mechanism helps escape local optima within the 0.5s time constraint.\n- **Performance**: The algorithm achieved a strong score of 26.26 and perfect reliability, maximizing the available execution time (0.502s).\n- **Feedback**: The usage of complex swap moves (2-1) and targeted perturbations proves highly effective for minimizing peak memory pressure, though the computational cost requires careful time budget management.\n**Program Identifier:** Generation 82 - Patch Name diverse_init - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Bottleneck-Targeted Iterated Local Search**\n- **Implementation**: Combines binary-search-tuned linearized bin packing initialization with an Iterated Local Search that targets bottleneck GPUs using complex operators (1-2 and 2-1 swaps) and ruin-recreate perturbations.\n- **Performance**: Achieved a high combined score of 55.08 with fast execution (0.035s), maximizing inverse KV pressure effectively.\n- **Feedback**: The complex swap operators targeting the highest load GPUs effectively minimized the maximum pressure, though the 98% success rate suggests the fallback allocation logic needs strengthening for tight packing constraints.\n**Program Identifier:** Generation 83 - Patch Name robust_ils_crossover - Correct Program: True\n\n**Program Name: Linearized Bin Packing with ILS and Multi-Item Swaps**\n- **Implementation**: Initializes using a linearized constraint (`Load + K*Size`) binary search, then refines via Iterated Local Search with lexicographical comparison and complex moves (1-2, 2-1 swaps) targeting bottlenecks.\n- **Performance**: High performance (score 51.48) and speed (0.045s), but the 98% success rate indicates occasional failures in the fallback mechanism.\n- **Feedback**: The linearization approach successfully adapts standard bin packing to the non-linear objective, while targeted multi-item swaps effectively redistribute load from high-pressure GPUs to those with slack.\n**Program Identifier:** Generation 84 - Patch Name opt_kv_placement_v2 - Correct Program: True\n\n**Program Name: Linearized Bin Packing Initialization with Multi-Operator ILS**\n- **Implementation**: Utilizes binary search to tune weights for linearized bin packing initialization, followed by Iterated Local Search targeting bottleneck GPUs with move and complex 1-2/2-1 swap operators.\n- **Performance**: Achieved a combined score of 57.36 with 0.097s execution time, though the 94% success rate suggests occasional failures in finding valid placements.\n- **Feedback**: The binary search strategy effectively balances size and load constraints initially, and the diverse swap operators successfully lower peak KV cache pressure, but the fallback mechanism needs improvement to ensure 100% feasibility.\n**Program Identifier:** Generation 85 - Patch Name optimize_init_and_perturbation - Correct Program: True\n\n**Program Name: Multi-Start Randomized Construction with Iterated Local Search**\n- **Implementation**: The solution employs a multi-start randomized binary search to generate diverse initial packings, followed by an Iterated Local Search (ILS) using Move, 1-1 Swap, and 2-1 Swap operators. It incorporates a Ruins & Recreate perturbation strategy that reshuffles items between bottleneck and lightly loaded GPUs to escape local optima.\n- **Performance**: Achieved a combined score of 26.26 with a 100% success rate within the 0.5s time limit.\n- **Feedback**: The implementation of a specific 2-1 swap operator and an aggressive perturbation mechanism targeting bottleneck and benefactor GPUs effectively resolves dense packing constraints, preventing the solver from stagnating in local optima.\n**Program Identifier:** Generation 86 - Patch Name aggressive_ruin_and_extended_init - Correct Program: True\n\n**Program Name: Hybrid Linearized Bin Packing and Iterated Local Search**\n- **Implementation**: The algorithm approximates the non-linear KVPR objective using a binary-search linearized bin packing strategy to generate initial candidates, which are then refined via Iterated Local Search (ILS) using move and multi-item swap operators (1-1, 2-1, 1-2) targeting bottleneck GPUs.\n- **Performance**: It achieves a high combined score of 46.16 with extremely low latency (0.035s), demonstrating efficient optimization, though the 96% success rate indicates rare failures on hard instances.\n- **Feedback**: The technique of linearizing the capacity constraint allows efficient application of standard bin packing heuristics, providing high-quality initialization for the local search, but the fallback mechanism requires further robustness to guarantee 100% feasibility.\n**Program Identifier:** Generation 87 - Patch Name kv_opt_hybrid_ils - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Dual-Ruin Iterated Local Search**\n- **Implementation**: Initializes using a linearized bin packing strategy that balances load and size via a binary-searched coefficient, followed by iterated local search with targeted swaps (1-1, 1-2, 2-1) and a dual-ruin perturbation on extreme GPUs.\n- **Performance**: The algorithm achieved a strong combined score of 47.85 with a high success rate (94%) and very low latency (0.061s).\n- **Feedback**: The linearized packing heuristic generates high-quality initial solutions by treating the KVPR objective as a weighted capacity problem, while the multi-item swap operators effectively address fragmentation in the local search phase.\n**Program Identifier:** Generation 88 - Patch Name dual_ruin_ils_search - Correct Program: True\n\n**Program Name: Memetic Algorithm with Linearized Packing and Multi-Swap ILS**\n- **Implementation**: This approach initializes using linearized bin packing with binary search and noise, followed by Iterated Local Search targeting bottleneck GPUs with move, 1-1, 2-1, and 1-2 swap operators. It utilizes a ruin-and-recreate perturbation strategy that empties the worst GPU to escape local optima.\n- **Performance**: Achieved a combined score of 43.64 with a 96.0% success rate and a fast execution time of 0.052s.\n- **Feedback**: The inclusion of higher-order swaps (2-1, 1-2) allows the algorithm to effectively navigate complex packing landscapes where simple swaps fail. The solution balances search depth and speed well, though the non-perfect success rate suggests slight instability in extremely tight constraint scenarios.\n**Program Identifier:** Generation 89 - Patch Name init_and_dual_ruin - Correct Program: True\n\n**Program Name: Linearized Binary Search Packing with Local Search Refinement**\n- **Implementation**: The algorithm initializes using binary search on the KVPR target to solve a linearized bin packing problem with multiple sorting heuristics, followed by local search optimization using dual ruin-and-recreate, move, and swap operators.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and minimal execution time (0.001s).\n- **Feedback**: Linearly approximating the fractional objective enables effective global initialization, while the targeted ruin-and-recreate strategy efficiently resolves local bottlenecks that simple moves cannot address.\n**Program Identifier:** Generation 90 - Patch Name linear_relaxation_dual_ruin_solver - Correct Program: True\n\n**Program Name:** Multi-Start Randomized Packing with Iterated Local Search\n- **Implementation:** Uses randomized Best Fit Descending bin packing with binary search for initialization, followed by Iterated Local Search using steepest descent moves/swaps and ruin-recreate perturbation on bottleneck GPUs.\n- **Performance:** Score: 0.0 (Failed validation).\n- **Feedback:** The program failed validation tests, likely because the strict bin-packing constraints or fallback logic resulted in incomplete model assignments when valid packings were not found immediately.\n**Program Identifier:** Generation 63 - Patch Name improved_local_search_objective - Correct Program: False\n\n**Program Name: Robust Linearized Packing with ILS and Dual Ruin Perturbation**\n- **Implementation**: Uses binary-search linearized bin packing for initialization, followed by Iterated Local Search with VND operators (Move, Swap 1-1/1-2/2-1) focusing on bottleneck GPUs. A \"Dual Ruin\" perturbation empties the highest-load and probabilistically the lowest-load GPUs to facilitate effective reshuffling.\n- **Performance**: Achieves a combined score of 60.57 with 0.023s execution time and 94% success rate.\n- **Feedback**: The \"Dual Ruin\" mechanism successfully mitigates fragmentation by creating buffer space on non-critical GPUs, while `__slots__` optimization allows for extensive local search within tight time limits.\n**Program Identifier:** Generation 91 - Patch Name hybrid_dual_ruin_placement - Correct Program: True\n\n**Program Name: Multi-Start Linearized Bin Packing with Ruin-and-Recreate ILS**\n- **Implementation**: Initializes placements via linearized bin packing with binary search for load-size weighting, optimized by Iterated Local Search using move/swap operators and bottleneck-targeted perturbation.\n- **Performance**: Achieves a combined score of 62.20 with fast 0.102s execution, though the 94% success rate indicates reliability issues.\n- **Feedback**: The sophisticated local search and perturbation strategy yields high optimization scores, but the fallback mechanisms are insufficient for guaranteeing valid placements in the most constrained scenarios.\n**Program Identifier:** Generation 92 - Patch Name sweep_init_dual_perturb - Correct Program: True\n\n**Program Name: Hybrid Memetic Algorithm with Linearized Bin Packing and ILS**\n- **Implementation**: Combines linearized bin packing initialization (using binary search for load/size balancing) with Iterated Local Search featuring multi-item swaps and a specific perturbation that redistributes load from both the heaviest and lightest GPUs.\n- **Performance**: Delivered a strong score of 50.31 with exceptionally fast execution (0.091s), achieving a 94% success rate.\n- **Feedback**: The algorithm efficiently optimizes KV cache pressure through specialized local search operators, though the sub-100% success rate suggests the fallback packing heuristic struggles with the strictest memory constraints.\n**Program Identifier:** Generation 93 - Patch Name hybrid_perturbation_sweep - Correct Program: True\n\n**Program Name: Multi-Start Local Search with Bottleneck-Targeted Swaps**\n- **Implementation**: Initializes placements using randomized Best Fit with binary search for weight coefficients, followed by steepest descent using Shift, Swap-1-1, Swap-2-1, and Swap-2-2 moves specifically targeting the highest-load GPU.\n- **Performance**: Achieved a high combined score of 26.26 with extremely low latency (0.003s) and 100% success rate.\n- **Feedback**: The focus on the bottleneck GPU for neighborhood generation drastically reduces the search space while maximizing impact, and including complex swaps (2-1, 2-2) effectively navigates tight packing constraints to minimize peak pressure.\n**Program Identifier:** Generation 94 - Patch Name diversified_restarts - Correct Program: True\n\n**Program Name: Multi-Start Local Search with Adaptive Bin Packing**\n- **Implementation**: Utilizes binary search for baseline capacity followed by randomized bin packing, then refines the solution using iterated local search with specific move, swap(1-1), and swap(2-1/1-2) operators targeting the bottleneck GPU.\n- **Performance**: Achieves a high score of 26.23 with excellent efficiency (0.002s execution time) and 100% reliability.\n- **Feedback**: The approach effectively balances load via constructive heuristics before refining with complex swap moves, while the adaptive reweighting strategy helps escape local optima during randomized restarts.\n**Program Identifier:** Generation 95 - Patch Name adaptive_reweighting - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Multi-Operator Iterated Local Search**\n- **Implementation**: Utilizes a linearized bin packing initialization sweeping diverse load-size weighting coefficients, refined by an Iterated Local Search with aggressive 1-1, 1-2, and 2-1 swap operators targeting high-pressure GPUs.\n- **Performance**: Achieved a high combined score of 52.52 and fast execution (0.105s), but suffered a 96.0% success rate.\n- **Feedback**: While the multi-operator local search effectively minimized cache pressure, the randomized fallback mechanism proved insufficient for the hardest packing constraints, preventing a 100% success rate.\n**Program Identifier:** Generation 96 - Patch Name adaptive_init_and_relaxed_swap - Correct Program: True\n\n**Program Name: Binary Search Packing with Multi-Strategy Sort and Local Search**\n- **Implementation**: This algorithm performs a binary search on the target KV pressure ratio, checking feasibility via Best Fit Decreasing with three dynamic sorting strategies (linearized weight, size, load) to fit transformed constraints. It concludes with a greedy local search that attempts to move or swap models to minimize the maximum pressure across GPUs.\n- **Performance**: Score: 0.00; Max KVPR: 0.000; Success Rate: 0.00% (Failed validation).\n- **Feedback**: The implementation failed to pass any validation tests, resulting in a zero score; while the mathematical transformation of the objective is standard, the packing heuristics or local search likely encountered runtime errors or failed to satisfy strict memory constraints in the test environment.\n**Program Identifier:** Generation 97 - Patch Name local_search_refinement - Correct Program: False\n\n**Program Name: Multi-Heuristic Bin Packing with Binary and Local Search**\n- **Implementation**: The algorithm minimizes KV cache pressure by binary searching for a target ratio, checking feasibility via Best-Fit packing using three different sorting strategies (linearized weight, size, load). It concludes with a local search that iteratively applies moves, 1-1 swaps, and 2-1 swaps to relieve the bottleneck GPU.\n- **Performance**: The solution achieves a high combined score of 26.23 with 100% success rate and extremely low latency (0.001s).\n- **Feedback**: The use of multiple sorting heuristics significantly improves the robustness of the binary search phase, while the inclusion of 2-1 swaps in the local search effectively resolves fragmentation that simpler operations miss.\n**Program Identifier:** Generation 98 - Patch Name improved_local_search_swaps - Correct Program: True\n\n**Program Name: Linearized Bin Packing with Iterated Local Search**\n- **Implementation**: Utilizes binary-search tuned linearized bin packing for initialization, followed by Variable Neighborhood Descent (moves, 1-1, 1-2, 2-1 swaps) and a Ruin-and-Recreate perturbation strategy to escape local optima.\n- **Performance**: Achieved a high score of 46.69 with fast execution (0.043s) and a 96% success rate.\n- **Feedback**: The combination of adaptive reweighting during initialization and diverse swap operators efficiently balances loads, though the algorithm occasionally struggles with feasibility in extremely tight packing scenarios.\n**Program Identifier:** Generation 99 - Patch Name adaptive_init_and_robust_fallback - Correct Program: True",
  "meta_scratch_pad": "Based on the analysis of Generations 91-99 and the current best program (Generation 92), here are the extracted optimization insights.\n\n## Successful Algorithmic Patterns\n- **Linearized Constraint Projection:** The most decisive factor for high scores continues to be the transformation of the 2D packing problem into a 1D problem using a multiplier $K$ (`Load + K * Size <= K * Capacity`). **Gen 92 (Score 62.20)** and **Gen 91 (Score 60.57)** utilize this to achieve scores double that of standard heuristics. The best program explicitly sweeps diverse $K$ values (`min_feasible_k * (1.0 + 0.05 * i)`) to generate varied initial candidates ranging from \"tightly packed\" to \"load balanced.\"\n- **Dual Ruin Perturbation:** A key innovation in **Gen 92** and **Gen 91** is the \"Dual Ruin\" strategy. Instead of only destroying the bottleneck GPU configuration, these algorithms also empty the *lightest loaded* GPU (the sink). This effectively creates a large buffer of free space, facilitating the relocation of large models from the bottleneck that simple swaps could not accommodate.\n- **Asymmetric Swap Operators (1-2 and 2-1):** The current best program (**Gen 92**) explicitly implements `Swap 1-2` (one item from bottleneck, two from dest) and `Swap 2-1`. This is essential for resolving fragmentation where a single large model creates high pressure, but cannot be swapped 1-to-1 with smaller models on other GPUs due to size mismatches.\n- **Vectorized Lexicographical Optimization:** **Gen 92** optimizes the entire sorted tuple of pressures `(max_kvpr, 2nd_max, ...)`. This \"smoothing\" approach ensures that relieving the primary bottleneck does not immediately create a new, equally bad bottleneck elsewhere, a common issue in greedy descent algorithms.\n\n## Ineffective Approaches\n- **Standard Heuristics with Parameter Sweeps:** Programs like **Gen 94 (Score 26.26)** and **Gen 98 (Score 26.23)** applied sophisticated binary search and sorting strategies to standard \"Best Fit\" heuristics. Despite achieving 100% success rates and extremely low latency (~0.001s), they failed to break the ~26 point plateau, confirming that standard bin packing heuristics cannot capture the non-linear KVPR objective effectively.\n- **Strict Feasibility Enforcement:** There is a clear trade-off between peak performance and 100% reliability. Programs that enforced strict validity (Gen 94, 95, 98) capped at low scores. The top performers (**Gen 91, 92**) accepted a ~94% success rate. The data suggests that requiring the heuristic to succeed on the single hardest test case prevents it from adopting the aggressive packing strategies needed for the other 94% of cases.\n- **Single-Target Perturbation:** Early feedback indicated that ruining only the bottleneck GPU often leads to cycling, as the displaced items simply return to the same configuration if no other GPU has sufficient contiguous space. The success of Dual Ruin in Gen 91/92 confirms that \"creating space\" is as important as \"freeing items.\"\n\n## Implementation Insights\n- **Diverse K-Sweep Initialization:** The **Gen 92** implementation demonstrates a specific coding pattern: finding `min_feasible_k` via binary search, then generating multiple candidates by increasing $K$ (`k * 1.05`, `k * 1.10`...). This acknowledges that the mathematically \"optimal\" $K$ for packing might not be optimal for the KVPR objective, so checking a range is computationally cheap and highly effective.\n- **Deep Bottleneck Search:** While standard local search might look at the top 1 bottleneck, **Gen 92** iterates through the `top 5` or `top 6` loaded GPUs as sources for complex moves. This implementation detail allows the algorithm to perform \"indirect\" optimizations\u2014fixing a secondary bottleneck to open up space for the primary bottleneck's models.\n- **Tuple-Based Objective Comparison:** The effective implementation in **Gen 92** uses Python's native tuple comparison `current_vector < best_vector` where `current_vector` is `tuple(sorted(kvprs, reverse=True))`. This concise pattern handles multi-objective optimization (primary peak, secondary peak, etc.) without complex custom comparator logic.\n\n## Performance Analysis\n- **The \"Linearization Gap\":** The evaluation results show a binary distribution. Implementations using standard packing heuristics (Gen 94, 95, 98) cluster tightly around **26.2**. Implementations using Linearized Bin Packing (Gen 91, 92, 93, 96) cluster between **50.0 and 62.2**. This indicates that linearization is a fundamental requirement for high scores in this domain.\n- **Reliability vs. Optimality:** The jump from a score of ~26 to ~62 comes at the cost of success rate dropping from 100% to ~94%. The \"Correct\" flag logic in evaluation penalizes failures heavily, yet the raw score potential of the aggressive strategies is so high that they are preferred.\n- **Execution Time Trade-offs:** The plateaued programs are extremely fast (0.001s - 0.003s). The top performers are slower (0.02s - 0.10s) due to the Iterated Local Search (ILS) overhead. However, 0.10s is well within acceptable limits, validating that ILS is a necessary cost for doubling the optimization score.",
  "meta_recommendations": "Based on the analysis of Generations 91-99 and the performance characteristics of the current best program, here are 5 actionable recommendations for future mutations:\n\n1.  **Geometric Capacity Filter for Asymmetric Swaps**\n    The `Swap 1-2` and `Swap 2-1` operators are structurally critical for high scores but computationally expensive ($O(N^3)$), limiting search depth. Implement a constant-time geometric pre-check: only enter the inner loops if `size_in <= dest.remaining_capacity + size_out`. This filters out thousands of geometrically impossible moves per iteration, significantly reducing overhead and allowing the Iterated Local Search (ILS) to run for more iterations within the time limit.\n\n2.  **Targeted \"Complementary\" Ruin Strategy**\n    While \"Dual Ruin\" (Bottleneck + Sink) is successful, it is static. Modify the perturbation to dynamically select the second GPU based on the *type* of pressure on the bottleneck. If the bottleneck has high Memory usage, ruin the GPU with the **most free memory** (even if its load is high). If the bottleneck has high Compute Load, ruin the GPU with the **lowest load**. This ensures the \"hole\" created in the solution is specifically shaped to accept the displaced items from the bottleneck.\n\n3.  **Multi-Candidate \"Warm-Start\" Race**\n    The current program generates diverse candidates via the $K$-sweep but immediately discards all but one based on static metrics. Implement a short \"race\" where the top 3 distinct candidates (selected by vector distance) each undergo a brief ILS optimization (e.g., 20 iterations). The candidate with the steepest improvement slope or best intermediate score is then selected for the full optimization budget, preventing the solver from committing to a",
  "meta_recommendations_history": [
    "Based on the analysis of the current best program (Generation 3) and the high-performing patterns from other generations (specifically the Binary Search linearization), here are 5 actionable recommendations for future mutations:\n\n1.  **Hybrid Linearization Initialization**: Integrate the \"Binary Search with Linearization\" pattern (successful in Generations 4-9) to generate the initial solution seed, rather than relying solely on simple greedy sorts. Use the current best program's Lexicographical Local Search to refine this seed. This combines the global approximation power of the linearization method with the fine-grained distribution shaping of the local search.\n2.  **Iterated Local Search (ILS) with Perturbation**: Instead of independent random restarts, implement an Iterated Local Search strategy where the best found solution is \"perturbed\" (e.g., randomly unassigning 20% of models or clearing the bottleneck GPU) and then re-optimized. This allows the search to explore the solution space surrounding high-quality optima, potentially bridging the gap between local and global maximums.\n3.  **Compound Neighborhood Moves (2-for-1 Swaps)**: Expand the local search `swap` operator to include \"2-for-1\" exchanges, where two smaller models from a target GPU are swapped for one large model from a bottleneck GPU. This specifically addresses memory capacity constraints (80GB) where 1-1 swaps often fail because no single model on the target is large enough to free up required space.\n4.  **Regret-Based Greedy Construction**: Modify the deterministic construction phase to order models by \"regret\"\u2014the difference in cost between placing a model on its best GPU versus its second-best GPU. Placing high-regret models first ensures that critical decisions are prioritized, preventing scenarios where \"difficult\" models are forced onto overloaded GPUs at the end of the process.\n5.  **Optimized Delta-Vector Evaluation**: Refine the local search acceptance criteria to compare only the modified elements of the pressure vector rather than re-sorting the entire state ($O(N \\log N)$) at every step. By checking if the modified GPUs' new pressures are lexicographically better than their old values (relative to the global max), you can significantly reduce computational overhead, allowing for more search iterations or restarts.",
    "Based on the analysis of the current best program (Generation 15) and its successful implementation of Perturbation-Based Iterated Local Search, here are 5 actionable recommendations for future mutations:\n\n1.  **Targeted Perturbation Strategy**: Refine the perturbation logic to move the model from the bottleneck GPU to the **least loaded feasible GPU** (lowest KVPR) rather than a *random* feasible one. This maintains the \"kick\" required to escape local optima while placing the displaced model in a location that minimizes immediate damage to the system's balance, potentially speeding up convergence.\n2.  **2-to-2 Swap Operator**: Extend the successful \"1-to-2 Swap\" pattern to include **\"2-to-2 Swaps\"**, where two models from the bottleneck GPU are exchanged for two models from a target GPU. This operator can resolve complex fragmentation scenarios and load imbalances that 1-to-1 or 1-to-2 swaps cannot address, particularly when both GPUs are near capacity but have different model count densities.\n3.  **Randomized Multi-Start Initialization**: Leverage the extremely low execution time (0.035s) by wrapping the entire algorithm in a multi-start loop. Introduce randomization into the `solve_linearized_bin_packing` function (e.g., by adding small random noise to the weights `w`) to generate 5-10 diverse starting seeds, running the Iterated Local Search on each and returning the global best.\n4.  **Tabu Search Integration**: Add a short-term memory (Tabu list) to the local search that prevents a model moved *out* of a bottleneck GPU from being moved *back* to it for a fixed number of iterations (e.g., 5-10). This prevents the algorithm from cycling between two states (undoing/redoing the same move) and forces it to explore new configurations deeper in the search space.\n5.  **Steepest Descent Move Selection**: Modify the local search `Move` operator to scan **all** valid moves for the bottleneck GPU and select the **best** one (lexicographically minimizing the pressure vector) rather than accepting the *first* improvement found. While computationally more expensive, the current speed margin allows for this more aggressive optimization to maximize the gain at each step.",
    "Based on the analysis of the current best program (Generation 27) and the successful patterns identified, here are 5 actionable recommendations for future program mutations:\n\n1.  **Randomized Multi-Start with Linearized Initialization**\n    The current Binary Search Initialization is highly effective but deterministic. Leverage the fast execution time (0.032s) to run this initialization 10-20 times with stochastic variations. Specifically, introduce small random noise (e.g., $\\pm 5\\%$) to the item weights (`w = (req_rate / slo) + target_k * m.model_size * random_factor`) inside the `solve_linearized_bin_packing` function and select the best resulting configuration. This helps explore the \"basin of attraction\" around the optimal `K` parameter.\n\n2.  **Steepest Descent Move Selection**\n    Shift the local search strategy from \"First Improvement\" to \"Best Improvement\" (Steepest Descent). Instead of accepting the first move that reduces the pressure vector, scan all possible moves for the bottleneck GPUs and select the one that yields the *lexicographically smallest* vector. While computationally more expensive, the current speed margin allows for this aggressive optimization to ensure every step maximizes the gain.\n\n3.  **2-to-2 Swap Operator**\n    Re-introduce the **2-to-2 Swap** operator (swapping two items from a bottleneck GPU with two items from a target GPU). While this operator failed in earlier generations (Gen 26) due to poor initialization, it is now viable thanks to the superior starting states provided by the Linearized Binary Search. This operator can resolve complex fragmentation patterns where two medium-sized models block optimization.\n\n4.  **Destructive Perturbation (Large Neighborhood Search)**\n    Upgrade the perturbation logic from moving a single item (current \"Guided Kick\") to a \"Ruins and Recreate\" approach. When the local search stagnates, completely empty the bottleneck GPU (remove all its models) and re-distribute them into the remaining GPUs using a Best-Fit Decreasing heuristic. This provides a stronger \"kick\" to escape deep local optima at the 40.10 score level.\n\n5.  **Tabu-Enhanced Search History**\n    Implement a short-term Tabu list to prevent the algorithm from cycling between states. Store the last 5-10 moves (e.g., as `(model_id, previous_gpu_id)` tuples) and forbid the Local Search operators from reversing these moves immediately. This forces the algorithm to explore new areas of the search space before falling back to previous configurations, making the descent phase more efficient.",
    "Based on the analysis of the current best program (Generation 31) and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Stochastic Multi-Start Initialization**\n    Capitalize on the extremely fast execution time (0.026s) by wrapping the **Linearized Binary Search** initialization in a multi-start loop (e.g., 10-20 iterations). in each iteration, apply small random noise (e.g., $\\pm 5\\%$) to the calculated item weights ($w = load + K \\cdot size$) before packing. Select the starting configuration that yields the best initial lexicographical vector, increasing the probability of landing in a superior basin of attraction.\n\n2.  **Steepest Descent (Best Improvement) Selection**\n    Shift the Move and Swap 1-1 operators from a \"First Improvement\" strategy (accepting the first valid better neighbor) to a \"Best Improvement\" strategy (scanning all neighbors for the bottleneck GPU and picking the best one). While computationally heavier, this ensures that every modification to the bottleneck GPU is optimal, preventing the algorithm from taking \"greedy but short-sighted\" steps that hinder global convergence.\n\n3.  **Ruins-and-Recreate Perturbation**\n    Replace the current single-item \"Guided Kick\" with a destructive Large Neighborhood Search (LNS) operator. When local search stagnates, completely remove **all** models from the highest-pressure GPU and re-distribute them to other GPUs using a Best-Fit Decreasing logic (allowing temporary infeasibility or forcing moves). This provides a sufficiently large perturbation to escape the deep local optima found at the 41.43 score level.\n\n4.  **Tabu Search Memory**\n    Implement a short-term cyclic memory (Tabu list) that records the last 5-10 moves as `(model_id, original_gpu_id)` tuples. Prevent the Local Search from reversing these moves for a set number of iterations. This simple mechanism effectively prevents the \"ping-pong\" cycling behavior observed in high-pressure clusters where two GPUs simply swap load back and forth.\n\n5.  **Expanded Scope for Asymmetric Swaps**\n    The current best program restricts the powerful **Swap 2-1** operator (moving 2 items out, taking 1 in) to only the single worst GPU (`sources[:1]`), whereas other operators scan the top 4. Expand the scope of the Swap 2-1 operator to the top 3-4 bottleneck GPUs. Secondary bottlenecks often lock the system; resolving fragmentation there can create the necessary space to relieve the primary bottleneck.",
    "Based on the analysis of the current best program (Generation 31) and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Stochastic Multi-Start Initialization**\n    Leverage the program's extremely fast execution time (0.026s) by wrapping the **Linearized Binary Search** initialization in a stochastic loop (e.g., 20 iterations). In each iteration, apply random noise (e.g., $\\pm 5\\%$) to the item weights ($w = load + K \\cdot size$) before packing. This simple variation allows the algorithm to explore multiple basins of attraction and select the best starting lexicographical vector, significantly improving the baseline before local search begins.\n\n2.  **Transition to \"Best Improvement\" for Bottlenecks**\n    Modify the **Move** and **Swap 1-1** operators to use a \"Best Improvement\" strategy specifically when processing the highest-pressure GPU. Instead of accepting the *first* valid move that improves the state (current behavior), scan all possible valid destinations for the bottleneck items and select the one that yields the maximal reduction in the lexicographical vector. This prevents the algorithm from making greedy, suboptimal moves that trap it in shallow local optima.\n\n3.  **Destructive \"Ruins-and-Recreate\" Perturbation**\n    Replace the current weak perturbation (moving a single random model) with a stronger **Large Neighborhood Search (LNS)** operator. When the local search stagnates, remove *all* (or the top 3-5 largest) models from the bottleneck GPU and re-insert them into the cluster using a \"Best Fit\" heuristic. This major structural change is necessary to escape the deep local optima found at the 41.43 score level, which single-move perturbations cannot resolve.\n\n4.  **Expanded Scope for Asymmetric Swaps (2-1)**\n    The current program unnecessarily restricts the powerful **Swap 2-1** operator (moving 2 items out, taking 1 in) to only the single absolute worst GPU (`sources[:1]`). Expand this scope to the top 3 or 4 bottleneck GPUs (`sources[:4]`), matching the scope of the other operators. Secondary bottlenecks often lock the system state; resolving fragmentation on the 2nd or 3rd worst GPU can create the slack needed to eventually relieve the primary bottleneck.\n\n5.  **Short-Term Tabu Memory**\n    Implement a simple cyclic **Tabu List** (size 5-10) that records recent moves as `(model_id, source_gpu_id)` tuples. Prevent the local search from reversing these moves for a set number of iterations. This low-overhead mechanism is critical for preventing \"ping-pong\" behavior\u2014where the algorithm endlessly swaps load between two high-pressure GPUs without making global progress\u2014thereby forcing the search to explore novel configurations.",
    "Based on the analysis of the current best",
    "Based on the analysis of Generation 66 and the global performance insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Objective-Aware Linearization Parameter Search:**\n    Currently, the binary search finds the *minimum* $K$ (tightest packing) that is feasible. However, the tightest packing often clumps items, worsening KV cache pressure. Modify the initialization to scan a range of feasible $K$ values (e.g., via grid search after finding the minimum feasible $K$) and select the one that yields the best *initial lexicographical KVPR vector*. A \"looser\" packing often distributes load more evenly.\n\n2.  **Multi-GPU Ruin and Recreate (Large Neighborhood Search):**\n    The current perturbation only empties the single worst GPU, which limits the algorithm's ability to redistribute massive loads. Expand the \"Ruin\" phase to simultaneously empty the **top two highest-pressure GPUs** (or the bottleneck and the most under-utilized GPU). This creates a larger pool of \"floating\" items, allowing the greedy reconstruction to escape local optima that require multi-GPU coordination to resolve.\n\n3.  **Guided Initialization via Item Reweighting:**\n    Implement a feedback loop that utilizes previous results to improve initialization. If a solution has a specific bottleneck GPU, increase the \"effective weight\" (load or size multiplier) of the items assigned to that GPU and re-run the `solve_linearized_bp` initialization. This \"penalty\" forces the linearization logic to separate those specific items in the next construction attempt, directly targeting the cause of the bottleneck.\n\n4.  **Robust Fallback for 100% Reliability:**\n    The 92% success rate severely caps the maximum possible score due to penalties. Implement a deterministic \"Safety Net\" heuristic\u2014such as **First-Fit Decreasing with extensive random restarting**\u2014that triggers *only* if the primary linearization strategy fails to find a valid placement. Guaranteeing a valid solution for every seed allows the evolutionary process to focus entirely on optimization without risking zero-score failures.\n\n5.  **Capacity-Matching Pruning for Asymmetric Swaps:**\n    The `Swap 2-1` operator is effective but computationally expensive ($O(N^3)$). Optimize it by adding a **size-matching filter**: only attempt to swap two source items $(a, b)$ for a destination item $c$ if their combined size is comparable (e.g., $0.8 \\times size(c) < size(a) + size(b) < 1.2 \\times size(c)$). This prevents wasting time on moves that are geometrically unlikely to fit or improve density, allowing more iterations within the time limit.",
    "Based on the analysis of Generation 66 (the current best performer) and the global optimization insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Objective-Aware Linearization Parameter Search**\n    The current binary search finds the *minimum* feasible $K$ (tightest packing), which often clumps items and inadvertently spikes KV pressure on a few GPUs. Modify the initialization to not stop at the first valid $K$, but to scan a range of feasible values (e.g., 5 points between the minimum feasible $K$ and a theoretical upper bound). Select the $K$ that produces the best *lexicographical vector* (lowest peak KVPR), as a \"looser\" packing often distributes high-load items more evenly than a tight one.\n\n2.  **Multi-GPU Ruin and Recreate (Dual-Target Strategy)**\n    Generation 66 currently only empties the single worst bottleneck GPU during perturbation. Adopt the \"Dual-Ruin\" pattern from Generation 71 by simultaneously emptying both the **highest-pressure GPU** (bottleneck) and the **lowest-pressure GPU** (underutilized capacity). This creates a larger pool of \"floating\" models and forces the reconstruction phase to redistribute the heavy items from the bottleneck into the specific whitespace available on the lightest GPU.\n\n3.  **Capacity-Matching Pruning for Asymmetric Swaps**\n    The `Swap 2-1` and `Swap 1-2` operators are powerful but computationally expensive ($O(N^3)$), limiting the total number of iterations. Implement a geometric filter that only attempts these swaps if the combined size of the models being moved is within a tolerance window (e.g., $\\pm 20\\%$) of the model being replaced. This prevents the algorithm from wasting cycles evaluating moves that are guaranteed to fail capacity constraints or drastically reduce density.\n\n4.  **Guided Initialization via Historical Item Reweighting**\n    Implement a feedback loop where models that consistently appear on the bottleneck GPU in previous solutions are assigned a \"penalty multiplier\" to their effective size or load. When re-running the `solve_linearized_bp` initialization with these penalized weights, the bin packing heuristic will naturally isolate these difficult items or prioritize their placement earlier, preventing them from accumulating on a single resource.\n\n5.  **Deterministic \"Safety Net\" for 100% Reliability**\n    The current best program has a 92% success rate, meaning it takes a zero-score penalty on 8% of inputs. Implement a robust fallback strategy\u2014specifically **First-Fit Decreasing (FFD)** run on the `Load + K*Size` metric with varying $K$ values\u2014that executes *only* if the primary solver fails to return a valid solution. Ensuring a valid placement for every seed removes the reliability ceiling and allows the evolutionary process to optimize purely for KVPR score.",
    "Based on the analysis of Generations 81-90 and the strengths/weaknesses of the current best program (Generation 66), here are 5 actionable recommendations for future program mutations:\n\n1.  **Lexicographical Linearization Sweep**\n    The current best program uses binary search to find the *minimum* feasible $K$, which effectively minimizes `Size` cost and creates the tightest possible packing. This often clumps items, creating spikes in Load. Modify the initialization to scan a range of feasible $K$ values (e.g., check 5 points between the minimum feasible $K$ and $1.5 \\times K$) and select the starting configuration that yields the best **lexicographical vector**. This ensures the optimization starts from a \"smoother\" distribution rather than just a dense one.\n\n2.  **Dual-Pivot (Source-Sink) Perturbation**\n    Generation 66 currently \"ruins\" (empties) only the single worst bottleneck GPU. Extend this to simultaneously empty the **lowest-pressure GPU (Sink)** as well. This explicitely creates high-quality whitespace on the most underutilized resource, providing a guaranteed destination for the heavy items being displaced from the bottleneck during the \"recreate\" phase.\n\n3.  **Capacity-Sum Pruning for Asymmetric Swaps**\n    The `Swap 1-2` and `Swap 2-1` operators are computationally expensive ($O(N^3)$) and limit the search depth. Implement a fast geometric filter that only attempts these swaps if the total size of the items being moved in is within a tolerance window (e.g., $\\pm 10\\%$) of the items being moved out plus the destination's available slack. This prevents wasting CPU cycles on structurally impossible moves.\n\n4.  **Adaptive \"Troublemaker\" Reweighting**\n    Implement a feedback mechanism in the initialization: run the `solve_linearized_bp` solver once, identify the models residing on the GPU with the highest peak load, multiply their effective \"weight\" in the linearization formula by a factor (e.g., 1.1x), and re-run the solver. This forces the bin-packing heuristic to treat these specific bottleneck-causing items as \"larger,\" naturally prioritizing their placement or isolating them from other heavy items.\n\n5.  **Time-Bounded Randomized Fallback**\n    To fix the current 8% failure rate (92% success), replace the single deterministic fallback with a **randomized FFD loop**. If the primary logic returns `None`, repeatedly execute First-Fit Decreasing with shuffled model orders until a valid solution is found or the time limit is reached. This ensures a valid (even if low-scoring) solution is always returned",
    "Based on the analysis of Generations 91-99 and the performance characteristics of the current best program, here are 5 actionable recommendations for future mutations:\n\n1.  **Geometric Capacity Filter for Asymmetric Swaps**\n    The `Swap 1-2` and `Swap 2-1` operators are structurally critical for high scores but computationally expensive ($O(N^3)$), limiting search depth. Implement a constant-time geometric pre-check: only enter the inner loops if `size_in <= dest.remaining_capacity + size_out`. This filters out thousands of geometrically impossible moves per iteration, significantly reducing overhead and allowing the Iterated Local Search (ILS) to run for more iterations within the time limit.\n\n2.  **Targeted \"Complementary\" Ruin Strategy**\n    While \"Dual Ruin\" (Bottleneck + Sink) is successful, it is static. Modify the perturbation to dynamically select the second GPU based on the *type* of pressure on the bottleneck. If the bottleneck has high Memory usage, ruin the GPU with the **most free memory** (even if its load is high). If the bottleneck has high Compute Load, ruin the GPU with the **lowest load**. This ensures the \"hole\" created in the solution is specifically shaped to accept the displaced items from the bottleneck.\n\n3.  **Multi-Candidate \"Warm-Start\" Race**\n    The current program generates diverse candidates via the $K$-sweep but immediately discards all but one based on static metrics. Implement a short \"race\" where the top 3 distinct candidates (selected by vector distance) each undergo a brief ILS optimization (e.g., 20 iterations). The candidate with the steepest improvement slope or best intermediate score is then selected for the full optimization budget, preventing the solver from committing to a"
  ],
  "total_programs_meta_processed": 100
}