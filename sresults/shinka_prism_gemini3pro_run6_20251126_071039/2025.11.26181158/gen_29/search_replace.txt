<NAME>
steepest_descent_and_targeted_perturbation
</NAME>

<DESCRIPTION>
1. Replaces the "First Improvement" strategy in the Move operator with a "Steepest Descent" (Best Improvement) strategy. This scans all possible moves from the top bottleneck GPUs and selects the one that minimizes the KVPR vector the most. This is computationally feasible and likely to converge to a better local optimum.
2. Refines the Perturbation operator to be "Targeted". Instead of kicking a model to a completely random feasible GPU, it chooses from the top 3 GPUs with the lowest KVPR. This helps rebalance the load more effectively while maintaining enough stochasticity to escape local optima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Move
        for source in sources:
            for i, model in enumerate(source.models):
                for dest in current_gpus:
                    if dest.id == source.id: continue
                    if dest.can_fit(model.model_size):
                        source.remove(i)
                        dest.add(model)
                        new_vec = get_vector(current_gpus)
                        if new_vec < current_vector:
                            current_vector = new_vec
                            improved_step = True
                            if current_vector < best_vector:
                                best_vector = current_vector
                                for k in range(gpu_num): best_gpus[k].copy_from(current_gpus[k])
                            break
                        else:
                            dest.remove(len(dest.models)-1)
                            source.restore_model(i, model)
                if improved_step: break
            if improved_step: break
        if improved_step: continue
=======
        # Move (Steepest Descent)
        best_move = None
        best_move_vec = current_vector

        for source in sources:
            for i, model in enumerate(source.models):
                for dest in current_gpus:
                    if dest.id == source.id: continue
                    if dest.can_fit(model.model_size):
                        source.remove(i)
                        dest.add(model)

                        new_vec = get_vector(current_gpus)
                        if new_vec < best_move_vec:
                            best_move_vec = new_vec
                            best_move = (source, i, dest, model)

                        dest.remove(len(dest.models)-1)
                        source.restore_model(i, model)

        if best_move:
            src, idx, dst, model = best_move
            src.remove(idx)
            dst.add(model)
            current_vector = best_move_vec
            improved_step = True
            if current_vector < best_vector:
                best_vector = current_vector
                for k in range(gpu_num): best_gpus[k].copy_from(current_gpus[k])

        if improved_step: continue
>>>>>>> REPLACE
<<<<<<< SEARCH
        # Perturbation
        if iter_cnt > max_iter - 20: break
        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break
        m_idx = random.randint(0, len(worst_gpu.models)-1)
        model_to_move = worst_gpu.models[m_idx]
        feasible_dests = [g for g in current_gpus if g.id != worst_gpu.id and g.can_fit(model_to_move.model_size)]
        if feasible_dests:
            dest = random.choice(feasible_dests)
            worst_gpu.remove(m_idx)
            dest.add(model_to_move)
            current_vector = get_vector(current_gpus)
        else:
            break
=======
        # Perturbation
        if iter_cnt > max_iter - 20: break
        worst_gpu = sorted_gpus[0]
        if not worst_gpu.models: break
        m_idx = random.randint(0, len(worst_gpu.models)-1)
        model_to_move = worst_gpu.models[m_idx]
        feasible_dests = [g for g in current_gpus if g.id != worst_gpu.id and g.can_fit(model_to_move.model_size)]

        if feasible_dests:
            # Targeted kick: prefer less loaded GPUs
            feasible_dests.sort(key=lambda g: g.kvpr())
            # Pick from top 3 best candidates to maintain some randomness
            candidates_kick = feasible_dests[:3]
            dest = random.choice(candidates_kick)

            worst_gpu.remove(m_idx)
            dest.add(model_to_move)
            current_vector = get_vector(current_gpus)
        else:
            break
>>>>>>> REPLACE
</DIFF>