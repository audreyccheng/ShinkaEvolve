<NAME>
polish_improvement
</NAME>

<DESCRIPTION>
1. Increased `BEAM_WIDTH` to 8 to improve the quality of the initial schedule skeleton found in Phase 1.
2. Enhanced Phase 3 (Deterministic Polish) to allow "sideways moves" (structural changes with equal cost) and increased `MAX_PASSES` to 12. This allows the algorithm to traverse plateaus in the search space and settle into better local minima, effectively implementing a robust "Gap Repair" strategy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Hyperparameters ---
    # Width 6 provides good structural coverage without excessive cost
    BEAM_WIDTH = 6

    # SA Parameters
=======
    # --- Hyperparameters ---
    # Width 8 provides better structural coverage for complex dependency chains
    BEAM_WIDTH = 8

    # SA Parameters
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Phase 3: Deterministic Polish (LPT Ordered) ---
    # Sort transactions by weight descending (Longest Processing Time)
    # This heuristic assumes harder-to-schedule items should be placed first/checked for optimization
    sorted_txns = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    # Iterate a few passes to allow settling
    MAX_PASSES = 5
    for pass_idx in range(MAX_PASSES):
        improved_in_pass = False

        for item in sorted_txns:
            # Find current position and remove
            try:
                curr_idx = polish_seq.index(item)
            except ValueError:
                continue

            polish_seq.pop(curr_idx)

            best_pos = -1
            min_c = float('inf')

            # Exhaustive scan for best position
            for j in range(len(polish_seq) + 1):
                polish_seq.insert(j, item)
                c = get_cost(polish_seq)
                if c < min_c:
                    min_c = c
                    best_pos = j
                polish_seq.pop(j)

            # Insert at best position
            polish_seq.insert(best_pos, item)

            # Check improvement locally
            if min_c < current_polish_cost:
                current_polish_cost = min_c
                improved_in_pass = True

        if current_polish_cost < best_cost:
            best_cost = current_polish_cost
            best_schedule = list(polish_seq)

        if not improved_in_pass:
            break
=======
    # --- Phase 3: Deterministic Polish (LPT Ordered) ---
    # Sort transactions by weight descending (Longest Processing Time)
    # This heuristic assumes harder-to-schedule items should be placed first/checked for optimization
    sorted_txns = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    # Run multiple passes to allow schedule to settle
    # Increased passes to ensure convergence, tracking structural changes
    MAX_PASSES = 12
    for pass_idx in range(MAX_PASSES):
        search_active = False # Tracks if we should continue passes (change or improvement)

        for item in sorted_txns:
            # Find current position and remove
            try:
                curr_idx = polish_seq.index(item)
            except ValueError:
                continue

            polish_seq.pop(curr_idx)

            best_pos = -1
            min_c = float('inf')

            # Exhaustive scan for best position
            # Left-Packing Bias: Strict inequality (<) prefers earlier positions (smaller index)
            # effectively compacting the schedule to the left when costs are equal.
            for j in range(len(polish_seq) + 1):
                polish_seq.insert(j, item)
                c = get_cost(polish_seq)
                if c < min_c:
                    min_c = c
                    best_pos = j
                polish_seq.pop(j)

            # Insert at best position
            polish_seq.insert(best_pos, item)

            # Check if schedule improved or changed structure
            if min_c < current_polish_cost:
                current_polish_cost = min_c
                search_active = True
            elif best_pos != curr_idx:
                # Structural change even if cost is same - allows traversing plateaus
                search_active = True

        if current_polish_cost < best_cost:
            best_cost = current_polish_cost
            best_schedule = list(polish_seq)

        if not search_active:
            break
>>>>>>> REPLACE
</DIFF>