<NAME>
ils_adaptive_ruin_polish_convergence
</NAME>

<DESCRIPTION>
I am enhancing the Refinement Phase (ILS) by introducing two key mechanisms based on performance analysis recommendations:
1.  **Adaptive Ruin Intensity**: Instead of static ruin sizes, the algorithm now tracks 'stagnation' (cycles since last improvement). As stagnation increases, the ruin factor scales up (1.0x -> 1.5x -> 2.0x), removing larger blocks of transactions to escape deeper local optima.
2.  **Gap Repair Convergence**: The deterministic Polish phase (Gap Repair) now runs for multiple passes (up to 3 or 5) instead of just one. This allows the iterative best-insertion strategy to converge closer to a local optimum, squeezing out remaining inefficiencies that a single pass misses.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 2. Refinement Phase: ILS with LPT-Polish ---

    best_schedule = list(current_schedule)
    best_cost = current_cost

    # Adjust cycles based on problem size
    ILS_CYCLES = 6
    if num_txns < 20: ILS_CYCLES = 3

    for cycle in range(ILS_CYCLES):

        # A. Restart Strategy
        # If we've drifted to a worse solution, probabilistically restart from best
        if cycle > 0 and current_cost > best_cost:
            if random.random() < 0.4:
                current_schedule = list(best_schedule)
                current_cost = best_cost

        # B. Multi-Mode Ruin
        work_seq = list(current_schedule)
        removed_txns = []

        mode = random.random()

        if mode < 0.30:
            # Mode 1: Tail Ruin (Break critical path at the end)
            bs = max(4, int(num_txns * 0.25))
            if len(work_seq) > bs:
                start = len(work_seq) - bs
                removed_txns = work_seq[start:]
                del work_seq[start:]

        elif mode < 0.65:
            # Mode 2: Random Block Ruin (Locality)
            bs = max(2, int(num_txns * 0.20))
            if len(work_seq) > bs:
                start = random.randint(0, len(work_seq) - bs)
                removed_txns = work_seq[start : start + bs]
                del work_seq[start : start + bs]

        else:
            # Mode 3: Disjoint Blocks (Global shuffle)
            total_rem = max(4, int(num_txns * 0.20))
            b1 = total_rem // 2
            b2 = total_rem - b1

            if len(work_seq) > b1:
                s1 = random.randint(0, len(work_seq) - b1)
                removed_txns.extend(work_seq[s1 : s1 + b1])
                del work_seq[s1 : s1 + b1]
            if len(work_seq) > b2:
                s2 = random.randint(0, len(work_seq) - b2)
                removed_txns.extend(work_seq[s2 : s2 + b2])
                del work_seq[s2 : s2 + b2]

        # C. Recreate: LPT-First Greedy Best-Fit
        # Sort removed transactions by length descending
        removed_txns.sort(key=lambda t: txn_lengths.get(t, 0), reverse=True)

        for txn in removed_txns:
            best_pos = -1
            best_incr = float('inf')

            # Find best insertion point
            for pos in range(len(work_seq) + 1):
                work_seq.insert(pos, txn)
                c = workload.get_opt_seq_cost(work_seq)

                # Check strict inequality to prefer earlier positions on ties
                if c < best_incr:
                    best_incr = c
                    best_pos = pos

                del work_seq[pos]

            work_seq.insert(best_pos, txn)

        current_schedule = work_seq
        current_cost = best_incr

        # Save if improved
        if current_cost < best_cost:
            best_cost = current_cost
            best_schedule = list(current_schedule)

        # D. Polish Phase: Deterministic LPT-Ordered Gap Repair
        # Systematically try to improve the schedule by moving transactions.
        # Run if the solution is promising.

        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.3)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            MAX_PASSES = 1 # Expensive operation, limit passes

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Order to check: LPT (Largest items first)
                # This ensures big blocks are settled in optimal spots before small items fill gaps
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Remove transaction
                    del current_schedule[current_idx]

                    # Cost without this transaction (baseline for this step)
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan for best position
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)
                        current_schedule.pop(pos) # Backtrack

                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        # Early Exit Optimization:
                        # If the new cost equals the baseline cost (schedule without txn),
                        # the transaction is perfectly hidden. We can't do better than "free".
                        # Stop scanning and accept this position (Pack Left).
                        if abs(c - base_val) < 1e-9:
                            break

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Check if this move improved the global best
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
=======
    # --- 2. Refinement Phase: ILS with Adaptive Ruin & Convergence Polish ---

    best_schedule = list(current_schedule)
    best_cost = current_cost

    # Tracking for adaptive ruin
    last_improvement_cycle = -1

    # Adjust cycles based on problem size
    ILS_CYCLES = 6
    if num_txns < 20: ILS_CYCLES = 4

    for cycle in range(ILS_CYCLES):

        # A. Restart Strategy
        # If we've drifted to a worse solution, probabilistically restart from best
        if cycle > 0 and current_cost > best_cost:
            # Higher probability if stagnating
            p_restart = 0.4
            if cycle - last_improvement_cycle > 2:
                p_restart = 0.8

            if random.random() < p_restart:
                current_schedule = list(best_schedule)
                current_cost = best_cost

        # B. Adaptive Multi-Mode Ruin
        # Calculate ruin intensity based on stagnation
        stagnation = cycle - last_improvement_cycle
        ruin_factor = 1.0
        if stagnation >= 2: ruin_factor = 1.5
        if stagnation >= 4: ruin_factor = 2.0

        work_seq = list(current_schedule)
        removed_txns = []

        mode = random.random()

        if mode < 0.30:
            # Mode 1: Tail Ruin (Break critical path at the end)
            base_size = max(4, int(num_txns * 0.25))
            bs = min(len(work_seq), int(base_size * ruin_factor))
            if len(work_seq) > bs:
                start = len(work_seq) - bs
                removed_txns = work_seq[start:]
                del work_seq[start:]

        elif mode < 0.65:
            # Mode 2: Random Block Ruin (Locality)
            base_size = max(2, int(num_txns * 0.20))
            bs = min(len(work_seq), int(base_size * ruin_factor))
            if len(work_seq) > bs:
                start = random.randint(0, len(work_seq) - bs)
                removed_txns = work_seq[start : start + bs]
                del work_seq[start : start + bs]

        else:
            # Mode 3: Disjoint Blocks (Global shuffle)
            base_total = max(4, int(num_txns * 0.20))
            total_rem = min(len(work_seq), int(base_total * ruin_factor))
            b1 = total_rem // 2
            b2 = total_rem - b1

            if len(work_seq) > b1:
                s1 = random.randint(0, len(work_seq) - b1)
                removed_txns.extend(work_seq[s1 : s1 + b1])
                del work_seq[s1 : s1 + b1]
            if len(work_seq) > b2:
                s2 = random.randint(0, len(work_seq) - b2)
                removed_txns.extend(work_seq[s2 : s2 + b2])
                del work_seq[s2 : s2 + b2]

        # C. Recreate: LPT-First Greedy Best-Fit
        # Sort removed transactions by length descending
        removed_txns.sort(key=lambda t: txn_lengths.get(t, 0), reverse=True)

        for txn in removed_txns:
            best_pos = -1
            best_incr = float('inf')

            # Find best insertion point
            for pos in range(len(work_seq) + 1):
                work_seq.insert(pos, txn)
                c = workload.get_opt_seq_cost(work_seq)

                # Check strict inequality to prefer earlier positions on ties
                if c < best_incr:
                    best_incr = c
                    best_pos = pos

                del work_seq[pos]

            work_seq.insert(best_pos, txn)

        current_schedule = work_seq
        current_cost = best_incr

        # Save if improved
        if current_cost < best_cost:
            best_cost = current_cost
            best_schedule = list(current_schedule)
            last_improvement_cycle = cycle

        # D. Polish Phase: Deterministic LPT-Ordered Gap Repair
        # Systematically try to improve the schedule by moving transactions.
        # Run if the solution is promising.

        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.3)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            # Allow multiple passes for convergence (Gap Repair)
            MAX_PASSES = 3
            if num_txns < 50: MAX_PASSES = 5

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Order to check: LPT (Largest items first)
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Remove transaction
                    del current_schedule[current_idx]

                    # Cost without this transaction (baseline for this step)
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan for best position
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)
                        current_schedule.pop(pos) # Backtrack

                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        # Early Exit Optimization: perfect packing
                        if abs(c - base_val) < 1e-9:
                            break

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Check if this move improved the global best
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
                            last_improvement_cycle = cycle
>>>>>>> REPLACE
</DIFF>