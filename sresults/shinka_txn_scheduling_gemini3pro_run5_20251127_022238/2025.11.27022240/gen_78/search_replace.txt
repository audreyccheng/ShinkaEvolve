<NAME>
gamma_decay_tweak
</NAME>

<DESCRIPTION>
Adjust the end value of the Gamma parameter in the Beam Search constructive phase from 1.0 to 0.8. A lower Gamma value at the end of the construction process reduces the reward for "work accomplished" and increases the penalty for "makespan increase", encouraging tighter packing of the final transactions in the schedule.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    BEAM_WIDTH = max(16, int(num_seqs * 2.5))
    GAMMA_START = 1.8
    GAMMA_END = 1.0

    # Seed beam
=======
    BEAM_WIDTH = max(16, int(num_seqs * 2.5))
    GAMMA_START = 1.8
    GAMMA_END = 0.8

    # Seed beam
>>>>>>> REPLACE
</DIFF>

<NAME>
deep_polish_early_exit
</NAME>

<DESCRIPTION>
Enhance the Polish (Gap Repair) phase by:
1. Implementing an "Early Exit" optimization: if inserting a transaction results in zero makespan increase (perfect parallelism), stop scanning positions immediately. This exploits the "Left-Packing" principle and saves significant computation.
2. Increasing the number of passes (`MAX_PASSES`) from 1 to 6-10. The efficiency gain from Early Exit allows for more iterations, enabling the algorithm to converge to a better local minimum.
3. Explicitly calculating the baseline cost (`base_val`) without the transaction to detect perfect fits.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # D. Polish: Deterministic Iterative Improvement (Gap Repair)
        # Scan entire schedule, try to move each transaction to its optimal position.
        # This is expensive but powerful.

        # Optimization: Only perform if we are close to best or randomly
        # to save compute on bad candidates.
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.3)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            MAX_PASSES = 1

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Check every transaction
                # Iterate over a snapshot so indices don't get messed up by moves
                # Sort by LPT: Try to optimize placement of large blocks first
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    # Find current location
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError:
                        continue # Should not happen

                    # Temporarily remove
                    del current_schedule[current_idx]

                    # Find best insertion point
                    best_pos = -1
                    best_val = float('inf')

                    # Full scan
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)
                        if c < best_val:
                            best_val = c
                            best_pos = pos
                        del current_schedule[pos]

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # If we found a better position that improves the global cost
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
=======
        # D. Polish: Deterministic Iterative Improvement (Gap Repair)
        # Scan entire schedule, try to move each transaction to its optimal position.
        # This is expensive but powerful.

        # Optimization: Only perform if we are close to best or randomly
        # to save compute on bad candidates.
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.3)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            # Increased passes for better convergence
            # Using Early Exit optimization makes this feasible
            MAX_PASSES = 6
            if num_txns < 40: MAX_PASSES = 10

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Check every transaction
                # Processing in LPT order (Big Rocks first) helps settle structure
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Cost without txn
                    del current_schedule[current_idx]

                    # Baseline cost without this transaction
                    # Useful for Early Exit optimization
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan all positions
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)

                        # Early Exit:
                        # If the cost with txn is same as cost without txn, it's perfectly hidden.
                        # We cannot do better than 0 cost increase.
                        # This optimization significantly speeds up the scan.
                        if abs(c - base_val) < 1e-9:
                            best_val = c
                            best_pos = pos
                            current_schedule.pop(pos) # Must pop before break to keep state consistent
                            break

                        # Check improvement
                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        del current_schedule[pos]

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Update if improved
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
>>>>>>> REPLACE
</DIFF>