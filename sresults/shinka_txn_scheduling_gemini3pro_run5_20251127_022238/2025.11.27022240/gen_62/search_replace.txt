<NAME>
enhanced_ils_polish
</NAME>

<DESCRIPTION>
I am overhauling the Refinement Phase (ILS) to implement a more robust "Gap Repair" strategy and adaptive perturbation.
1.  **Adaptive Ruin:** Introduced a `last_improved_cycle` tracker. If the algorithm stagnates (no global improvement), the ruin size (number of removed transactions) increases by 30% or 60% (`ruin_factor`). This helps escape deeper local optima.
2.  **Intense Polish (Gap Repair):**
    *   Increased `MAX_PASSES` to 3 (5 for small workloads) to allow the deterministic improvement to converge closer to the true local optimum.
    *   **Early Exit Optimization:** Added a check inside the polish scan. If a position results in a cost equal to the schedule *minus* the transaction (perfect latency hiding), we stop scanning immediately. This drastically reduces the computational cost of the polish phase, making the increased passes feasible.
    *   **LPT Ordering:** Explicitly maintained processing transactions in Longest Processing Time order during polish to settle large blocks ("big rocks") first.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 2. Refinement Phase: Deterministic ILS ---

    best_schedule = list(current_schedule)
    best_cost = current_cost

    ILS_CYCLES = 5
    if num_txns < 20: ILS_CYCLES = 2

    for cycle in range(ILS_CYCLES):

        # A. Restart Strategy
        if cycle > 0 and current_cost > best_cost:
            # Periodically revert to best to focus search
            if random.random() < 0.4:
                current_schedule = list(best_schedule)
                current_cost = best_cost

        # B. Multi-Mode Ruin
        work_seq = list(current_schedule)
        removed_txns = []

        r_mode = random.random()

        if r_mode < 0.25:
            # Mode 1: Tail Ruin (Target critical path end)
            bs = max(4, int(num_txns * 0.25))
            if len(work_seq) > bs:
                start = len(work_seq) - bs
                removed_txns = work_seq[start:]
                del work_seq[start:]

        elif r_mode < 0.55:
            # Mode 2: Single Large Block (Locality)
            bs = max(2, int(num_txns * 0.2))
            if len(work_seq) > bs:
                start = random.randint(0, len(work_seq) - bs)
                removed_txns = work_seq[start : start + bs]
                del work_seq[start : start + bs]

        elif r_mode < 0.85:
            # Mode 3: Two Disjoint Blocks (Global shuffle)
            total_rem = max(4, int(num_txns * 0.20))
            b1 = total_rem // 2
            b2 = total_rem - b1

            if len(work_seq) > b1:
                s1 = random.randint(0, len(work_seq) - b1)
                removed_txns.extend(work_seq[s1 : s1 + b1])
                del work_seq[s1 : s1 + b1]
            if len(work_seq) > b2:
                s2 = random.randint(0, len(work_seq) - b2)
                removed_txns.extend(work_seq[s2 : s2 + b2])
                del work_seq[s2 : s2 + b2]

        else:
            # Mode 4: Random Scatter (Dependency chains)
            cnt = max(3, int(num_txns * 0.15))
            indices = sorted(random.sample(range(len(work_seq)), min(len(work_seq), cnt)), reverse=True)
            for idx in indices:
                removed_txns.append(work_seq.pop(idx))

        # Sort removed transactions by LPT (Longest Processing Time)
        # Re-inserting big items first (Big Rocks principle)
        removed_txns.sort(key=lambda t: txn_lengths.get(t, 0), reverse=True)

        # C. Recreate (Greedy Best-Fit)
        for txn in removed_txns:
            best_pos = -1
            best_incr = float('inf')

            for pos in range(len(work_seq) + 1):
                work_seq.insert(pos, txn)
                c = workload.get_opt_seq_cost(work_seq)
                if c < best_incr:
                    best_incr = c
                    best_pos = pos
                del work_seq[pos]

            work_seq.insert(best_pos, txn)

        current_schedule = work_seq
        current_cost = best_incr

        # Save if improved
        if current_cost < best_cost:
            best_cost = current_cost
            best_schedule = list(current_schedule)

        # D. Polish: Deterministic Iterative Improvement (Gap Repair)
        # Scan entire schedule, try to move each transaction to its optimal position.

        # Heuristic to decide if polish is needed
        # Always polish if we are near the best solution to try and break through
        # Or randomly to explore
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.3)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            MAX_PASSES = 1
            if num_txns < 50: MAX_PASSES = 2 # Allow more passes for small workloads

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Check every transaction
                # Processing in LPT order can sometimes help settle major blocks first
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    # Find current location
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError:
                        continue

                    # Cost without txn
                    del current_schedule[current_idx]

                    # Find best insertion point
                    best_pos = -1
                    best_val = float('inf')

                    # Scan all positions
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)
                        if c < best_val:
                            best_val = c
                            best_pos = pos
                        del current_schedule[pos]

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Update if improved
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
=======
    # --- 2. Refinement Phase: Deterministic ILS with Adaptive Ruin & Intense Polish ---

    best_schedule = list(current_schedule)
    best_cost = current_cost

    # Tracking stagnation for adaptive ruin
    last_improved_cycle = -1

    ILS_CYCLES = 6
    if num_txns < 20: ILS_CYCLES = 3

    for cycle in range(ILS_CYCLES):

        # Adaptive Ruin Strength: Increase disruption if stagnated
        stagnation = cycle - last_improved_cycle
        ruin_factor = 1.0
        if stagnation > 1:
            ruin_factor = 1.3
        if stagnation > 3:
            ruin_factor = 1.6

        # A. Restart Strategy
        # If deeply stagnated or worse than best, potentially restart
        if cycle > 0 and current_cost > best_cost:
            if random.random() < 0.5:
                current_schedule = list(best_schedule)
                current_cost = best_cost
                # Don't reset last_improved_cycle to maintain urgency

        # B. Multi-Mode Ruin
        work_seq = list(current_schedule)
        removed_txns = []

        r_mode = random.random()

        if r_mode < 0.25:
            # Mode 1: Tail Ruin (Critical Path)
            base_size = max(4, int(num_txns * 0.25))
            bs = int(base_size * ruin_factor)
            if len(work_seq) > bs:
                start = len(work_seq) - bs
                removed_txns = work_seq[start:]
                del work_seq[start:]

        elif r_mode < 0.55:
            # Mode 2: Single Large Block (Locality)
            base_size = max(2, int(num_txns * 0.2))
            bs = min(len(work_seq), int(base_size * ruin_factor))
            if len(work_seq) > bs:
                start = random.randint(0, len(work_seq) - bs)
                removed_txns = work_seq[start : start + bs]
                del work_seq[start : start + bs]

        elif r_mode < 0.85:
            # Mode 3: Two Disjoint Blocks (Global shuffle)
            base_total = max(4, int(num_txns * 0.20))
            total_rem = min(len(work_seq), int(base_total * ruin_factor))
            b1 = total_rem // 2
            b2 = total_rem - b1

            if len(work_seq) > b1:
                s1 = random.randint(0, len(work_seq) - b1)
                removed_txns.extend(work_seq[s1 : s1 + b1])
                del work_seq[s1 : s1 + b1]
            if len(work_seq) > b2:
                s2 = random.randint(0, len(work_seq) - b2)
                removed_txns.extend(work_seq[s2 : s2 + b2])
                del work_seq[s2 : s2 + b2]

        else:
            # Mode 4: Random Scatter (Dependency chains)
            base_cnt = max(3, int(num_txns * 0.15))
            cnt = min(len(work_seq), int(base_cnt * ruin_factor))
            indices = sorted(random.sample(range(len(work_seq)), cnt), reverse=True)
            for idx in indices:
                removed_txns.append(work_seq.pop(idx))

        # Sort removed transactions by LPT (Longest Processing Time)
        # Re-inserting big items first (Big Rocks principle)
        removed_txns.sort(key=lambda t: txn_lengths.get(t, 0), reverse=True)

        # C. Recreate (Greedy Best-Fit)
        for txn in removed_txns:
            best_pos = -1
            best_incr = float('inf')

            for pos in range(len(work_seq) + 1):
                work_seq.insert(pos, txn)
                c = workload.get_opt_seq_cost(work_seq)
                if c < best_incr:
                    best_incr = c
                    best_pos = pos
                del work_seq[pos]

            work_seq.insert(best_pos, txn)

        current_schedule = work_seq
        current_cost = best_incr

        # Save if improved
        if current_cost < best_cost:
            best_cost = current_cost
            best_schedule = list(current_schedule)
            last_improved_cycle = cycle

        # D. Polish: Deterministic Iterative Improvement (Gap Repair)
        # Scan entire schedule, try to move each transaction to its optimal position.

        # Polish Condition:
        # 1. New global best found (Lock it in)
        # 2. Promising solution (Within 5% of best)
        # 3. Random exploration (20%)
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.2)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            # Increased passes for better convergence
            MAX_PASSES = 3
            if num_txns < 40: MAX_PASSES = 5

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Check every transaction
                # Processing in LPT order (Big Rocks first) helps settle structure
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Cost without txn
                    del current_schedule[current_idx]

                    # Baseline cost without this transaction
                    # Useful for Early Exit optimization
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan all positions
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)

                        # Check improvement
                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        # Early Exit:
                        # If the cost with txn is same as cost without txn, it's perfectly hidden.
                        # We cannot do better than 0 cost increase.
                        # This optimization significantly speeds up the scan.
                        if abs(c - base_val) < 1e-9:
                            best_val = c
                            best_pos = pos
                            current_schedule.pop(pos) # Must pop before break to keep state consistent
                            break

                        del current_schedule[pos]

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Update if improved
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
                            last_improved_cycle = cycle
>>>>>>> REPLACE
</DIFF>