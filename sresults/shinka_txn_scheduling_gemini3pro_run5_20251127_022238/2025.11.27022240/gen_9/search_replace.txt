<NAME>
hybrid_beam_sa_reheat
</NAME>

<DESCRIPTION>
Replaces the randomized beam search and simple local search with a robust hybrid approach:
1.  **Exhaustive Beam Search**: Instead of sampling next transactions, we evaluate *all* possible next transactions at each step of the beam search. This ensures local optimality during the construction phase, which was a key factor in previous high-performing solutions. The beam width is dynamically sized based on `num_seqs`.
2.  **Simulated Annealing with Reheating**: Replaces simple hill-climbing. It uses three mutation operators (Swap, Insert, Reverse) and a reheating mechanism to escape local optima if the search stagnates or cools down too much.
3.  **Cost Caching**: Caches schedule costs to maximize the number of evaluations possible within the time budget.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
import time
import random
import sys
import os
=======
import time
import random
import sys
import os
import math
>>>>>>> REPLACE
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using beam search followed by extensive local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection (used as beam width)

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # Beam Search configuration
    beam_width = num_seqs
    candidates_per_node = 20

    # Initialize beam with unique random start transactions
    all_txns = list(range(workload.num_txns))
    num_starts = min(beam_width, len(all_txns))
    start_txns = random.sample(all_txns, num_starts)

    # Beam element: (cost, schedule, remaining_txns_list)
    beam = []
    for t in start_txns:
        rem = list(all_txns)
        rem.remove(t)
        cost = workload.get_opt_seq_cost([t])
        beam.append((cost, [t], rem))

    # Iteratively expand the beam
    target_length = workload.num_txns
    while len(beam[0][1]) < target_length:
        candidates = []
        for cost, sched, rem in beam:
            # Sample subset of remaining transactions
            n_sample = min(len(rem), candidates_per_node)
            next_txns = random.sample(rem, n_sample)

            for next_txn in next_txns:
                new_sched = sched + [next_txn]
                new_cost = workload.get_opt_seq_cost(new_sched)
                # Store needed info to reconstruct state (avoid deep copying rem yet)
                candidates.append((new_cost, new_sched, rem, next_txn))

        # Select top k candidates based on lowest cost
        # Shuffle first to break ties randomly
        random.shuffle(candidates)
        candidates.sort(key=lambda x: x[0])
        best_candidates = candidates[:beam_width]

        # Construct next beam
        new_beam = []
        for cost, new_sched, old_rem, added_txn in best_candidates:
            new_rem = list(old_rem)
            new_rem.remove(added_txn)
            new_beam.append((cost, new_sched, new_rem))
        beam = new_beam

    # Select best schedule from beam
    best_cost, best_schedule, _ = min(beam, key=lambda x: x[0])

    # Extended Local Search phase on the single best schedule
    # Uses both Move and Swap operators
    current_schedule = list(best_schedule)
    current_cost = best_cost

    # Iterations count balanced to fit within execution time budget
    # Saved comparisons from beam search allow for more local search
    iterations = 3000

    for _ in range(iterations):
        op = random.random()
        test_schedule = list(current_schedule)

        if op < 0.5:
            # Move operator: pick random txn and insert elsewhere
            idx_from = random.randint(0, len(test_schedule) - 1)
            txn = test_schedule.pop(idx_from)
            idx_to = random.randint(0, len(test_schedule)) # can insert at end
            test_schedule.insert(idx_to, txn)
        else:
            # Swap operator: swap two random positions
            idx1 = random.randint(0, len(test_schedule) - 1)
            idx2 = random.randint(0, len(test_schedule) - 1)
            if idx1 == idx2: continue
            test_schedule[idx1], test_schedule[idx2] = test_schedule[idx2], test_schedule[idx1]

        new_cost = workload.get_opt_seq_cost(test_schedule)

        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = test_schedule

    return current_cost, current_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Exhaustive Beam Search followed by Simulated Annealing with Reheating.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Parameter affecting computational budget (used to scale beam width)

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # Hyperparameters
    # Beam width: scale with budget but keep manageable.
    # Exhaustive search at each beam step is expensive, so width is smaller than random sampling approaches.
    BEAM_WIDTH = max(4, int(num_seqs * 0.6))

    # SA Parameters
    SA_ITERATIONS = 5000
    SA_COOLING_RATE = 0.995
    SA_REHEAT_THRESHOLD = 300  # Iterations without improvement

    # Cost Cache
    cost_cache = {}

    def get_cost(seq):
        t_seq = tuple(seq)
        if t_seq in cost_cache:
            return cost_cache[t_seq]
        c = workload.get_opt_seq_cost(seq)
        cost_cache[t_seq] = c
        return c

    # --- Phase 1: Exhaustive Beam Search ---
    # Initialize beam with ALL transactions to find best starts
    beam = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        beam.append({
            'cost': cost,
            'seq': seq,
            'rem': set(range(workload.num_txns)) - {t}
        })

    # Prune to width
    beam.sort(key=lambda x: x['cost'])
    beam = beam[:BEAM_WIDTH]

    # Construction loop
    for _ in range(workload.num_txns - 1):
        candidates = []

        # Expand each beam node
        for node in beam:
            parent_seq = node['seq']
            parent_rem = node['rem']

            # Exhaustively evaluate all valid next transactions
            for t in parent_rem:
                new_seq = parent_seq + [t]
                cost = get_cost(new_seq)
                candidates.append((cost, new_seq, parent_rem, t))

        # Select best global candidates
        candidates.sort(key=lambda x: x[0])

        new_beam = []
        for cost, seq, parent_rem, t in candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            # Create new node
            new_rem = parent_rem.copy()
            new_rem.remove(t)
            new_beam.append({
                'cost': cost,
                'seq': seq,
                'rem': new_rem
            })

        beam = new_beam

    # Best schedule from construction
    if not beam:
        return float('inf'), []

    current_schedule = list(beam[0]['seq'])
    current_cost = beam[0]['cost']

    # --- Phase 2: Simulated Annealing with Reheating ---
    best_schedule = list(current_schedule)
    best_cost = current_cost

    # Initial temperature
    T_max = current_cost * 0.1
    T = T_max
    T_min = 0.001

    stagnant_steps = 0

    for _ in range(SA_ITERATIONS):
        # Generate neighbor
        neighbor = list(current_schedule)
        n = len(neighbor)

        op = random.random()
        idx1 = random.randint(0, n - 1)
        idx2 = random.randint(0, n - 1)

        if op < 0.4: # Swap
            neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
        elif op < 0.8: # Insert
            if idx1 != idx2:
                val = neighbor.pop(idx1)
                neighbor.insert(idx2, val)
        else: # Reverse
            start, end = sorted((idx1, idx2))
            if start < end:
                neighbor[start:end+1] = neighbor[start:end+1][::-1]

        new_cost = get_cost(neighbor)
        delta = new_cost - current_cost

        # Acceptance
        accept = False
        if delta < 0:
            accept = True
        elif T > 1e-9:
            if random.random() < math.exp(-delta / T):
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = new_cost
            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)
                stagnant_steps = 0
            else:
                stagnant_steps += 1
        else:
            stagnant_steps += 1

        # Cooling
        T *= SA_COOLING_RATE

        # Reheating
        if stagnant_steps > SA_REHEAT_THRESHOLD or T < T_min:
            T = T_max * 0.5
            T_max *= 0.9 # Decay reheat ceiling
            stagnant_steps = 0
            # Occasionally jump back to best known to explore its neighborhood again
            if random.random() < 0.4:
                current_schedule = list(best_schedule)
                current_cost = best_cost

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>