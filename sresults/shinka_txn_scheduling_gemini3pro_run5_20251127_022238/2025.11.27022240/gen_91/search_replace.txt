<NAME>
optimize_polish_and_gamma
</NAME>

<DESCRIPTION>
1.  **Broaden Gamma Range (2.0 -> 0.8):** In the Beam Search, I broaden the gamma decay range. Starting at 2.0 encourages more aggressive parallelism early on (structure formation), while ending at 0.8 prioritizes tight packing and hole-filling at the end. This wider range allows the algorithm to adapt better from global structure to local efficiency.
2.  **Convergent Alternating Polish:** I significantly upgrade the polish phase (Gap Repair).
    *   **Increased Passes:** I increase `MAX_PASSES` to 10 (or 15 for small workloads) to allow the schedule to fully settle into a local optimum. The "Early Exit" optimization (breaking on perfect fits) keeps this computationally feasible.
    *   **Alternating Sort Order:** Instead of only processing transactions in LPT order, I alternate the processing order in each pass. Odd passes use **LPT** (Big Rocks) to optimize structure, while even passes use **Reverse Schedule** order to specifically target the tail of the schedule for direct makespan reduction. This helps break out of LPT-specific local minima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    BEAM_WIDTH = max(16, int(num_seqs * 2.5))
    GAMMA_START = 1.8
    GAMMA_END = 1.0

    # Seed beam
=======
    BEAM_WIDTH = max(16, int(num_seqs * 2.5))
    GAMMA_START = 2.0
    GAMMA_END = 0.8

    # Seed beam
>>>>>>> REPLACE
<<<<<<< SEARCH
        # D. Polish: Iterative Gap Repair
        # This is the critical refinement step.
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.2)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            # Allow multiple passes for convergence
            MAX_PASSES = 3
            if num_txns < 50: MAX_PASSES = 5

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Check every transaction in LPT order
                # Big Rocks First: Settling large items helps small items fill gaps later
                txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Remove transaction temporarily
                    del current_schedule[current_idx]

                    # Baseline cost without this transaction
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan all positions
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)

                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        # Early Exit Optimization:
                        # If cost increase is 0 (perfect fit), we can't improve further.
                        # Break immediately to save compute.
                        # This implicitly prefers the earliest perfect fit (Pack Left).
                        if abs(c - base_val) < 1e-9:
                            best_val = c
                            best_pos = pos
                            current_schedule.pop(pos) # Clean up before break
                            break

                        del current_schedule[pos]

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Check for improvement against global current state
                    # We compare against current_cost before the move loop started for this txn?
                    # No, we just need to see if the best found position is better than what we had.
                    # Since we modified the schedule in place, we implicitly compare.
                    # But we need to update 'current_cost' correctly.

                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
                            last_improved_cycle = cycle
=======
        # D. Polish: Convergent Alternating Gap Repair
        # Systematically remove and re-insert transactions to minimize holes.
        should_polish = (current_cost <= best_cost * 1.05) or (random.random() < 0.25)

        if should_polish and num_txns > 1:
            improved = True
            passes = 0
            # Allow higher passes for better convergence. Early Exit keeps it fast.
            MAX_PASSES = 10
            if num_txns < 40: MAX_PASSES = 15

            while improved and passes < MAX_PASSES:
                improved = False
                passes += 1

                # Alternating Sort Order:
                # Odd passes: LPT (Big Rocks) - Prioritize fitting large items.
                # Even passes: Reverse Schedule - Prioritize moving items from the tail (Makespan reduction).
                if passes % 2 == 1:
                    txns_to_check = sorted(current_schedule, key=lambda t: txn_lengths.get(t, 0), reverse=True)
                else:
                    txns_to_check = list(reversed(current_schedule))

                for txn in txns_to_check:
                    try:
                        current_idx = current_schedule.index(txn)
                    except ValueError: continue

                    # Remove transaction
                    del current_schedule[current_idx]

                    # Baseline cost without this transaction
                    base_val = workload.get_opt_seq_cost(current_schedule)

                    best_pos = -1
                    best_val = float('inf')

                    # Scan all positions
                    for pos in range(len(current_schedule) + 1):
                        current_schedule.insert(pos, txn)
                        c = workload.get_opt_seq_cost(current_schedule)
                        current_schedule.pop(pos) # Backtrack

                        if c < best_val:
                            best_val = c
                            best_pos = pos

                        # Early Exit: Perfect Packing
                        # If delta is 0, we found a perfect hole.
                        if abs(c - base_val) < 1e-9:
                            best_val = c
                            best_pos = pos
                            break

                    # Re-insert at best position
                    current_schedule.insert(best_pos, txn)

                    # Update cost and check improvement
                    if best_val < current_cost - 1e-6:
                        current_cost = best_val
                        improved = True
                        if current_cost < best_cost:
                            best_cost = current_cost
                            best_schedule = list(current_schedule)
                            last_improved_cycle = cycle
>>>>>>> REPLACE
</DIFF>