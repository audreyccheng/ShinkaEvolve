# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Cost-Sampled Transaction Scheduler**
- **Implementation**: The algorithm constructs a schedule by iteratively selecting the best next transaction from a random sample of 10 candidates based on the lowest intermediate makespan cost. It employs a fixed sample rate of 1.0 to ensure greedy optimization is applied at every step of the sequence generation.
- **Performance**: Achieved a combined score of 2.67, successfully optimizing total makespan across all three workloads.
- **Feedback**: The approach effectively uses local look-ahead to optimize ordering, but it ignores the `num_seqs` parameter to perform only a single pass, limiting its ability to escape local optima via multiple restarts.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Greedy Cost Sampling with Random Restarts**
- **Implementation**: The algorithm constructs schedules by iteratively appending the best transaction from a random sample of candidates based on partial makespan costs, repeating this process with multiple random starts.
- **Performance**: The approach achieved a combined optimization score of 2.91 across the three workloads.
- **Feedback**: Sampling a subset of candidates at each step significantly reduces computational complexity compared to exhaustive greedy search, while random restarts help mitigate the limitations of the local greedy heuristic.
**Program Identifier:** Generation 1 - Patch Name implement_multi_sequence_greedy_search - Correct Program: True

**Program Name: Randomized Greedy Scheduling with LPT Heuristics and Restarts**
- **Implementation**: This solution implements a greedy construction algorithm that selects the next transaction by evaluating a mix of longest-processing-time candidates and random samples against the simulation cost. It utilizes multiple restarts to broaden the search space and avoid local optima.
- **Performance**: The algorithm achieved a combined optimization score of 2.87, effectively handling three distinct workloads.
- **Feedback**: Blending heuristic selection (LPT) with random sampling allows for effective exploration, while evaluating partial schedule costs ensures high-quality local decisions, though simulation overhead limits the number of candidates checked.
**Program Identifier:** Generation 2 - Patch Name smart_greedy_scheduler - Correct Program: True

**Program Name: Sampled Greedy Construction with Stochastic Local Search**
- **Implementation**: The algorithm builds schedules using a greedy strategy that evaluates a random sample of 24 candidate transactions at each step to minimize incremental cost, repeated over 10 random restarts. Each generated schedule is subsequently refined using a local search that attempts to improve the makespan via 200 random single-transaction relocation moves.
- **Performance**: The solution achieved a combined score of 3.23, effectively optimizing transaction ordering for reduced makespan across all workloads.
- **Feedback**: The use of candidate sampling during the greedy phase efficiently balances construction speed with decision quality, while the integration of local search and multiple restarts successfully mitigates the risk of getting trapped in poor local optima.
**Program Identifier:** Generation 3 - Patch Name improved_greedy_with_local_search - Correct Program: True

**Program Name: Hybrid Heuristic Beam Search Scheduler**
- **Implementation**: The solution implements a beam search algorithm that maintains multiple partial schedules, expanding them by selecting candidates via a mix of Longest Processing Time (LPT) heuristics and random sampling.
- **Performance**: The algorithm achieved a combined maximization score of 3.16, successfully generating valid and optimized schedules for all transaction workloads.
- **Feedback**: The combination of beam search with LPT heuristics effectively balances exploration and exploitation, allowing the scheduler to avoid local optima while prioritizing computationally expensive transactions early.
**Program Identifier:** Generation 4 - Patch Name beam_search_scheduler - Correct Program: True

**Program Name: Hybrid Beam Search with Simulated Annealing Scheduling**
- **Implementation**: This approach constructs initial schedules using a Beam Search with candidate sampling to reduce search space, followed by Simulated Annealing refinement utilizing cost caching and mixed swap/insert perturbations.
- **Performance**: The algorithm achieved a combined score of 3.56, successfully optimizing makespans across three distinct workloads.
- **Feedback**: The hybrid strategy effectively balances greedy construction with local search refinement, while caching mechanisms and candidate sampling ensure the complex optimization fits within execution time limits.
**Program Identifier:** Generation 5 - Patch Name beam_simulated_annealing - Correct Program: True

**Program Name: Hybrid Beam Search with Post-Process Local Search**
- **Implementation**: The solution employs a sampled Beam Search (width 10) to construct a high-quality initial sequence, followed by 3000 iterations of stochastic hill climbing using move and swap operators for refinement.
- **Performance**: It achieved a combined maximization score of 3.37 across three workloads, effectively optimizing makespan with a balanced execution time.
- **Feedback**: The two-stage approach allows the algorithm to find a strong global structure quickly via Beam Search and then escape local optima or tighten the schedule via extensive local search, proving robust across varying workload patterns.
**Program Identifier:** Generation 6 - Patch Name beam_search_optimization - Correct Program: True

**Program Name: Hybrid Exhaustive Beam Search with Simulated Annealing**
- **Implementation**: Constructs an initial schedule using a beam search (width 4) that exhaustively evaluates all valid next transactions, then refines the result via simulated annealing (4000 iterations) using swap and insert operations.
- **Performance**: Achieved a combined score of 3.82 across the three transaction workloads.
- **Feedback**: The exhaustive construction approach ensures a high-quality initial sequence by strictly optimizing local greedy moves, while cost caching minimizes the overhead of repeated evaluations during both phases.
**Program Identifier:** Generation 7 - Patch Name exhaustive_beam_search - Correct Program: True

**Program Name: Hybrid LPT-Biased Beam Search with Diversity Sampling**
- **Implementation**: Implements a beam search that prioritizes Longest Processing Time (LPT) transactions while injecting random candidates and diversity-based pruning to prevent convergence on local optima.
- **Performance**: Achieved a combined score of 3.25 with valid schedules generated for all 300 transactions.
- **Feedback**: The inclusion of LPT heuristics significantly improves the baseline quality, while the stochastic elements in the beam selection process effectively maintain search diversity without excessive computational overhead.
**Program Identifier:** Generation 8 - Patch Name improved_beam_search - Correct Program: True

**Program Name: Beam Search Construction with Reheating Simulated Annealing**
- **Implementation**: The solution combines an exhaustive beam search to construct a strong initial schedule with a simulated annealing phase that utilizes reheating and diverse mutation operators (swap, insert, reverse) for refinement. A cost cache is implemented to optimize the expensive makespan calculations during both the construction and optimization phases.
- **Performance**: The algorithm achieved a combined score of 3.70, effectively minimizing the total makespan across all workloads.
- **Feedback**: The hybrid approach successfully balances global structure identification via beam search with local optimization via annealing, while the reheating mechanism prevents early convergence to suboptimal solutions.
**Program Identifier:** Generation 9 - Patch Name hybrid_beam_sa_reheat - Correct Program: True

**Program Name: Work-Density Guided Beam Search**
- **Implementation**: Implements a beam search using a custom scoring metric (`Makespan - Gamma * Work`) to prioritize heavy transactions early, generating candidates via Longest Processing Time (LPT) heuristics and random sampling.
- **Performance**: Achieved a strong combined score of 3.50, successfully minimizing makespan across complex workloads within time constraints.
- **Feedback**: The density-based scoring effectively counteracts the greedy tendency to delay expensive tasks, while stochastic pruning maintains necessary diversity in the search beam.
**Program Identifier:** Generation 10 - Patch Name density_beam_search - Correct Program: True

**Program Name: Diversity-Aware Beam Search with Block-Move Simulated Annealing**
- **Implementation**: This solution constructs an initial schedule using beam search with diversity constraints to limit parent dominance, followed by simulated annealing refinement using swap, insert, and contiguous block-move operators. A dictionary-based cost cache is utilized to eliminate redundant makespan calculations during the intensive search phases.
- **Performance**: The program achieved a high combined score of 3.44, effectively balancing the minimization of transaction makespan with computational overhead.
- **Feedback**: The diversity mechanism in the beam search effectively prevents premature convergence on local optima, while the block-move operator in the annealing phase is particularly well-suited for reordering clusters of dependent transactions.
**Program Identifier:** Generation 11 - Patch Name hybrid_beam_block_sa - Correct Program: True

**Program Name: Hybrid Beam Search with Work-Density Scoring and Annealing**
- **Implementation**: Combines a constructive Beam Search using Longest Processing Time (LPT) and work-density scoring with a Simulated Annealing refinement phase employing swap and insert mutations.
- **Performance**: The solution achieved a high combined score of 3.29, demonstrating effective conflict resolution and schedule optimization.
- **Feedback**: By generating a high-quality initial schedule via the work-density biased beam search, the algorithm allows the annealing phase to efficiently resolve local conflicts without needing to explore the entire global space.
**Program Identifier:** Generation 12 - Patch Name hybrid_beam_annealing - Correct Program: True

**Program Name: Hybrid Diversity-Aware Beam Search and Simulated Annealing**
- **Implementation**: The solution constructs an initial schedule using a diversity-constrained beam search to prevent premature convergence, followed by simulated annealing with block moves and reheating for structural refinement. A caching mechanism is employed to speed up the evaluation of repeated sequence costs during the search process.
- **Performance**: The algorithm achieved a combined score of 3.51, successfully optimizing schedules for 300 transactions across three workloads.
- **Feedback**: The integration of diversity constraints within the beam search ensures a broad exploration of the search space before refinement. Additionally, the block move operator in the annealing phase effectively handles dependencies by moving related transaction clusters together.
**Program Identifier:** Generation 13 - Patch Name diversity_beam_sa_block - Correct Program: True

**Program Name: Hybrid Beam Search with Diversity and Block-Move Simulated Annealing**
- **Implementation**: The algorithm constructs an initial schedule using a diversity-aware beam search that limits children per parent, followed by simulated annealing employing block moves, swaps, reverses, and reheating logic. A caching mechanism is utilized to store sequence costs and reduce redundant simulator computations.
- **Performance**: The solution achieved a combined score of 3.61, successfully generating valid schedules for all 300 transactions across the workloads.
- **Feedback**: The use of a diversity-constrained beam search provides a high-quality initialization that prevents premature convergence. The subsequent annealing with block-level operators effectively refines the schedule by escaping local optima.
**Program Identifier:** Generation 14 - Patch Name diversity_beam_sa_block_moves - Correct Program: True

**Program Name: Hybrid Beam Search and Block-Move Simulated Annealing**
- **Implementation**: Uses Beam Search (width 5) to construct a high-quality initial schedule, followed by Simulated Annealing with specific operators for insertion, swapping, and moving contiguous blocks of transactions.
- **Performance**: Achieved a combined score of 3.83, indicating highly effective schedule optimization.
- **Feedback**: The beam search initialization successfully resolves complex dependencies upfront, while the block move operator allows the annealing phase to relocate transaction clusters without breaking their internal ordering.
**Program Identifier:** Generation 15 - Patch Name exhaustive_beam_sa_block_move - Correct Program: True

**Program Name: Hybrid Beam Search with Block-Move Simulated Annealing**
- **Implementation**: Combines a diversity-aware Beam Search using LPT heuristics for initial construction with a Simulated Annealing refinement phase featuring swap, insert, and contiguous block-move operators.
- **Performance**: Achieved a combined score of 3.45, demonstrating strong optimization capability within the time constraints.
- **Feedback**: The inclusion of block moves allows the algorithm to efficiently reorder clusters of dependent transactions, while diversity pruning during the construction phase prevents premature convergence on suboptimal schedules.
**Program Identifier:** Generation 16 - Patch Name enhanced_hybrid_beam_sa - Correct Program: True

**Program Name: Hybrid Beam Search with Adaptive Simulated Annealing**
- **Implementation**: Combines a greedy beam search initialization (width 4) with a simulated annealing phase featuring adaptive operator weights (swap, insert, block, reverse) and temperature reheating.
- **Performance**: Achieved a combined score of 3.85, generating valid schedules across complex, simple, and minimal workloads.
- **Feedback**: The beam search effectively seeds the optimization with a high-quality baseline, while the adaptive operator mechanism allows the algorithm to dynamically favor mutation strategies that yield improvements.
**Program Identifier:** Generation 17 - Patch Name adaptive_beam_sa - Correct Program: True

**Program Name: Hybrid Beam Search with Diversity and SA Block Moves**
- **Implementation**: Combines LPT-seeded Beam Search with diversity-aware pruning for initial construction, followed by Simulated Annealing using block moves and tail-biased insertion for refinement.
- **Performance**: Achieved a high combined score of 3.62, successfully minimizing total makespan across mixed transaction workloads.
- **Feedback**: The inclusion of diversity mechanisms in the constructive phase and structural block moves in the refinement phase effectively balanced exploration and exploitation.
**Program Identifier:** Generation 18 - Patch Name restore_beam_width_and_biased_sa - Correct Program: True

**Program Name: Hybrid Work-Density Beam Search with Annealing Refinement**
- **Implementation**: This solution employs a Beam Search guided by a "work-density" metric to prioritize heavy transactions early, followed by Simulated Annealing using block-move and insertion operators to refine the schedule.
- **Performance**: The algorithm achieved a strong combined score of 3.55, demonstrating effective optimization across diverse workloads.
- **Feedback**: The combination of LPT-based candidate generation in the constructive phase and structural block mutations in the refinement phase allows the algorithm to efficiently establish a strong baseline and escape local optima.
**Program Identifier:** Generation 19 - Patch Name hybrid_density_beam_sa - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

Based on the evaluation results of the transaction scheduling programs, here is the analysis of the algorithmic patterns, implementation details, and performance trends.

## Successful Algorithmic Patterns
- **Exhaustive Beam Initialization**: The highest-performing programs, **Generation 17** (Score: 3.85) and **Generation 15** (Score: 3.83), utilize an "exhaustive" Beam Search strategy. Unlike lower-scoring variants that use heuristics (LPT/Density) to filter candidates, these programs evaluate *every* possible next transaction via the simulator. This computationally expensive but accurate construction phase consistently yields a superior initial schedule compared to heuristic approximations.
- **Adaptive Metaheuristic Refinement**: The current best program, **Generation 17**, distinguishes itself by employing Simulated Annealing with **adaptive operator weights**. By dynamically adjusting the probability of selecting `swap`, `insert`, `block`, or `reverse` operators based on their success rate (rewarding global improvements with +3.0 weight), the algorithm focuses its computational budget on the most effective mutation types for the specific workload state.
- **Block-Move Operations**: Across the top tier of recent generations (**Generation 11, 13, 14, 15, 17**), the inclusion of a "block-move" operator in the refinement phase is a recurring success factor. This operator allows the algorithm to relocate contiguous clusters of transactions—likely dependent chains formed during the beam search—without disrupting their internal order, facilitating the resolution of complex dependencies.

## Ineffective Approaches
- **Static Heuristics for Candidate Generation**: Programs relying on static metrics like Longest Processing Time (LPT) or Work-Density to guide the Beam Search (e.g., **Generation 19**, Score 3.55; **Generation 16**, Score 3.45; **Generation 12**, Score 3.29) consistently underperform compared to simulation-based approaches (Scores 3.82+). The complex interaction costs of the transactions render static proxies less effective than actual cost simulation.
- **Over-Constrained Diversity without Exhaustive Search**: While diversity mechanisms (used in **Generation 14**, Score 3.61; **Generation 18**, Score 3.62) improved over basic greedy baselines, they did not reach the performance of the pure exhaustive beam search (**Generation 15**, 3.83). This suggests that forcing diversity at the expense of selecting the locally optimal simulation result (the "greedy" choice) is suboptimal for this specific problem size and time constraint.

## Implementation Insights
- **Narrow Beam with Perfect Local Information**: The current best program (**Generation 17**) and its high-performing predecessors use a very small `BEAM_WIDTH = 4`. This implementation choice explicitly trades search breadth for the ability to perform an **exhaustive expansion** (looping through all `p_rem` candidates) at each step. This ensures the limited beam is populated with high-confidence local optima rather than uncertain heuristic guesses.
- **Dynamic Weight Adaptation Implementation**: **Generation 17** implements a reinforcement-learning-style mechanism within the SA loop. It maintains a dictionary `OP_WEIGHTS` and updates it using a decay factor (`OP_ADAPTATION_RATE = 0.1`) and rewards. This implementation allows the algorithm to automatically transition from exploration (using all operators) to exploitation (favoring productive operators) without manual tuning.
- **Cost Caching for High-Iteration Refinement**: To support the extensive 6000 iterations of Simulated Annealing in **Generation 17**, an efficient `cost_cache` (mapping tuple sequences to costs) is critical. This coding pattern prevents redundant simulations during the "reheating" and refinement phases, where the algorithm frequently revisits similar sequence structures.

## Performance Analysis
- **The "Exhaustive" Performance Gap**: There is a distinct performance tiering based on the construction method. Programs using heuristic construction (Generations 12, 16, 19) plateau around scores of **3.30 - 3.55**. In contrast, programs using exhaustive simulation-based construction (Generations 7, 15, 17) consistently achieve scores above **3.80**, marking a significant step-change in solution quality.
- **Incremental Gains from Adaptivity**: Comparing **Generation 15** (Score 3.83) to **Generation 17** (Score 3.85) reveals that while the exhaustive beam initialization is the primary driver of performance, the addition of adaptive operator selection provides a measurable edge. It allows the solution to push closer to the theoretical optimum by more efficiently navigating the local search space.
- **Optimization Ceiling**: The scores for the top hybrids are clustering tightly (3.82, 3.83, 3.85), suggesting that the combination of Exhaustive Beam Search and Simulated Annealing is approaching the maximum possible efficiency for these workloads within the given time limits. Further gains may require structural changes to how "work" is defined or predicted rather than just search strategy refinements.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the analysis of the high-performing Generation 17 program and the global insights, here are 5 actionable recommendations for future mutations:

1.  **Implement Iterated Local Search (ILS) with Ruin-and-Recreate**
    Replace the simple "reheating" mechanism in the Simulated Annealing phase with a formal Iterated Local Search structure. When the search stagnates, apply a "ruin-and-recreate" kick: remove a significant contiguous block of transactions (e.g., 10-20% of the schedule) and re-insert them using a greedy best-fit strategy. This structural perturbation is more effective than random swaps at breaking out of deep local optima in dependency-heavy scheduling problems.

2.  **Enforce Structural Diversity in Beam Search**
    Modify the pruning logic in the Exhaustive Beam Search to reject candidates that are too similar to those already selected for the next beam. For example, ensure that the last $N$ added transactions differ across beam members. With a narrow beam width of 4, preventing the beam from saturating with nearly identical sequence tails ensures the algorithm explores distinct pathways in the solution space.

3.  **Adopt Dynamic Beam Width**
    Change the static `BEAM_WIDTH = 4` to a dynamic strategy that expands the width (e.g., to 8) when the cost variance among top candidates is low, and contracts it (e.g., to 2) when a clear leader emerges. This adaptive resource allocation allows the algorithm to investigate more possibilities at "ambiguous" decision points while saving time on obvious steps, maximizing the efficiency of the exhaustive evaluation.

4.  **Integrate Variable Neighborhood Descent (VND)**
    Refine the adaptive operator logic to include a systematic "descent" phase. Instead of purely probabilistic selection, cyclically exhaust specific neighborhoods (e.g., try *all* adjacent swaps, then *all* block moves of size 3) until a local optimum is reached, before reverting to random perturbations. This ensures that simple, accessible improvements are deterministically captured rather than left to chance.

5.  **Lookahead Tie-Breaking in Construction**
    Enhance the greedy selection step in the beam search by adding a lightweight tie-breaker. If the simulation costs of two candidate transactions are within a small margin, select the one that leaves a "cheaper" set of remaining transactions (estimated by a fast static metric like raw transaction cost sum). This helps the greedy construction avoid locally attractive moves that leave behind computationally expensive clusters of transactions.