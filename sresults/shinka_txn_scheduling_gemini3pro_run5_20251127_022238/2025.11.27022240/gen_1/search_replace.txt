<NAME>
implement_multi_sequence_greedy_search
</NAME>

<DESCRIPTION>
The existing `get_best_schedule` function ignores the `num_seqs` parameter, performing only a single randomized greedy pass. This implementation updates the function to respect `num_seqs` by performing multiple independent runs (restarts) of the greedy schedule construction and returning the best result found. This exploits the randomized nature of the starting transaction and the candidate sampling to better explore the solution space.

Additionally, the inner greedy logic has been refactored to be cleaner and more efficient. It now uses `random.sample` to pick a subset of candidate transactions (size 8) at each step and selects the one that results in the minimum partial makespan. This balances computational cost with the quality of the greedy choice, avoiding the pitfalls of a purely random selection while keeping runtime manageable compared to a full deterministic search.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    def get_greedy_cost_sampled(num_samples, sample_rate):
        # greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = [x for x in range(0, workload.num_txns)]
        remaining_txns.remove(start_txn)
        running_cost = workload.txns[start_txn][0][3]

        for i in range(0, workload.num_txns - 1):
            min_cost = 100000  # MAX
            min_relative_cost = 10
            min_txn = -1
            holdout_txns = []
            done = False
            key_maps = []

            sample = random.random()
            if sample > sample_rate:
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                txn_seq.append(t)
                remaining_txns.pop(idx)
                continue

            for j in range(0, num_samples):
                idx = 0
                if len(remaining_txns) > 1:
                    idx = random.randint(0, len(remaining_txns) - 1)
                else:
                    done = True
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                txn_len = workload.txns[t][0][3]
                test_seq = txn_seq.copy()
                test_seq.append(t)
                cost = 0
                cost = workload.get_opt_seq_cost(test_seq)
                if cost < min_cost:
                    min_cost = cost
                    min_txn = t
                if done:
                    break
            assert(min_txn != -1)
            running_cost = min_cost
            txn_seq.append(min_txn)
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        assert len(set(txn_seq)) == workload.num_txns

        overall_cost = workload.get_opt_seq_cost(txn_seq)
        return overall_cost, txn_seq

    return get_greedy_cost_sampled(10, 1.0)
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy with restarts.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Run the greedy construction multiple times with random starts
    for _ in range(num_seqs):
        # Start with a random transaction
        start_txn = random.randint(0, workload.num_txns - 1)
        current_schedule = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Iteratively build the schedule
        while remaining_txns:
            # Sample a subset of remaining transactions to evaluate
            # Using a sample size balances speed and quality.
            # Checking all remaining would be O(N^2) calls to cost function.
            sample_size = min(len(remaining_txns), 8)
            candidates = random.sample(remaining_txns, sample_size)

            best_next_txn = -1
            min_next_cost = float('inf')

            # Evaluate candidates
            for txn in candidates:
                # Cost is monotonic, so minimizing partial schedule makespan is a good greedy heuristic
                test_schedule = current_schedule + [txn]
                cost = workload.get_opt_seq_cost(test_schedule)

                if cost < min_next_cost:
                    min_next_cost = cost
                    best_next_txn = txn

            # Append the best candidate found
            if best_next_txn != -1:
                current_schedule.append(best_next_txn)
                remaining_txns.remove(best_next_txn)
            else:
                # Fallback (should not happen with valid logic)
                txn = remaining_txns.pop(0)
                current_schedule.append(txn)

        # Check if this full schedule is the best so far
        final_cost = workload.get_opt_seq_cost(current_schedule)
        if final_cost < best_overall_cost:
            best_overall_cost = final_cost
            best_schedule = current_schedule

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>