<NAME>
adaptive_beam_and_polish
</NAME>

<DESCRIPTION>
1.  **Adaptive Density-Aware Beam Search:** Implements a linear decay for the `gamma` parameter (2.0 to 0.5) to shift focus from "parallelism/work-density" (early schedule) to "tight packing/makespan minimization" (late schedule). It also introduces a continuous "efficiency" score based on how much the makespan increases relative to the transaction length.
2.  **Deterministic Polish:** Adds a single-pass "Iterative Best-Move" phase after the Simulated Annealing loop. This iterates through every transaction in the schedule, removes it, and re-inserts it at the optimal position. This deterministic cleanup is often more effective at removing final inefficiencies than random stochastic moves.
3.  **Adjustment:** Reduces `SA_ITERATIONS` from 5000 to 2500 to compensate for the computational cost of the deterministic polish phase, ensuring total execution time remains reasonable.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Hyperparameters ---
    # Width 4 strikes the best balance between exploring structural diversity
    # and computational cost for the exhaustive expansion step.
    BEAM_WIDTH = 4

    # SA Parameters
    SA_ITERATIONS = 5000
    SA_COOLING_RATE = 0.998
    SA_START_TEMP_RATIO = 0.05
=======
    # --- Hyperparameters ---
    # Width 4 strikes the best balance between exploring structural diversity
    # and computational cost for the exhaustive expansion step.
    BEAM_WIDTH = 4

    # SA Parameters
    # Reduced iterations to allow budget for the deterministic polish phase
    SA_ITERATIONS = 2500
    SA_COOLING_RATE = 0.998
    SA_START_TEMP_RATIO = 0.05
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Pre-calculation: Transaction Weights ---
    # Used for tie-breaking in Beam Search (prefer packing heavier txns for free)
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Density-Aware Beam Search ---
    # Initialize beam
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Score: minimize cost, then maximize weight (subtracted).
        # Factor 0.001 ensures it only breaks ties or near-ties.
        score = cost - (0.001 * txn_weights[t])
        candidates.append({
            'cost': cost,
            'score': score,
            'seq': seq,
            'rem': [x for x in range(workload.num_txns) if x != t]
        })

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    for _ in range(workload.num_txns - 1):
        next_candidates = []

        for node in beam:
            b_seq = node['seq']
            b_rem = node['rem']

            for cand in b_rem:
                new_seq = b_seq + [cand]
                new_cost = get_cost(new_seq)

                # Density-Aware Scoring
                # If new_cost is same as old, we packed 'cand' for free.
                # We prefer packing larger 'cand'.
                score = new_cost - (0.001 * txn_weights[cand])

                next_candidates.append((score, new_cost, new_seq, b_rem, cand))

        # Select best global candidates by score
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_score, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = list(c_parent_rem)
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
=======
    # --- Pre-calculation: Transaction Weights ---
    # Used for density-aware heuristics
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Adaptive Density-Aware Beam Search ---
    # Gamma decays from high (prioritizing parallelism) to low (minimizing makespan)
    GAMMA_START = 2.0
    GAMMA_END = 0.5

    # Initialize beam
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Initial score
        w = txn_weights[t]
        # At start, efficiency is max, gamma is max
        score = cost - (GAMMA_START * w)
        candidates.append({
            'cost': cost,
            'score': score,
            'seq': seq,
            'rem': [x for x in range(workload.num_txns) if x != t]
        })

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    total_txns = workload.num_txns

    for _ in range(total_txns - 1):
        next_candidates = []

        # Calculate dynamic gamma based on schedule completeness
        current_len = len(beam[0]['seq'])
        progress = current_len / total_txns
        gamma = GAMMA_START * (1.0 - progress) + GAMMA_END * progress

        for node in beam:
            b_seq = node['seq']
            b_rem = node['rem']
            b_cost = node['cost']

            for cand in b_rem:
                new_seq = b_seq + [cand]
                new_cost = get_cost(new_seq)

                delta = new_cost - b_cost
                w = txn_weights[cand]

                # Efficiency Bonus:
                # If delta < w, we found a slot where the cost increase is less than the txn length
                # This implies some parallelism.
                efficiency = 0.0
                if delta < w:
                    efficiency = (w - delta) / w

                # Score = Cost - (Gamma * Efficiency * Weight)
                # Maximize the efficiency-weighted transaction size packed
                score = new_cost - (gamma * efficiency * w)

                next_candidates.append((score, new_cost, new_seq, b_rem, cand))

        # Select best global candidates by score
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_score, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = list(c_parent_rem)
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
>>>>>>> REPLACE
<<<<<<< SEARCH
        # 4. Cooling
        T *= SA_COOLING_RATE

    return best_cost, best_schedule
=======
        # 4. Cooling
        T *= SA_COOLING_RATE

    # --- Phase 3: Deterministic Polish ---
    # Iterative Best-Insertion pass to refine the final schedule
    # We perform one full pass: remove each transaction and re-insert at best position
    polish_seq = list(best_schedule)
    current_polish_cost = best_cost
    improved = False

    # Strategy: Iterate indices 0 to N-1.
    for i in range(len(polish_seq)):
        # Remove item at i
        item = polish_seq.pop(i)

        best_pos = -1
        min_c = float('inf')

        # Scan all valid positions for this item
        for j in range(len(polish_seq) + 1):
            polish_seq.insert(j, item)
            c = get_cost(polish_seq)
            if c < min_c:
                min_c = c
                best_pos = j
            polish_seq.pop(j)

        # Insert at best position
        polish_seq.insert(best_pos, item)
        current_polish_cost = min_c

    if current_polish_cost < best_cost:
        best_cost = current_polish_cost
        best_schedule = polish_seq

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>