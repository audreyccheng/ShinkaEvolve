<NAME>
implement_ils_ruin_recreate
</NAME>

<DESCRIPTION>
Replaces the single-pass Simulated Annealing refinement phase with an Iterated Local Search (ILS) strategy featuring a "Ruin and Recreate" perturbation.
1. The algorithm performs multiple cycles of perturbation followed by local search.
2. **Perturbation (Ruin & Recreate):** Removes a contiguous block of transactions (breaking local dependencies) and re-inserts them one by one using a Greedy Best-Fit strategy. This helps escape local optima that simple swaps cannot resolve.
3. **Local Search:** A short burst of Simulated Annealing is applied after reconstruction to polish the schedule and resolve minor conflicts.
4. **Restart Strategy:** Periodically reverts to the best-found schedule to intensify the search around the most promising solutions.
This approach is more effective for dependency-heavy scheduling than pure SA or Beam Search alone.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 2. Refinement Phase: SA with Block Moves ---

    MAX_ITER = 750 # Slightly increased iterations
    INITIAL_TEMP = max(1.0, current_cost * 0.05)
    COOLING_RATE = 0.99

    best_schedule = list(current_schedule)
    best_cost = current_cost

    temp = INITIAL_TEMP

    for i in range(MAX_ITER):
        neighbor = list(current_schedule)
        r = random.random()

        # Dynamic Operator Selection with Bias to target schedule tail
        if r < 0.25:
            # Standard Swap
            idx1, idx2 = random.sample(range(num_txns), 2)
            neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
        elif r < 0.50:
            # Biased Insert: Move from second half to anywhere (Targeting Tail)
            idx1 = random.randint(num_txns // 2, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        elif r < 0.75:
            # Standard Insert
            idx1 = random.randint(0, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        else:
            # Block Move: Move a contiguous chunk
            if num_txns > 4:
                # Slightly larger blocks allowed
                block_size = random.randint(2, max(3, num_txns // 6))
                start_idx = random.randint(0, num_txns - block_size)

                # Extract block
                block = neighbor[start_idx : start_idx + block_size]
                del neighbor[start_idx : start_idx + block_size]

                # Insert block
                insert_idx = random.randint(0, len(neighbor))
                neighbor[insert_idx:insert_idx] = block
            else:
                # Fallback for very small workloads
                idx1, idx2 = random.sample(range(num_txns), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]

        # Evaluate neighbor
        neighbor_cost = workload.get_opt_seq_cost(neighbor)
        delta = neighbor_cost - current_cost

        accept = False
        if delta < 0:
            accept = True
        elif temp > 0.001:
            prob = math.exp(-delta / temp)
            if random.random() < prob:
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = neighbor_cost
            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)

        temp *= COOLING_RATE
        if temp < 0.001:
            break

    return best_cost, best_schedule
=======
    # --- 2. Refinement Phase: Iterated Local Search (ILS) ---
    # Replaces simple SA with a Ruin-and-Recreate strategy + Local Search

    # Configuration
    ILS_CYCLES = 5  # Number of ruin-recreate loops
    SA_STEPS = 120  # Steps of local search after recreation

    best_schedule = list(current_schedule)
    best_cost = current_cost

    # We maintain current_schedule as the working solution

    for cycle in range(ILS_CYCLES):
        # A. Perturbation: Ruin and Recreate (Skip first cycle to purely optimize beam result)
        if cycle > 0:
            # Ruin: Remove a contiguous block
            # Size: 10% to 20% of transactions
            block_size = random.randint(max(2, int(num_txns * 0.1)), max(3, int(num_txns * 0.2)))
            start_idx = random.randint(0, num_txns - block_size)

            # Extract transactions to re-insert
            removed_txns = current_schedule[start_idx : start_idx + block_size]
            del current_schedule[start_idx : start_idx + block_size]

            # Shuffle to avoid bias
            random.shuffle(removed_txns)

            # Recreate: Greedy Best-Fit Insertion
            # For each txn, find best position in current partial schedule
            for txn in removed_txns:
                best_pos = -1
                best_incr_cost = float('inf')

                # Try all valid positions
                # Optimization: We know removing a txn generally reduces/keeps cost,
                # adding it increases. We want min increase.
                for pos in range(len(current_schedule) + 1):
                    current_schedule.insert(pos, txn)
                    cost = workload.get_opt_seq_cost(current_schedule)
                    if cost < best_incr_cost:
                        best_incr_cost = cost
                        best_pos = pos
                    del current_schedule[pos]

                # Commit best insert
                current_schedule.insert(best_pos, txn)

            current_cost = workload.get_opt_seq_cost(current_schedule)

            # Update best if this greedy step found a better global solution (unlikely but possible)
            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)

        # B. Local Search: Simulated Annealing
        # Short burst of SA to fix local suboptimal orderings after insertion
        temp = max(1.0, current_cost * 0.03)
        cooling = 0.96

        for _ in range(SA_STEPS):
            neighbor = list(current_schedule)
            r = random.random()

            # Operators
            if r < 0.3: # Swap
                i, j = random.sample(range(num_txns), 2)
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            elif r < 0.7: # Insert (Shift)
                i = random.randint(0, num_txns - 1)
                val = neighbor.pop(i)
                j = random.randint(0, num_txns - 1)
                neighbor.insert(j, val)
            else: # Block Reorder (Reverse small chunk)
                bs = random.randint(2, 6)
                if num_txns > bs:
                    si = random.randint(0, num_txns - bs)
                    neighbor[si:si+bs] = reversed(neighbor[si:si+bs])

            # Evaluation
            n_cost = workload.get_opt_seq_cost(neighbor)
            delta = n_cost - current_cost

            accept = False
            if delta < 0:
                accept = True
            elif temp > 0.001 and random.random() < math.exp(-delta / temp):
                accept = True

            if accept:
                current_schedule = neighbor
                current_cost = n_cost
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_schedule = list(current_schedule)

            temp *= cooling

        # C. Acceptance / Restart Strategy for next cycle
        # If we drifted too far from best, restart from best with some probability
        # This intensifies search around the global optimum
        if current_cost > best_cost:
            # 60% chance to revert to best, 40% chance to explore from current
            if random.random() < 0.6:
                current_schedule = list(best_schedule)
                current_cost = best_cost

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>