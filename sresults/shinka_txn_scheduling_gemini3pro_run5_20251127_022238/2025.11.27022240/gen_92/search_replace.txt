<NAME>
optimize_beam_and_polish
</NAME>

<DESCRIPTION>
1.  **Phase 1 (Beam Search):** Increase `GAMMA_START` from 4.0 to 6.0. This change increases the bias towards parallel execution ("hiding" latency) in the early stages of the beam search. A higher initial gamma encourages the construction of a highly parallel "skeleton" for the schedule, which is crucial for minimizing makespan.
2.  **Phase 3 (Polish):** Replace the "Alternating Polish" (LPT/SPT interleaved) with a **Sequential Polish** strategy. We first run the LPT (Longest Processing Time) polish to convergence (or max 15 passes) to optimally place the large, structure-defining transactions ("Big Rocks"). Once the main structure is stabilized, we run the SPT (Shortest Processing Time) polish (max 5 passes) to fill remaining gaps with smaller transactions ("Sand"). This two-stage approach prevents small items from disrupting the optimal placement of large items and mimics a robust packing strategy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 1: Efficiency-Squared Beam Search ---
    # Heuristic: Score = Cost - Gamma * Weight * (Efficiency^2)
    # Encourages "hiding" transactions in parallel slots.
    GAMMA_START = 4.0
    GAMMA_END = 1.0

    candidates = []
=======
    # --- Phase 1: Efficiency-Squared Beam Search ---
    # Heuristic: Score = Cost - Gamma * Weight * (Efficiency^2)
    # Encourages "hiding" transactions in parallel slots.
    GAMMA_START = 6.0
    GAMMA_END = 1.0

    candidates = []
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Phase 3: Alternating Polish (LPT/SPT) ---
    # Alternate between optimizing large items (LPT) and small filling items (SPT).
    txns_lpt = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)
    txns_spt = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=False)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    MAX_PASSES = 20
    for pass_idx in range(MAX_PASSES):
        search_active = False

        # Alternate sorting order
        current_order = txns_lpt if pass_idx % 2 == 0 else txns_spt

        for item in current_order:
            try:
                curr_idx = polish_seq.index(item)
            except ValueError:
                continue

            polish_seq.pop(curr_idx)
            best_pos = -1
            min_c = float('inf')

            # Exhaustive scan.
            # Strict inequality (<) favors earlier positions for equal cost (Left-Packing)
            for j in range(len(polish_seq) + 1):
                polish_seq.insert(j, item)
                c = get_cost(polish_seq)
                if c < min_c:
                    min_c = c
                    best_pos = j
                polish_seq.pop(j)

            polish_seq.insert(best_pos, item)

            if min_c < current_polish_cost:
                current_polish_cost = min_c
                search_active = True
            elif min_c == current_polish_cost and best_pos != curr_idx:
                # Structural change helps escape plateaus
                search_active = True

        if current_polish_cost < best_cost:
            best_cost = current_polish_cost
            best_schedule = list(polish_seq)

        if not search_active:
            break

    return best_cost, best_schedule
=======
    # --- Phase 3: Sequential Polish (Big Rocks then Sand) ---
    # 1. LPT Polish: Stabilize large items ("Big Rocks")
    # 2. SPT Polish: Fill gaps with small items ("Sand")
    txns_lpt = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)
    txns_spt = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=False)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    # Strategy configuration: (Ordering, Max Passes)
    # We give LPT more time to converge as it defines the structure.
    polish_phases = [
        (txns_lpt, 15),
        (txns_spt, 5)
    ]

    for current_order, max_pass in polish_phases:
        for _ in range(max_pass):
            search_active = False

            for item in current_order:
                try:
                    curr_idx = polish_seq.index(item)
                except ValueError:
                    continue

                polish_seq.pop(curr_idx)
                best_pos = -1
                min_c = float('inf')

                # Exhaustive scan.
                # Strict inequality (<) favors earlier positions for equal cost (Left-Packing)
                for j in range(len(polish_seq) + 1):
                    polish_seq.insert(j, item)
                    c = get_cost(polish_seq)
                    if c < min_c:
                        min_c = c
                        best_pos = j
                    polish_seq.pop(j)

                polish_seq.insert(best_pos, item)

                if min_c < current_polish_cost:
                    current_polish_cost = min_c
                    search_active = True
                elif min_c == current_polish_cost and best_pos != curr_idx:
                    # Structural change helps escape plateaus
                    search_active = True

            if current_polish_cost < best_cost:
                best_cost = current_polish_cost
                best_schedule = list(polish_seq)

            if not search_active:
                break

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>