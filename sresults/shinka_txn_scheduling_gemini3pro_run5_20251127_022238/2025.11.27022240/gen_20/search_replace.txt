<NAME>
ils_greedy_repair
</NAME>

<DESCRIPTION>
Replace the single-pass Adaptive Simulated Annealing with an Iterated Local Search (ILS) framework.
The ILS alternates between:
1. Short bursts of Adaptive Simulated Annealing (to refine local order).
2. A "Destruction and Greedy Repair" perturbation. This removes a block of transactions and re-inserts them one-by-one into their optimal positions (Greedy Best-Fit). This allows the algorithm to make structural changes that satisfy dependencies better than random swaps.
This approach leverages the "greedy" property (good for makespan) within the local search phase.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 2: Adaptive Simulated Annealing ---
    best_schedule = list(current_schedule)
    best_cost = current_cost

    T = current_cost * SA_START_TEMP_RATIO

    # Operations list
    ops = list(OP_WEIGHTS.keys())

    for it in range(SA_ITERATIONS):
        # 1. Select Operator based on weights
        total_weight = sum(OP_WEIGHTS.values())
        r = random.uniform(0, total_weight)
        cumulative = 0
        selected_op = ops[-1]
        for op in ops:
            cumulative += OP_WEIGHTS[op]
            if r <= cumulative:
                selected_op = op
                break

        # 2. Generate Neighbor
        neighbor = list(current_schedule)
        n = len(neighbor)

        if selected_op == 'swap':
            i, j = random.sample(range(n), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

        elif selected_op == 'insert':
            i = random.randint(0, n - 1)
            val = neighbor.pop(i)
            j = random.randint(0, n - 1)
            neighbor.insert(j, val)

        elif selected_op == 'block':
            # Move block of random size (2 to 10% of length)
            b_size = random.randint(2, max(3, int(n * 0.10)))
            if n > b_size:
                i = random.randint(0, n - b_size)
                block = neighbor[i : i+b_size]
                del neighbor[i : i+b_size]
                j = random.randint(0, len(neighbor))
                neighbor[j:j] = block

        elif selected_op == 'reverse':
            i, j = sorted(random.sample(range(n), 2))
            neighbor[i:j+1] = neighbor[i:j+1][::-1]

        new_cost = get_cost(neighbor)
        delta = new_cost - current_cost

        # 3. Acceptance Criteria
        accept = False
        improved = False

        if delta < 0:
            accept = True
            if new_cost < best_cost:
                improved = True
                best_cost = new_cost
                best_schedule = list(neighbor)
        elif T > 1e-9:
            if random.random() < math.exp(-delta / T):
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = new_cost

        # 4. Adapt Weights
        reward = 0.0
        if improved:
            reward = 3.0 # Strong reward for global improvement
        elif accept and delta < 0:
            reward = 1.0 # Reward for local improvement
        elif accept:
            reward = 0.1 # Small reward for finding acceptable moves (mobility)

        # Decay and update
        OP_WEIGHTS[selected_op] = (1 - OP_ADAPTATION_RATE) * OP_WEIGHTS[selected_op] + OP_ADAPTATION_RATE * (OP_MIN_WEIGHT + reward)

        # 5. Cooling & Reheating
        T *= SA_COOLING_RATE

        # Reheat if stuck at low temp
        if T < 0.005 and it < SA_ITERATIONS * 0.8:
            # Check if we are stagnant? (implicit in T dropping without much activity)
            # Just reheat to a fraction of initial temp
            T = current_cost * 0.01

    return best_cost, best_schedule
=======
    # --- Phase 2: Iterated Local Search (ILS) with Greedy Repair ---
    best_schedule = list(current_schedule)
    best_cost = current_cost

    # ILS Parameters
    ILS_ITERS = 20
    SA_ITERS_PER_ILS = 300
    REPAIR_BLOCK_SIZE_MIN = 3
    REPAIR_BLOCK_SIZE_MAX = 6

    # Helper to run Adaptive SA
    def run_adaptive_sa(start_schedule, start_cost, steps, start_temp):
        curr_s = list(start_schedule)
        curr_c = start_cost
        local_best_s = list(curr_s)
        local_best_c = curr_c

        ops = list(OP_WEIGHTS.keys())
        T = start_temp

        for _ in range(steps):
            # Select Operator
            total_weight = sum(OP_WEIGHTS.values())
            r = random.uniform(0, total_weight)
            cumulative = 0
            selected_op = ops[-1]
            for op in ops:
                cumulative += OP_WEIGHTS[op]
                if r <= cumulative:
                    selected_op = op
                    break

            neighbor = list(curr_s)
            n = len(neighbor)

            if selected_op == 'swap':
                i, j = random.sample(range(n), 2)
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            elif selected_op == 'insert':
                i = random.randint(0, n - 1)
                val = neighbor.pop(i)
                j = random.randint(0, n - 1)
                neighbor.insert(j, val)
            elif selected_op == 'block':
                b_size = random.randint(2, max(3, int(n * 0.10)))
                if n > b_size:
                    i = random.randint(0, n - b_size)
                    block = neighbor[i : i+b_size]
                    del neighbor[i : i+b_size]
                    j = random.randint(0, len(neighbor))
                    neighbor[j:j] = block
            elif selected_op == 'reverse':
                i, j = sorted(random.sample(range(n), 2))
                neighbor[i:j+1] = neighbor[i:j+1][::-1]

            new_c = get_cost(neighbor)
            delta = new_c - curr_c

            accept = False
            if delta < 0:
                accept = True
            elif T > 1e-9:
                if random.random() < math.exp(-delta / T):
                    accept = True

            if accept:
                curr_s = neighbor
                curr_c = new_c
                if curr_c < local_best_c:
                    local_best_c = curr_c
                    local_best_s = list(curr_s)

                # Update weights
                reward = 1.0 if delta < 0 else 0.1
                OP_WEIGHTS[selected_op] = (1 - OP_ADAPTATION_RATE) * OP_WEIGHTS[selected_op] + OP_ADAPTATION_RATE * (OP_MIN_WEIGHT + reward)

            T *= SA_COOLING_RATE

        return local_best_c, local_best_s

    # ILS Loop
    temp_base = current_cost * SA_START_TEMP_RATIO

    for loop in range(ILS_ITERS):
        # 1. Local Search (Adaptive SA)
        sa_cost, sa_schedule = run_adaptive_sa(current_schedule, current_cost, SA_ITERS_PER_ILS, temp_base)

        # Update global best
        if sa_cost < best_cost:
            best_cost = sa_cost
            best_schedule = list(sa_schedule)

        # 2. Perturbation: Greedy Block Repair
        pert_schedule = list(sa_schedule)
        n = len(pert_schedule)

        b_size = random.randint(REPAIR_BLOCK_SIZE_MIN, REPAIR_BLOCK_SIZE_MAX)
        if n > b_size:
            start_idx = random.randint(0, n - b_size)
            removed_block = pert_schedule[start_idx : start_idx + b_size]
            del pert_schedule[start_idx : start_idx + b_size]

            # Greedy Re-insertion
            for item in removed_block:
                best_insert_idx = -1
                best_insert_cost = float('inf')

                # Scan all valid positions
                for i in range(len(pert_schedule) + 1):
                    cand = pert_schedule[:i] + [item] + pert_schedule[i:]
                    c = get_cost(cand)
                    if c < best_insert_cost:
                        best_insert_cost = c
                        best_insert_idx = i

                pert_schedule.insert(best_insert_idx, item)

            pert_cost = best_insert_cost

            # 3. Acceptance of Perturbation
            delta = pert_cost - sa_cost
            accept_pert = False

            T_ils = best_cost * 0.02

            if delta < 0:
                accept_pert = True
                if pert_cost < best_cost:
                    best_cost = pert_cost
                    best_schedule = list(pert_schedule)
            elif random.random() < math.exp(-delta / T_ils):
                accept_pert = True

            if accept_pert:
                current_schedule = pert_schedule
                current_cost = pert_cost
            else:
                # Revert to SA result to explore other perturbations
                current_schedule = sa_schedule
                current_cost = sa_cost

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>