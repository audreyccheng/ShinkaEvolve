<NAME>
increase_beam_width
</NAME>

<DESCRIPTION>
Increase BEAM_WIDTH from 4 to 6. Previous results indicate that a wider beam (6) provides significantly better structural diversity for the initial schedule construction, which benefits the subsequent optimization phases (SA and Polish).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Hyperparameters ---
    # Width 4 strikes a balance between quality and runtime
    BEAM_WIDTH = 4
=======
    # --- Hyperparameters ---
    # Width 6 provides good structural coverage without excessive cost
    BEAM_WIDTH = 6
>>>>>>> REPLACE
</DIFF>

<NAME>
add_lpt_polish_phase
</NAME>

<DESCRIPTION>
Add a deterministic "Polish" phase after the Simulated Annealing loop.
This phase iterates through transactions sorted by weight (LPT - Longest Processing Time) and optimally re-inserts them into the schedule.
This approach helps repair structural defects in the schedule that stochastic methods like SA might miss or be too slow to fix.
We perform multiple passes (up to 10) to ensure the schedule converges to a local minimum.
We use strict inequality when searching for the best position (`c < min_c`) combined with a forward scan (0 to N) to implicitly favor "left-packing" (earliest best position), which tends to reduce gaps.
Sideways moves (changing position with equal cost) are applied during the pass, which facilitates escaping local optima, but the loop continues only if strict makespan reduction is observed.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 4. Cooling
        T *= SA_COOLING_RATE

    return best_cost, best_schedule
=======
        # 4. Cooling
        T *= SA_COOLING_RATE

    # --- PHASE 3: Deterministic Polish (LPT Ordered) ---
    # Sort transactions by weight descending (Longest Processing Time)
    # Re-inserting heavy items optimally often fixes structural issues
    sorted_txns = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    # Run multiple passes to allow schedule to settle
    # We allow sideways moves during the pass (implicit in re-insertion) but require strict improvement to continue
    MAX_PASSES = 10
    for pass_idx in range(MAX_PASSES):
        improved_in_pass = False

        for item in sorted_txns:
            # Find current position and remove
            try:
                curr_idx = polish_seq.index(item)
            except ValueError:
                continue

            polish_seq.pop(curr_idx)

            best_pos = -1
            min_c = float('inf')

            # Exhaustive scan for best position
            # Forward scan + strict inequality (<) => Left-Packing Bias for ties
            for j in range(len(polish_seq) + 1):
                polish_seq.insert(j, item)
                c = get_cost(polish_seq)
                if c < min_c:
                    min_c = c
                    best_pos = j
                polish_seq.pop(j)

            # Insert at best position
            polish_seq.insert(best_pos, item)

            # Check for strict improvement
            if min_c < current_polish_cost:
                current_polish_cost = min_c
                improved_in_pass = True

        if current_polish_cost < best_cost:
            best_cost = current_polish_cost
            best_schedule = list(polish_seq)

        if not improved_in_pass:
            break

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>