<NAME>
optimize_beam_and_ruin
</NAME>

<DESCRIPTION>
1.  **Weighted Beam Search**: Introduce transaction weights based on standalone costs. Update the Beam Search scoring function to use these weights as a tie-breaker. This prioritizes packing "heavier" (more complex) transactions into the schedule when the makespan increase is identical (e.g., zero-cost parallelism), leading to better structural foundations.
2.  **Multi-Segment Ruin**: Enhance the Stagnation Recovery mechanism to remove two disjoint blocks of transactions instead of one. This allows the subsequent Greedy Re-insertion to effectively "teleport" transactions or swap entire dependency chains across the schedule, providing a stronger escape from local optima than single-block moves.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Cost Cache ---
    cost_cache = {}

    def get_cost(seq):
        t_seq = tuple(seq)
        if t_seq in cost_cache:
            return cost_cache[t_seq]
        c = workload.get_opt_seq_cost(seq)
        cost_cache[t_seq] = c
        return c

    # --- Phase 1: Exhaustive Beam Search Construction ---
    # Initialize beam
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Store rem as set for O(1) removal, though copying takes time.
        # Beam is small, so list operations are fine. Using set for clarity in logic.
        candidates.append({'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})

    candidates.sort(key=lambda x: x['cost'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    for _ in range(workload.num_txns - 1):
        next_candidates = []

        for node in beam:
            p_seq = node['seq']
            p_rem = node['rem']

            # Exhaustive expansion
            for cand in p_rem:
                new_seq = p_seq + [cand]
                new_cost = get_cost(new_seq)
                next_candidates.append((new_cost, new_seq, p_rem, cand))

        # Sort by cost to keep best
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
=======
    # --- Cost Cache ---
    cost_cache = {}

    def get_cost(seq):
        t_seq = tuple(seq)
        if t_seq in cost_cache:
            return cost_cache[t_seq]
        c = workload.get_opt_seq_cost(seq)
        cost_cache[t_seq] = c
        return c

    # --- Pre-calculation: Transaction Weights ---
    # Used for tie-breaking in Beam Search (prefer packing heavier txns first)
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Exhaustive Beam Search Construction ---
    # Initialize beam
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Score minimizes cost, then maximizes weight (subtracted)
        score = cost - (1e-5 * txn_weights[t])
        candidates.append({'score': score, 'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    for _ in range(workload.num_txns - 1):
        next_candidates = []

        for node in beam:
            p_seq = node['seq']
            p_rem = node['rem']

            # Exhaustive expansion
            for cand in p_rem:
                new_seq = p_seq + [cand]
                new_cost = get_cost(new_seq)

                # Tie-breaker: prefer heavier transactions if makespan is similar
                # This prioritizes packing "large rocks" into zero-cost slots
                score = new_cost - (1e-5 * txn_weights[cand])

                next_candidates.append((score, new_cost, new_seq, p_rem, cand))

        # Sort by score to keep best
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for _, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'score': _, 'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
>>>>>>> REPLACE
<<<<<<< SEARCH
        # 1. Stagnation Check -> Ruin-and-Recreate (Kick)
        if steps_since_imp > STAGNATION_LIMIT:
            # Perform Kick: Remove random block and greedy re-insert
            kick_seq = list(best_schedule) # Intensify around best found
            n = len(kick_seq)

            b_size = random.randint(KICK_BLOCK_SIZE_MIN, KICK_BLOCK_SIZE_MAX)
            if n > b_size:
                start = random.randint(0, n - b_size)
                removed_block = kick_seq[start : start + b_size]
                del kick_seq[start : start + b_size]

                # Greedy Best-Fit Insertion for each item in the block
                for item in removed_block:
                    best_pos = -1
                    min_c = float('inf')

                    # Try all positions
                    for i in range(len(kick_seq) + 1):
                        kick_seq.insert(i, item)
                        c = get_cost(kick_seq)
                        if c < min_c:
                            min_c = c
                            best_pos = i
                        kick_seq.pop(i)

                    kick_seq.insert(best_pos, item)

                # Update current state to the result of the kick
                current_schedule = kick_seq
                current_cost = min_c

                if current_cost < best_cost:
                    best_cost = current_cost
                    best_schedule = list(current_schedule)
                    steps_since_imp = 0
                else:
                    # Reset counter to give the new state a chance
                    steps_since_imp = 0

                # Reheat temperature slightly to allow local settling
                T = max(T, current_cost * 0.02)
                continue
=======
        # 1. Stagnation Check -> Ruin-and-Recreate (Kick)
        if steps_since_imp > STAGNATION_LIMIT:
            # Perform Kick: Multi-Segment Ruin
            kick_seq = list(best_schedule) # Intensify around best found
            removed_items = []

            # Remove 2 disjoint blocks to allow teleporting transactions across the schedule
            for _ in range(2):
                n_curr = len(kick_seq)
                if n_curr > KICK_BLOCK_SIZE_MIN:
                    b_size = random.randint(KICK_BLOCK_SIZE_MIN, min(n_curr, KICK_BLOCK_SIZE_MAX))
                    if n_curr > b_size:
                        start = random.randint(0, n_curr - b_size)
                        removed_items.extend(kick_seq[start : start + b_size])
                        del kick_seq[start : start + b_size]

            # Shuffle removed items to avoid bias from original order
            random.shuffle(removed_items)

            # Greedy Best-Fit Insertion for each removed item
            for item in removed_items:
                best_pos = -1
                min_c = float('inf')

                # Try all positions in the partial schedule
                for i in range(len(kick_seq) + 1):
                    kick_seq.insert(i, item)
                    c = get_cost(kick_seq)
                    if c < min_c:
                        min_c = c
                        best_pos = i
                    kick_seq.pop(i)

                kick_seq.insert(best_pos, item)

            # Update current state to the result of the kick
            current_schedule = kick_seq
            current_cost = min_c

            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)
                steps_since_imp = 0
            else:
                # Reset counter to give the new state a chance
                steps_since_imp = 0

            # Reheat temperature slightly to allow local settling
            T = max(T, current_cost * 0.02)
            continue
>>>>>>> REPLACE
</DIFF>