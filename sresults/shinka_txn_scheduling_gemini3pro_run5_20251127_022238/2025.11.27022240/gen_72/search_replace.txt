<NAME>
deterministic_lpt_polish
</NAME>

<DESCRIPTION>
Introduces a deterministic "Polish" phase at the end of the scheduling process (Phase 3). This phase iterates through transactions sorted by weight (Longest Processing Time first) and exhaustively finds the best insertion position for each, essentially performing a "Gap Repair". This helps settle the schedule into a deep local minimum. To afford the computational cost of this O(N^2) phase (checking all positions for all items multiple times), the SA phase iterations are reduced from 6000 to 4000 and the expensive 'best_insert' operator is removed from the SA loop. The Polish phase runs for up to 5 passes but exits early if no improvement is found.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Density-Aware Beam Search followed by
    Adaptive SA with Hybrid Ruin-and-Recreate and Greedy Local Search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Parameter affecting the computational budget

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # --- Hyperparameters ---
    # Width 6 provides good structural coverage without excessive cost
    BEAM_WIDTH = 6

    # SA Parameters
    SA_ITERATIONS = 6000
    SA_COOLING_RATE = 0.9985
    SA_START_TEMP_RATIO = 0.05

    # Ruin-and-Recreate Parameters
    STAGNATION_LIMIT = 200 # Aggressive restart to escape local optima
    RUIN_BLOCK_SIZE_MIN = 2
    RUIN_BLOCK_SIZE_MAX = 6

    # Adaptive Operator Weights
    # 'best_insert' is expensive but effective for fine-tuning
    OP_WEIGHTS = {
        'swap': 2.0,
        'insert': 8.0,
        'block_move': 4.0,
        'reverse': 1.0,
        'best_insert': 0.5
    }
    OP_MIN_WEIGHT = 0.5
    OP_ADAPTATION_RATE = 0.1

    # --- Cost Cache ---
    cost_cache = {}

    def get_cost(seq):
        t_seq = tuple(seq)
        if t_seq in cost_cache:
            return cost_cache[t_seq]
        c = workload.get_opt_seq_cost(seq)
        cost_cache[t_seq] = c
        return c

    # --- Pre-calculation: Transaction Weights ---
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Density-Aware Beam Search ---
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Score heuristic: Cost minus small weight factor to prefer packing heavier txns
        score = cost - (0.002 * txn_weights[t])
        candidates.append({'score': score, 'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    for _ in range(workload.num_txns - 1):
        next_candidates = []
        for node in beam:
            b_seq = node['seq']
            b_rem = node['rem']

            for cand in b_rem:
                new_seq = b_seq + [cand]
                new_cost = get_cost(new_seq)

                # Heuristic: Prefer lower cost, break ties with heavier transaction
                score = new_cost - (0.002 * txn_weights[cand])
                next_candidates.append((score, new_cost, new_seq, b_rem, cand))

        # Greedy pruning
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_score, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam

    if not beam:
        return float('inf'), []

    current_schedule = beam[0]['seq']
    current_cost = beam[0]['cost']

    # --- Phase 2: Adaptive SA with Hybrid Ruin-and-Recreate ---
    best_schedule = list(current_schedule)
    best_cost = current_cost

    T = current_cost * SA_START_TEMP_RATIO
    ops = list(OP_WEIGHTS.keys())
    steps_since_imp = 0

    for it in range(SA_ITERATIONS):
        # 1. Ruin-and-Recreate (Kick) on Stagnation
        if steps_since_imp > STAGNATION_LIMIT:
            kick_seq = list(best_schedule)
            n = len(kick_seq)
            removed_items = []

            # Hybrid Ruin Strategy:
            # 50%: Multi-Segment Ruin (from Inspiration) - good for shuffling blocks
            # 50%: Scatter Ruin (from Current) - good for breaking global dependencies
            strategy = random.random()

            if strategy < 0.5:
                # Multi-Segment (2 blocks)
                for _ in range(2):
                    if len(kick_seq) > RUIN_BLOCK_SIZE_MIN:
                        sz = random.randint(RUIN_BLOCK_SIZE_MIN, min(len(kick_seq), RUIN_BLOCK_SIZE_MAX))
                        start = random.randint(0, len(kick_seq) - sz)
                        removed_items.extend(kick_seq[start : start+sz])
                        del kick_seq[start : start+sz]
            else:
                # Scatter Ruin
                if n > RUIN_BLOCK_SIZE_MIN:
                    num_to_remove = random.randint(3, 8)
                    indices = sorted(random.sample(range(n), num_to_remove), reverse=True)
                    for idx in indices:
                        removed_items.append(kick_seq.pop(idx))

            # Recreate: Greedy Best-Fit
            random.shuffle(removed_items)

            for item in removed_items:
                best_pos = -1
                min_c = float('inf')

                # Try all positions
                for i in range(len(kick_seq) + 1):
                    kick_seq.insert(i, item)
                    c = get_cost(kick_seq)
                    if c < min_c:
                        min_c = c
                        best_pos = i
                    kick_seq.pop(i)

                kick_seq.insert(best_pos, item)

            current_schedule = kick_seq
            current_cost = min_c

            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)
                steps_since_imp = 0
            else:
                steps_since_imp = 0

            T = max(T, current_cost * 0.05)
            continue

        # 2. Operator Selection
        total_w = sum(OP_WEIGHTS.values())
        r = random.uniform(0, total_w)
        cum = 0
        op = ops[0]
        for o in ops:
            cum += OP_WEIGHTS[o]
            if r <= cum:
                op = o
                break

        neighbor = list(current_schedule)
        n = len(neighbor)

        if op == 'swap':
            i, j = random.sample(range(n), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
        elif op == 'insert':
            i = random.randint(0, n - 1)
            val = neighbor.pop(i)
            j = random.randint(0, n - 1)
            neighbor.insert(j, val)
        elif op == 'reverse':
            i, j = sorted(random.sample(range(n), 2))
            neighbor[i:j+1] = neighbor[i:j+1][::-1]
        elif op == 'block_move':
            b_size = random.randint(2, 6)
            if n > b_size:
                i = random.randint(0, n - b_size)
                block = neighbor[i:i+b_size]
                del neighbor[i:i+b_size]
                j = random.randint(0, len(neighbor))
                neighbor[j:j] = block
        elif op == 'best_insert':
            # Expensive greedy insert of a random element
            idx = random.randint(0, n - 1)
            val = neighbor.pop(idx)
            best_pos = -1
            min_c = float('inf')

            # Exhaustive check of insertion points
            for i in range(len(neighbor) + 1):
                neighbor.insert(i, val)
                c = get_cost(neighbor)
                if c < min_c:
                    min_c = c
                    best_pos = i
                neighbor.pop(i)
            neighbor.insert(best_pos, val)

        new_cost = get_cost(neighbor)
        delta = new_cost - current_cost

        # 3. Acceptance
        accept = False
        if delta < 0:
            accept = True
            if new_cost < best_cost:
                best_cost = new_cost
                best_schedule = list(neighbor)
                steps_since_imp = 0
            else:
                steps_since_imp += 1
        else:
            steps_since_imp += 1
            if T > 1e-9 and random.random() < math.exp(-delta / T):
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = new_cost

        # 4. Adapt Weights
        reward = 0.1
        if delta < 0:
            reward = 1.0 if new_cost >= best_cost else 2.0

        OP_WEIGHTS[op] = (1 - OP_ADAPTATION_RATE) * OP_WEIGHTS[op] + OP_ADAPTATION_RATE * (OP_MIN_WEIGHT + reward)

        # 5. Cooling
        T *= SA_COOLING_RATE

    return best_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Density-Aware Beam Search followed by
    Adaptive SA with Hybrid Ruin-and-Recreate and Deterministic Polish.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Parameter affecting the computational budget

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # --- Hyperparameters ---
    # Width 6 provides good structural coverage without excessive cost
    BEAM_WIDTH = 6

    # SA Parameters
    # Reduced iterations to allow budget for the deterministic polish phase
    SA_ITERATIONS = 4000
    SA_COOLING_RATE = 0.9985
    SA_START_TEMP_RATIO = 0.05

    # Ruin-and-Recreate Parameters
    STAGNATION_LIMIT = 200 # Aggressive restart to escape local optima
    RUIN_BLOCK_SIZE_MIN = 2
    RUIN_BLOCK_SIZE_MAX = 6

    # Adaptive Operator Weights
    # Removed 'best_insert' to save time for the final polish phase
    OP_WEIGHTS = {
        'swap': 2.0,
        'insert': 8.0,
        'block_move': 4.0,
        'reverse': 1.0
    }
    OP_MIN_WEIGHT = 0.5
    OP_ADAPTATION_RATE = 0.1

    # --- Cost Cache ---
    cost_cache = {}

    def get_cost(seq):
        t_seq = tuple(seq)
        if t_seq in cost_cache:
            return cost_cache[t_seq]
        c = workload.get_opt_seq_cost(seq)
        cost_cache[t_seq] = c
        return c

    # --- Pre-calculation: Transaction Weights ---
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Density-Aware Beam Search ---
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Score heuristic: Cost minus small weight factor to prefer packing heavier txns
        score = cost - (0.002 * txn_weights[t])
        candidates.append({'score': score, 'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    for _ in range(workload.num_txns - 1):
        next_candidates = []
        for node in beam:
            b_seq = node['seq']
            b_rem = node['rem']

            for cand in b_rem:
                new_seq = b_seq + [cand]
                new_cost = get_cost(new_seq)

                # Heuristic: Prefer lower cost, break ties with heavier transaction
                score = new_cost - (0.002 * txn_weights[cand])
                next_candidates.append((score, new_cost, new_seq, b_rem, cand))

        # Greedy pruning
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_score, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam

    if not beam:
        return float('inf'), []

    current_schedule = beam[0]['seq']
    current_cost = beam[0]['cost']

    # --- Phase 2: Adaptive SA with Hybrid Ruin-and-Recreate ---
    best_schedule = list(current_schedule)
    best_cost = current_cost

    T = current_cost * SA_START_TEMP_RATIO
    ops = list(OP_WEIGHTS.keys())
    steps_since_imp = 0

    for it in range(SA_ITERATIONS):
        # 1. Ruin-and-Recreate (Kick) on Stagnation
        if steps_since_imp > STAGNATION_LIMIT:
            kick_seq = list(best_schedule)
            n = len(kick_seq)
            removed_items = []

            # Hybrid Ruin Strategy:
            # 50%: Multi-Segment Ruin (from Inspiration) - good for shuffling blocks
            # 50%: Scatter Ruin (from Current) - good for breaking global dependencies
            strategy = random.random()

            if strategy < 0.5:
                # Multi-Segment (2 blocks)
                for _ in range(2):
                    if len(kick_seq) > RUIN_BLOCK_SIZE_MIN:
                        sz = random.randint(RUIN_BLOCK_SIZE_MIN, min(len(kick_seq), RUIN_BLOCK_SIZE_MAX))
                        start = random.randint(0, len(kick_seq) - sz)
                        removed_items.extend(kick_seq[start : start+sz])
                        del kick_seq[start : start+sz]
            else:
                # Scatter Ruin
                if n > RUIN_BLOCK_SIZE_MIN:
                    num_to_remove = random.randint(3, 8)
                    indices = sorted(random.sample(range(n), num_to_remove), reverse=True)
                    for idx in indices:
                        removed_items.append(kick_seq.pop(idx))

            # Recreate: Greedy Best-Fit
            random.shuffle(removed_items)

            for item in removed_items:
                best_pos = -1
                min_c = float('inf')

                # Try all positions
                for i in range(len(kick_seq) + 1):
                    kick_seq.insert(i, item)
                    c = get_cost(kick_seq)
                    if c < min_c:
                        min_c = c
                        best_pos = i
                    kick_seq.pop(i)

                kick_seq.insert(best_pos, item)

            current_schedule = kick_seq
            current_cost = min_c

            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)
                steps_since_imp = 0
            else:
                steps_since_imp = 0

            T = max(T, current_cost * 0.05)
            continue

        # 2. Operator Selection
        total_w = sum(OP_WEIGHTS.values())
        r = random.uniform(0, total_w)
        cum = 0
        op = ops[0]
        for o in ops:
            cum += OP_WEIGHTS[o]
            if r <= cum:
                op = o
                break

        neighbor = list(current_schedule)
        n = len(neighbor)

        if op == 'swap':
            i, j = random.sample(range(n), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
        elif op == 'insert':
            i = random.randint(0, n - 1)
            val = neighbor.pop(i)
            j = random.randint(0, n - 1)
            neighbor.insert(j, val)
        elif op == 'reverse':
            i, j = sorted(random.sample(range(n), 2))
            neighbor[i:j+1] = neighbor[i:j+1][::-1]
        elif op == 'block_move':
            b_size = random.randint(2, 6)
            if n > b_size:
                i = random.randint(0, n - b_size)
                block = neighbor[i:i+b_size]
                del neighbor[i:i+b_size]
                j = random.randint(0, len(neighbor))
                neighbor[j:j] = block

        new_cost = get_cost(neighbor)
        delta = new_cost - current_cost

        # 3. Acceptance
        accept = False
        if delta < 0:
            accept = True
            if new_cost < best_cost:
                best_cost = new_cost
                best_schedule = list(neighbor)
                steps_since_imp = 0
            else:
                steps_since_imp += 1
        else:
            steps_since_imp += 1
            if T > 1e-9 and random.random() < math.exp(-delta / T):
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = new_cost

        # 4. Adapt Weights
        reward = 0.1
        if delta < 0:
            reward = 1.0 if new_cost >= best_cost else 2.0

        OP_WEIGHTS[op] = (1 - OP_ADAPTATION_RATE) * OP_WEIGHTS[op] + OP_ADAPTATION_RATE * (OP_MIN_WEIGHT + reward)

        # 5. Cooling
        T *= SA_COOLING_RATE

    # --- Phase 3: Deterministic Polish (LPT Ordered) ---
    # Sort transactions by weight descending (Longest Processing Time)
    # This heuristic assumes harder-to-schedule items should be placed first/checked for optimization
    sorted_txns = sorted(range(workload.num_txns), key=lambda x: txn_weights[x], reverse=True)

    polish_seq = list(best_schedule)
    current_polish_cost = best_cost

    # Iterate a few passes to allow settling
    MAX_PASSES = 5
    for pass_idx in range(MAX_PASSES):
        improved_in_pass = False

        for item in sorted_txns:
            # Find current position and remove
            try:
                curr_idx = polish_seq.index(item)
            except ValueError:
                continue

            polish_seq.pop(curr_idx)

            best_pos = -1
            min_c = float('inf')

            # Exhaustive scan for best position
            for j in range(len(polish_seq) + 1):
                polish_seq.insert(j, item)
                c = get_cost(polish_seq)
                if c < min_c:
                    min_c = c
                    best_pos = j
                polish_seq.pop(j)

            # Insert at best position
            polish_seq.insert(best_pos, item)

            # Check improvement locally
            if min_c < current_polish_cost:
                current_polish_cost = min_c
                improved_in_pass = True

        if current_polish_cost < best_cost:
            best_cost = current_polish_cost
            best_schedule = list(polish_seq)

        if not improved_in_pass:
            break

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>