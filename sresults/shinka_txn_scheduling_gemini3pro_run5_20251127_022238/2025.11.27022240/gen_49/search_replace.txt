<NAME>
dynamic_beam_and_sorted_ruin
</NAME>
<DESCRIPTION>
1.  **Dynamic Density-Aware Beam Search**: Re-introduces transaction weights and uses a linearly decaying `gamma` factor in the scoring function. This prioritizes placing "heavy" (long/complex) transactions early in the schedule when parallelism opportunities are highest, transitioning to minimizing cost extension later.
2.  **Multi-Mode Ruin**: Adds a "Scatter" mode to the Ruin phase (50% probability), which removes random individual transactions instead of a contiguous block. This helps break dependency chains that block moves cannot.
3.  **Sorted Recreate**: During the Recreate phase, removed transactions are re-inserted in descending order of their weight (complexity). This heuristic ("Big Rocks First") improves packing efficiency by placing difficult items before smaller ones.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 1: Exhaustive Beam Search Construction ---
    # Initialize beam
    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Store rem as set for O(1) removal, though copying takes time.
        # Beam is small, so list operations are fine. Using set for clarity in logic.
        candidates.append({'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})

    candidates.sort(key=lambda x: x['cost'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    for _ in range(workload.num_txns - 1):
        next_candidates = []

        for node in beam:
            p_seq = node['seq']
            p_rem = node['rem']

            # Exhaustive expansion
            for cand in p_rem:
                new_seq = p_seq + [cand]
                new_cost = get_cost(new_seq)
                next_candidates.append((new_cost, new_seq, p_rem, cand))

        # Sort by cost to keep best
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
=======
    # --- Pre-calculation: Transaction Weights ---
    txn_weights = {}
    for t in range(workload.num_txns):
        txn_weights[t] = get_cost([t])

    # --- Phase 1: Density-Aware Beam Search Construction ---
    # Initialize beam
    candidates = []
    # Gamma: Heuristic weight for packing density. Decays linearly.
    # Start high to encourage parallel packing of heavy items early.
    GAMMA_START = 0.5

    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        # Score = Cost - (Gamma * Weight). Lower is better.
        score = cost - (GAMMA_START * txn_weights[t])
        candidates.append({
            'cost': cost,
            'score': score,
            'seq': seq,
            'rem': {x for x in range(workload.num_txns) if x != t}
        })

    candidates.sort(key=lambda x: x['score'])
    beam = candidates[:BEAM_WIDTH]

    # Iteratively build schedule
    for step in range(1, workload.num_txns):
        next_candidates = []
        # Gamma decay: decreases as schedule fills
        progress = step / workload.num_txns
        gamma = GAMMA_START * (1.0 - progress)

        for node in beam:
            p_seq = node['seq']
            p_rem = node['rem']

            # Exhaustive expansion
            for cand in p_rem:
                new_seq = p_seq + [cand]
                new_cost = get_cost(new_seq)

                # Dynamic scoring
                score = new_cost - (gamma * txn_weights[cand])
                next_candidates.append((score, new_cost, new_seq, p_rem, cand))

        # Sort by score
        next_candidates.sort(key=lambda x: x[0])

        new_beam = []
        for c_score, c_cost, c_seq, c_parent_rem, c_cand in next_candidates:
            if len(new_beam) >= BEAM_WIDTH:
                break

            new_rem = c_parent_rem.copy()
            new_rem.remove(c_cand)
            new_beam.append({'cost': c_cost, 'score': c_score, 'seq': c_seq, 'rem': new_rem})

        beam = new_beam
>>>>>>> REPLACE
<<<<<<< SEARCH
        # 1. Stagnation Check -> Ruin-and-Recreate (Kick)
        if steps_since_imp > STAGNATION_LIMIT:
            # Perform Kick: Remove random block and greedy re-insert
            kick_seq = list(best_schedule) # Intensify around best found
            n = len(kick_seq)

            b_size = random.randint(KICK_BLOCK_SIZE_MIN, KICK_BLOCK_SIZE_MAX)
            if n > b_size:
                start = random.randint(0, n - b_size)
                removed_block = kick_seq[start : start + b_size]
                del kick_seq[start : start + b_size]

                # Greedy Best-Fit Insertion for each item in the block
                for item in removed_block:
                    best_pos = -1
                    min_c = float('inf')

                    # Try all positions
                    for i in range(len(kick_seq) + 1):
                        kick_seq.insert(i, item)
                        c = get_cost(kick_seq)
                        if c < min_c:
                            min_c = c
                            best_pos = i
                        kick_seq.pop(i)

                    kick_seq.insert(best_pos, item)

                # Update current state to the result of the kick
                current_schedule = kick_seq
                current_cost = min_c

                if current_cost < best_cost:
                    best_cost = current_cost
                    best_schedule = list(current_schedule)
                    steps_since_imp = 0
                else:
                    # Reset counter to give the new state a chance
                    steps_since_imp = 0

                # Reheat temperature slightly to allow local settling
                T = max(T, current_cost * 0.02)
                continue
=======
        # 1. Stagnation Check -> Ruin-and-Recreate (Kick)
        if steps_since_imp > STAGNATION_LIMIT:
            # Perform Kick: Multi-Mode Ruin and Sorted Re-insert
            kick_seq = list(best_schedule) # Intensify around best found
            n = len(kick_seq)
            removed_items = []

            # Mode Selection: 50% Block, 50% Scatter
            if random.random() < 0.5:
                # Block Ruin
                b_size = random.randint(KICK_BLOCK_SIZE_MIN, KICK_BLOCK_SIZE_MAX)
                if n > b_size:
                    start = random.randint(0, n - b_size)
                    removed_items = kick_seq[start : start + b_size]
                    del kick_seq[start : start + b_size]
            else:
                # Scatter Ruin (Random indices)
                num_to_remove = random.randint(KICK_BLOCK_SIZE_MIN, KICK_BLOCK_SIZE_MAX)
                # Sample indices
                if n > 0:
                    indices = sorted(random.sample(range(n), min(n, num_to_remove)), reverse=True)
                    for idx in indices:
                        removed_items.append(kick_seq.pop(idx))

            if removed_items:
                # Sort removed items by weight (descending) -> "Big Rocks First"
                # This helps place difficult/heavy transactions in optimal slots first
                removed_items.sort(key=lambda x: txn_weights[x], reverse=True)

                # Greedy Best-Fit Insertion
                for item in removed_items:
                    best_pos = -1
                    min_c = float('inf')

                    # Try all positions
                    for i in range(len(kick_seq) + 1):
                        kick_seq.insert(i, item)
                        c = get_cost(kick_seq)
                        if c < min_c:
                            min_c = c
                            best_pos = i
                        kick_seq.pop(i)

                    kick_seq.insert(best_pos, item)

                # Update current state to the result of the kick
                current_schedule = kick_seq
                current_cost = min_c

                if current_cost < best_cost:
                    best_cost = current_cost
                    best_schedule = list(current_schedule)
                    steps_since_imp = 0
                else:
                    # Reset counter to give the new state a chance
                    steps_since_imp = 0

                # Reheat temperature slightly to allow local settling
                T = max(T, current_cost * 0.02)
                continue
>>>>>>> REPLACE
</DIFF>