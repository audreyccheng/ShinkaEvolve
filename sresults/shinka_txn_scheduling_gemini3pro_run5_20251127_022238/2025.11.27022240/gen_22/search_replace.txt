<NAME>
ILS_Refinement
</NAME>

<DESCRIPTION>
Replacing the simple Simulated Annealing refinement phase with an Iterated Local Search (ILS) strategy featuring a "Ruin-and-Recreate" perturbation.
1.  **Ruin-and-Recreate**: Periodically removes a contiguous block of transactions and re-inserts them using a greedy strategy with position sampling (checking start, end, and random locations). This structural kick helps escape local optima better than simple swaps.
2.  **Budget Management**: Increases the refinement budget to utilize the fast simulator more effectively (up to 3000 evaluations), allowing for deeper exploration.
3.  **Local Search**: Uses a short burst of Simulated Annealing after each reconstruction to settle the schedule into a local minimum.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Select best from construction
    beam.sort(key=lambda x: x['cost'])
    best_candidate = beam[0]

    current_schedule = best_candidate['seq']
    current_cost = best_candidate['cost']

    # --- 2. Refinement Phase: SA with Block Moves ---

    MAX_ITER = 750 # Slightly increased iterations
    INITIAL_TEMP = max(1.0, current_cost * 0.05)
    COOLING_RATE = 0.99

    best_schedule = list(current_schedule)
    best_cost = current_cost

    temp = INITIAL_TEMP

    for i in range(MAX_ITER):
        neighbor = list(current_schedule)
        r = random.random()

        # Dynamic Operator Selection with Bias to target schedule tail
        if r < 0.25:
            # Standard Swap
            idx1, idx2 = random.sample(range(num_txns), 2)
            neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
        elif r < 0.50:
            # Biased Insert: Move from second half to anywhere (Targeting Tail)
            idx1 = random.randint(num_txns // 2, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        elif r < 0.75:
            # Standard Insert
            idx1 = random.randint(0, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        else:
            # Block Move: Move a contiguous chunk
            if num_txns > 4:
                # Slightly larger blocks allowed
                block_size = random.randint(2, max(3, num_txns // 6))
                start_idx = random.randint(0, num_txns - block_size)

                # Extract block
                block = neighbor[start_idx : start_idx + block_size]
                del neighbor[start_idx : start_idx + block_size]

                # Insert block
                insert_idx = random.randint(0, len(neighbor))
                neighbor[insert_idx:insert_idx] = block
            else:
                # Fallback for very small workloads
                idx1, idx2 = random.sample(range(num_txns), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]

        # Evaluate neighbor
        neighbor_cost = workload.get_opt_seq_cost(neighbor)
        delta = neighbor_cost - current_cost

        accept = False
        if delta < 0:
            accept = True
        elif temp > 0.001:
            prob = math.exp(-delta / temp)
            if random.random() < prob:
                accept = True

        if accept:
            current_schedule = neighbor
            current_cost = neighbor_cost
            if current_cost < best_cost:
                best_cost = current_cost
                best_schedule = list(current_schedule)

        temp *= COOLING_RATE
        if temp < 0.001:
            break

    return best_cost, best_schedule
=======
    # Select best from construction
    beam.sort(key=lambda x: x['cost'])
    best_candidate = beam[0]

    # --- 2. Refinement Phase: Iterated Local Search (ILS) ---
    # ILS uses a "Ruin and Recreate" strategy to escape local optima.
    # We alternate between destructively perturbing the best solution (Ruin)
    # and repairing/improving it (Recreate/Local Search).

    current_schedule = list(best_candidate['seq'])
    current_cost = best_candidate['cost']

    best_schedule = list(current_schedule)
    best_cost = current_cost

    # Evaluation Budget Management
    MAX_EVALS = 3000
    evals_performed = 0

    # SA Parameters for the local search phase
    SA_ITER = 100
    INITIAL_TEMP = max(1.0, current_cost * 0.03)
    COOLING = 0.96

    while evals_performed < MAX_EVALS:
        # A. Ruin-and-Recreate (Perturbation)
        # We start from the global best to aggressively find better basins
        work_seq = list(best_schedule)

        # Ruin: Remove a random contiguous block
        if num_txns > 8:
            # Block size between 5% and 20%
            block_size = random.randint(3, max(4, int(num_txns * 0.2)))
            start_idx = random.randint(0, num_txns - block_size)

            removed = work_seq[start_idx : start_idx + block_size]
            del work_seq[start_idx : start_idx + block_size]

            # Recreate: Greedy Insertion with Sampling
            # For each removed item, check a few positions and pick the best
            # This repairs the schedule structure
            random.shuffle(removed) # Vary re-insertion order

            for txn in removed:
                best_pos_cost = float('inf')
                best_pos = random.randint(0, len(work_seq)) # Default

                # Check Start, End, and K random positions
                candidates_idx = {0, len(work_seq)}
                for _ in range(5):
                    candidates_idx.add(random.randint(0, len(work_seq)))

                for pos in candidates_idx:
                    work_seq.insert(pos, txn)
                    c = workload.get_opt_seq_cost(work_seq)
                    evals_performed += 1

                    if c < best_pos_cost:
                        best_pos_cost = c
                        best_pos = pos

                    del work_seq[pos] # Backtrack
                    if evals_performed >= MAX_EVALS: break

                if evals_performed >= MAX_EVALS: break
                work_seq.insert(best_pos, txn)

        else:
            # Small workload fallback
            random.shuffle(work_seq)
            evals_performed += 1

        if evals_performed >= MAX_EVALS: break

        # B. Local Search (Simulated Annealing)
        # Refine the reconstructed schedule
        curr_seq_sa = work_seq
        curr_cost_sa = workload.get_opt_seq_cost(curr_seq_sa)
        temp = INITIAL_TEMP

        for _ in range(SA_ITER):
            neighbor = list(curr_seq_sa)
            r = random.random()

            # Operators
            if r < 0.5:
                # Insert
                idx1 = random.randint(0, len(neighbor) - 1)
                val = neighbor.pop(idx1)
                idx2 = random.randint(0, len(neighbor))
                neighbor.insert(idx2, val)
            elif r < 0.8:
                # Swap
                idx1, idx2 = random.sample(range(len(neighbor)), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
            else:
                # Block Reverse (Local reordering)
                sz = random.randint(2, 6)
                idx = random.randint(0, max(0, len(neighbor) - sz))
                neighbor[idx:idx+sz] = reversed(neighbor[idx:idx+sz])

            n_cost = workload.get_opt_seq_cost(neighbor)
            evals_performed += 1

            delta = n_cost - curr_cost_sa
            accept = False
            if delta < 0:
                accept = True
            elif temp > 0.001 and random.random() < math.exp(-delta / temp):
                accept = True

            if accept:
                curr_seq_sa = neighbor
                curr_cost_sa = n_cost
                if curr_cost_sa < best_cost:
                    best_cost = curr_cost_sa
                    best_schedule = list(curr_seq_sa)

            temp *= COOLING
            if evals_performed >= MAX_EVALS: break

    return best_cost, best_schedule
>>>>>>> REPLACE

</DIFF>