<NAME>
optimize_beam_and_polish
</NAME>

<DESCRIPTION>
1.  **Correct Beam Search Seeding**: Change the initialization score from `cost - 0.01*w` to `cost - 1.2*w`. Since `cost` equals `w` for single transactions, the original code sorted by `0.99w` (Smallest First), which is suboptimal for packing. The new formula sorts by `-0.2w` (Largest First), implementing a "Big Rocks First" strategy which is standard for minimizing makespan.
2.  **Enhance Beam Search Config**: Increase `BEAM_WIDTH` to 8 and widen the `GAMMA` range (6.0 to 0.5) to better explore high-efficiency packings initially and focus on gap-filling later.
3.  **Extended Optimization Phases**: Increase `SA_ITERATIONS` to 3500 and `POLISH_MAX_PASSES` to 40 to allow the algorithm to fully converge to a local minimum, leveraging the improved starting structure from the beam search.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Hyperparameters ---
    BEAM_WIDTH = 5

    # SA Parameters
    SA_ITERATIONS = 2500
    SA_COOLING_RATE = 0.998
    SA_START_TEMP_RATIO = 0.05

    # Ruin Parameters
    STAGNATION_LIMIT = 200
    RUIN_BLOCK_SIZE_MIN = 2
    RUIN_BLOCK_SIZE_MAX = 6

    # Polish Parameters
    POLISH_MAX_PASSES = 20
=======
    # --- Hyperparameters ---
    BEAM_WIDTH = 8

    # SA Parameters
    SA_ITERATIONS = 3500
    SA_COOLING_RATE = 0.9985
    SA_START_TEMP_RATIO = 0.05

    # Ruin Parameters
    STAGNATION_LIMIT = 200
    RUIN_BLOCK_SIZE_MIN = 2
    RUIN_BLOCK_SIZE_MAX = 6

    # Polish Parameters
    POLISH_MAX_PASSES = 40
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Phase 1: Efficiency-Squared Beam Search ---
    # Heuristic: Score = Cost - Gamma * Weight * (Efficiency^2)
    # Efficiency = (Weight - MarginalCost) / Weight.
    # High efficiency (near 1.0) means the txn was "hidden" (executed in parallel).

    GAMMA_START = 4.0
    GAMMA_END = 1.0

    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        w = txn_weights[t]
        # Initial candidates: Prefer heavier anchors to start
        score = cost - (0.01 * w)
        candidates.append({'score': score, 'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})
=======
    # --- Phase 1: Efficiency-Squared Beam Search ---
    # Heuristic: Score = Cost - Gamma * Weight * (Efficiency^2)
    # Efficiency = (Weight - MarginalCost) / Weight.
    # High efficiency (near 1.0) means the txn was "hidden" (executed in parallel).

    GAMMA_START = 6.0
    GAMMA_END = 0.5

    candidates = []
    for t in range(workload.num_txns):
        seq = [t]
        cost = get_cost(seq)
        w = txn_weights[t]
        # Initial candidates: Prefer heavier anchors to start (LPT seeding)
        # Using 1.2 ensures negative score for larger weights, sorting them first
        score = cost - (1.2 * w)
        candidates.append({'score': score, 'cost': cost, 'seq': seq, 'rem': {x for x in range(workload.num_txns) if x != t}})
>>>>>>> REPLACE
</DIFF>