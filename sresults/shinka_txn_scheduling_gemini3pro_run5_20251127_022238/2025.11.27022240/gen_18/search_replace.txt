<NAME>
restore_beam_width_and_biased_sa
</NAME>

<DESCRIPTION>
1. Restore Beam Search parameters (`BEAM_WIDTH=20`, `GAMMA=1.3`, `SAMPLE_SIZE=16`) to match the high-performing Generation 7 configuration, addressing the quality drop in the construction phase caused by overly aggressive pruning.
2. Introduce a "Biased Insert" operator in the Simulated Annealing phase (25% probability). This operator specifically selects transactions from the latter half of the schedule (the "tail") and re-inserts them elsewhere. This heuristic targets the critical path more effectively than random insertion.
3. Slightly increase the max block size for block moves (`num_txns // 6`) to allow shifting larger clusters of dependent transactions.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 1. Constructive Phase: Enhanced Beam Search ---
    # Increased beam width and sampling for better initial quality
    BEAM_WIDTH = max(8, int(num_seqs))
    SAMPLE_SIZE = 12
    GAMMA = 1.4

    # Initial Beam Seeding
=======
    # --- 1. Constructive Phase: Enhanced Beam Search ---
    # Restoring higher beam width and sampling from successful Generation 7
    BEAM_WIDTH = max(16, int(num_seqs * 2))
    SAMPLE_SIZE = 16
    GAMMA = 1.3

    # Initial Beam Seeding
>>>>>>> REPLACE
<<<<<<< SEARCH
    for i in range(MAX_ITER):
        neighbor = list(current_schedule)
        r = random.random()

        if r < 0.35:
            # Swap
            idx1, idx2 = random.sample(range(num_txns), 2)
            neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
        elif r < 0.7:
            # Insert (Single Move)
            idx1 = random.randint(0, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        else:
            # Block Move: Move a contiguous chunk
            if num_txns > 4:
                block_size = random.randint(2, max(3, num_txns // 8))
                start_idx = random.randint(0, num_txns - block_size)

                # Extract block
                block = neighbor[start_idx : start_idx + block_size]
                del neighbor[start_idx : start_idx + block_size]

                # Insert block
                insert_idx = random.randint(0, len(neighbor))
                neighbor[insert_idx:insert_idx] = block
            else:
                # Fallback for very small workloads
                idx1, idx2 = random.sample(range(num_txns), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]

        # Evaluate neighbor
=======
    for i in range(MAX_ITER):
        neighbor = list(current_schedule)
        r = random.random()

        # Dynamic Operator Selection with Bias to target schedule tail
        if r < 0.25:
            # Standard Swap
            idx1, idx2 = random.sample(range(num_txns), 2)
            neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
        elif r < 0.50:
            # Biased Insert: Move from second half to anywhere (Targeting Tail)
            idx1 = random.randint(num_txns // 2, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        elif r < 0.75:
            # Standard Insert
            idx1 = random.randint(0, num_txns - 1)
            val = neighbor.pop(idx1)
            idx2 = random.randint(0, num_txns - 1)
            neighbor.insert(idx2, val)
        else:
            # Block Move: Move a contiguous chunk
            if num_txns > 4:
                # Slightly larger blocks allowed
                block_size = random.randint(2, max(3, num_txns // 6))
                start_idx = random.randint(0, num_txns - block_size)

                # Extract block
                block = neighbor[start_idx : start_idx + block_size]
                del neighbor[start_idx : start_idx + block_size]

                # Insert block
                insert_idx = random.randint(0, len(neighbor))
                neighbor[insert_idx:insert_idx] = block
            else:
                # Fallback for very small workloads
                idx1, idx2 = random.sample(range(num_txns), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]

        # Evaluate neighbor
>>>>>>> REPLACE
</DIFF>