<NAME>
beam_search_optimization
</NAME>

<DESCRIPTION>
Replacing the independent greedy restarts with a Beam Search algorithm. Beam search explores the schedule space more effectively by maintaining the 'k' best partial schedules at each step, preventing early bad commitments. The freed-up computational budget is then used for a more extensive Local Search phase on the best candidate, using both Move and Swap operators to escape local optima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy with restarts and local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Run the greedy construction multiple times with random starts
    for _ in range(num_seqs):
        # Start with a random transaction
        start_txn = random.randint(0, workload.num_txns - 1)
        current_schedule = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Iteratively build the schedule
        while remaining_txns:
            # Sample a subset of remaining transactions to evaluate
            # Increased sample size for better greedy decisions
            sample_size = min(len(remaining_txns), 24)
            candidates = random.sample(remaining_txns, sample_size)

            best_next_txn = -1
            min_next_cost = float('inf')

            # Evaluate candidates
            for txn in candidates:
                # Cost is monotonic, so minimizing partial schedule makespan is a good greedy heuristic
                test_schedule = current_schedule + [txn]
                cost = workload.get_opt_seq_cost(test_schedule)

                if cost < min_next_cost:
                    min_next_cost = cost
                    best_next_txn = txn

            # Append the best candidate found
            if best_next_txn != -1:
                current_schedule.append(best_next_txn)
                remaining_txns.remove(best_next_txn)
            else:
                # Fallback (should not happen with valid logic)
                txn = remaining_txns.pop(0)
                current_schedule.append(txn)

        # Local search phase to refine the schedule
        # Attempt to improve by moving random transactions
        current_cost = workload.get_opt_seq_cost(current_schedule)

        # Perform local search iterations
        for _ in range(200):
            # Select a random transaction to move
            idx_from = random.randint(0, len(current_schedule) - 1)
            txn = current_schedule[idx_from]

            # Select a random new position
            idx_to = random.randint(0, len(current_schedule) - 1)
            if idx_from == idx_to:
                continue

            # Construct candidate schedule
            test_schedule = list(current_schedule)
            test_schedule.pop(idx_from)
            test_schedule.insert(idx_to, txn)

            new_cost = workload.get_opt_seq_cost(test_schedule)

            if new_cost < current_cost:
                current_cost = new_cost
                current_schedule = test_schedule

        # Check if this full schedule is the best so far
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_schedule = current_schedule

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using beam search followed by extensive local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection (used as beam width)

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # Beam Search configuration
    beam_width = num_seqs
    candidates_per_node = 20

    # Initialize beam with unique random start transactions
    all_txns = list(range(workload.num_txns))
    num_starts = min(beam_width, len(all_txns))
    start_txns = random.sample(all_txns, num_starts)

    # Beam element: (cost, schedule, remaining_txns_list)
    beam = []
    for t in start_txns:
        rem = list(all_txns)
        rem.remove(t)
        cost = workload.get_opt_seq_cost([t])
        beam.append((cost, [t], rem))

    # Iteratively expand the beam
    target_length = workload.num_txns
    while len(beam[0][1]) < target_length:
        candidates = []
        for cost, sched, rem in beam:
            # Sample subset of remaining transactions
            n_sample = min(len(rem), candidates_per_node)
            next_txns = random.sample(rem, n_sample)

            for next_txn in next_txns:
                new_sched = sched + [next_txn]
                new_cost = workload.get_opt_seq_cost(new_sched)
                # Store needed info to reconstruct state (avoid deep copying rem yet)
                candidates.append((new_cost, new_sched, rem, next_txn))

        # Select top k candidates based on lowest cost
        # Shuffle first to break ties randomly
        random.shuffle(candidates)
        candidates.sort(key=lambda x: x[0])
        best_candidates = candidates[:beam_width]

        # Construct next beam
        new_beam = []
        for cost, new_sched, old_rem, added_txn in best_candidates:
            new_rem = list(old_rem)
            new_rem.remove(added_txn)
            new_beam.append((cost, new_sched, new_rem))
        beam = new_beam

    # Select best schedule from beam
    best_cost, best_schedule, _ = min(beam, key=lambda x: x[0])

    # Extended Local Search phase on the single best schedule
    # Uses both Move and Swap operators
    current_schedule = list(best_schedule)
    current_cost = best_cost

    # Iterations count balanced to fit within execution time budget
    # Saved comparisons from beam search allow for more local search
    iterations = 3000

    for _ in range(iterations):
        op = random.random()
        test_schedule = list(current_schedule)

        if op < 0.5:
            # Move operator: pick random txn and insert elsewhere
            idx_from = random.randint(0, len(test_schedule) - 1)
            txn = test_schedule.pop(idx_from)
            idx_to = random.randint(0, len(test_schedule)) # can insert at end
            test_schedule.insert(idx_to, txn)
        else:
            # Swap operator: swap two random positions
            idx1 = random.randint(0, len(test_schedule) - 1)
            idx2 = random.randint(0, len(test_schedule) - 1)
            if idx1 == idx2: continue
            test_schedule[idx1], test_schedule[idx2] = test_schedule[idx2], test_schedule[idx1]

        new_cost = workload.get_opt_seq_cost(test_schedule)

        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = test_schedule

    return current_cost, current_schedule
>>>>>>> REPLACE
</DIFF>