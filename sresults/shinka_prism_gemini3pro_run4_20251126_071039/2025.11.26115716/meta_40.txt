# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Sorted Greedy KV-Cache Pressure Minimization**
- **Implementation**: The algorithm sorts models in descending order by their request-rate-to-SLO ratio and assigns each to the GPU with the lowest current ratio of accumulated load to remaining memory.
- **Performance**: The solution performed effectively, achieving a combined score of 21.89 and a 100% success rate with negligible execution time.
- **Feedback**: Prioritizing models with high request density and balancing the load-to-space ratio proved to be a robust heuristic for minimizing maximum KV cache pressure without complex optimization.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Binary Search with Dynamic Linearized Sorting Key**
- **Implementation**: Uses binary search on the target pressure ratio, validating feasibility via First-Fit Decreasing sorted by a dynamic key ($Weight + K \times Size$) representing the linearized capacity constraint.
- **Performance**: Achieved a strong score of 26.23 with 100% success rate and 0.001s execution time.
- **Feedback**: The linearized sorting metric effectively adapts the heuristic to prioritize either model size or request load based on the current pressure target, yielding optimal placements efficiently.
**Program Identifier:** Generation 1 - Patch Name parametric_kvpr_search - Correct Program: True

**Program Name: Greedy Size-Density Sorted Model Placement**
- **Implementation**: The algorithm sorts models by size and request density in descending order, then greedily assigns each model to the GPU that results in the lowest local KV cache pressure after placement.
- **Performance**: The approach achieved a combined score of 20.43 with a 100% success rate, indicating strong optimization of memory pressure.
- **Feedback**: Prioritizing large, dense models prevents resource fragmentation, and the lookahead strategy for calculating resulting pressure ensures a balanced distribution of load across GPUs.
**Program Identifier:** Generation 2 - Patch Name greedy_post_placement_min_kvpr - Correct Program: True

**Program Name: Binary Search with Multi-Heuristic Bin Packing**
- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search on the target pressure value, checking feasibility via three bin packing strategies: Best Fit and First Fit on items sorted by dynamic weight ($w + K \cdot s$), and Best Fit on size-sorted items.
- **Performance**: It achieved a strong combined score of 26.23 (max KVPR 25.233) with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Employing diverse sorting and packing heuristics within the binary search allows the solver to adapt to different data distributions, effectively balancing load and escaping local optima common in single-heuristic greedy approaches.
**Program Identifier:** Generation 3 - Patch Name improved_bin_packing_heuristics - Correct Program: True

**Program Name: Hybrid Greedy and Binary Search Best-Fit Decreasing Algorithm**
- **Implementation**: This solution employs a dual strategy: a greedy heuristic that locally minimizes immediate cache pressure, and a global optimization method that uses binary search to linearize the non-linear objective function into a Best-Fit Decreasing bin packing problem.
- **Performance**: The algorithm achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The approach effectively solves the fractional minimization problem by transforming it into a linear constraint (`weight + K * size`), allowing standard bin packing heuristics to find near-optimal distributions where simple greedy methods might fail.
**Program Identifier:** Generation 4 - Patch Name hybrid_kvpr_optimizer - Correct Program: True

**Program Name: Greedy KVPR Minimization with Traffic Density Sorting**
- **Implementation**: The algorithm sorts models by `req_rate/slo` descending and assigns each to the GPU that results in the minimum local KV cache pressure ratio.
- **Performance**: Achieved a combined score of 22.67 with a 100% success rate and fast execution.
- **Feedback**: Sorting by request density ensures high-load models are distributed early, while the local minimization step effectively balances pressure across available resources.
**Program Identifier:** Generation 5 - Patch Name improved_greedy_placement - Correct Program: True

**Program Name:** Ensemble Greedy Heuristics for KV Cache Pressure Minimization
- **Implementation:** The algorithm executes four distinct greedy heuristics—sorting by load, size, or isolated pressure and targeting minimal current or resulting pressure—and selects the final placement that minimizes the maximum KV pressure across all GPUs.
- **Performance:** It achieved a strong combined score of 23.48 with a 100% success rate and negligible execution time.
- **Feedback:** The ensemble approach proves highly effective for this non-linear packing problem, as different heuristics (like prioritizing model size vs. request load) outperform each other depending on the specific input distribution.
**Program Identifier:** Generation 6 - Patch Name ensemble_greedy_placement - Correct Program: True

**Program Name: Ensemble Greedy Heuristics with Multiple Sorting Keys**
- **Implementation**: The algorithm tests four different greedy strategies, sorting models by weight, size, isolated pressure, and density, then assigning them to the GPU that minimizes immediate KV cache pressure. It evaluates the resulting global maximum KVPR for each strategy and returns the optimal placement configuration.
- **Performance**: The solution achieved a high combined score of 23.69 with a 100% success rate and negligible execution time.
- **Feedback**: Using an ensemble of sorting heuristics allows the algorithm to adapt to diverse model distributions, avoiding the pitfalls of a single greedy approach. This method robustly balances memory constraints against request load to effectively minimize the system-wide maximum KVPR.
**Program Identifier:** Generation 7 - Patch Name ensemble_greedy_placement - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Best Fit Packing**
- **Implementation**: The algorithm minimizes maximum KV cache pressure by binary searching for a target threshold, validating feasibility via a Best Fit packing routine that rotates through multiple sorting heuristics (e.g., weighted sum, size) and randomized trials.
- **Performance**: It delivers a strong combined score of 26.26 with a perfect success rate and minimal execution overhead (0.097s).
- **Feedback**: By transforming the non-linear KVPR constraint into a linear packing problem with dynamic item weights, the approach efficiently approximates the optimal distribution, while randomized shuffling ensures robustness when deterministic heuristics fail.
**Program Identifier:** Generation 8 - Patch Name improved_heuristics_and_search - Correct Program: True

**Program Name: Hybrid Greedy and Binary Search with Local Refinement**
- **Implementation**: Utilizes a hybrid approach combining multiple greedy heuristics and binary search on KVPR targets to generate candidates, followed by local search refinement using moves and swaps to relieve the bottleneck GPU.
- **Performance**: Achieved a high combined score of 26.23 with a perfect success rate and minimal execution time (0.001s).
- **Feedback**: The strategy of diversifying initial candidates followed by targeted local optimization proves highly effective for minimizing peak memory pressure without compromising speed.
**Program Identifier:** Generation 9 - Patch Name refined_placement_heuristics_local_search - Correct Program: True

**Program Name: Multi-Heuristic Binary Search with Local Descent Optimization**
- **Implementation**: This approach utilizes binary search over the target KVPR using five distinct bin-packing heuristics (Best/First Fit with various sort keys) and refines the result with a greedy local search to offload bottleneck GPUs.
- **Performance**: Achieved a high combined score of 26.23 with 100% success rate and rapid execution (0.002s).
- **Feedback**: The combination of diverse packing strategies during the binary search phase ensures robustness, while the local optimization step effectively smooths out load imbalances left by the initial placement.
**Program Identifier:** Generation 10 - Patch Name bs_multi_heuristic_local_search - Correct Program: True

**Program Name: Hybrid Ensemble with Binary Search and Local Refinement**
- **Implementation**: The solution employs an ensemble of four greedy heuristics, a binary search over the target pressure using Best Fit Decreasing, and a local search refinement to relieve the bottleneck GPU.
- **Performance**: It achieved a high combined score of 26.23 with 100% success rate and very fast execution (0.001s).
- **Feedback**: The binary search mechanism effectively converted the non-linear min-max objective into a solvable bin-packing constraint, significantly improving load balancing compared to standalone greedy strategies.
**Program Identifier:** Generation 11 - Patch Name binary_search_and_refinement - Correct Program: True

**Program Name: Linearized Binary Search with Randomized Best-Fit and Hill-Climbing**
- **Implementation**: Solves the fractional minimization problem by binary searching for a target pressure using a linearized constraint ($w + K \cdot s \leq K \cdot C$) within a randomized Best-Fit packing routine, refined by post-allocation Hill-Climbing.
- **Performance**: Achieved an excellent combined score of 26.23 with 100% success rate and negligible execution time (0.003s).
- **Feedback**: The transformation of the fractional objective into a linear bin-packing problem allows for efficient heuristics, while the randomized restarts and local search effectively escape local optima to minimize the bottleneck.
**Program Identifier:** Generation 12 - Patch Name noisy_bfd_search_plus_repair - Correct Program: True

**Program Name: Binary Search with Linearized Beam Packing and Local Refinement**
- **Implementation**: Transforms the non-linear objective into a linearized bin packing problem solved via binary search and beam search with symmetry breaking and best-fit heuristics. A local search post-processing step actively rebalances loads to further minimize pressure and tighten search bounds.
- **Performance**: Achieved a high combined score of 26.23 with 0.006s execution time and 100% success rate.
- **Feedback**: The linearization strategy combined with symmetry-breaking beam search effectively handles the non-convex constraints, while local refinement significantly improves solution quality by aggressively lowering the maximum bottleneck.
**Program Identifier:** Generation 13 - Patch Name prism_beam - Correct Program: True

**Program Name: Hybrid Greedy Ensemble with Binary Search Bin Packing**
- **Implementation**: The algorithm employs a greedy ensemble with various sorting keys and placement strategies, coupled with a binary search that re-frames the problem as Bin Packing, and concludes with local search refinement.
- **Performance**: Achieved a combined score of 26.23 and a KVPR metric of 25.233 with a perfect success rate and minimal latency.
- **Feedback**: Transforming the non-linear objective into a bin packing feasibility check proved highly effective, allowing the use of Best Fit Decreasing to balance load better than standard greedy methods alone.
**Program Identifier:** Generation 14 - Patch Name reintroduce_binary_and_local_search - Correct Program: True

**Program Name: Binary Search Linearized Packing with Hill-Climbing Refinement**
- **Implementation**: The algorithm minimizes KV cache pressure using binary search on the pressure ratio, checking feasibility via a linearized best-fit decreasing bin packing with randomized restarts and swap-based repairs. A final hill-climbing phase applies targeted moves and swaps to relieve the highest-pressure GPU.
- **Performance**: Achieved a strong combined score of 26.23 with a 100% success rate and rapid 0.003s execution time.
- **Feedback**: The linearization of the fractional objective allows for effective standard bin packing heuristics, while the aggressive bound updates and local search refinement ensure optimal load balancing across diverse test cases.
**Program Identifier:** Generation 15 - Patch Name repair_and_tighten_bounds - Correct Program: True

**Program Name: Binary Search Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm transforms the non-linear KVPR minimization into a Bin Packing feasibility problem on effective model sizes ($s + w/K$) solved via binary search, initialized by greedy heuristics and optimized with local search moves.
- **Performance**: The solution achieves a high combined score of 26.23 with a 100% success rate and low latency (0.023s).
- **Feedback**: The reduction to a standard bin packing problem allows effective optimization of the complex objective, while the multi-stage pipeline ensures both solution quality and computational efficiency.
**Program Identifier:** Generation 16 - Patch Name hybrid_placement_search - Correct Program: True

**Program Name: Hybrid Greedy Ensemble with Binary Search and Local Refinement**
- **Implementation**: The algorithm employs an ensemble of greedy strategies followed by a binary search that transforms the non-linear min-max ratio problem into a linear bin-packing feasibility check, concluding with local search moves and swaps to relieve bottleneck GPUs.
- **Performance**: It achieved a combined score of 26.23 with a 100% success rate and extremely fast execution time (0.001s).
- **Feedback**: The transformation of the objective function into a bin-packing constraint allows for effective global optimization, while the local search refinement ensures that specific high-pressure assignments are smoothed out efficiently.
**Program Identifier:** Generation 17 - Patch Name improved_local_search - Correct Program: True

**Program Name: Linearized Binary Search Packing with Repair and Local Optimization**
- **Implementation**: The algorithm linearizes the non-linear KV cache pressure objective to enable a binary search using a greedy Best-Fit strategy, augmented by a one-step swap repair mechanism for items that fail to fit. It further refines the placement using randomized noisy sorting restarts and a post-placement hill-climbing phase.
- **Performance**: The solution achieved an excellent combined score of 26.25 with a 100% success rate and extremely fast execution (0.002s).
- **Feedback**: Linearizing the cost function effectively simplifies the complex objective into a standard bin-packing constraint, allowing the binary search to converge rapidly on an optimal value. The combination of lookahead repair during packing and post-process local search provides significant robustness against local optima.
**Program Identifier:** Generation 18 - Patch Name none - Correct Program: True

**Program Name: Effective-Size Bin Packing with Ensemble Greedy and Local Search**
- **Implementation**: The solution employs a multi-strategy greedy initialization and a binary search that transforms the pressure objective into a linear bin-packing constraint ($s + w/K$), refined by bottleneck-targeted local moves and swaps.
- **Performance**: Achieved a combined score of 26.23 with a 100% success rate and exceptional speed (0.001s).
- **Feedback**: The linearization of the non-linear KVPR objective during binary search is a key optimization that, combined with local search, effectively balances memory usage and request load.
**Program Identifier:** Generation 19 - Patch Name iterative_binpack_refine - Correct Program: True

**Program Name: Beam Search with Linearized Cost and Hill Climbing**
- **Implementation**: Uses binary search to minimize max-KVPR, employing a Beam Search (width 8) with a linearized cost heuristic ($W + K \cdot S$) to check feasibility and local hill-climbing for refinement.
- **Performance**: Combined score: 0.00; Success Rate: 0.00 (failed all tests).
- **Feedback**: The zero success rate is caused by a critical `IndexError` in the beam search return statement (accessing index 2 of a length-2 tuple), causing the program to crash on every execution.
**Program Identifier:** Generation 20 - Patch Name beam_search_placement - Correct Program: False

**Program Name: Hybrid Beam Search with Binary Effective-Size Packing**
- **Implementation**: This solution combines a beam search ensemble using multiple sorting heuristics for initialization, a binary search that optimizes KVPR by transforming constraints into a bin packing problem with "effective size" ($s + w/K$), and a final local search to relieve bottleneck GPUs.
- **Performance**: Achieved a high score of 26.23 and 100% success rate with negligible execution time (0.003s), indicating excellent optimization quality and efficiency.
- **Feedback**: The binary search strategy effectively linearized the non-linear KVPR objective, allowing standard bin packing heuristics to find near-optimal distributions, while the local search refined edge cases that the packing logic missed.
**Program Identifier:** Generation 21 - Patch Name beam_search_placement - Correct Program: True

**Program Name: Hybrid Binary Search Bin Packing with Local Search Refinement**
- **Implementation**: The algorithm employs an ensemble of greedy heuristics for initialization, performs a binary search on the target KVPR by treating feasibility as a bin-packing problem, and refines the solution using iterative move and swap local search operations.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Converting the continuous min-max objective into a binary search over discrete feasibility checks proved highly effective for global optimization, while the local search phase successfully resolved remaining bottlenecks.
**Program Identifier:** Generation 22 - Patch Name bs_multisort_and_ls_swap - Correct Program: True

**Program Name: Binary Search Packing with Hill Climbing Optimization**
- **Implementation**: The algorithm uses binary search with a linearized Best Fit packing heuristic to generate an initial valid placement, followed by a local search phase that iteratively performs model moves and swaps to relieve the bottleneck GPU.
- **Performance**: Achieved a combined score of 26.26 with a fast execution time of 0.020s and a 100% success rate.
- **Feedback**: The combination of a constraint-aware global construction method and local refinement proves highly effective for the non-linear objective function, ensuring robust load balancing across GPUs.
**Program Identifier:** Generation 23 - Patch Name randomized_bs_with_local_search - Correct Program: True

**Program Name: Binary Search with Linearized Beam Packing and Local Search**
- **Implementation**: This approach binary searches for the optimal KV pressure, utilizing a beam search packer to solve the feasibility problem by linearizing capacity constraints ($w + K \cdot s \le K \cdot C$). A subsequent hill-climbing phase refines the allocation by iteratively moving or swapping models to relieve the highest-pressure GPU.
- **Performance**: The solution achieved a high score of 26.23 with a 100% success rate, balancing load effectively with negligible runtime (0.044s).
- **Feedback**: The linearization technique effectively transformed the complex non-linear objective into a manageable packing problem. Combining beam search for robust initial placement with local search for fine-tuning provided a superior balance of speed and solution quality.
**Program Identifier:** Generation 24 - Patch Name implement_beam_search - Correct Program: True

**Program Name: Binary Search with Linearized Packing and Hill Climbing**
- **Implementation**: The algorithm employs binary search on the target pressure using a linearized cost function ($w + K \cdot s$) for Best-Fit packing, augmented by a repair mechanism that swaps items to resolve placement failures. An aggressive hill-climbing optimization refines valid placements by moving items from the bottleneck GPU to tighter the upper bound dynamically.
- **Performance**: It achieves a high combined score of 26.25 with negligible execution time (0.002s) and a 100% success rate.
- **Feedback**: The combination of multiple sorting heuristics and a swap-based repair strategy ensures robustness, while the in-loop local search effectively minimizes the bottleneck beyond the precision of the binary search alone.
**Program Identifier:** Generation 25 - Patch Name hybrid_repair_search - Correct Program: True

**Program Name: Linearized Binary Search Packing with Hill Climbing**
- **Implementation**: The solution uses binary search to find the optimal maximum pressure target by transforming the non-linear objective into a linear bin-packing constraint ($w + k \cdot s$), solved via Best-Fit Decreasing. It refines the result using a greedy local search that moves or swaps models to specifically relieve the highest-pressure GPU.
- **Performance**: Achieved a high combined score of 26.23 with negligible execution time (0.003s) and perfect reliability.
- **Feedback**: Linearizing the KVPR constraint allowed standard bin-packing heuristics to find near-optimal distributions efficiently, while the targeted hill climbing effectively smoothed out remaining bottlenecks.
**Program Identifier:** Generation 26 - Patch Name hybrid_search_placement - Correct Program: True

**Program Name: Hybrid Beam Search with Bin Packing and Local Search**
- **Implementation**: The algorithm employs a symmetry-pruned Beam Search with multiple sorting heuristics and a Binary Search that transforms the pressure objective into a variable-size Bin Packing problem, followed by local Move/Swap refinement.
- **Performance**: Achieved a high combined score of 26.23 with a perfect success rate and rapid execution (0.006s).
- **Feedback**: The reduction of the min-max KVPR problem to a capacity-constrained packing problem (via Binary Search) provided excellent global bounds, while local search efficiently resolved residual bottlenecks.
**Program Identifier:** Generation 27 - Patch Name beam_search_placement - Correct Program: True

**Program Name: Hybrid Binary Search with Heuristic Packing and Local Search**
- **Implementation**: The algorithm minimizes maximum KV cache pressure by binary searching for a feasible threshold using a best-fit packing heuristic that maximizes weighted requirements, followed by a hill-climbing local search that performs model moves and swaps to relieve bottleneck GPUs.
- **Performance**: It achieved a combined score of 26.26 with a 100% success rate and a fast execution time of 0.029s.
- **Feedback**: The combination of diverse deterministic and randomized packing strategies ensures valid initial placements, while the post-processing local optimization significantly tightens the bounds, resulting in a robust and high-performing solution.
**Program Identifier:** Generation 28 - Patch Name add_local_search_refinement - Correct Program: True

**Program Name: Ensemble Greedy with Binary Search and Steepest Descent**
- **Implementation**: This solution initializes with an ensemble of greedy strategies and refines the result using a binary search on target pressure with beam search for feasibility. It concludes with a steepest descent local search that iteratively relieves the bottleneck GPU via optimal moves and swaps.
- **Performance**: The algorithm achieved a high combined score of 25.69 with a perfect success rate and a fast execution time of 0.022s.
- **Feedback**: Transforming the non-linear KVPR objective into a bin-packing feasibility problem via binary search proved highly effective. The addition of steepest descent local search ensured that the bottleneck GPU was specifically targeted for final optimization.
**Program Identifier:** Generation 29 - Patch Name bs_beam_ls_placement - Correct Program: True

**Program Name: Binary Search on Pressure with Beam Search and Local Refinement**
- **Implementation**: The algorithm linearizes the KVPR objective by binary searching on the target pressure, using beam search to verify feasibility at each step. This is augmented by an initial greedy ensemble and a final local search (moves and swaps) for optimization.
- **Performance**: Achieved a high combined score of 26.23 with 100% success rate and negligible latency (0.003s).
- **Feedback**: The approach effectively handles the non-linear objective by transforming it into a parameterized bin packing problem, efficiently balancing global search structure with local refinement.
**Program Identifier:** Generation 30 - Patch Name beam_search_placement - Correct Program: True

**Program Name: Binary Search with Ejection Chain Search**
- **Implementation**: Combines binary search on the KV pressure target with a Best Fit packing heuristic (using multiple sort keys and swap repairs) and optimizes placements using hill-climbing with ejection chains (moves, swaps, 3-cycles).
- **Performance**: Score 0.00; Max KVPR 0.000; Success Rate 0.000.
- **Feedback**: The zero success rate indicates the algorithm systematically fails to produce valid solutions, likely because the packing heuristic raises exceptions when unable to fit models into GPUs (Bin Packing failure), or due to bugs in the complex in-place state transitions.
**Program Identifier:** Generation 31 - Patch Name chain_move_placement - Correct Program: False

**Program Name: Binary Search Packing with Hill Climbing Refinement**
- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search on the target value, validated by a multi-strategy Best-Fit packing heuristic with randomized retries. It refines solutions via a hill-climbing local search that iteratively moves and swaps models from the highest-pressure GPU.
- **Performance**: The solution achieved a score of 26.26 with a 100% success rate and negligible execution time (0.030s).
- **Feedback**: Combining global search strategies (multiple sort keys) with local optimization effectively handles the non-linear cost function. The randomized restarts and specific bottleneck-targeting in the local search ensure robust and balanced resource utilization.
**Program Identifier:** Generation 32 - Patch Name add_deterministic_strategy - Correct Program: True

**Program Name: Hybrid Greedy-Beam Search with Local Refinement**
- **Implementation**: Combines multiple greedy heuristics and a binary-search-driven beam search to generate candidate placements, followed by a local search that iteratively optimizes the bottleneck GPU through model moves and swaps.
- **Performance**: Achieved a high combined score of 26.23 with 100% success rate and extremely fast execution (0.005s).
- **Feedback**: The hybrid approach effectively balances exploration (via diverse sorting keys and beam search) and exploitation (via local refinement), successfully handling the non-linear KV cache pressure constraint.
**Program Identifier:** Generation 33 - Patch Name beam_search_packing - Correct Program: True

**Program Name: Hybrid Greedy Ensemble with Binary Search and Local Refinement**
- **Implementation**: The algorithm employs an ensemble of greedy heuristics to initialize bounds, followed by a binary search on the target pressure that transforms the task into a bin packing problem with variable item sizes based on the target $K$. A final local search phase iteratively moves models from the highest-pressure GPU to others to further minimize the global maximum.
- **Performance**: The solution achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution time (0.006s).
- **Feedback**: The transformation of the non-linear pressure objective into a binary search over bin packing constraints was highly effective, while the use of randomized sorting keys and local search refinements successfully mitigated local optima.
**Program Identifier:** Generation 34 - Patch Name stochastic_packing_and_swaps - Correct Program: True

**Program Name: Binary Search with Beam Packing and Local Search**
- **Implementation**: The algorithm minimizes maximum KV pressure by binary searching for a target threshold, verified via a beam search packer using linearized constraints ($w + ks \le kC$) and diverse sorting strategies. A final local search phase refines the placement by iteratively moving or swapping models to relieve the bottleneck GPU.
- **Performance**: The solution achieves a high combined score of 26.23, solving all test cases with 100% success and exceptional speed (0.017s).
- **Feedback**: Linearizing the non-linear objective function allows for efficient bin packing heuristics, while the combination of beam search and local optimization robustly balances the load across GPUs.
**Program Identifier:** Generation 35 - Patch Name beam_search_packing - Correct Program: True

**Program Name: Binary Search with Beam Feasibility and Hill Climbing**
- **Implementation**: The algorithm combines binary search on target pressure with a width-5 beam search for feasibility, utilizing a sum-of-squares heuristic and symmetry breaking. A hill-climbing refinement step optimizes bottleneck GPUs via moves and swaps to dynamically tighten the search bounds.
- **Performance**: Achieved a combined score of 26.23 with a 100% success rate and 0.001s execution time.
- **Feedback**: Updating binary search bounds with results from the local search refinement accelerates convergence, while symmetry breaking in the beam search efficiently handles the placement state space.
**Program Identifier:** Generation 36 - Patch Name beam_search_opt - Correct Program: True

**Program Name: Binary Search Packing with Linearized Cost and Local Search**
- **Implementation**: The algorithm performs a binary search on the target pressure, using a greedy packing strategy with a linearized cost function and randomized sorting to verify feasibility. A post-processing hill-climbing phase further optimizes the solution by moving or swapping models to relieve the bottleneck GPU.
- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and rapid execution time (0.029s).
- **Feedback**: The linearized heuristic (`w + k * s`) effectively adapted standard bin packing to the non-linear objective, while the local search and randomized restarts significantly improved solution quality by escaping local optima.
**Program Identifier:** Generation 37 - Patch Name binary_search_noisy_sort_hill_climbing_v2 - Correct Program: True

**Program Name: Linearized Beam Search with Steepest Descent Optimization**
- **Implementation**: This approach binary searches for the target pressure `K` by transforming the problem into a bin packing variation (`w + K*s <= K*C`) solved via Beam Search with adaptive width. A subsequent steepest descent local search iteratively swaps or moves models from the bottleneck GPU to improve the maximum pressure ratio.
- **Performance**: The algorithm achieved a high combined score of 26.26 with a fast execution time of 0.002s and a 100% success rate.
- **Feedback**: Transforming the nonlinear capacity constraint into a linear form enabled the effective use of standard packing heuristics, while the hybrid constructive and iterative approach balanced speed and solution quality effectively.
**Program Identifier:** Generation 38 - Patch Name beam_search_steepest_descent - Correct Program: True

**Program Name: Binary Search Packing with Repair and Hill Climbing Optimization**
- **Implementation**: Utilizes binary search over the KVPR target using a heuristic packing check that includes a "repair" mechanism (swapping failing items with placed ones) and randomized ordering, followed by hill-climbing post-optimization to refine moves and swaps.
- **Performance**: Achieved a high score of 26.26 with extremely fast execution (0.056s) and 100% success rate.
- **Feedback**: The repair strategy efficiently handles packing failures, while the local hill-climbing optimization significantly refines the solution quality, resulting in a robust and high-performing algorithm.
**Program Identifier:** Generation 39 - Patch Name hybrid_optimized_placement - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

Based on the provided evaluation results and the code of the Current Best Program, here is the analysis of algorithmic patterns, implementation details, and performance trends.

## Successful Algorithmic Patterns
- **Randomized Feasibility Search within Binary Search:** The distinct step up in performance from a score of 26.23 to 26.26 is exclusively associated with programs that incorporate stochastic elements into the construction phase. The **Current Best Program**, along with **Generation 32, 37, and 39**, utilizes randomized shuffling or "noisy" sorting within the feasibility check loop. This allows the algorithm to find valid permutations for tighter $K$ targets that deterministic heuristics miss.
- **Dynamic Constraint Linearization:** Top-scoring programs (Current Best, **Generation 37, 38**) successfully linearize the non-linear KVPR objective. The **Current Best Program** specifically uses a dynamic sorting strategy where the sort key changes based on the binary search's current target: `lambda x: x['w'] + k_target * x['s']`. This effectively transforms the problem into a parameterized bin packing problem where the "cost" of an item shifts relative to the tightness of the memory constraint.
- **Aggressive Bound Tightening via Actual Maxima:** A critical optimization in the **Current Best Program** is updating the binary search's upper bound (`high`) to the *actual* maximum KVPR observed in a valid placement, rather than the tested `mid` value. This technique, also hinted at in **Generation 36**, accelerates convergence and allows the binary search to "snap" to the true optimal value rather than just bisecting toward it.

## Ineffective Approaches
- **Pure Deterministic Heuristics (The 26.23 Ceiling):** A clear pattern has emerged where purely deterministic algorithms—regardless of complexity—plateau at a score of 26.23. **Generation 30, 33, 34, 35, and 36** all employed sophisticated techniques like Beam Search, Greedy Ensembles, and Local Search refinement but lacked randomization. The evaluation confirms that without stochastic exploration, these methods get stuck in the same local optima (structural limit of deterministic packing).
- **Complex In-Place Modifications:** **Generation 31** attempted a complex "Ejection Chain Search" which resulted in a 0.00 score and 0% success rate. The complexity of managing state transitions (moves, swaps, 3-cycles) in-place without a robust fallback or validation mechanism led to system-wide failures, likely due to invalid states or unhandled exceptions during the bin packing checks.
- **Post-Placement Refinement Without Randomized Construction:** While local search (Hill Climbing) is beneficial, it cannot compensate for a suboptimal construction bound. Programs that relied heavily on refining a deterministic initial placement (seen in earlier generations and implicit in the feedback for **Gen 30, 33**) could not break the 26.23 barrier. The "Current Best" proves that optimizing the *construction* (finding the right `K`) is more impactful than fixing the solution afterwards.

## Implementation Insights
- **Tiered Feasibility Strategy:** The **Current Best Program** exhibits a highly effective "tiered" approach to feasibility checking to balance speed and quality. It first attempts four computationally cheap deterministic sorts (Dynamic Weight, Size, Weight, Density). Only if these fail does it engage the computationally expensive loop of 50 randomized shuffles. This ensures easy cases are solved in ~0.001s, while hard cases get the necessary CPU cycles (up to ~0.097s) to find optimal solutions.
- **Robust Floating-Point Comparisons:** The **Current Best Program** handles the non-linear constraint safely by rewriting `w / rem <= K` as `w <= K * rem + 1e-9`. It explicitly handles the edge case where `rem_mem` approaches zero (`rem_mem <= 1e-9`). This implementation detail prevents numerical instability and ensures that placements are valid even when GPUs are filled to capacity.
- **Function-Encapsulated Packing Logic:** High-performing implementations like the **Current Best** and **Generation 32** encapsulate the packing logic into a helper function (e.g., `try_pack`). This allows the main binary search loop to easily swap strategies (changing sort keys or shuffling input) without duplicating the complex bin-packing validation logic.

## Performance Analysis
- **The Stochastic Gap (26.23 vs 26.26):** There is a definitive performance stratification. Deterministic programs (**Gen 30, 33-36**) consistently score **26.23**. Programs that introduce randomization during construction (**Current Best, Gen 32, 37, 39**) consistently score **26.26**. This 0.03 difference represents the margin between a "good" greedy fit and an "optimal" stochastic fit.
- **Computational Cost of Optimality:** The **Current Best Program** runs in **0.097s**, which is significantly slower than the fastest deterministic solutions (e.g., **Gen 36** at 0.001s). However, since the scoring metric prioritizes the objective value (Score), this trade-off is optimal. The algorithm spends extra time only when necessary (via the fallback shuffle loop) to squeeze out the final marginal gains.
- **Success Rate Convergence:** Aside from the buggy **Generation 31**, every evaluated program achieved a 100% success rate. The challenge has effectively shifted entirely from "constraint satisfaction" to "objective minimization." The standard for a correct program now implies using Binary Search on a linearized constraint; the differentiator is purely the ability to minimize `K`.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the analysis of the Current Best Program and the global insights, here are 5 actionable recommendations for future program mutations:

1.  **Implement "Noisy Heuristic" Sorting**
    Replace the uniform random shuffling in the stochastic loop with a "perturbed sort" mechanism. Instead of `rng.shuffle(indices)`, sort the items using the successful heuristic with multiplicative noise: `key = (w + k_target * s) * uniform(0.9, 1.1)`. This keeps the search focused on the high-probability neighborhood of the optimal deterministic order, rather than exploring the entire permutation space blindly.

2.  **Upgrade Greedy Packing to Limited Beam Search**
    Modify the `try_pack` function to use a low-width Beam Search (e.g., width=3) instead of a purely greedy approach. By maintaining the top 3 partial placement states (ranked by residual capacity or linearized cost) at each step, the algorithm can backtrack locally to escape structural traps that cause the current single-path greedy logic to fail on tight $K$ targets.

3.  **Integrate Failure-Driven Prioritization**
    Enhance the stochastic loop to learn from previous failed iterations within the same check. If a packing attempt fails because a specific item fits nowhere, record that item and force it to be placed at the beginning of the queue in the next iteration. This effectively automates a "hardest-item-first" heuristic customized to the specific bottleneck of the current dataset.

4.  **Diversify Bin Selection Criteria**
    The current algorithm exclusively uses a "Best Fit" strategy (maximizing `w + K*s` in the bin), which tends to fill GPUs to capacity and can create unbalance. Introduce a secondary strategy in the stochastic loop that selects the "Least Loaded" GPU (maximizing remaining space) or minimizes the variance of `KVPR` across GPUs. Alternating between packing tight and load balancing increases the probability of finding a valid configuration.

5.  **Add Hyperbolic Sorting Keys**
    Expand the deterministic strategy pool with non-linear keys that better model the KVPR constraint `w / rem <= K`. Specifically, add a sort key `lambda x: x['w'] / (GPU_MEM_SIZE - x['s'] + 1e-9)`. This directly correlates with the "cost" of an item as the bin fills up and may solve difficult cases deterministically without triggering the expensive randomized fallback loop.