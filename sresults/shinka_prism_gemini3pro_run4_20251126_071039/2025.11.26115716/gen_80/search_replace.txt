<NAME>
adaptive_search_and_steepest_descent
</NAME>

<DESCRIPTION>
1. Implements Adaptive Stochastic Depth in the binary search. It increases the number of random trials in later iterations where the search bounds are tighter, optimizing the trade-off between speed and thoroughness.
2. Replaces the "First Improvement" Local Search with a "Steepest Descent" approach. It evaluates all possible moves and swaps involving the bottleneck GPU and selects the one that minimizes the resulting peak pressure (primary) and sum of squared pressures (secondary). This helps in making more optimal decisions and breaking ties effectively to achieve better load balancing.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # -------------------------------------------------------
    # 2. Binary Search
    # -------------------------------------------------------
    # Perform search to push K down.
    # The stochastic packer gives us a good chance to find a valid config if one exists near 'mid'.
    if high > low + 1e-4:
        # Number of BS iterations
        for _ in range(32):
            mid = (low + high) / 2.0

            # Use randomization to try harder to fit into 'mid'
            # Increased trials to leverage failure-driven adaptation and new packing modes
            sol = try_pack(mid, max_random_trials=32)

            if sol:
=======
    # -------------------------------------------------------
    # 2. Binary Search
    # -------------------------------------------------------
    # Perform search to push K down.
    # The stochastic packer gives us a good chance to find a valid config if one exists near 'mid'.
    if high > low + 1e-4:
        # Number of BS iterations
        for bs_iter in range(32):
            mid = (low + high) / 2.0

            # Adaptive Stochastic Depth: Increase trials as we narrow down (bounds converge)
            # Early iterations: loose bounds, easy to check -> few trials
            # Late iterations: tight bounds, hard to check -> many trials
            adaptive_trials = 10 + int(40 * (bs_iter / 31.0))

            # Use randomization to try harder to fit into 'mid'
            sol = try_pack(mid, max_random_trials=adaptive_trials)

            if sol:
>>>>>>> REPLACE
<<<<<<< SEARCH
    # Optimization Loop
    for _ in range(250):
        # Identify bottleneck
        max_p = -1.0
        src_gpu = -1
        for g in range(gpu_num):
            if g_stats[g]['p'] > max_p:
                max_p = g_stats[g]['p']
                src_gpu = g

        if src_gpu == -1 or max_p < 1e-9: break

        improved = False
        src_list = curr_map[src_gpu]

        # 3.1 Try Move
        for list_idx, m_idx in enumerate(src_list):
            m = m_data[m_idx]

            # Src State if moved
            src_rem_new = GPU_MEM_SIZE - (g_stats[src_gpu]['s'] - m['s'])
            src_w_new = g_stats[src_gpu]['w'] - m['w']
            src_p_new = src_w_new / src_rem_new if src_rem_new > 1e-9 else (float('inf') if src_w_new > 0 else 0.0)

            best_move_dst = None

            for dst in range(gpu_num):
                if dst == src_gpu: continue
                if g_stats[dst]['s'] + m['s'] > GPU_MEM_SIZE: continue

                dst_rem_new = GPU_MEM_SIZE - (g_stats[dst]['s'] + m['s'])
                dst_w_new = g_stats[dst]['w'] + m['w']
                dst_p_new = dst_w_new / dst_rem_new if dst_rem_new > 1e-9 else (float('inf') if dst_w_new > 0 else 0.0)

                if max(src_p_new, dst_p_new) < max_p - 1e-5:
                    best_move_dst = dst
                    break # First improvement is fine

            if best_move_dst is not None:
                # Apply Move
                curr_map[src_gpu].pop(list_idx)
                curr_map[best_move_dst].append(m_idx)

                # Update Stats
                g_stats[src_gpu]['w'] = src_w_new
                g_stats[src_gpu]['s'] = GPU_MEM_SIZE - src_rem_new
                g_stats[src_gpu]['p'] = src_p_new

                dst_rem = GPU_MEM_SIZE - (g_stats[best_move_dst]['s'] + m['s'])
                dst_w = g_stats[best_move_dst]['w'] + m['w']
                dst_p = dst_w / dst_rem if dst_rem > 1e-9 else (float('inf') if dst_w > 0 else 0.0)
                g_stats[best_move_dst] = {'w': dst_w, 's': GPU_MEM_SIZE - dst_rem, 'p': dst_p}

                improved = True
                break

        if improved: continue

        # 3.2 Try Swap (only if move failed)
        # To save time, only check top heavy items from src or random subset? No, check all for now (usually few items per GPU)
        for s_list_idx, m_src_idx in enumerate(src_list):
            m_src = m_data[m_src_idx]

            for dst in range(gpu_num):
                if dst == src_gpu: continue
                dst_list = curr_map[dst]

                for d_list_idx, m_dst_idx in enumerate(dst_list):
                    m_dst = m_data[m_dst_idx]

                    # Capacity Check
                    new_src_s = g_stats[src_gpu]['s'] - m_src['s'] + m_dst['s']
                    if new_src_s > GPU_MEM_SIZE: continue

                    new_dst_s = g_stats[dst]['s'] - m_dst['s'] + m_src['s']
                    if new_dst_s > GPU_MEM_SIZE: continue

                    # Pressure Check
                    new_src_rem = GPU_MEM_SIZE - new_src_s
                    new_src_w = g_stats[src_gpu]['w'] - m_src['w'] + m_dst['w']
                    new_src_p = new_src_w / new_src_rem if new_src_rem > 1e-9 else float('inf')

                    new_dst_rem = GPU_MEM_SIZE - new_dst_s
                    new_dst_w = g_stats[dst]['w'] - m_dst['w'] + m_src['w']
                    new_dst_p = new_dst_w / new_dst_rem if new_dst_rem > 1e-9 else float('inf')

                    if max(new_src_p, new_dst_p) < max_p - 1e-5:
                        # Apply Swap
                        curr_map[src_gpu].pop(s_list_idx)
                        curr_map[src_gpu].append(m_dst_idx)

                        curr_map[dst].pop(d_list_idx)
                        curr_map[dst].append(m_src_idx)

                        g_stats[src_gpu] = {'w': new_src_w, 's': new_src_s, 'p': new_src_p}
                        g_stats[dst] = {'w': new_dst_w, 's': new_dst_s, 'p': new_dst_p}

                        improved = True
                        break
                if improved: break
            if improved: break

        if not improved: break
=======
    # Optimization Loop (Steepest Descent with Tie-Breaking)
    # Objective: Minimize Max KVPR. Secondary: Minimize Sum of Squared KVPR.

    # Calculate initial sum of squares
    sum_sq_p = sum(gs['p']**2 for gs in g_stats)

    for _ in range(300):
        # Identify bottleneck
        max_p = -1.0
        src_gpu = -1
        for g in range(gpu_num):
            if g_stats[g]['p'] > max_p:
                max_p = g_stats[g]['p']
                src_gpu = g

        if src_gpu == -1 or max_p < 1e-9: break

        best_action = None # (type, improvement_metric, details)
        # improvement_metric: (new_max_pair, new_sum_sq_delta) - minimize this

        src_list = curr_map[src_gpu]

        # 3.1 Evaluate Moves (Src -> Dst)
        for list_idx, m_idx in enumerate(src_list):
            m = m_data[m_idx]

            src_rem_new = GPU_MEM_SIZE - (g_stats[src_gpu]['s'] - m['s'])
            src_w_new = g_stats[src_gpu]['w'] - m['w']
            src_p_new = src_w_new / src_rem_new if src_rem_new > 1e-9 else (float('inf') if src_w_new > 0 else 0.0)

            for dst in range(gpu_num):
                if dst == src_gpu: continue
                if g_stats[dst]['s'] + m['s'] > GPU_MEM_SIZE: continue

                dst_rem_new = GPU_MEM_SIZE - (g_stats[dst]['s'] + m['s'])
                dst_w_new = g_stats[dst]['w'] + m['w']
                dst_p_new = dst_w_new / dst_rem_new if dst_rem_new > 1e-9 else (float('inf') if dst_w_new > 0 else 0.0)

                new_max_pair = max(src_p_new, dst_p_new)

                # Check strict improvement on max_p for the involved pair
                if new_max_pair >= max_p - 1e-7: continue

                # Delta Sum Sq: (new_src^2 + new_dst^2) - (old_src^2 + old_dst^2)
                delta_sq = (src_p_new**2 + dst_p_new**2) - (g_stats[src_gpu]['p']**2 + g_stats[dst]['p']**2)

                metric = (new_max_pair, delta_sq)

                if best_action is None or metric < best_action[1]:
                    best_action = ('move', metric, (list_idx, dst, m_idx, src_p_new, dst_p_new))

        # 3.2 Evaluate Swaps (Src <-> Dst)
        for s_list_idx, m_src_idx in enumerate(src_list):
            m_src = m_data[m_src_idx]

            for dst in range(gpu_num):
                if dst == src_gpu: continue
                dst_list = curr_map[dst]

                for d_list_idx, m_dst_idx in enumerate(dst_list):
                    m_dst = m_data[m_dst_idx]

                    new_src_s = g_stats[src_gpu]['s'] - m_src['s'] + m_dst['s']
                    if new_src_s > GPU_MEM_SIZE: continue
                    new_dst_s = g_stats[dst]['s'] - m_dst['s'] + m_src['s']
                    if new_dst_s > GPU_MEM_SIZE: continue

                    new_src_rem = GPU_MEM_SIZE - new_src_s
                    new_src_w = g_stats[src_gpu]['w'] - m_src['w'] + m_dst['w']
                    new_src_p = new_src_w / new_src_rem if new_src_rem > 1e-9 else float('inf')

                    new_dst_rem = GPU_MEM_SIZE - new_dst_s
                    new_dst_w = g_stats[dst]['w'] - m_dst['w'] + m_src['w']
                    new_dst_p = new_dst_w / new_dst_rem if new_dst_rem > 1e-9 else float('inf')

                    new_max_pair = max(new_src_p, new_dst_p)

                    if new_max_pair >= max_p - 1e-7: continue

                    delta_sq = (new_src_p**2 + new_dst_p**2) - (g_stats[src_gpu]['p']**2 + g_stats[dst]['p']**2)
                    metric = (new_max_pair, delta_sq)

                    if best_action is None or metric < best_action[1]:
                        best_action = ('swap', metric, (s_list_idx, dst, d_list_idx, m_src_idx, m_dst_idx, new_src_p, new_dst_p))

        # Execute Best Action
        if best_action:
            act_type, _, details = best_action
            if act_type == 'move':
                s_list_idx, dst_gpu, m_idx, sp, dp = details
                m = m_data[m_idx]

                curr_map[src_gpu].pop(s_list_idx)
                curr_map[dst_gpu].append(m_idx)

                g_stats[src_gpu]['w'] -= m['w']
                g_stats[src_gpu]['s'] -= m['s']
                g_stats[src_gpu]['p'] = sp

                g_stats[dst_gpu]['w'] += m['w']
                g_stats[dst_gpu]['s'] += m['s']
                g_stats[dst_gpu]['p'] = dp

                sum_sq_p += best_action[1][1]

            elif act_type == 'swap':
                s_l_idx, dst_gpu, d_l_idx, m_s_idx, m_d_idx, sp, dp = details
                m_s = m_data[m_s_idx]
                m_d = m_data[m_d_idx]

                curr_map[src_gpu][s_l_idx] = m_d_idx
                curr_map[dst_gpu][d_l_idx] = m_s_idx

                g_stats[src_gpu]['w'] = g_stats[src_gpu]['w'] - m_s['w'] + m_d['w']
                g_stats[src_gpu]['s'] = g_stats[src_gpu]['s'] - m_s['s'] + m_d['s']
                g_stats[src_gpu]['p'] = sp

                g_stats[dst_gpu]['w'] = g_stats[dst_gpu]['w'] - m_d['w'] + m_s['w']
                g_stats[dst_gpu]['s'] = g_stats[dst_gpu]['s'] - m_d['s'] + m_s['s']
                g_stats[dst_gpu]['p'] = dp

                sum_sq_p += best_action[1][1]
        else:
            break
>>>>>>> REPLACE
</DIFF>