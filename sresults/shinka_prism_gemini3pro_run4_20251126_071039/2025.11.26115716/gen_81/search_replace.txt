<NAME>
enhanced_bin_packing_strategies
</NAME>

<DESCRIPTION>
Improves the Binary Search phase by diversifying the packing strategies used in the feasibility check.
1.  Introduces 'Density' (weight/size) as a sorting key.
2.  Adds a 'Worst Fit' bin selection mode (interleaved with Best Fit) to better explore the solution space by load balancing when capacity permits.
3.  Increases the number of random trials per check from 30 to 50 to utilize available time budget.
4.  Adds 'Density' heuristic to the initial greedy ensemble.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        (lambda m: (m.req_rate / m.slo) / (GPU_MEM_SIZE - m.model_size + 1e-6), 'min_result'),
        (lambda m: m.req_rate / m.slo, 'min_current'),
        # Linearized pressure heuristic: w + K*s
        (lambda m: (m.req_rate / m.slo) + k_est * m.model_size, 'min_result'),
    ]
=======
        (lambda m: (m.req_rate / m.slo) / (GPU_MEM_SIZE - m.model_size + 1e-6), 'min_result'),
        (lambda m: m.req_rate / m.slo, 'min_current'),
        (lambda m: (m.req_rate / m.slo) / (m.model_size + 1e-6), 'min_result'),
        # Linearized pressure heuristic: w + K*s
        (lambda m: (m.req_rate / m.slo) + k_est * m.model_size, 'min_result'),
    ]
>>>>>>> REPLACE
<<<<<<< SEARCH
                # Randomized Best Fit Decreasing Check with Failure Memory
                found_placement = None
                failed_items = set()

                # Strategies for sorting: Effective Size, Physical Size, Weight
                strategies = [
                    lambda m: m.model_size + (m.req_rate / m.slo) / mid,
                    lambda m: m.model_size,
                    lambda m: m.req_rate / m.slo
                ]

                for attempt in range(30):
                    base_key = strategies[attempt % len(strategies)]

                    noise = 0.0
                    if attempt > 3:
                        noise = 0.01 + (attempt * 0.003)

                    def sort_key(m):
                        val = base_key(m)
                        if noise > 0:
                            val *= random.uniform(1.0 - noise, 1.0 + noise)
                        # Memory: Prioritize items that failed previously
                        if id(m) in failed_items:
                            val += 1e9
                        return val

                    bs_models = sorted(models, key=sort_key, reverse=True)

                    temp_placement = {i: [] for i in range(gpu_num)}
                    gpu_w = [0.0] * gpu_num
                    gpu_s = [0.0] * gpu_num
                    possible_k = True
                    first_fail_model = None

                    for model in bs_models:
                        w = model.req_rate / model.slo
                        s = model.model_size
                        eff = s + w/mid

                        best_idx = None
                        min_rem_eff = float('inf')

                        # Best Fit on Effective Capacity
                        for i in range(gpu_num):
                            if gpu_s[i] + s > GPU_MEM_SIZE: continue

                            curr_eff = gpu_s[i] + gpu_w[i]/mid
                            if curr_eff + eff <= GPU_MEM_SIZE + 1e-6:
                                rem_eff = GPU_MEM_SIZE - (curr_eff + eff)
                                if rem_eff < min_rem_eff:
                                    min_rem_eff = rem_eff
                                    best_idx = i

                        if best_idx is None:
                            possible_k = False
                            first_fail_model = model
                            break

                        temp_placement[best_idx].append(model)
                        gpu_w[best_idx] += w
                        gpu_s[best_idx] += s

                    if possible_k:
                        found_placement = temp_placement
                        break
                    else:
                        if first_fail_model:
                            failed_items.add(id(first_fail_model))
=======
                # Randomized Multi-Strategy Packing Check with Failure Memory
                found_placement = None
                failed_items = set()

                # Strategies: (sort_key_lambda, bin_selection_mode)
                base_strategies = [
                    (lambda m: m.model_size + (m.req_rate / m.slo) / mid, 'best_fit'),
                    (lambda m: m.model_size, 'best_fit'),
                    (lambda m: m.req_rate / m.slo, 'best_fit'),
                    (lambda m: (m.req_rate / m.slo) / (m.model_size + 1e-6), 'best_fit'),
                ]

                for attempt in range(50):
                    # Cycle strategies
                    base_key, fit_mode = base_strategies[attempt % len(base_strategies)]

                    # Interleave Worst Fit occasionally to diversify bin usage
                    if attempt % 7 == 6:
                        fit_mode = 'worst_fit'

                    noise = 0.0
                    if attempt >= len(base_strategies):
                        noise = 0.01 + (attempt * 0.002)

                    def sort_key(m):
                        val = base_key(m)
                        if noise > 0:
                            val *= random.uniform(1.0 - noise, 1.0 + noise)
                        if id(m) in failed_items:
                            val += 1e9
                        return val

                    bs_models = sorted(models, key=sort_key, reverse=True)

                    temp_placement = {i: [] for i in range(gpu_num)}
                    gpu_w = [0.0] * gpu_num
                    gpu_s = [0.0] * gpu_num
                    possible_k = True
                    first_fail_model = None

                    for model in bs_models:
                        w = model.req_rate / model.slo
                        s = model.model_size
                        eff = s + w/mid

                        best_idx = None

                        if fit_mode == 'best_fit':
                            best_metric = float('inf')
                        else:
                            best_metric = -1.0

                        for i in range(gpu_num):
                            if gpu_s[i] + s > GPU_MEM_SIZE: continue

                            curr_eff = gpu_s[i] + gpu_w[i]/mid
                            if curr_eff + eff <= GPU_MEM_SIZE + 1e-6:
                                rem_eff = GPU_MEM_SIZE - (curr_eff + eff)

                                if fit_mode == 'best_fit':
                                    if rem_eff < best_metric:
                                        best_metric = rem_eff
                                        best_idx = i
                                else:
                                    if rem_eff > best_metric:
                                        best_metric = rem_eff
                                        best_idx = i

                        if best_idx is None:
                            possible_k = False
                            first_fail_model = model
                            break

                        temp_placement[best_idx].append(model)
                        gpu_w[best_idx] += w
                        gpu_s[best_idx] += s

                    if possible_k:
                        found_placement = temp_placement
                        break
                    else:
                        if first_fail_model:
                            failed_items.add(id(first_fail_model))
>>>>>>> REPLACE
</DIFF>