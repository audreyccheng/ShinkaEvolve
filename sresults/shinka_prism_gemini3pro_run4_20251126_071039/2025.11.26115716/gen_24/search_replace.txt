<NAME>
implement_beam_search
</NAME>

<DESCRIPTION>
Replace the randomized greedy packing strategy in the binary search feasibility check with a deterministic Beam Search.
The Beam Search maintains multiple partial placement states (beams) and expands them by placing the next item into available GPUs.
It uses a scoring function (sum of squares of linearized loads) that aligns with the Best-Fit heuristic to prioritize tight packing, but the beam width allows escaping local optima that a single greedy pass would miss.
Symmetry breaking is applied to identical bins to improve efficiency.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def pack(k_target, max_attempts=5):
        """
        Try to pack items into gpu_num bins such that for all j:
        sum(w) / (C - sum(s)) <= k_target
        Equivalently: sum(w + k_target*s) <= k_target * C
        """

        # Helper for a single packing attempt
        def try_order(ordered_items):
            # Track current usage
            # Linear Capacity = K * C
            # Item Linear Size = w + K * s
            # We use Best Fit Decreasing on Linear Size to minimize wasted Linear Capacity

            pl = [[] for _ in range(gpu_num)]
            g_w = [0.0] * gpu_num
            g_s = [0.0] * gpu_num

            for item in ordered_items:
                w = item['w']
                s = item['s']
                # Cost in the linearized domain
                cost = w + k_target * s

                best_idx = -1
                best_residue = float('inf')

                for i in range(gpu_num):
                    # Hard memory limit
                    if g_s[i] + s > GPU_MEM_SIZE:
                        continue

                    # KVPR / Linear Capacity Limit
                    # Current load: g_w + K * g_s
                    # New load: (g_w + w) + K * (g_s + s)
                    current_lin_load = g_w[i] + k_target * g_s[i]
                    new_lin_load = current_lin_load + cost
                    limit = k_target * GPU_MEM_SIZE

                    if new_lin_load > limit + 1e-5:
                        continue

                    # Best Fit: Minimize remaining space in the linearized bin
                    # residue = limit - new_lin_load
                    # We want to minimize residue => maximize new_lin_load
                    residue = limit - new_lin_load

                    if residue < best_residue:
                        best_residue = residue
                        best_idx = i

                if best_idx != -1:
                    pl[best_idx].append(item['model'])
                    g_w[best_idx] += w
                    g_s[best_idx] += s
                else:
                    return None
            return pl

        # 1. Deterministic Strategy
        # Sort by decreasing linear cost: w + k*s
        base_items = sorted(items, key=lambda x: x['w'] + k_target * x['s'], reverse=True)
        res = try_order(base_items)
        if res: return res

        # 2. Randomized Restarts (Noisy Sorting)
        if max_attempts > 0:
            # Seed based on k_target to ensure determinism for the same call
            rng = random.Random(hash(k_target))
            for _ in range(max_attempts):
                # Perturb the sort keys by +/- 10%
                # This keeps the general "heavy first" heuristic but changes local ordering
                noisy_items = sorted(items, key=lambda x: (x['w'] + k_target * x['s']) * rng.uniform(0.9, 1.1), reverse=True)
                res = try_order(noisy_items)
                if res: return res

        return None

    # 2. Binary Search
    best_pl_list = None

    # Initial Check at High Bound
    high = 1e9
    # Quick check
    if not pack(high, 0):
        # Detailed check
        if not pack(high, 20):
            raise ValueError("Unable to place models on GPUs (insufficient memory).")

    # If high check passed, we have a candidate. But pack(high) creates a packing valid for K=1e9.
    # We want to measure its actual K to tighten 'high'.
    # Re-run pack to capture the result
    best_pl_list = pack(high, 20)
    high = get_max_kvpr(best_pl_list)
    if high == float('inf'): high = 1e9

    low = k_min

    # Search Loop
    for _ in range(25):
        if high - low < 1e-4: break
        mid = (low + high) / 2

        # Try to pack with K = mid
        res = pack(mid, max_attempts=5)

        if res:
            best_pl_list = res
            actual_max = get_max_kvpr(res)
            # If we found a valid packing with actual max KVPR 'actual_max',
            # we know a solution exists for K = actual_max.
            # And by definition actual_max <= mid (since it fit in mid).
            # So we can safely lower high to actual_max.
            high = min(mid, actual_max)
        else:
            low = mid

    # Convert to dict format
    final_pl = {i: best_pl_list[i] for i in range(gpu_num)}
=======
    def pack(k_target, beam_width=1):
        """
        Try to pack items into gpu_num bins with linearized capacity constraints.
        Uses Beam Search to find a valid assignment.
        """
        limit_val = k_target * GPU_MEM_SIZE

        # Sort items by decreasing linear cost
        sorted_items = []
        for m_item in items:
            cost = m_item['w'] + k_target * m_item['s']
            sorted_items.append({'model': m_item['model'], 'w': m_item['w'], 's': m_item['s'], 'cost': cost})
        sorted_items.sort(key=lambda x: x['cost'], reverse=True)

        # Beam Search State: {'loads': [{'w', 's', 'lin'}], 'pl': [[models]], 'score': val}
        initial_loads = [{'w': 0.0, 's': 0.0, 'lin': 0.0} for _ in range(gpu_num)]
        initial_pl = [[] for _ in range(gpu_num)]
        # Score 0 initially
        beam = [{'loads': initial_loads, 'pl': initial_pl, 'score': 0.0}]

        if beam_width < 1: beam_width = 1

        for item in sorted_items:
            w, s, cost = item['w'], item['s'], item['cost']
            candidates = []

            for state in beam:
                seen_states = set()

                for i in range(gpu_num):
                    b = state['loads'][i]

                    # Capacity checks
                    if b['s'] + s > GPU_MEM_SIZE: continue
                    new_lin = b['lin'] + cost
                    if new_lin > limit_val + 1e-5: continue

                    # Symmetry breaking
                    # If multiple empty/identical bins exist in this state, only try one
                    state_sig = (round(b['s'], 5), round(b['lin'], 5))
                    if state_sig in seen_states: continue
                    seen_states.add(state_sig)

                    # Create new state
                    new_loads = state['loads'][:]
                    new_bin = b.copy()
                    new_bin['w'] += w
                    new_bin['s'] += s
                    new_bin['lin'] = new_lin
                    new_loads[i] = new_bin

                    new_pl = state['pl'][:]
                    new_pl[i] = state['pl'][i] + [item['model']]

                    # Best Fit heuristic score: maximize sum of squares of linear loads
                    # Promotes tight packing (uneven distribution)
                    new_score = state['score'] - (b['lin']**2) + (new_lin**2)

                    candidates.append({'loads': new_loads, 'pl': new_pl, 'score': new_score})

            if not candidates:
                return None

            # Prune to beam_width
            if len(candidates) > beam_width:
                # Sort by score descending
                candidates.sort(key=lambda x: x['score'], reverse=True)
                beam = candidates[:beam_width]
            else:
                beam = candidates

        return beam[0]['pl']

    # 2. Binary Search
    best_pl_list = None

    # Initial Check at High Bound
    high = 1e9
    # Quick check with greedy (beam_width=1)
    best_pl_list = pack(high, 1)
    if not best_pl_list:
        # Detailed check with wide beam
        best_pl_list = pack(high, 50)
        if not best_pl_list:
            raise ValueError("Unable to place models on GPUs (insufficient memory).")

    # Refine high bound using actual max KVPR of the valid solution
    high = get_max_kvpr(best_pl_list)
    if high == float('inf'): high = 1e9

    low = k_min

    # Search Loop
    for _ in range(25):
        if high - low < 1e-4: break
        mid = (low + high) / 2

        # Try to pack with Beam Search (width 8 gives robustness)
        res = pack(mid, beam_width=8)

        if res:
            best_pl_list = res
            actual_max = get_max_kvpr(res)
            high = min(mid, actual_max)
        else:
            low = mid

    # Convert to dict format
    final_pl = {i: best_pl_list[i] for i in range(gpu_num)}
>>>>>>> REPLACE
</DIFF>