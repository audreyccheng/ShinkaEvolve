<NAME>
failure_driven_packing
</NAME>

<DESCRIPTION>
Refine the feasibility checking function `solve_check` to use Failure-Driven Prioritization.
When the Beam Search packing fails to place an item, the function now returns the item that caused the failure. In the randomized attempts loop, instead of blindly re-shuffling or re-sorting with noise, the algorithm moves the failed item to the front of the list for the next attempt. This heuristic greedily attempts to place the most difficult items (those that failed previously) into empty bins first, significantly improving the chances of finding a valid packing for tighter KVPR constraints.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def solve_check(k_target, beam_width=4, attempts=0):
        """
        Check feasibility for K using Beam Search with multiple sorting strategies.
        Constraint: Sum(w + K*s) <= K*C for each bin.
        """
        limit = k_target * GPU_MEM_SIZE

        def run_beam(ordered_items):
            # Beam State: (score, loads_tuple, placement_list)
            start_loads = tuple([0.0] * gpu_num)
            start_pl = tuple([[] for _ in range(gpu_num)])
            beam = [(0.0, start_loads, start_pl)]

            for item_data in ordered_items:
                # Calculate cost for this specific item
                cost = item_data['w'] + k_target * item_data['s']
                if cost > limit + 1e-5: return None

                candidates = []
                seen_signatures = set()

                for score, loads, pl in beam:
                    tried_loads = set()
                    for i in range(gpu_num):
                        current_l = loads[i]
                        if current_l in tried_loads: continue

                        if current_l + cost <= limit + 1e-5:
                            tried_loads.add(current_l)

                            new_loads_list = list(loads)
                            new_loads_list[i] += cost

                            # Symmetry breaking
                            sig = tuple(sorted(new_loads_list))
                            if sig in seen_signatures: continue
                            seen_signatures.add(sig)

                            new_pl_list = list(pl)
                            new_pl_list[i] = pl[i] + [item_data]

                            # Best Fit Heuristic: Sum of squares
                            new_score = sum(l*l for l in new_loads_list)
                            candidates.append((new_score, tuple(new_loads_list), tuple(new_pl_list)))

                if not candidates:
                    return None

                # Sort descending by score (Best Fit)
                candidates.sort(key=lambda x: x[0], reverse=True)
                beam = candidates[:beam_width]

            return beam[0][2]

        # Strategies: 1. Linearized Cost, 2. Size, 3. Density
        keys = [
            lambda x: x['w'] + k_target * x['s'],
            lambda x: x['s'],
            lambda x: x['w'] / (x['s'] + 1e-9)
        ]

        for key in keys:
            res = run_beam(sorted(items, key=key, reverse=True))
            if res: return res

        if attempts > 0:
            rng = random.Random(42 + int(k_target * 1000))
            base_key = lambda x: x['w'] + k_target * x['s']
            for _ in range(attempts):
                # Add noise to the sort key
                noisy_items = sorted(items, key=lambda x: base_key(x) * rng.uniform(0.9, 1.1), reverse=True)
                res = run_beam(noisy_items)
                if res: return res

        return None
=======
    def solve_check(k_target, beam_width=4, attempts=0):
        """
        Check feasibility for K using Beam Search with multiple sorting strategies.
        Constraint: Sum(w + K*s) <= K*C for each bin.
        Returns: Placement (list of lists) or None.
        """
        limit = k_target * GPU_MEM_SIZE

        def run_beam(ordered_items):
            # Beam State: (score, loads_tuple, placement_list)
            start_loads = tuple([0.0] * gpu_num)
            start_pl = tuple([[] for _ in range(gpu_num)])
            beam = [(0.0, start_loads, start_pl)]

            for item_data in ordered_items:
                # Calculate cost for this specific item
                cost = item_data['w'] + k_target * item_data['s']
                if cost > limit + 1e-5: return None, item_data

                candidates = []
                seen_signatures = set()

                for score, loads, pl in beam:
                    tried_loads = set()
                    for i in range(gpu_num):
                        current_l = loads[i]
                        if current_l in tried_loads: continue

                        if current_l + cost <= limit + 1e-5:
                            tried_loads.add(current_l)

                            new_loads_list = list(loads)
                            new_loads_list[i] += cost

                            # Symmetry breaking
                            sig = tuple(sorted(new_loads_list))
                            if sig in seen_signatures: continue
                            seen_signatures.add(sig)

                            new_pl_list = list(pl)
                            new_pl_list[i] = pl[i] + [item_data]

                            # Best Fit Heuristic: Sum of squares
                            new_score = sum(l*l for l in new_loads_list)
                            candidates.append((new_score, tuple(new_loads_list), tuple(new_pl_list)))

                if not candidates:
                    return None, item_data

                # Sort descending by score (Best Fit)
                candidates.sort(key=lambda x: x[0], reverse=True)
                beam = candidates[:beam_width]

            return beam[0][2], None

        # Strategies: 1. Linearized Cost, 2. Size, 3. Density
        keys = [
            lambda x: x['w'] + k_target * x['s'],
            lambda x: x['s'],
            lambda x: x['w'] / (x['s'] + 1e-9)
        ]

        for key in keys:
            res, _ = run_beam(sorted(items, key=key, reverse=True))
            if res: return res

        if attempts > 0:
            rng = random.Random(42 + int(k_target * 1000))
            base_key = lambda x: x['w'] + k_target * x['s']

            # Start with a noisy linearized sort
            current_items = sorted(items, key=lambda x: base_key(x) * rng.uniform(0.9, 1.1), reverse=True)

            for _ in range(attempts):
                res, failed_item = run_beam(current_items)
                if res: return res

                # Failure-Driven Prioritization: Move failed item to front
                if failed_item:
                    try:
                        idx = current_items.index(failed_item)
                        if idx == 0:
                            # Item too large to fit even in empty bin, or stuck
                            break
                        current_items.pop(idx)
                        current_items.insert(0, failed_item)
                    except ValueError:
                        rng.shuffle(current_items)
                else:
                    rng.shuffle(current_items)

        return None
>>>>>>> REPLACE
</DIFF>