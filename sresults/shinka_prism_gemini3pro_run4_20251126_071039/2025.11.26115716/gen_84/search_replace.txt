<NAME>
optimize_binary_search_and_bounds
</NAME>

<DESCRIPTION>
1.  **Tightened Lower Bound**: The theoretical lower bound `lb` is updated to consider per-item constraints. If a single model `m` placed alone on a GPU results in pressure `P`, then the global maximum pressure must be at least `P`. This raises `low` and narrows the search range.
2.  **Standalone Pressure Heuristic**: Added a new sorting strategy to `try_pack` based on "standalone pressure" ($w / (C - s)$). This prioritizes models that are "hardest" to fit in terms of pressure consumption relative to the remaining space they leave, which is distinct from density ($w/s$).
3.  **Refined Solutions in Binary Search**: When `try_pack` finds a feasible solution at `mid`, instead of just accepting it and setting `high = mid`, we run a quick greedy local search ("refinement") to reduce its max KVPR immediately. This refined max pressure is often significantly lower than `mid`. We then update `high` to this lower value, allowing the binary search to converge much faster to the optimal region.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Theoretical Lower Bound
    # sum(w) / (N*C - sum(s))
    rem_global = gpu_num * GPU_MEM_SIZE - total_s
    if rem_global <= 1e-9:
        if total_w > 0: lb = float('inf')
        else: lb = 0.0
    else:
        lb = total_w / rem_global
=======
    # Theoretical Lower Bound
    # sum(w) / (N*C - sum(s))
    rem_global = gpu_num * GPU_MEM_SIZE - total_s
    if rem_global <= 1e-9:
        if total_w > 0: lb = float('inf')
        else: lb = 0.0
    else:
        lb = total_w / rem_global

    # Tighten LB with single-item constraints
    for m in m_data:
        rem = GPU_MEM_SIZE - m['s']
        if rem > 1e-9:
            val = m['w'] / rem
            if val > lb: lb = val
>>>>>>> REPLACE
<<<<<<< SEARCH
            (lambda x: x['w'] / (x['s'] + 1e-9), True, 'best_fit'),
        ]
=======
            (lambda x: x['w'] / (x['s'] + 1e-9), True, 'best_fit'),
            (lambda x: x['w'] / (GPU_MEM_SIZE - x['s'] + 1e-9), True, 'best_fit'),
        ]
>>>>>>> REPLACE
<<<<<<< SEARCH
            if sol:
                # Found a valid packing.
                # However, the packing only guarantees KVPR <= mid (approx).
                # We save it and try to find an even smaller mid.

                # Recalculate actual max pressure to keep the best real solution found
                curr_max = 0.0
                for idxs in sol.values():
                    w = sum(m_data[i]['w'] for i in idxs)
                    s = sum(m_data[i]['s'] for i in idxs)
                    rem = GPU_MEM_SIZE - s
                    val = w/rem if rem > 1e-9 else (float('inf') if w > 0 else 0.0)
                    curr_max = max(curr_max, val)

                if curr_max < best_max_kvpr:
                    best_max_kvpr = curr_max
                    best_placement = sol

                high = mid
=======
            if sol:
                # Found a valid packing.
                # Run a quick local search to potentially lower the max KVPR immediately.
                # This helps tighten the binary search upper bound 'high' more aggressively.

                # Convert to stats for optimization
                q_placement = {k: list(v) for k, v in sol.items()}
                q_stats = []
                q_max_p = 0.0
                for g in range(gpu_num):
                    idxs = q_placement[g]
                    w = sum(m_data[i]['w'] for i in idxs)
                    s = sum(m_data[i]['s'] for i in idxs)
                    rem = GPU_MEM_SIZE - s
                    p = w/rem if rem > 1e-9 else (float('inf') if w > 0 else 0.0)
                    q_stats.append({'w': w, 's': s, 'p': p})
                    q_max_p = max(q_max_p, p)

                # Quick refinement loop (Greedy moves from bottleneck)
                for _ in range(5): # Limit iterations for speed
                    src_gpu = -1
                    max_p_val = -1.0
                    for g in range(gpu_num):
                        if q_stats[g]['p'] > max_p_val:
                            max_p_val = q_stats[g]['p']
                            src_gpu = g

                    if src_gpu == -1 or max_p_val < 1e-9: break

                    improved = False
                    src_idxs = q_placement[src_gpu]

                    # Try to move one item
                    for idx_in_list, m_idx in enumerate(src_idxs):
                        m = m_data[m_idx]

                        # New Src stats
                        src_s_new = q_stats[src_gpu]['s'] - m['s']
                        src_rem_new = GPU_MEM_SIZE - src_s_new
                        src_w_new = q_stats[src_gpu]['w'] - m['w']
                        src_p_new = src_w_new/src_rem_new if src_rem_new > 1e-9 else (float('inf') if src_w_new > 0 else 0.0)

                        best_dst = None

                        for dst in range(gpu_num):
                            if dst == src_gpu: continue
                            if q_stats[dst]['s'] + m['s'] > GPU_MEM_SIZE: continue

                            dst_s_new = q_stats[dst]['s'] + m['s']
                            dst_rem_new = GPU_MEM_SIZE - dst_s_new
                            dst_w_new = q_stats[dst]['w'] + m['w']
                            dst_p_new = dst_w_new/dst_rem_new if dst_rem_new > 1e-9 else (float('inf') if dst_w_new > 0 else 0.0)

                            # We accept if we reduce the global max (which is currently max_p_val on src)
                            # AND we don't create a new max higher than max_p_val
                            if max(src_p_new, dst_p_new) < max_p_val - 1e-5:
                                best_dst = dst
                                break

                        if best_dst is not None:
                            # Apply move
                            q_placement[src_gpu].pop(idx_in_list)
                            q_placement[best_dst].append(m_idx)

                            q_stats[src_gpu] = {'w': src_w_new, 's': src_s_new, 'p': src_p_new}

                            d_rem = GPU_MEM_SIZE - (q_stats[best_dst]['s'] + m['s'])
                            d_w = q_stats[best_dst]['w'] + m['w']
                            d_p = d_w/d_rem if d_rem > 1e-9 else (float('inf') if d_w > 0 else 0.0)
                            q_stats[best_dst] = {'w': d_w, 's': GPU_MEM_SIZE - d_rem, 'p': d_p}

                            improved = True
                            break

                    if not improved: break

                # Final calc of optimized solution
                final_max = 0.0
                for g in range(gpu_num):
                    if q_stats[g]['p'] > final_max: final_max = q_stats[g]['p']

                if final_max < best_max_kvpr:
                    best_max_kvpr = final_max
                    best_placement = q_placement

                # Tighten upper bound to the found solution's max pressure
                high = min(mid, final_max)
>>>>>>> REPLACE
</DIFF>