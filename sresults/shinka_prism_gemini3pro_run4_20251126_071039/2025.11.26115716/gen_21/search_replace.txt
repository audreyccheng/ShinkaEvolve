<NAME>
beam_search_placement
</NAME>

<DESCRIPTION>
Replace the greedy ensemble initialization with a Beam Search based approach.
Beam Search maintains multiple candidate partial placements (the beam), allowing the algorithm to make locally suboptimal decisions (like placing a high-pressure model on a specific GPU) if it leads to a better global maximum KVPR in the end. This explores the solution space more effectively than simple greedy heuristics.
We apply Beam Search with a width of 8 using the same sorting heuristics (Density, Weight, Size, Isolated Pressure) to establish a strong initial solution.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # ---------------------------------------------------------
    # 1. Greedy Ensemble Initialization
    # ---------------------------------------------------------
    # Heuristics: (Sort Key, Strategy)
    # Strategies: 'min_peak' (minimize resulting KVPR), 'min_load' (minimize current KVPR)
    heuristics = [
        (lambda x: x['w'] / (x['s'] + 1e-6), 'min_peak'),  # Density
        (lambda x: x['w'], 'min_load'),                    # Weight (Load Balance)
        (lambda x: x['s'], 'min_peak'),                    # Size (Bin Packing)
        (lambda x: x['w'] / (GPU_MEM_SIZE - x['s'] + 1e-6), 'min_peak') # Isolated Pressure
    ]

    for key_fn, strategy in heuristics:
        sorted_indices = sorted(range(len(m_data)), key=lambda i: key_fn(m_data[i]), reverse=True)

        p_indices = {i: [] for i in range(gpu_num)}
        gpu_state = [{'w': 0.0, 's': 0.0} for _ in range(gpu_num)]
        possible = True

        for idx in sorted_indices:
            item = m_data[idx]
            best_gpu = None
            best_val = float('inf')

            for i in range(gpu_num):
                if gpu_state[i]['s'] + item['s'] > GPU_MEM_SIZE: continue

                rem = GPU_MEM_SIZE - gpu_state[i]['s']

                if strategy == 'min_peak':
                    # Min-Max Greedy
                    new_rem = rem - item['s']
                    if new_rem <= 1e-9: val = float('inf')
                    else: val = (gpu_state[i]['w'] + item['w']) / new_rem
                else:
                    # Load Balancing
                    if rem <= 1e-9: val = float('inf')
                    else: val = gpu_state[i]['w'] / rem

                if val < best_val:
                    best_val = val
                    best_gpu = i

            if best_gpu is None:
                possible = False
                break

            p_indices[best_gpu].append(idx)
            gpu_state[best_gpu]['w'] += item['w']
            gpu_state[best_gpu]['s'] += item['s']

        if possible:
            score = evaluate_indices(p_indices)
            if score < best_max_kvpr:
                best_max_kvpr = score
                best_placement_indices = p_indices
=======
    # ---------------------------------------------------------
    # 1. Beam Search Ensemble Initialization
    # ---------------------------------------------------------
    # Uses beam search with limited width to find better initial placements
    # by exploring multiple GPU assignments for each model.

    def run_beam_search(sorted_idxs, beam_width=8):
        # Beam item: (max_kvpr, assignment_list, gpu_states)
        # assignment_list: list of GPU IDs for models in sorted_idxs order
        beam = [(0.0, [], [{'w': 0.0, 's': 0.0} for _ in range(gpu_num)])]

        for idx in sorted_idxs:
            item = m_data[idx]
            candidates = []

            for curr_max_p, assign, g_states in beam:
                for g in range(gpu_num):
                    st = g_states[g]
                    if st['s'] + item['s'] > GPU_MEM_SIZE: continue

                    new_rem = GPU_MEM_SIZE - (st['s'] + item['s'])
                    if new_rem <= 1e-9:
                        # Full GPU
                        p = float('inf') if (st['w'] + item['w']) > 1e-9 else 0.0
                    else:
                        p = (st['w'] + item['w']) / new_rem

                    new_max = max(curr_max_p, p)
                    candidates.append((new_max, g, assign, g_states))

            if not candidates:
                return None

            # Keep best candidates based on max KVPR
            candidates.sort(key=lambda x: x[0])

            new_beam = []
            # Take top beam_width unique paths
            for p_val, g, old_assign, old_states in candidates[:beam_width]:
                new_st = [dict(s) for s in old_states]
                new_st[g]['w'] += item['w']
                new_st[g]['s'] += item['s']
                new_beam.append((p_val, old_assign + [g], new_st))

            beam = new_beam

        if not beam: return None

        # Reconstruct best placement
        best_res = beam[0]
        final_placement = {i: [] for i in range(gpu_num)}
        for i, g_id in enumerate(best_res[1]):
            final_placement[g_id].append(sorted_idxs[i])
        return final_placement

    # Heuristics: Just different sorting keys now. Beam search handles the placement logic.
    sort_keys = [
        lambda x: x['w'] / (x['s'] + 1e-6),              # Density
        lambda x: x['w'],                                # Weight
        lambda x: x['s'],                                # Size
        lambda x: x['w'] / (GPU_MEM_SIZE - x['s'] + 1e-6) # Isolated Pressure
    ]

    for key_fn in sort_keys:
        sorted_indices = sorted(range(len(m_data)), key=lambda i: key_fn(m_data[i]), reverse=True)
        res_indices = run_beam_search(sorted_indices, beam_width=8)

        if res_indices:
            score = evaluate_indices(res_indices)
            if score < best_max_kvpr:
                best_max_kvpr = score
                best_placement_indices = res_indices
>>>>>>> REPLACE
</DIFF>