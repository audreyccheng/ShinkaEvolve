<NAME>
two_slope_conf_and_targeted_reconcile
</NAME>

<DESCRIPTION>
I propose three targeted improvements to boost confidence calibration and slightly improve counter accuracy without overhauling the algorithm:

1) Refine residual-to-confidence mapping: Replace the logistic mapping with a two-slope residual mapping that decays slowly within tolerance and more aggressively for large violations. This avoids overconfidence for big residuals and better matches calibration goals.

2) Tie-break and multiplicative pre-step in router balancing: When average TX/RX confidences are close (within 0.05), break ties by choosing the direction with larger absolute imbalance. Additionally, add a bounded multiplicative pre-step before the existing additive redistribution to quickly reduce large router imbalances. The pre-step is controlled by imbalance-scaled alpha, bounded scaling, and a per-interface multiplicative cap (±15%), followed by conservative confidence penalties.

3) Tolerance-gated, cap-limited pair reconciliation with confidence penalty: Run reconciliation only when residual exceeds a rate-aware tolerance and cap the move to 20% of the current value per side. Apply a proportional confidence penalty based on the residual/tolerance ratio to improve calibration.

Also, I added a small no-edit bonus in final confidence to reward interfaces that did not require changes, improving calibration for correct counters.

These changes are consistent with the Hodor-style validation/repair approach and previous higher-performing variants, aiming to increase the confidence_calibration score while preserving or improving counter repair accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    # Limited reconciliation strength to pull pair endpoints toward symmetry
    PAIR_RECONCILE_ALPHA = 0.30
    EPS = 1e-9
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    # Limited reconciliation strength to pull pair endpoints toward symmetry
    PAIR_RECONCILE_ALPHA = 0.30
    # Cap for reconciliation move as a fraction of current value
    PAIR_RECONCILE_CAP_FRAC = 0.20
    # Multiplicative pre-step parameters
    MULT_PRE_CAP_FRAC = 0.15
    ALPHA_REF_IMBAL = 0.15
    ALPHA_MIN, ALPHA_MAX = 0.25, 0.60
    # Tie-break threshold for direction selection when confidences are similar
    TIE_EPS_CONF = 0.05
    EPS = 1e-9
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def conf_from_residual(residual: float, tol: float) -> float:
        # Logistic decay for smoother, better-calibrated confidence
        # residual ~ tol -> ~0.5; residual << tol -> close to 1; residual >> tol -> close to 0
        tol = max(tol, 1e-9)
        x = residual / tol
        k = 3.0
        return clamp(1.0 / (1.0 + exp(k * (x - 1.0))))
=======
    def conf_from_residual(residual: float, tol: float) -> float:
        # Two-slope residual-to-confidence:
        # - near 0 residual -> ~1
        # - residual ≈ tol -> ~0.8
        # - large residuals decay faster to avoid overconfidence
        tol = max(tol, 1e-9)
        x = residual / tol
        conf = 1.0 - min(1.0, x / 5.0)
        if x > 3.0:
            conf -= 0.1 * (x - 3.0) / 2.0
        return clamp(conf)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)

        # Decide which direction to scale: scale the less trusted direction
        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling magnitude for confidence penalty computation
        s_bounded = max(0.5, min(2.0, s))

        # Weighted additive redistribution toward target using lower-trust interfaces more
        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
        if not up_list:
            continue

        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx
=======
        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)

        # Decide which direction to scale: scale the less trusted direction; tie-break by larger need
        need_rx = sum_tx - sum_rx  # amount to add to RX to match TX
        need_tx = sum_rx - sum_tx  # amount to add to TX to match RX
        if abs(avg_tx_conf - avg_rx_conf) <= TIE_EPS_CONF:
            scale_rx = abs(need_rx) >= abs(need_tx)
        else:
            scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX

        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling magnitude for confidence penalty computation
        s_bounded = max(0.5, min(2.0, s))

        # Prepare up interfaces list
        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
        if not up_list:
            continue

        # Imbalance-tuned bounded multiplicative pre-step (focus on chosen direction)
        alpha = clamp((imbalance / ALPHA_REF_IMBAL) if ALPHA_REF_IMBAL > 0 else ALPHA_MIN, ALPHA_MIN, ALPHA_MAX)
        m = 1.0 + alpha * (s_bounded - 1.0)
        if abs(m - 1.0) > 1e-6:
            for i in up_list:
                if scale_rx:
                    v = max(0.0, interim[i]['rx'])
                else:
                    v = max(0.0, interim[i]['tx'])
                allowed = MULT_PRE_CAP_FRAC * max(v, 1.0)
                proposed = v * m
                delta = proposed - v
                # Clamp multiplicative delta by per-interface cap
                if delta > 0:
                    delta = min(delta, allowed)
                else:
                    delta = max(delta, -allowed)
                new_v = max(0.0, v + delta)
                if new_v != v:
                    drel = rel_diff(v, new_v)
                    if scale_rx:
                        interim[i]['rx'] = new_v
                        interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded)))))
                    else:
                        interim[i]['tx'] = new_v
                        interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded)))))

        # Weighted additive redistribution toward target using lower-trust interfaces more
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Limited pair-symmetry reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']
        b_rx_old = interim[b_id]['rx']
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > HARDENING_THRESHOLD:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            a_tx_new = max(0.0, a_tx_old + PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old))
            b_rx_new = max(0.0, b_rx_old + PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old))
            if a_tx_new != a_tx_old:
                drel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], 1.0 - min(1.0, 0.5 * drel)))
            if b_rx_new != b_rx_old:
                drel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], 1.0 - min(1.0, 0.5 * drel)))

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']
        b_tx_old = interim[b_id]['tx']
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > HARDENING_THRESHOLD:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            a_rx_new = max(0.0, a_rx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old))
            b_tx_new = max(0.0, b_tx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old))
            if a_rx_new != a_rx_old:
                drel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], 1.0 - min(1.0, 0.5 * drel)))
            if b_tx_new != b_tx_old:
                drel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], 1.0 - min(1.0, 0.5 * drel)))
=======
    # Targeted, tolerance-gated pair reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']
        b_rx_old = interim[b_id]['rx']
        traffic_tx = max(a_tx_old, b_rx_old, 1.0)
        tol_pair_post = max(0.02, 2.5 / traffic_tx)
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > tol_pair_post:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            move_a = PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old)
            move_b = PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_tx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_rx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if a_tx_new != a_tx_old:
                interim[a_id]['tx'] = a_tx_new
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(tol_pair_post, 1e-9))
                interim[a_id]['tx_conf'] = clamp(interim[a_id]['tx_conf'] * penalty)
            if b_rx_new != b_rx_old:
                interim[b_id]['rx'] = b_rx_new
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(tol_pair_post, 1e-9))
                interim[b_id]['rx_conf'] = clamp(interim[b_id]['rx_conf'] * penalty)

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']
        b_tx_old = interim[b_id]['tx']
        traffic_rx = max(a_rx_old, b_tx_old, 1.0)
        tol_pair_post2 = max(0.02, 2.5 / traffic_rx)
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > tol_pair_post2:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            move_a2 = PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old)
            move_b2 = PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old)
            cap_a2 = PAIR_RECONCILE_CAP_FRAC * max(a_rx_old, 1.0)
            cap_b2 = PAIR_RECONCILE_CAP_FRAC * max(b_tx_old, 1.0)
            move_a2 = max(-cap_a2, min(cap_a2, move_a2))
            move_b2 = max(-cap_b2, min(cap_b2, move_b2))
            a_rx_new = max(0.0, a_rx_old + move_a2)
            b_tx_new = max(0.0, b_tx_old + move_b2)
            if a_rx_new != a_rx_old:
                interim[a_id]['rx'] = a_rx_new
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(tol_pair_post2, 1e-9))
                interim[a_id]['rx_conf'] = clamp(interim[a_id]['rx_conf'] * penalty)
            if b_tx_new != b_tx_old:
                interim[b_id]['tx'] = b_tx_new
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(tol_pair_post2, 1e-9))
                interim[b_id]['tx_conf'] = clamp(interim[b_id]['tx_conf'] * penalty)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        CHANGE_PENALTY_WEIGHT = 0.5
        final_tx_conf = clamp(base_tx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_tx))
        final_rx_conf = clamp(base_rx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_rx))

        if resolved_status == 'down':
=======
        CHANGE_PENALTY_WEIGHT = 0.5
        final_tx_conf = clamp(base_tx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_tx))
        final_rx_conf = clamp(base_rx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_rx))

        # No-edit bonus to reward stable counters
        if rel_diff(r['orig_tx'], r['tx']) <= 1e-3:
            final_tx_conf = clamp(final_tx_conf + 0.05)
        if rel_diff(r['orig_rx'], r['rx']) <= 1e-3:
            final_rx_conf = clamp(final_rx_conf + 0.05)

        if resolved_status == 'down':
>>>>>>> REPLACE

</DIFF>