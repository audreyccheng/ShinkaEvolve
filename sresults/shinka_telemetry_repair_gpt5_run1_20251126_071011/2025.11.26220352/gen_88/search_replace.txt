<NAME>
elastic_guard_asym_reconcile_weight_tuning
</NAME>

<DESCRIPTION>
I propose three targeted improvements to increase repair accuracy and confidence calibration:

1) Elastic router guard and traffic-aware weighting: Replace the fixed router delta guard with an elastic guard that scales with router imbalance and confidence skew. Also refine redistribution weights to use a dynamic, traffic-aware tolerance per interface (tol_pair_i = max(0.02, 2.5/max(v_i,1.0))), cap pair-residual contribution at 2.0, add a +0.1 boost for highly inconsistent pairs, and preserve existing small-link and cap-consumption dampening. This aligns with the Hodor hardening principle and the “tiny-link” protection.

2) Targeted multiplicative pre-step: Apply the pre-step only to interfaces in the bottom 40% of direction-specific confidence or with pair residuals above their dynamic tolerance, preventing unnecessary edits on trusted ports while still correcting skew on lower-trust ones.

3) Asymmetric pair reconciliation and improvement bonus: Use asymmetric alphas (higher adjustment on the lower-confidence endpoint) for pair reconciliation, moving toward symmetry more on the less trusted side. Refine confidence calibration by adding an improvement bonus when both pair residuals improve by at least 50% and the router imbalance reduces by at least 30%, or when either of these holds. This enhances calibration by rewarding demonstrable improvements.

These changes are minimal, consistent with the existing pipeline, and should improve both counter repair accuracy and confidence calibration without harming status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def conf_two_slope(residual: float, tol: float) -> float:
        tol = max(tol, 1e-9)
        x = residual / tol
        # base decay: 1 at x=0, down to 0 at x>=5
        conf = 1.0 - min(1.0, x / 5.0)
        # extra penalty for very large residuals
        if x > 3.0:
            conf = conf - 0.1 * (x - 3.0) / 2.0
        return clamp(conf)
=======
    def conf_two_slope(residual: float, tol: float) -> float:
        tol = max(tol, 1e-9)
        x = residual / tol
        # base decay: 1 at x=0, down to 0 at x>=5
        conf = 1.0 - min(1.0, x / 5.0)
        # extra penalty for very large residuals
        if x > 3.0:
            conf = conf - 0.1 * (x - 3.0) / 2.0
        return clamp(conf)

    def percentile(vals: List[float], q: float) -> float:
        arr = [v for v in vals if isfinite(v)]
        n = len(arr)
        if n == 0:
            return 0.0
        arr.sort()
        q = max(0.0, min(1.0, q))
        idx = int(q * (n - 1))
        return arr[idx]
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Apply multiplicative pre-step with per-interface cap ±15%
            if m != 1.0:
                for i in up_list:
                    if scale_rx:
                        v = max(0.0, interim[i]['rx'])
                    else:
                        v = max(0.0, interim[i]['tx'])
                    allowed = MULT_PRE_CAP_FRAC * max(v, 1.0)
                    proposed = v * m
                    delta = proposed - v
                    # Clamp by per-interface cap
                    if delta > 0:
                        delta = min(delta, allowed)
                    else:
                        delta = max(delta, -allowed)
                    new_v = max(0.0, v + delta)
                    if abs(delta) > EPS:
                        if scale_rx:
                            interim[i]['rx'] = new_v
                            interim[i]['mult_scaled_rx'] = True
                            rel = rel_diff(v, new_v)
                            interim[i]['scaled_rel_rx'] = max(interim[i]['scaled_rel_rx'], rel)
                            interim[i]['edit_rx_abs'] += abs(delta)
                            interim[i]['edit_rx_rel'] = max(interim[i]['edit_rx_rel'], rel)
                            interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, 0.5 * imbalance + 0.5 * rel)))
                        else:
                            interim[i]['tx'] = new_v
                            interim[i]['mult_scaled_tx'] = True
                            rel = rel_diff(v, new_v)
                            interim[i]['scaled_rel_tx'] = max(interim[i]['scaled_rel_tx'], rel)
                            interim[i]['edit_tx_abs'] += abs(delta)
                            interim[i]['edit_tx_rel'] = max(interim[i]['edit_tx_rel'], rel)
                            interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, 0.5 * imbalance + 0.5 * rel)))
                        interim[i]['touched'] = True
=======
            # Apply multiplicative pre-step with per-interface cap ±15%
            if m != 1.0:
                # Target only low-trust or high-residual interfaces in the scaled direction
                dir_key_pre = 'rx' if scale_rx else 'tx'
                confs = [interim[i][f'{dir_key_pre}_conf'] for i in up_list]
                conf_thresh = percentile(confs, 0.4)
                for i in up_list:
                    v = max(0.0, interim[i][dir_key_pre])
                    conf_i = interim[i][f'{dir_key_pre}_conf']
                    # Traffic-aware tolerance for pair residual
                    tol_pair_i = max(0.02, 2.5 / max(v, 1.0))
                    pair_resid_i = pair_residual_dir(i, dir_key_pre)
                    do_adjust = (conf_i <= conf_thresh) or (pair_resid_i > tol_pair_i)
                    if not do_adjust:
                        continue
                    allowed = MULT_PRE_CAP_FRAC * max(v, 1.0)
                    proposed = v * m
                    delta = proposed - v
                    # Clamp by per-interface cap
                    if delta > 0:
                        delta = min(delta, allowed)
                    else:
                        delta = max(delta, -allowed)
                    new_v = max(0.0, v + delta)
                    if abs(delta) > EPS:
                        if scale_rx:
                            interim[i]['rx'] = new_v
                            interim[i]['mult_scaled_rx'] = True
                            rel = rel_diff(v, new_v)
                            interim[i]['scaled_rel_rx'] = max(interim[i]['scaled_rel_rx'], rel)
                            interim[i]['edit_rx_abs'] += abs(delta)
                            interim[i]['edit_rx_rel'] = max(interim[i]['edit_rx_rel'], rel)
                            interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, 0.5 * imbalance + 0.5 * rel)))
                        else:
                            interim[i]['tx'] = new_v
                            interim[i]['mult_scaled_tx'] = True
                            rel = rel_diff(v, new_v)
                            interim[i]['scaled_rel_tx'] = max(interim[i]['scaled_rel_tx'], rel)
                            interim[i]['edit_tx_abs'] += abs(delta)
                            interim[i]['edit_tx_rel'] = max(interim[i]['edit_tx_rel'], rel)
                            interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, 0.5 * imbalance + 0.5 * rel)))
                        interim[i]['touched'] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # Router total delta guard
                avg_up_traffic = 0.5 * (sum_tx + sum_rx)
                router_delta_guard = ROUTER_TOTAL_DELTA_GUARD * avg_up_traffic
                router_delta_used = 0.0
=======
                # Elastic router total delta guard
                avg_up_traffic = 0.5 * (sum_tx + sum_rx)
                guard_frac = clamp(0.15 + 0.4 * imbalance + 0.4 * abs(avg_tx_conf - avg_rx_conf), 0.15, 0.35)
                router_delta_guard = guard_frac * avg_up_traffic
                router_delta_used = 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                def build_weights(pass_idx: int) -> Dict[str, float]:
                    nonlocal dir_key
                    sum_v = sum(max(0.0, interim[i][dir_key]) for i in up_list) + EPS
                    weights: Dict[str, float] = {}
                    for i in up_list:
                        v = max(0.0, interim[i][dir_key])
                        conf = interim[i][f'{dir_key}_conf']
                        pair_resid = pair_residual_dir(i, dir_key)
                        TOL_PAIR = TOL_PAIR_BASE
                        pair_term = min(3.0, pair_resid / max(TOL_PAIR, 1e-9))
                        w = 0.6 * (1.0 - conf) + 0.25 * pair_term + 0.15 * (v / sum_v)
                        if v < 1.0:
                            w *= 0.5
                        if pass_idx > 0 and consumed_frac_prev.get(i, 0.0) > 0.7:
                            w *= 0.7
                        # Ensure minimal positive weight
                        weights[i] = max(0.02, w)
                    return weights
=======
                def build_weights(pass_idx: int) -> Dict[str, float]:
                    nonlocal dir_key
                    sum_v = sum(max(0.0, interim[i][dir_key]) for i in up_list) + EPS
                    weights: Dict[str, float] = {}
                    for i in up_list:
                        v = max(0.0, interim[i][dir_key])
                        conf = interim[i][f'{dir_key}_conf']
                        pair_resid = pair_residual_dir(i, dir_key)
                        tol_pair_i = max(0.02, 2.5 / max(v, 1.0))
                        pair_term = min(2.0, pair_resid / max(tol_pair_i, 1e-9))
                        w = 0.6 * (1.0 - conf) + 0.25 * pair_term + 0.15 * (v / sum_v)
                        if v < 1.0:
                            w *= 0.5
                        if pass_idx > 0 and consumed_frac_prev.get(i, 0.0) > 0.7:
                            w *= 0.7
                        if pair_resid > 2.0 * tol_pair_i:
                            w += 0.1
                        # Ensure minimal positive weight
                        weights[i] = max(0.02, w)
                    return weights
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if res_fwd > tol_pair_post:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            move_a = PAIR_RECONCILE_FRACTION * (v_mid - a_tx_old)
            move_b = PAIR_RECONCILE_FRACTION * (v_mid - b_rx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_tx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_rx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if abs(a_tx_new - a_tx_old) > EPS:
                rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['edit_tx_abs'] += abs(a_tx_new - a_tx_old)
                interim[a_id]['edit_tx_rel'] = max(interim[a_id]['edit_tx_rel'], rel)
                # Penalty proportional to residual
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], penalty))
            if abs(b_rx_new - b_rx_old) > EPS:
                rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['edit_rx_abs'] += abs(b_rx_new - b_rx_old)
                interim[b_id]['edit_rx_rel'] = max(interim[b_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], penalty))
=======
        if res_fwd > tol_pair_post:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            # Asymmetric alphas: move more on lower-confidence endpoint
            a_conf = interim[a_id]['tx_conf']
            b_conf = interim[b_id]['rx_conf']
            alpha_low, alpha_high = 0.40, 0.20
            alpha_a = alpha_low if a_conf < b_conf else alpha_high
            alpha_b = alpha_low if b_conf < a_conf else alpha_high
            move_a = alpha_a * (v_mid - a_tx_old)
            move_b = alpha_b * (v_mid - b_rx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_tx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_rx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if abs(a_tx_new - a_tx_old) > EPS:
                rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['edit_tx_abs'] += abs(a_tx_new - a_tx_old)
                interim[a_id]['edit_tx_rel'] = max(interim[a_id]['edit_tx_rel'], rel)
                # Penalty proportional to residual
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], penalty))
            if abs(b_rx_new - b_rx_old) > EPS:
                rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['edit_rx_abs'] += abs(b_rx_new - b_rx_old)
                interim[b_id]['edit_rx_rel'] = max(interim[b_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], penalty))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if res_rev > tol_pair_post2:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            move_a = PAIR_RECONCILE_FRACTION * (v_mid2 - a_rx_old)
            move_b = PAIR_RECONCILE_FRACTION * (v_mid2 - b_tx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_rx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_tx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_rx_new = max(0.0, a_rx_old + move_a)
            b_tx_new = max(0.0, b_tx_old + move_b)
            if abs(a_rx_new - a_rx_old) > EPS:
                rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['edit_rx_abs'] += abs(a_rx_new - a_rx_old)
                interim[a_id]['edit_rx_rel'] = max(interim[a_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], penalty))
            if abs(b_tx_new - b_tx_old) > EPS:
                rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['edit_tx_abs'] += abs(b_tx_new - b_tx_old)
                interim[b_id]['edit_tx_rel'] = max(interim[b_id]['edit_tx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], penalty))
=======
        if res_rev > tol_pair_post2:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            a_conf2 = interim[a_id]['rx_conf']
            b_conf2 = interim[b_id]['tx_conf']
            alpha_low, alpha_high = 0.40, 0.20
            alpha_a2 = alpha_low if a_conf2 < b_conf2 else alpha_high
            alpha_b2 = alpha_low if b_conf2 < a_conf2 else alpha_high
            move_a = alpha_a2 * (v_mid2 - a_rx_old)
            move_b = alpha_b2 * (v_mid2 - b_tx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_rx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_tx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_rx_new = max(0.0, a_rx_old + move_a)
            b_tx_new = max(0.0, b_tx_old + move_b)
            if abs(a_rx_new - a_rx_old) > EPS:
                rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['edit_rx_abs'] += abs(a_rx_new - a_rx_old)
                interim[a_id]['edit_rx_rel'] = max(interim[a_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], penalty))
            if abs(b_tx_new - b_tx_old) > EPS:
                rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['edit_tx_abs'] += abs(b_tx_new - b_tx_old)
                interim[b_id]['edit_tx_rel'] = max(interim[b_id]['edit_tx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], penalty))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Final confidence calibration based on post-repair invariants
    # Compute per-router imbalance residuals with current interim
    router_final_imbalance: Dict[str, float] = {}
=======
    # Final confidence calibration based on post-repair invariants
    # Compute original per-router imbalance from original telemetry (status up)
    router_orig_imbalance: Dict[str, float] = {}
    for router, if_list in router_ifaces.items():
        up_ifaces0 = [i for i in if_list if telemetry.get(i, {}).get('interface_status') == 'up']
        if not up_ifaces0:
            router_orig_imbalance[router] = 0.0
            continue
        sum_tx0 = sum(max(0.0, interim[i]['orig_tx']) for i in up_ifaces0)
        sum_rx0 = sum(max(0.0, interim[i]['orig_rx']) for i in up_ifaces0)
        router_orig_imbalance[router] = rel_diff(sum_tx0, sum_rx0)

    # Compute per-router imbalance residuals with current interim
    router_final_imbalance: Dict[str, float] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        final_tx_conf = finalize_conf(base_tx_conf, edit_tx_rel, cap_hit_tx, scaled_rel_tx, r['orig_tx'], r['tx'])
        final_rx_conf = finalize_conf(base_rx_conf, edit_rx_rel, cap_hit_rx, scaled_rel_rx, r['orig_rx'], r['rx'])
=======
        final_tx_conf = finalize_conf(base_tx_conf, edit_tx_rel, cap_hit_tx, scaled_rel_tx, r['orig_tx'], r['tx'])
        final_rx_conf = finalize_conf(base_rx_conf, edit_rx_rel, cap_hit_rx, scaled_rel_rx, r['orig_rx'], r['rx'])

        # Improvement bonus: reward large pair residual and router imbalance reductions
        impr_bonus = 0.0
        if peer:
            res_fwd0 = rel_diff(r['orig_tx'], interim[peer]['orig_rx'])
            res_rev0 = rel_diff(r['orig_rx'], interim[peer]['orig_tx'])
            res_fwd1 = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev1 = rel_diff(r['rx'], interim[peer]['tx'])
            impr_fwd = (res_fwd0 > 0.0) and (res_fwd1 <= 0.5 * res_fwd0)
            impr_rev = (res_rev0 > 0.0) and (res_rev1 <= 0.5 * res_rev0)
        else:
            impr_fwd = False
            impr_rev = False
        orig_imb = router_orig_imbalance.get(router, 0.0)
        final_imb = router_final_imbalance.get(router, 0.0)
        router_impr = (orig_imb > 0.0 and final_imb <= 0.7 * orig_imb)
        if (impr_fwd and impr_rev) and router_impr:
            impr_bonus = 0.05
        elif (impr_fwd and impr_rev) or router_impr:
            impr_bonus = 0.03
        final_tx_conf = clamp(final_tx_conf + impr_bonus)
        final_rx_conf = clamp(final_rx_conf + impr_bonus)
>>>>>>> REPLACE
</DIFF>