<NAME>
targeted_pair_caps_and_router_penalty
</NAME>

<DESCRIPTION>
I propose three tightly scoped improvements aligned with the Hodor-inspired strategy to improve both counter accuracy and confidence calibration:

1) Targeted pair reconciliation using remaining budget: We now track per-interface absolute router edits (router_delta_abs) and use remaining per-direction budget for pair reconciliation: remaining_cap_dir = 0.20*max(pre_router_dir, 1.0) - router_delta_abs. We also reconcile only pairs that were touched by router edits, preserving the calibration advantage for untouched links. This implements Recommendation 4 and avoids over-editing.

2) Refined multiplicative router pass weighting: We slightly increase focus on highly inconsistent links by adding a small weight boost (+0.1) when pair residuals exceed 2× their tolerance before applying bounded multiplicative scaling. This targets the most inconsistent edges (Recommendation 3), improving counter repairs without excessive edits.

3) Router scale intensity confidence penalty: We store the bounded router ratio s_bounded per router and subtract a small penalty from confidence when |1−s_bounded| > 0.25 (up to 0.05). This enhances confidence calibration by reflecting router-level scale intensity (Recommendation 5).

These changes are localized to the router scaling, pair reconciliation, and confidence sections. They preserve existing logic and caps while targeting improved calibration and accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    router_imbalance: Dict[str, float] = {}
    post_router: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
    router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
=======
    router_imbalance: Dict[str, float] = {}
    post_router: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
    router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
    # Track absolute deltas from router edits to compute remaining budget for pair reconciliation
    router_delta_abs: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
    # Store bounded router ratio per router for confidence calibration
    s_bounded_map: Dict[str, float] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        s_bounded = clamp(s, 0.85, 1.15)
        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
        k = 1.0 + alpha * (s_bounded - 1.0)
=======
        s_bounded = clamp(s, 0.85, 1.15)
        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
        k = 1.0 + alpha * (s_bounded - 1.0)
        # Save for later confidence calibration
        s_bounded_map[router_id] = s_bounded
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['tx'] = new_val
                router_delta_rel[i]['tx'] = abs(move) / max(old, 1.0)
=======
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['tx'] = new_val
                router_delta_rel[i]['tx'] = abs(move) / max(old, 1.0)
                router_delta_abs[i]['tx'] += abs(move)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['rx'] = new_val
                router_delta_rel[i]['rx'] = abs(move) / max(old, 1.0)
=======
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['rx'] = new_val
                router_delta_rel[i]['rx'] = abs(move) / max(old, 1.0)
                router_delta_abs[i]['rx'] += abs(move)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves (≤ 20% of current value)
            cap_a = 0.2 * max(a_tx, 1.0)
            cap_b = 0.2 * max(b_rx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            cap_a = 0.2 * max(a_rx, 1.0)
            cap_b = 0.2 * max(b_tx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
=======
        # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
        touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
        if not touched:
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves using remaining cap (≤ 20% of pre-router value minus router edits)
            base_a = pre[iface]['pre_tx']
            base_b = pre[peer_id]['pre_rx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            base_a = pre[iface]['pre_rx']
            base_b = pre[peer_id]['pre_tx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_confidence = rx_link_conf * router_factor * rx_change_factor
        tx_confidence = tx_link_conf * router_factor * tx_change_factor
=======
        rx_confidence = rx_link_conf * router_factor * rx_change_factor
        tx_confidence = tx_link_conf * router_factor * tx_change_factor

        # Router scale intensity penalty using bounded ratio (helps calibration)
        s_b = s_bounded_map.get(router_id, 1.0)
        if abs(1.0 - s_b) > 0.25:
            pen = min(0.05, 0.2 * abs(1.0 - s_b))
            rx_confidence -= pen
            tx_confidence -= pen
>>>>>>> REPLACE
</DIFF>