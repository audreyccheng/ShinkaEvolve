<NAME>
tolerance_and_partial_reconcile_with_clamped_router_scaling
</NAME>

<DESCRIPTION>
I’m improving three key parts of the algorithm to boost both repair accuracy and confidence calibration:

1) Use rate-aware pair tolerance in the pre-pass: Previously, we used a fixed 2% threshold to decide whether to substitute with the peer’s counter. This can over-correct tiny links and under-correct large ones. I now use a traffic-aware tolerance (pair_tolerance) for each pair direction to reduce false positives and improve accuracy on both small and large links.

2) Clamp router scaling factors: Uniform, unconstrained multiplicative scaling can be aggressive and hurt both accuracy and confidence. I introduce a clamp (0.85–1.15) on router scaling factors, which reduces overshoot and stabilizes the redistribution step.

3) Partial, asymmetric pair reconciliation: Instead of overwriting one side to perfectly match its peer (which can be too drastic), I adjust both sides partway toward each other based on a suspicion/severity heuristic. This better respects uncertainty and yields improved calibration by avoiding large edits when evidence is mixed.

Additionally, I add a small confidence bonus when post-repair residuals are within tolerance in both directions, recognizing successful repairs. These targeted changes improve counter accuracy while enhancing confidence calibration, which should raise the combined score.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    def pair_tolerance(a: float, b: float) -> float:
        # Rate-aware tolerance: looser for very low traffic, at least HARDENING_THRESHOLD
        traffic = max(abs(a), abs(b), 1.0)
        return max(HARDENING_THRESHOLD, 2.5 / traffic)
=======
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def pair_tolerance(a: float, b: float) -> float:
        # Rate-aware tolerance: looser for very low traffic, at least HARDENING_THRESHOLD
        traffic = max(abs(a), abs(b), 1.0)
        return max(HARDENING_THRESHOLD, 2.5 / traffic)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Apply direct substitution when violation exceeds tolerance (higher accuracy under single-sided faults)
                if rx_link_diff > HARDENING_THRESHOLD:
                    pre_rx = peer_tx
                if tx_link_diff > HARDENING_THRESHOLD:
                    pre_tx = peer_rx
=======
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Use traffic-aware tolerance per direction to decide substitution
                tol_rx = pair_tolerance(rx_orig, peer_tx)
                tol_tx = pair_tolerance(tx_orig, peer_rx)

                # Apply direct substitution when violation exceeds tolerance (higher accuracy under single-sided faults)
                if rx_link_diff > tol_rx:
                    pre_rx = peer_tx
                if tx_link_diff > tol_tx:
                    pre_tx = peer_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, 1e-9)
                for i in up_ifaces:
                    # Scale only TX values on active interfaces
                    scale_tx[i] = k
            else:
                k = sum_tx / max(sum_rx, 1e-9)
                for i in up_ifaces:
                    # Scale only RX values on active interfaces
                    scale_rx[i] = k
=======
            if sum_tx > sum_rx:
                k_raw = sum_rx / max(sum_tx, 1e-9)
                k = clamp(k_raw, 0.85, 1.15)
                for i in up_ifaces:
                    # Scale only TX values on active interfaces
                    scale_tx[i] = k
            else:
                k_raw = sum_tx / max(sum_rx, 1e-9)
                k = clamp(k_raw, 0.85, 1.15)
                for i in up_ifaces:
                    # Scale only RX values on active interfaces
                    scale_rx[i] = k
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Reconcile A.tx <-> B.rx if residual exceeds tolerance
        if tx_pair_resid > tol_tx:
            a_tx_s = suspicion(iface, 'tx')
            b_rx_s = suspicion(peer_id, 'rx')
            if a_tx_s >= b_rx_s:
                post[iface]['tx'] = post[peer_id]['rx']
            else:
                post[peer_id]['rx'] = post[iface]['tx']
=======
        # Reconcile A.tx <-> B.rx if residual exceeds tolerance
        if tx_pair_resid > tol_tx:
            a_tx_s = suspicion(iface, 'tx')
            b_rx_s = suspicion(peer_id, 'rx')
            # Partial, asymmetric move toward agreement based on severity and suspicion
            sev = clamp((tx_pair_resid / max(tol_tx, 1e-9)) - 1.0, 0.0, 1.0)
            alpha_hi = 0.5 * (0.5 + 0.5 * sev)   # more suspicious endpoint moves more
            alpha_lo = 0.25 * (0.5 + 0.5 * sev) # less suspicious endpoint moves less
            if a_tx_s >= b_rx_s:
                post[iface]['tx'] = (1.0 - alpha_hi) * a_tx + alpha_hi * b_rx
                post[peer_id]['rx'] = (1.0 - alpha_lo) * b_rx + alpha_lo * a_tx
            else:
                post[peer_id]['rx'] = (1.0 - alpha_hi) * b_rx + alpha_hi * a_tx
                post[iface]['tx'] = (1.0 - alpha_lo) * a_tx + alpha_lo * b_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Reconcile A.rx <-> B.tx if residual exceeds tolerance
        if rx_pair_resid > tol_rx:
            a_rx_s = suspicion(iface, 'rx')
            b_tx_s = suspicion(peer_id, 'tx')
            if a_rx_s >= b_tx_s:
                post[iface]['rx'] = post[peer_id]['tx']
            else:
                post[peer_id]['tx'] = post[iface]['rx']
=======
        # Reconcile A.rx <-> B.tx if residual exceeds tolerance
        if rx_pair_resid > tol_rx:
            a_rx_s = suspicion(iface, 'rx')
            b_tx_s = suspicion(peer_id, 'tx')
            sev2 = clamp((rx_pair_resid / max(tol_rx, 1e-9)) - 1.0, 0.0, 1.0)
            alpha_hi2 = 0.5 * (0.5 + 0.5 * sev2)
            alpha_lo2 = 0.25 * (0.5 + 0.5 * sev2)
            if a_rx_s >= b_tx_s:
                post[iface]['rx'] = (1.0 - alpha_hi2) * a_rx + alpha_hi2 * b_tx
                post[peer_id]['tx'] = (1.0 - alpha_lo2) * b_tx + alpha_lo2 * a_rx
            else:
                post[peer_id]['tx'] = (1.0 - alpha_hi2) * b_tx + alpha_hi2 * a_rx
                post[iface]['rx'] = (1.0 - alpha_lo2) * a_rx + alpha_lo2 * b_tx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Confidence components based on post-repair residuals
        if had_peer and local_status == 'up' and (peer_status == 'up'):
            peer_id = peers.get(iface)
            # Peer repaired (post) rates
            peer_tx_after = post[peer_id]['tx']
            peer_rx_after = post[peer_id]['rx']
            rx_resid = rel_diff(rx_repaired, peer_tx_after)  # A.rx vs B.tx
            tx_resid = rel_diff(tx_repaired, peer_rx_after)  # A.tx vs B.rx
            rx_link_conf = max(0.0, 1.0 - rx_resid)
            tx_link_conf = max(0.0, 1.0 - tx_resid)
        elif local_status == 'down':
            # When locally down and we zeroed, high confidence if zeroed
            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
        else:
            # No reliable peer information
            rx_link_conf = 0.6
            tx_link_conf = 0.6
=======
        # Confidence components based on post-repair residuals
        if had_peer and local_status == 'up' and (peer_status == 'up'):
            peer_id = peers.get(iface)
            # Peer repaired (post) rates
            peer_tx_after = post[peer_id]['tx']
            peer_rx_after = post[peer_id]['rx']
            rx_resid = rel_diff(rx_repaired, peer_tx_after)  # A.rx vs B.tx
            tx_resid = rel_diff(tx_repaired, peer_rx_after)  # A.tx vs B.rx
            rx_link_conf = max(0.0, 1.0 - rx_resid)
            tx_link_conf = max(0.0, 1.0 - tx_resid)
            tight_pair = (rx_resid <= HARDENING_THRESHOLD and tx_resid <= HARDENING_THRESHOLD)
        elif local_status == 'down':
            # When locally down and we zeroed, high confidence if zeroed
            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
            tight_pair = False
        else:
            # No reliable peer information
            rx_link_conf = 0.6
            tx_link_conf = 0.6
            tight_pair = False
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
        rx_untouched = (not pre[iface]['pre_rx_changed']) and (s_dev_rx == 0.0) and (not pair_edits.get(iface, {}).get('rx_edited', False))
        tx_untouched = (not pre[iface]['pre_tx_changed']) and (s_dev_tx == 0.0) and (not pair_edits.get(iface, {}).get('tx_edited', False))
        if rx_untouched:
            rx_confidence += 0.03
        if tx_untouched:
            tx_confidence += 0.03
=======
        # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
        rx_untouched = (not pre[iface]['pre_rx_changed']) and (s_dev_rx == 0.0) and (not pair_edits.get(iface, {}).get('rx_edited', False))
        tx_untouched = (not pre[iface]['pre_tx_changed']) and (s_dev_tx == 0.0) and (not pair_edits.get(iface, {}).get('tx_edited', False))
        if rx_untouched:
            rx_confidence += 0.03
        if tx_untouched:
            tx_confidence += 0.03

        # Bonus for tight pair agreement after repair (both directions within tolerance)
        if had_peer and local_status == 'up' and (peer_status == 'up'):
            peer_id2 = peers.get(iface)
            if peer_id2 and peer_id2 in post:
                rx_resid2 = rel_diff(rx_repaired, post[peer_id2]['tx'])
                tx_resid2 = rel_diff(tx_repaired, post[peer_id2]['rx'])
                if rx_resid2 <= HARDENING_THRESHOLD and tx_resid2 <= HARDENING_THRESHOLD:
                    rx_confidence += 0.03
                    tx_confidence += 0.03
>>>>>>> REPLACE
</DIFF>