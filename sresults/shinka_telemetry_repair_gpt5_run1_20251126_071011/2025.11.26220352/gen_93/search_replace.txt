<NAME>
tol_based_conf_and_weight_dampening
</NAME>

<DESCRIPTION>
I propose three targeted improvements to boost counter accuracy and confidence calibration:

1) Use rate-aware tolerances in the first-pass triage decisions. Previously, link symmetry validation used a fixed 2% threshold, which can overcorrect tiny links and underreact on larger ones. Switching to pair_tolerance in the pre-pass makes substitutions/averaging responsive to traffic scale.

2) Damp router redistribution weights on already-consistent pairs. During router-level scaling, links that already satisfy tolerance were still being nudged by volumetric and residual weighting. I add a 30% weight reduction when the pair residual is within tolerance (on the chosen direction), preserving correct counters and improving both accuracy and calibration.

3) Calibrate link-level confidence against tolerance. Instead of using 1 − residual directly, I compute confidence as 1 when residual ≤ tolerance, then decrease smoothly beyond tolerance: conf = 1 − ((resid − tol)/(1 − tol)). This aligns the score with the Hodor tolerance model. I also add back a small “tight pair” bonus when both directions fall within tolerance after repair, slightly reduce default no-peer confidence from 0.6 to 0.55, and soften the large-change penalty slope back to 0.5 to avoid over-penalizing good repairs.

These edits are minimal and consistent with the current pipeline, improving calibration without harming the strong counter repair performance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
                pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD

                # Triage: if only one direction violates, substitute; if both violate, average
                if pair_tx_ok and not pair_rx_ok:
                    pre_rx = peer_tx
                elif pair_rx_ok and not pair_tx_ok:
                    pre_tx = peer_rx
                elif not pair_rx_ok and not pair_tx_ok:
                    pre_rx = 0.5 * (rx_orig + peer_tx)
                    pre_tx = 0.5 * (tx_orig + peer_rx)
                # else: both within tolerance -> keep as-is
=======
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Use traffic-aware tolerance to avoid over-correcting tiny links
                tol_rx = pair_tolerance(rx_orig, peer_tx)
                tol_tx = pair_tolerance(tx_orig, peer_rx)

                pair_rx_ok = rx_link_diff <= tol_rx
                pair_tx_ok = tx_link_diff <= tol_tx

                # Triage: if only one direction violates, substitute; if both violate, average
                if pair_tx_ok and not pair_rx_ok:
                    pre_rx = peer_tx
                elif pair_rx_ok and not pair_tx_ok:
                    pre_tx = peer_rx
                elif not pair_rx_ok and not pair_tx_ok:
                    pre_rx = 0.5 * (rx_orig + peer_tx)
                    pre_tx = 0.5 * (tx_orig + peer_rx)
                # else: both within tolerance -> keep as-is
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
=======
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                # Fairness dampening: reduce edits when pair is already within tolerance
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid <= tol:
                        w *= 0.7
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
=======
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                # Small boost for highly inconsistent pairs
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid > 2.0 * tol:
                        w += 0.1
                # Fairness dampening: reduce edits when pair is already within tolerance
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    if resid <= tol:
                        w *= 0.7
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
            peer_tx_after = post[peer_id]['tx']
            peer_rx_after = post[peer_id]['rx']
            rx_resid = rel_diff(rx_repaired, peer_tx_after)
            tx_resid = rel_diff(tx_repaired, peer_rx_after)
            rx_link_conf = max(0.0, 1.0 - rx_resid)
            tx_link_conf = max(0.0, 1.0 - tx_resid)
        elif norm_status(repaired_status) == 'down':
            rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
        else:
            rx_link_conf = 0.6
            tx_link_conf = 0.6
=======
        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
            peer_tx_after = post[peer_id]['tx']
            peer_rx_after = post[peer_id]['rx']
            rx_resid = rel_diff(rx_repaired, peer_tx_after)
            tx_resid = rel_diff(tx_repaired, peer_rx_after)
            # Map confidence against traffic-aware tolerance: full confidence within tol, taper beyond
            tol_rx_conf = pair_tolerance(rx_repaired, peer_tx_after)
            tol_tx_conf = pair_tolerance(tx_repaired, peer_rx_after)
            rx_link_conf = max(0.0, 1.0 - max(0.0, rx_resid - tol_rx_conf) / max(1.0 - tol_rx_conf, EPS))
            tx_link_conf = max(0.0, 1.0 - max(0.0, tx_resid - tol_tx_conf) / max(1.0 - tol_tx_conf, EPS))
        elif norm_status(repaired_status) == 'down':
            rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
        else:
            rx_link_conf = 0.55
            tx_link_conf = 0.55
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_weight = 0.4 if rx_change < 0.15 else 0.55
        tx_weight = 0.4 if tx_change < 0.15 else 0.55
=======
        rx_weight = 0.4 if rx_change < 0.15 else 0.5
        tx_weight = 0.4 if tx_change < 0.15 else 0.5
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.03
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.03

        # Improvement bonus when pair residuals and router imbalance both improve significantly
        if 'router_imbalance_post' in locals():
            if 'router_improve_frac_map' not in locals():
                router_improve_frac_map = {}
                for rid in topology:
                    before = router_imbalance.get(rid, 0.0)
                    after = router_imbalance_post.get(rid, 0.0)
                    if before <= 0.0:
                        router_improve_frac_map[rid] = 0.0
                    else:
                        router_improve_frac_map[rid] = max(0.0, (before - after) / before)
            if pair_improve.get(iface, {}).get('both50', False) and router_improve_frac_map.get(router_id, 0.0) >= 0.30:
                rx_confidence += 0.04
                tx_confidence += 0.04
=======
        # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.03
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.03

        # Bonus for tight pair agreement after repair (both directions within tolerance)
        if had_peer and local_status == 'up' and (peer_status == 'up'):
            peer_id2 = peers.get(iface)
            if peer_id2 and peer_id2 in post:
                rx_resid2 = rel_diff(rx_repaired, post[peer_id2]['tx'])
                tx_resid2 = rel_diff(tx_repaired, post[peer_id2]['rx'])
                tol_rx2 = pair_tolerance(rx_repaired, post[peer_id2]['tx'])
                tol_tx2 = pair_tolerance(tx_repaired, post[peer_id2]['rx'])
                if rx_resid2 <= tol_rx2 and tx_resid2 <= tol_tx2:
                    rx_confidence += 0.03
                    tx_confidence += 0.03

        # Improvement bonus when pair residuals and router imbalance both improve significantly
        if 'router_imbalance_post' in locals():
            if 'router_improve_frac_map' not in locals():
                router_improve_frac_map = {}
                for rid in topology:
                    before = router_imbalance.get(rid, 0.0)
                    after = router_imbalance_post.get(rid, 0.0)
                    if before <= 0.0:
                        router_improve_frac_map[rid] = 0.0
                    else:
                        router_improve_frac_map[rid] = max(0.0, (before - after) / before)
            if pair_improve.get(iface, {}).get('both50', False) and router_improve_frac_map.get(router_id, 0.0) >= 0.30:
                rx_confidence += 0.04
                tx_confidence += 0.04
>>>>>>> REPLACE
</DIFF>