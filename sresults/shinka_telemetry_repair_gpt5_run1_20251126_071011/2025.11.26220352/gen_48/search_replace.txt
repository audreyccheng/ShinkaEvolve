<NAME>
asymmetric_capped_pair_reconcile
</NAME>

<DESCRIPTION>
I propose improving the pairwise reconciliation step to be safer and better calibrated by making asymmetrical, capped adjustments instead of hard equality overwrites. Previously, when a link residual exceeded the tolerance, the algorithm forced one side to equal the peer rate, which can overshoot in scenarios where both sides have errors, harming counter accuracy and confidence calibration.

The changes:
- Add a small helper clamp function.
- Introduce pair reconciliation tuning constants: PAIR_STRONG_THR (0.15) and RECONCILE_CAP_FRAC (0.2).
- Modify pair reconciliation logic to:
  - If residual is modest (â‰¤ 0.15), retain prior behavior and set one side equal to the peer for fast closure.
  - If residual is large (> 0.15), move only the more suspicious side toward the peer but cap the per-move magnitude at 20% of its current value, preventing excessive corrections and maintaining non-negativity.

This asymmetrical, capped approach preserves strong fixes where justified, while preventing overcorrections on large discrepancies, which should improve both counter accuracy and confidence calibration (confidence now naturally drops when large residuals remain). No other parts of the algorithm are changed, keeping the flow conservation stage and confidence computation intact.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-9
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-9
    # Pair reconciliation tuning: threshold for "strong" fix and per-move cap
    PAIR_STRONG_THR = 0.15
    RECONCILE_CAP_FRAC = 0.2
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Helpers
    def norm_status(s: Any) -> str:
        s = str(s).lower()
        return s if s in ("up", "down") else "up"  # treat unknown as up conservatively

    def nz_float(x: Any) -> float:
        try:
            v = float(x)
        except Exception:
            v = 0.0
        return max(0.0, v)

    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom
=======
    # Helpers
    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def norm_status(s: Any) -> str:
        s = str(s).lower()
        return s if s in ("up", "down") else "up"  # treat unknown as up conservatively

    def nz_float(x: Any) -> float:
        try:
            v = float(x)
        except Exception:
            v = 0.0
        return max(0.0, v)

    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Reconcile A.tx <-> B.rx
        if resid_tx > HARDENING_THRESHOLD:
            a_tx_s = suspicion(iface, 'tx')
            b_rx_s = suspicion(peer_id, 'rx')
            if a_tx_s >= b_rx_s:
                post[iface]['tx'] = post[peer_id]['rx']
            else:
                post[peer_id]['rx'] = post[iface]['tx']

        # Reconcile A.rx <-> B.tx
        if resid_rx > HARDENING_THRESHOLD:
            a_rx_s = suspicion(iface, 'rx')
            b_tx_s = suspicion(peer_id, 'tx')
            if a_rx_s >= b_tx_s:
                post[iface]['rx'] = post[peer_id]['tx']
            else:
                post[peer_id]['tx'] = post[iface]['rx']
=======
        # Reconcile A.tx <-> B.rx
        if resid_tx > HARDENING_THRESHOLD:
            a_tx_s = suspicion(iface, 'tx')
            b_rx_s = suspicion(peer_id, 'rx')
            if resid_tx <= PAIR_STRONG_THR:
                # modest residual: set the more suspicious side equal to its peer
                if a_tx_s >= b_rx_s:
                    post[iface]['tx'] = post[peer_id]['rx']
                else:
                    post[peer_id]['rx'] = post[iface]['tx']
            else:
                # large residual: move the more suspicious side toward peer with a capped step
                if a_tx_s >= b_rx_s:
                    cur = post[iface]['tx']
                    target = post[peer_id]['rx']
                    cap = RECONCILE_CAP_FRAC * max(cur, 1.0)
                    delta = clamp(target - cur, -cap, cap)
                    post[iface]['tx'] = max(0.0, cur + delta)
                else:
                    cur = post[peer_id]['rx']
                    target = post[iface]['tx']
                    cap = RECONCILE_CAP_FRAC * max(cur, 1.0)
                    delta = clamp(target - cur, -cap, cap)
                    post[peer_id]['rx'] = max(0.0, cur + delta)

        # Reconcile A.rx <-> B.tx
        if resid_rx > HARDENING_THRESHOLD:
            a_rx_s = suspicion(iface, 'rx')
            b_tx_s = suspicion(peer_id, 'tx')
            if resid_rx <= PAIR_STRONG_THR:
                if a_rx_s >= b_tx_s:
                    post[iface]['rx'] = post[peer_id]['tx']
                else:
                    post[peer_id]['tx'] = post[iface]['rx']
            else:
                if a_rx_s >= b_tx_s:
                    cur = post[iface]['rx']
                    target = post[peer_id]['tx']
                    cap = RECONCILE_CAP_FRAC * max(cur, 1.0)
                    delta = clamp(target - cur, -cap, cap)
                    post[iface]['rx'] = max(0.0, cur + delta)
                else:
                    cur = post[peer_id]['tx']
                    target = post[iface]['rx']
                    cap = RECONCILE_CAP_FRAC * max(cur, 1.0)
                    delta = clamp(target - cur, -cap, cap)
                    post[peer_id]['tx'] = max(0.0, cur + delta)
>>>>>>> REPLACE

</DIFF>