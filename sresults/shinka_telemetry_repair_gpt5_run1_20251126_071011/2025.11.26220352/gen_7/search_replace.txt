<NAME>
peer_substitution_and_safe_router_scaling
</NAME>

<DESCRIPTION>
I propose three targeted changes to improve counter repair accuracy while preserving good confidence calibration:

1) Switch link-level repair from averaging to direct peer substitution when link symmetry violations exceed the hardening threshold. Averaging dilutes a good redundant signal with a bad one; direct substitution is superior under single-sided faults and matches the research guidance of using redundant signals to harden measurements.

2) Make status-aware zeroing local-only. Previously, if either side reported down, both directions were zeroed. This overreacts to a potentially corrupted peer status and harms accuracy. We now zero only when the local interface is down; when the peer is down, we avoid using its counters and treat the peer as unavailable for hardening.

3) Make router-level flow conservation safer: scale only when there are at least two locally up interfaces and non-trivial volume, and scale only those up interfaces. This prevents pathological scaling on single-interface routers or near-zero traffic conditions and avoids penalizing correct counters.

Additionally, I align the status confidence comparison to use lowercase to avoid spurious mismatches and adjust link-confidence when the peer is down to a neutral baseline rather than incorrectly assuming high certainty.

These changes should increase counter_repair_accuracy and maintain strong confidence_calibration, improving the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Status-aware zeroing: if either side is down, no traffic should flow
        if local_status == 'down' or (had_peer and peer_status == 'down'):
            pre_rx = 0.0
            pre_tx = 0.0
            rx_link_diff = 0.0
            tx_link_diff = 0.0
        else:
            # Both sides up (or no peer) -> link hardening using redundant signals if peer present
            if had_peer:
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Only adjust if violation exceeds tolerance, else leave unchanged to avoid perturbing good data
                if rx_link_diff > HARDENING_THRESHOLD:
                    pre_rx = 0.5 * (rx_orig + peer_tx)
                if tx_link_diff > HARDENING_THRESHOLD:
                    pre_tx = 0.5 * (tx_orig + peer_rx)
            else:
                rx_link_diff = 0.0
                tx_link_diff = 0.0
=======
        # Status-aware zeroing: if local interface is down, no traffic should flow
        if local_status == 'down':
            pre_rx = 0.0
            pre_tx = 0.0
            rx_link_diff = 0.0
            tx_link_diff = 0.0
        else:
            # Link hardening only when a reliable peer signal is available (peer up)
            if had_peer and peer_status == 'up':
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Direct substitution improves accuracy under single-sided faults
                if rx_link_diff > HARDENING_THRESHOLD:
                    pre_rx = peer_tx
                if tx_link_diff > HARDENING_THRESHOLD:
                    pre_tx = peer_rx
            else:
                rx_link_diff = 0.0
                tx_link_diff = 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Sum only for interfaces that are up locally (down links already zeroed)
        sum_rx = 0.0
        sum_tx = 0.0
        for iface in candidate_ifaces:
            if pre[iface]['local_status'] == 'up':
                sum_rx += pre[iface]['pre_rx']
                sum_tx += pre[iface]['pre_tx']

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # If imbalance exceeds threshold, scale the larger side to match the smaller
        if imbalance > HARDENING_THRESHOLD:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, 1e-9)
                for iface in candidate_ifaces:
                    # Scale only TX values on this router
                    scale_tx[iface] = k
            else:
                k = sum_tx / max(sum_rx, 1e-9)
                for iface in candidate_ifaces:
                    # Scale only RX values on this router
                    scale_rx[iface] = k
=======
        # Consider only locally up interfaces (down links already zeroed)
        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Scale only when we have multiple active interfaces and meaningful volume
        if imbalance > HARDENING_THRESHOLD and len(up_ifaces) >= 2 and (sum_rx + sum_tx) > 1e-6:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, 1e-9)
                for i in up_ifaces:
                    # Scale only TX values on active interfaces
                    scale_tx[i] = k
            else:
                k = sum_tx / max(sum_rx, 1e-9)
                for i in up_ifaces:
                    # Scale only RX values on active interfaces
                    scale_rx[i] = k
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if had_peer and local_status == 'up' and (peer_status == 'up' or peer_status == 'unknown'):
            rx_link_conf = max(0.0, 1.0 - rx_link_diff)
            tx_link_conf = max(0.0, 1.0 - tx_link_diff)
        elif local_status == 'down' or (had_peer and peer_status == 'down'):
            # When link is down and we zeroed, high confidence if zeroed
            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
        else:
            # No peer information
            rx_link_conf = 0.6
            tx_link_conf = 0.6
=======
        if had_peer and local_status == 'up' and (peer_status == 'up' or peer_status == 'unknown'):
            rx_link_conf = max(0.0, 1.0 - rx_link_diff)
            tx_link_conf = max(0.0, 1.0 - tx_link_diff)
        elif local_status == 'down':
            # When locally down and we zeroed, high confidence if zeroed
            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
        else:
            # No reliable peer information (no peer or peer is down)
            rx_link_conf = 0.6
            tx_link_conf = 0.6
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if repaired_status != peer_status_raw:
                status_confidence = min(status_confidence, 0.5)
=======
            if str(repaired_status).lower() != peer_status_raw:
                status_confidence = min(status_confidence, 0.5)
>>>>>>> REPLACE
</DIFF>