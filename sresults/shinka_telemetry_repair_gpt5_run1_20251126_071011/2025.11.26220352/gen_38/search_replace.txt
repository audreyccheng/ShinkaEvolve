<NAME>
imbalance_tuned_scale_weighted_redistribution_and_targeted_reconcile
</NAME>

<DESCRIPTION>
I propose three targeted improvements inspired by the Hodor validation/repair principles and the provided recommendations to improve both counter accuracy and confidence calibration:

1) Replace the logistic residual-to-confidence mapping with a two-slope mapping that better reflects residual magnitudes. This improves calibration by keeping higher confidence for small residuals and penalizing very large residuals more sharply.

2) Refine the router-level repair:
   - Use an imbalance-tuned, bounded multiplicative pre-step with a per-interface cap (±15%) and an adaptive alpha, and a tie-break rule when average TX/RX confidences are close (≤0.05). This implements a gentler, more targeted correction toward balance while respecting uncertainty.
   - Enrich additive redistribution weights with pair residuals and volume share, and adapt weights across passes by reducing weights for interfaces that already consumed >70% of their cap. Maintain staged caps and a router total delta guard. Also, track whether an interface is touched to drive post-repair reconciliation.

3) Make the post-redistribution link symmetry reconciliation targeted only to pairs where at least one endpoint was edited (touched). Use a capped 25% pull toward midpoint with per-direction cap ≤20% of value and apply a mild confidence penalty proportional to residual. This reduces unnecessary changes and improves both accuracy and calibration.

These edits preserve existing invariants and data structures, make better use of redundancy, and calibrate confidence to reflect repair certainty, aiming to improve the combined score without broad rewrites.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def conf_from_residual(residual: float, tol: float) -> float:
        # Logistic decay for smoother, better-calibrated confidence
        # residual ~ tol -> ~0.5; residual << tol -> close to 1; residual >> tol -> close to 0
        tol = max(tol, 1e-9)
        x = residual / tol
        k = 3.0
        return clamp(1.0 / (1.0 + exp(k * (x - 1.0))))
=======
    def conf_from_residual(residual: float, tol: float) -> float:
        # Two-slope residual-to-confidence mapping for better calibration
        # near 0 residual -> ~1; at residual ~= tol -> ~0.8; at 5*tol -> ~0
        tol = max(tol, 1e-9)
        x = residual / tol
        conf = 1.0 - min(1.0, x / 5.0)
        if x > 3.0:
            conf -= 0.1 * (x - 3.0) / 2.0
        return clamp(conf)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        interim[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'rx_conf': 1.0,
            'tx_conf': 1.0,
            'status': data.get('interface_status', 'unknown'),
            'status_conf': 1.0,
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            # Keep originals for output tuples
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown'),
        }
=======
        interim[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'rx_conf': 1.0,
            'tx_conf': 1.0,
            'status': data.get('interface_status', 'unknown'),
            'status_conf': 1.0,
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            # Keep originals for output tuples
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown'),
            # Track whether router-level edits touched this interface
            'touched': False,
        }
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Multiplicative pre-step: gentle move toward target scale with per-interface cap
        s_step = max(0.85, min(1.15, s_bounded ** 0.5))
        if abs(1.0 - s_step) > 0.01:
            for i in up_list:
                if scale_rx:
                    old_v = max(0.0, float(interim[i]['rx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['rx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    old_v = max(0.0, float(interim[i]['tx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['tx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))

        # Recompute current totals after multiplicative step
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx

        need = target_total - sum_old
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            # Tiny residual; skip redistribution
            continue

        # Per-router total delta cap for additive redistribution
        router_total = max(sum_old, target_total, 1.0)
        router_delta_remaining = ROUTER_TOTAL_DELTA_FRAC * router_total

        # Build weights from direction-specific confidence (lower confidence -> larger weight)
        weights: Dict[str, float] = {}
        values: Dict[str, float] = {}
        base_confs: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                conf = float(interim[i]['rx_conf'])
                v = max(0.0, float(interim[i]['rx']))
            else:
                conf = float(interim[i]['tx_conf'])
                v = max(0.0, float(interim[i]['tx']))
            w = max(0.05, 1.0 - conf)
            weights[i] = w
            values[i] = v
            base_confs[i] = conf

        # Ramped per-interface caps across passes
        pos_rem: Dict[str, float] = {i: CAP_RAMP_FRACS[0] * max(values[i], 1.0) for i in up_list}
        neg_rem: Dict[str, float] = {i: CAP_RAMP_FRACS[0] * max(values[i], 1.0) for i in up_list}
        inc_pass2: Dict[str, float] = {i: (CAP_RAMP_FRACS[1] - CAP_RAMP_FRACS[0]) * max(values[i], 1.0) for i in up_list}
        inc_pass3: Dict[str, float] = {}
        for i in up_list:
            v0 = values[i]
            conf0 = base_confs[i]
            allow_more = (conf0 < 0.6) or (v0 < 5.0)
            inc_pass3[i] = ((CAP_RAMP_FRACS[2] - CAP_RAMP_FRACS[1]) * max(v0, 1.0)) if allow_more else 0.0

        for pass_idx in range(3):
            if abs(need) <= EPS or router_delta_remaining <= EPS:
                break
            # Increase capacities for this pass
            if pass_idx == 1:
                for i in up_list:
                    pos_rem[i] += inc_pass2[i]
                    neg_rem[i] += inc_pass2[i]
            elif pass_idx == 2:
                for i in up_list:
                    pos_rem[i] += inc_pass3[i]
                    neg_rem[i] += inc_pass3[i]

            # Eligible interfaces based on remaining capacity in needed direction
            if need > 0:
                elig = [i for i in up_list if pos_rem[i] > EPS]
            else:
                elig = [i for i in up_list if neg_rem[i] > EPS]
            if not elig:
                continue

            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                continue

            for i in elig:
                if abs(need) <= EPS or router_delta_remaining <= EPS:
                    break
                quota = need * (weights[i] / sumW)
                if need > 0:
                    d = min(max(0.0, quota), pos_rem[i], router_delta_remaining)
                    pos_rem[i] -= d
                else:
                    d = -min(max(0.0, -quota), neg_rem[i], router_delta_remaining)
                    neg_rem[i] -= -d

                if abs(d) <= EPS:
                    continue

                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                router_delta_remaining -= abs(d)

                # Confidence drops with global imbalance, scaling magnitude and per-interface change
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                need -= d
=======
        # Tie-break when confidences are close: choose direction with larger absolute need
        need_rx = sum_tx - sum_rx  # need applied to RX to match TX
        need_tx = sum_rx - sum_tx  # need applied to TX to match RX
        if abs(avg_tx_conf - avg_rx_conf) <= 0.05:
            scale_rx = abs(need_rx) >= abs(need_tx)

        # Multiplicative pre-step: imbalance-tuned, bounded, with per-interface cap
        # s_bounded already in [0.5, 2.0]; alpha tunes aggressiveness with imbalance
        alpha = max(0.25, min(0.60, imbalance / 0.15 if 0.15 > 0 else 0.25))
        m = 1.0 + alpha * (s_bounded - 1.0)
        if abs(1.0 - m) > 1e-6:
            for i in up_list:
                if scale_rx:
                    old_v = max(0.0, float(interim[i]['rx']))
                else:
                    old_v = max(0.0, float(interim[i]['tx']))
                proposed = old_v * m
                delta = proposed - old_v
                cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                delta = max(-cap, min(cap, delta))
                new_v = max(0.0, old_v + delta)
                if scale_rx:
                    interim[i]['rx'] = new_v
                else:
                    interim[i]['tx'] = new_v
                if abs(delta) > EPS:
                    # Confidence penalty scales with imbalance and relative change
                    delta_rel = rel_diff(old_v, new_v)
                    if scale_rx:
                        interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                    else:
                        interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                    interim[i]['touched'] = True

        # Recompute current totals after multiplicative step
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx

        need = target_total - sum_old
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            # Tiny residual; skip redistribution
            continue

        # Per-router total delta cap for additive redistribution
        router_total = max(sum_old, target_total, 1.0)
        router_delta_remaining = ROUTER_TOTAL_DELTA_FRAC * router_total

        # Prepare direction-specific base values and confidences
        values: Dict[str, float] = {}
        base_confs: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                base_confs[i] = float(interim[i]['rx_conf'])
                values[i] = max(0.0, float(interim[i]['rx']))
            else:
                base_confs[i] = float(interim[i]['tx_conf'])
                values[i] = max(0.0, float(interim[i]['tx']))

        # Staged per-interface caps across passes, with tracking to reduce weights on heavy consumers
        cap_total: Dict[str, float] = {i: CAP_RAMP_FRACS[0] * max(values[i], 1.0) for i in up_list}
        cap_rem: Dict[str, float] = {i: cap_total[i] for i in up_list}
        inc_pass2: Dict[str, float] = {i: (CAP_RAMP_FRACS[1] - CAP_RAMP_FRACS[0]) * max(values[i], 1.0) for i in up_list}
        inc_pass3: Dict[str, float] = {}
        for i in up_list:
            v0 = values[i]
            conf0 = base_confs[i]
            allow_more = (conf0 < 0.6) or (v0 < 5.0)
            inc_pass3[i] = ((CAP_RAMP_FRACS[2] - CAP_RAMP_FRACS[1]) * max(v0, 1.0)) if allow_more else 0.0
        consumed_frac_prev: Dict[str, float] = {i: 0.0 for i in up_list}

        def pair_residual_for_dir(iface_id: str) -> float:
            peer = peer_of.get(iface_id)
            if not peer:
                return 0.0
            if interim[iface_id]['status'] != 'up' or interim[peer]['status'] != 'up':
                return 0.0
            if scale_rx:
                a = interim[iface_id]['rx']; b = interim[peer]['tx']
            else:
                a = interim[iface_id]['tx']; b = interim[peer]['rx']
            return rel_diff(a, b)

        for pass_idx in range(3):
            if abs(need) <= EPS or router_delta_remaining <= EPS:
                break
            # Increase capacities for this pass
            if pass_idx == 1:
                for i in up_list:
                    cap_total[i] += inc_pass2[i]
                    cap_rem[i] += inc_pass2[i]
            elif pass_idx == 2:
                for i in up_list:
                    cap_total[i] += inc_pass3[i]
                    cap_rem[i] += inc_pass3[i]

            # Build enriched weights
            sum_v = sum(max(0.0, values[i]) for i in up_list) + EPS
            TOL_PAIR_W = HARDENING_THRESHOLD * 1.5
            weights: Dict[str, float] = {}
            for i in up_list:
                conf = base_confs[i]
                v = max(0.0, values[i])
                pair_resid = pair_residual_for_dir(i)
                pair_term = min(3.0, pair_resid / max(TOL_PAIR_W, 1e-9))
                w = 0.6 * (1.0 - conf) + 0.25 * pair_term + 0.15 * (v / sum_v)
                if v < 1.0:
                    w *= 0.5
                if pass_idx > 0 and consumed_frac_prev.get(i, 0.0) > 0.7:
                    w *= 0.7
                weights[i] = max(0.02, w)

            # Eligible interfaces based on remaining capacity
            if need > 0:
                elig = [i for i in up_list if cap_rem[i] > EPS]
            else:
                elig = [i for i in up_list if cap_rem[i] > EPS]
            if not elig:
                continue

            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                continue

            for i in elig:
                if abs(need) <= EPS or router_delta_remaining <= EPS:
                    break
                quota = need * (weights[i] / sumW)
                # Clamp by remaining per-interface cap and router guard
                d = max(-cap_rem[i], min(cap_rem[i], quota))
                if abs(d) > router_delta_remaining:
                    d = (router_delta_remaining if d > 0 else -router_delta_remaining)
                if abs(d) <= EPS:
                    continue

                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                cap_rem[i] = max(0.0, cap_rem[i] - abs(d))
                router_delta_remaining -= abs(d)
                need -= d
                # Write back and adjust confidence
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                interim[i]['touched'] = True

            # Track consumption for next pass weighting and optional freezing
            for i in up_list:
                total_cap_i = max(cap_total[i], EPS)
                consumed_frac_prev[i] = 1.0 - (cap_rem[i] / total_cap_i)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Limited pair-symmetry reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']
        b_rx_old = interim[b_id]['rx']
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > HARDENING_THRESHOLD:
            v_mid = (a_tx_old + b_rx_old) / 2.0
            a_tx_new = a_tx_old + PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old)
            b_rx_new = b_rx_old + PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old)
            a_tx_new = max(0.0, a_tx_new)
            b_rx_new = max(0.0, b_rx_new)
            if a_tx_new != a_tx_old:
                delta_rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], 1.0 - 0.5 * delta_rel))
            if b_rx_new != b_rx_old:
                delta_rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], 1.0 - 0.5 * delta_rel))

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']
        b_tx_old = interim[b_id]['tx']
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > HARDENING_THRESHOLD:
            v_mid2 = (a_rx_old + b_tx_old) / 2.0
            a_rx_new = a_rx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old)
            b_tx_new = b_tx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old)
            a_rx_new = max(0.0, a_rx_new)
            b_tx_new = max(0.0, b_tx_new)
            if a_rx_new != a_rx_old:
                delta_rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], 1.0 - 0.5 * delta_rel))
            if b_tx_new != b_tx_old:
                delta_rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], 1.0 - 0.5 * delta_rel))
=======
    # Targeted pair-symmetry reconciliation after router redistribution (only touched pairs)
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue
        if not (interim[a_id].get('touched') or interim[b_id].get('touched')):
            continue

        TOL_PAIR_LOCAL = max(0.02, HARDENING_THRESHOLD * 1.5)

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']; b_rx_old = interim[b_id]['rx']
        traffic_tx = max(a_tx_old, b_rx_old, 1.0)
        tol_tx = max(TOL_PAIR_LOCAL, 2.5 / traffic_tx)
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > tol_tx:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            move_a = PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old)
            move_b = PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old)
            cap_a = 0.20 * max(a_tx_old, 1.0)
            cap_b = 0.20 * max(b_rx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if a_tx_new != a_tx_old:
                drel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                # Mild penalty proportional to normalized residual
                interim[a_id]['tx_conf'] = clamp(interim[a_id]['tx_conf'] * (1.0 - 0.3 * min(1.0, res_fwd / TOL_PAIR_LOCAL)))
            if b_rx_new != b_rx_old:
                drel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(interim[b_id]['rx_conf'] * (1.0 - 0.3 * min(1.0, res_fwd / TOL_PAIR_LOCAL)))

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']; b_tx_old = interim[b_id]['tx']
        traffic_rx = max(a_rx_old, b_tx_old, 1.0)
        tol_rx = max(TOL_PAIR_LOCAL, 2.5 / traffic_rx)
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > tol_rx:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            move_a2 = PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old)
            move_b2 = PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old)
            cap_a2 = 0.20 * max(a_rx_old, 1.0)
            cap_b2 = 0.20 * max(b_tx_old, 1.0)
            move_a2 = max(-cap_a2, min(cap_a2, move_a2))
            move_b2 = max(-cap_b2, min(cap_b2, move_b2))
            a_rx_new = max(0.0, a_rx_old + move_a2)
            b_tx_new = max(0.0, b_tx_old + move_b2)
            if a_rx_new != a_rx_old:
                drel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(interim[a_id]['rx_conf'] * (1.0 - 0.3 * min(1.0, res_rev / TOL_PAIR_LOCAL)))
            if b_tx_new != b_tx_old:
                drel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(interim[b_id]['tx_conf'] * (1.0 - 0.3 * min(1.0, res_rev / TOL_PAIR_LOCAL)))
>>>>>>> REPLACE
</DIFF>