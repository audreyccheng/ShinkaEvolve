<NAME>
asymmetric_reconcile_dynamic_guard_conf_calibration
</NAME>

<DESCRIPTION>
I propose targeted edits to improve counter repair accuracy and confidence calibration:

1) Add asymmetric pair reconciliation with budget-aware caps. The lower-confidence endpoint moves more (alpha_low=0.35 vs alpha_high=0.20), and moves are constrained by remaining reconciliation capacity derived from pre-router snapshots and previously consumed router edits.

2) Dynamically scale the router total delta guard based on router imbalance and confidence difference, and fix a tie-break bug when choosing which direction to scale by preferring to scale the smaller-sum direction in ties.

3) Slightly enrich redistribution weights by boosting interfaces with large pair residuals, and record per-router scale severity s_dev = |1 − s_bounded| to calibrate confidences later.

4) Refine final confidence calibration with scale-severity and cap-consumption penalties, taper edit penalty by edit size, and add an untouched bonus. Also snapshot pre-router values before router balancing.

These changes follow the Hodor-inspired validation-repair approach and aim to improve both repair accuracy and calibrated confidence.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    PAIR_RECONCILE_FRACTION = 0.25      # move 25% toward each other
    PAIR_RECONCILE_CAP_FRAC = 0.20      # per-direction reconcile cap ≤ 20% of value
=======
    PAIR_RECONCILE_FRACTION = 0.25      # move 25% toward each other
    PAIR_RECONCILE_CAP_FRAC = 0.20      # per-direction reconcile cap ≤ 20% of value
    ALPHA_LOW, ALPHA_HIGH = 0.35, 0.20  # asymmetric reconcile strengths (low-confidence end moves more)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        interim[if_id] = {
            'rx': rx0, 'tx': tx0,
            'rx_conf': 1.0, 'tx_conf': 1.0,
            'status': data.get('interface_status', 'unknown'),
            'status_conf': 1.0,
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            'orig_rx': rx0, 'orig_tx': tx0, 'orig_status': data.get('interface_status', 'unknown'),
            # edit tracking
            'edit_rx_abs': 0.0, 'edit_tx_abs': 0.0,
            'edit_rx_rel': 0.0, 'edit_tx_rel': 0.0,
            'cap_hit_rx': False, 'cap_hit_tx': False,
            'mult_scaled_rx': False, 'mult_scaled_tx': False,
            'scaled_rel_rx': 0.0, 'scaled_rel_tx': 0.0,
            'touched': False,
        }
=======
        interim[if_id] = {
            'rx': rx0, 'tx': tx0,
            'rx_conf': 1.0, 'tx_conf': 1.0,
            'status': data.get('interface_status', 'unknown'),
            'status_conf': 1.0,
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            'orig_rx': rx0, 'orig_tx': tx0, 'orig_status': data.get('interface_status', 'unknown'),
            # edit tracking
            'edit_rx_abs': 0.0, 'edit_tx_abs': 0.0,
            'edit_rx_rel': 0.0, 'edit_tx_rel': 0.0,
            'cap_hit_rx': False, 'cap_hit_tx': False,
            'mult_scaled_rx': False, 'mult_scaled_tx': False,
            'scaled_rel_rx': 0.0, 'scaled_rel_tx': 0.0,
            'touched': False,
            # pre-router snapshots (will be updated before router balancing)
            'pre_router_rx': rx0, 'pre_router_tx': tx0,
        }
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Uncertainty-weighted, capacity-capped redistribution using staged passes
    for router, if_list in router_ifaces.items():
=======
    # Snapshot pre-router values for remaining-cap accounting
    for _if in interim:
        interim[_if]['pre_router_rx'] = interim[_if]['rx']
        interim[_if]['pre_router_tx'] = interim[_if]['tx']

    router_scale_dev: Dict[str, float] = {}

    # Uncertainty-weighted, capacity-capped redistribution using staged passes
    for router, if_list in router_ifaces.items():
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if abs(avg_tx_conf - avg_rx_conf) < TIE_EPS_CONF:
                scale_rx = abs(need_rx) >= abs(need_tx)
            else:
                scale_rx = avg_tx_conf >= avg_rx_conf  # if TX is more trusted, scale RX
=======
            if abs(avg_tx_conf - avg_rx_conf) < TIE_EPS_CONF:
                # Tie-break: scale the smaller-sum direction toward the larger
                scale_rx = sum_tx >= sum_rx
            else:
                scale_rx = avg_tx_conf >= avg_rx_conf  # if TX is more trusted, scale RX
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            s_bounded = max(0.5, min(2.0, s))
            alpha = max(ALPHA_MIN, min(ALPHA_MAX, (imbalance / ALPHA_REF_IMBAL) if ALPHA_REF_IMBAL > 0 else ALPHA_MIN))
            m = 1.0 + alpha * (s_bounded - 1.0)
=======
            s_bounded = max(0.5, min(2.0, s))
            router_scale_dev[router] = abs(1.0 - s_bounded)
            alpha = max(ALPHA_MIN, min(ALPHA_MAX, (imbalance / ALPHA_REF_IMBAL) if ALPHA_REF_IMBAL > 0 else ALPHA_MIN))
            m = 1.0 + alpha * (s_bounded - 1.0)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                def build_weights(pass_idx: int) -> Dict[str, float]:
                    nonlocal dir_key
                    sum_v = sum(max(0.0, interim[i][dir_key]) for i in up_list) + EPS
                    weights: Dict[str, float] = {}
                    for i in up_list:
                        v = max(0.0, interim[i][dir_key])
                        conf = interim[i][f'{dir_key}_conf']
                        pair_resid = pair_residual_dir(i, dir_key)
                        TOL_PAIR = TOL_PAIR_BASE
                        pair_term = min(3.0, pair_resid / max(TOL_PAIR, 1e-9))
                        w = 0.6 * (1.0 - conf) + 0.25 * pair_term + 0.15 * (v / sum_v)
                        if v < 1.0:
                            w *= 0.5
                        if pass_idx > 0 and consumed_frac_prev.get(i, 0.0) > 0.7:
                            w *= 0.7
                        # Ensure minimal positive weight
                        weights[i] = max(0.02, w)
                    return weights
=======
                def build_weights(pass_idx: int) -> Dict[str, float]:
                    nonlocal dir_key
                    sum_v = sum(max(0.0, interim[i][dir_key]) for i in up_list) + EPS
                    weights: Dict[str, float] = {}
                    for i in up_list:
                        v = max(0.0, interim[i][dir_key])
                        conf = interim[i][f'{dir_key}_conf']
                        pair_resid = pair_residual_dir(i, dir_key)
                        TOL_PAIR = TOL_PAIR_BASE
                        pair_term = min(3.0, pair_resid / max(TOL_PAIR, 1e-9))
                        w = 0.6 * (1.0 - conf) + 0.25 * pair_term + 0.15 * (v / sum_v)
                        # Focus extra on highly inconsistent edges
                        if pair_resid > 2.0 * TOL_PAIR:
                            w += 0.1
                        if v < 1.0:
                            w *= 0.5
                        if pass_idx > 0 and consumed_frac_prev.get(i, 0.0) > 0.7:
                            w *= 0.7
                        # Ensure minimal positive weight
                        weights[i] = max(0.02, w)
                    return weights
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                avg_up_traffic = 0.5 * (sum_tx + sum_rx)
                router_delta_guard = ROUTER_TOTAL_DELTA_GUARD * avg_up_traffic
=======
                avg_up_traffic = 0.5 * (sum_tx + sum_rx)
                guard_frac = clamp(0.15 + 0.5 * imbalance + 0.5 * abs(avg_tx_conf - avg_rx_conf), 0.15, 0.35)
                router_delta_guard = guard_frac * avg_up_traffic
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Targeted post-redistribution pair reconcile (only for touched pairs)
    for a_id, b_id in pairs:
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue
        if not (interim[a_id]['touched'] or interim[b_id]['touched']):
            continue

        # Forward: a.tx vs b.rx
        a_tx_old, b_rx_old = interim[a_id]['tx'], interim[b_id]['rx']
        traffic_tx = max(a_tx_old, b_rx_old, 1.0)
        tol_pair_post = max(0.02, 2.5 / traffic_tx)
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > tol_pair_post:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            move_a = PAIR_RECONCILE_FRACTION * (v_mid - a_tx_old)
            move_b = PAIR_RECONCILE_FRACTION * (v_mid - b_rx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_tx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_rx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if abs(a_tx_new - a_tx_old) > EPS:
                rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['edit_tx_abs'] += abs(a_tx_new - a_tx_old)
                interim[a_id]['edit_tx_rel'] = max(interim[a_id]['edit_tx_rel'], rel)
                # Penalty proportional to residual
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], penalty))
            if abs(b_rx_new - b_rx_old) > EPS:
                rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['edit_rx_abs'] += abs(b_rx_new - b_rx_old)
                interim[b_id]['edit_rx_rel'] = max(interim[b_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], penalty))

        # Reverse: a.rx vs b.tx
        a_rx_old, b_tx_old = interim[a_id]['rx'], interim[b_id]['tx']
        traffic_rx = max(a_rx_old, b_tx_old, 1.0)
        tol_pair_post2 = max(0.02, 2.5 / traffic_rx)
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > tol_pair_post2:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            move_a = PAIR_RECONCILE_FRACTION * (v_mid2 - a_rx_old)
            move_b = PAIR_RECONCILE_FRACTION * (v_mid2 - b_tx_old)
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(a_rx_old, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(b_tx_old, 1.0)
            move_a = max(-cap_a, min(cap_a, move_a))
            move_b = max(-cap_b, min(cap_b, move_b))
            a_rx_new = max(0.0, a_rx_old + move_a)
            b_tx_new = max(0.0, b_tx_old + move_b)
            if abs(a_rx_new - a_rx_old) > EPS:
                rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['edit_rx_abs'] += abs(a_rx_new - a_rx_old)
                interim[a_id]['edit_rx_rel'] = max(interim[a_id]['edit_rx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], penalty))
            if abs(b_tx_new - b_tx_old) > EPS:
                rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['edit_tx_abs'] += abs(b_tx_new - b_tx_old)
                interim[b_id]['edit_tx_rel'] = max(interim[b_id]['edit_tx_rel'], rel)
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], penalty))
=======
    # Targeted post-redistribution pair reconcile (only for touched pairs)
    for a_id, b_id in pairs:
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue
        if not (interim[a_id]['touched'] or interim[b_id]['touched']):
            continue

        # Forward: a.tx vs b.rx
        a_tx_old, b_rx_old = interim[a_id]['tx'], interim[b_id]['rx']
        traffic_tx = max(a_tx_old, b_rx_old, 1.0)
        tol_pair_post = max(0.02, 2.5 / traffic_tx)
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > tol_pair_post:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            # Asymmetric moves: lower-confidence end moves more
            conf_a_tx = interim[a_id]['tx_conf']
            conf_b_rx = interim[b_id]['rx_conf']
            alpha_a = ALPHA_LOW if conf_a_tx < conf_b_rx else ALPHA_HIGH
            alpha_b = ALPHA_LOW if conf_b_rx < conf_a_tx else ALPHA_HIGH
            move_a = alpha_a * (v_mid - a_tx_old)
            move_b = alpha_b * (v_mid - b_rx_old)
            # Remaining budget based on pre-router values minus router edits
            cap_a_rem = max(0.0, PAIR_RECONCILE_CAP_FRAC * max(interim[a_id].get('pre_router_tx', a_tx_old), 1.0) - interim[a_id].get('edit_tx_abs', 0.0))
            cap_b_rem = max(0.0, PAIR_RECONCILE_CAP_FRAC * max(interim[b_id].get('pre_router_rx', b_rx_old), 1.0) - interim[b_id].get('edit_rx_abs', 0.0))
            move_a = max(-cap_a_rem, min(cap_a_rem, move_a))
            move_b = max(-cap_b_rem, min(cap_b_rem, move_b))
            a_tx_new = max(0.0, a_tx_old + move_a)
            b_rx_new = max(0.0, b_rx_old + move_b)
            if abs(a_tx_new - a_tx_old) > EPS:
                rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['edit_tx_abs'] += abs(a_tx_new - a_tx_old)
                interim[a_id]['edit_tx_rel'] = max(interim[a_id]['edit_tx_rel'], rel)
                interim[a_id]['touched'] = True
                # Penalty proportional to residual
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], penalty))
            if abs(b_rx_new - b_rx_old) > EPS:
                rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['edit_rx_abs'] += abs(b_rx_new - b_rx_old)
                interim[b_id]['edit_rx_rel'] = max(interim[b_id]['edit_rx_rel'], rel)
                interim[b_id]['touched'] = True
                penalty = 1.0 - 0.3 * min(1.0, res_fwd / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], penalty))

        # Reverse: a.rx vs b.tx
        a_rx_old, b_tx_old = interim[a_id]['rx'], interim[b_id]['tx']
        traffic_rx = max(a_rx_old, b_tx_old, 1.0)
        tol_pair_post2 = max(0.02, 2.5 / traffic_rx)
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > tol_pair_post2:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            conf_a_rx = interim[a_id]['rx_conf']
            conf_b_tx = interim[b_id]['tx_conf']
            alpha_a = ALPHA_LOW if conf_a_rx < conf_b_tx else ALPHA_HIGH
            alpha_b = ALPHA_LOW if conf_b_tx < conf_a_rx else ALPHA_HIGH
            move_a = alpha_a * (v_mid2 - a_rx_old)
            move_b = alpha_b * (v_mid2 - b_tx_old)
            cap_a_rem = max(0.0, PAIR_RECONCILE_CAP_FRAC * max(interim[a_id].get('pre_router_rx', a_rx_old), 1.0) - interim[a_id].get('edit_rx_abs', 0.0))
            cap_b_rem = max(0.0, PAIR_RECONCILE_CAP_FRAC * max(interim[b_id].get('pre_router_tx', b_tx_old), 1.0) - interim[b_id].get('edit_tx_abs', 0.0))
            move_a = max(-cap_a_rem, min(cap_a_rem, move_a))
            move_b = max(-cap_b_rem, min(cap_b_rem, move_b))
            a_rx_new = max(0.0, a_rx_old + move_a)
            b_tx_new = max(0.0, b_tx_old + move_b)
            if abs(a_rx_new - a_rx_old) > EPS:
                rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['edit_rx_abs'] += abs(a_rx_new - a_rx_old)
                interim[a_id]['edit_rx_rel'] = max(interim[a_id]['edit_rx_rel'], rel)
                interim[a_id]['touched'] = True
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], penalty))
            if abs(b_tx_new - b_tx_old) > EPS:
                rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['edit_tx_abs'] += abs(b_tx_new - b_tx_old)
                interim[b_id]['edit_tx_rel'] = max(interim[b_id]['edit_tx_rel'], rel)
                interim[b_id]['touched'] = True
                penalty = 1.0 - 0.3 * min(1.0, res_rev / max(TOL_PAIR_BASE, 1e-9))
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], penalty))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        def finalize_conf(base: float, edit_rel: float, cap_hit: bool, scaled_rel: float, orig_val: float, new_val: float) -> float:
            # Two-slope change penalty
            pen_factor = max(0.0, 1.0 - 0.6 * max(0.0, edit_rel - HARDENING_THRESHOLD))
            conf = clamp(base * pen_factor)
            if cap_hit:
                conf *= 0.9
            if scaled_rel > 0.0:
                conf *= (1.0 - min(0.15, 0.3 * scaled_rel))
            # No-edit bonus
            if rel_diff(orig_val, new_val) <= 1e-3:
                conf = clamp(conf + 0.05)
            return clamp(conf)

        final_tx_conf = finalize_conf(base_tx_conf, edit_tx_rel, cap_hit_tx, scaled_rel_tx, r['orig_tx'], r['tx'])
        final_rx_conf = finalize_conf(base_rx_conf, edit_rx_rel, cap_hit_rx, scaled_rel_rx, r['orig_rx'], r['rx'])
=======
        def finalize_conf(base: float, edit_rel: float, cap_hit: bool, scaled_rel: float, cons_frac: float, s_dev: float, touched: bool, orig_val: float, new_val: float) -> float:
            # Tapered change penalty: lighter for small edits, heavier otherwise
            pen_weight = 0.4 if edit_rel < 0.15 else 0.5
            conf = clamp(base * (1.0 - pen_weight * max(0.0, edit_rel - HARDENING_THRESHOLD)))
            if cap_hit:
                conf *= 0.9
            if scaled_rel > 0.0:
                conf *= (1.0 - min(0.15, 0.3 * scaled_rel))
            # Router-scale severity penalty
            if s_dev > 0.25:
                conf -= (0.03 + 0.02 * clamp((s_dev - 0.25) / 0.75, 0.0, 1.0))
            # Cap consumption penalty if interface consumed >70% of cap
            if cons_frac > 0.7:
                conf -= 0.08 * clamp((cons_frac - 0.7) / 0.3, 0.0, 1.0)
            # Untouched bonus
            if not touched:
                conf += 0.03
            # No-edit bonus
            if rel_diff(orig_val, new_val) <= 1e-3:
                conf = clamp(conf + 0.05)
            return clamp(conf)

        s_dev = router_scale_dev.get(router, 0.0)
        cons_frac_tx = min(1.0, r.get('edit_tx_abs', 0.0) / (STAGED_CAPS[-1] * max(r.get('pre_router_tx', r['orig_tx']), 1.0) + EPS))
        cons_frac_rx = min(1.0, r.get('edit_rx_abs', 0.0) / (STAGED_CAPS[-1] * max(r.get('pre_router_rx', r['orig_rx']), 1.0) + EPS))
        final_tx_conf = finalize_conf(base_tx_conf, edit_tx_rel, cap_hit_tx, scaled_rel_tx, cons_frac_tx, s_dev, r.get('touched', False), r['orig_tx'], r['tx'])
        final_rx_conf = finalize_conf(base_rx_conf, edit_rx_rel, cap_hit_rx, scaled_rel_rx, cons_frac_rx, s_dev, r.get('touched', False), r['orig_rx'], r['rx'])
>>>>>>> REPLACE
</DIFF>