--- a/original.py
+++ b/original.py
@@ -1,291 +1,390 @@
 # EVOLVE-BLOCK-START
 """
-Network telemetry repair algorithm that detects and corrects inconsistencies
-in network interface telemetry data using topology relationships.
-
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
+Network telemetry repair algorithm using consensus graph gradient reconciliation.
+
+This method builds a graph of interface-direction nodes (rx, tx), adds soft
+constraints for link symmetry and router flow conservation, and runs several
+lightweight gradient-style consensus iterations to reconcile counters. It then
+computes calibrated confidences using logistic residual mapping with
+rate-aware tolerance, plus penalties for large changes and router imbalance.
 """
 from typing import Dict, Any, Tuple, List
+import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]], 
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
-    
-    Core principle: Use network invariants to validate and repair telemetry:
-    1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
-    2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
-    3. Interface Consistency: Status should be consistent across connected pairs
-    
-    Args:
-        telemetry: Dictionary where key is interface_id and value contains:
-            - interface_status: "up" or "down" 
-            - rx_rate: receive rate in Mbps
-            - tx_rate: transmit rate in Mbps
-            - connected_to: interface_id this interface connects to
-            - local_router: router_id this interface belongs to
-            - remote_router: router_id on the other side
-        topology: Dictionary where key is router_id and value contains a list of interface_ids
-        
-    Returns:
-        Dictionary with same structure but telemetry values become tuples of:
-        (original_value, repaired_value, confidence_score)
-        where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
+
+    Maintains output structure and fields:
+      - rx_rate, tx_rate, interface_status become (orig, repaired, confidence) tuples
+      - connected_to, local_router, remote_router copied unchanged
     """
-    
-    # Measurement timing tolerance (from Hodor research: ~2%)
-    HARDENING_THRESHOLD = 0.02
+    # Core tolerances
+    HARDENING_THRESHOLD = 0.02  # ~2% base tolerance (Hodor)
+    MIN_TOL = 0.02              # minimum relative tolerance
+    LOW_RATE_CONST = 5.0        # extra absolute tolerance in Mbps for low rates
     EPS = 1e-9
+
+    # Iteration controls
+    ITERATIONS = 5
+    MEAS_STEP_BASE = 0.35   # base step for measurement tether
+    LINK_STEP_BASE = 0.25   # base step for link consensus
+    ROUTER_STEP_CAP = 0.20  # per-iteration cap for router residual step multiplier
 
     # Helpers
     def norm_status(s: Any) -> str:
         s = str(s).lower()
-        return s if s in ("up", "down") else "up"  # treat unknown as up conservatively
+        return s if s in ("up", "down") else "up"
 
     def nz_float(x: Any) -> float:
         try:
             v = float(x)
         except Exception:
             v = 0.0
-        return max(0.0, v)
+        return 0.0 if not math.isfinite(v) else max(0.0, v)
 
     def rel_diff(a: float, b: float) -> float:
         a = float(a)
         b = float(b)
         denom = max(abs(a), abs(b), 1.0)
         return abs(a - b) / denom
 
-    # Precompute peer mapping
+    def rate_aware_tol(a: float, b: float) -> float:
+        # Relative tolerance blended with absolute allowance for low rates
+        mag = max(a, b, 1.0)
+        return max(MIN_TOL, LOW_RATE_CONST / mag)
+
+    # Map interfaces to peers
     peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
 
-    # First pass: link-aware hardening with status-aware zeroing and triage substitution
-    pre: Dict[str, Dict[str, Any]] = {}
+    # Build node structures for directions with initial measurements (m_) and working values (v_)
+    nodes: Dict[str, Dict[str, Any]] = {}
     for iface, data in telemetry.items():
-        local_status = norm_status(data.get('interface_status', 'unknown'))
+        status = norm_status(data.get('interface_status', 'unknown'))
+        rx_m = nz_float(data.get('rx_rate', 0.0))
+        tx_m = nz_float(data.get('tx_rate', 0.0))
+        # Enforce local down -> zero prior
+        if status == 'down':
+            rx_m = 0.0
+            tx_m = 0.0
+        nodes[iface] = {
+            'status': status,
+            'peer_id': peers.get(iface),
+            'router_id': data.get('local_router'),
+            'm_rx': rx_m,
+            'm_tx': tx_m,
+            'v_rx': rx_m,
+            'v_tx': tx_m,
+        }
+
+    # Precompute router groupings of interfaces (only those present in telemetry)
+    router_ifaces: Dict[str, List[str]] = {r: [i for i in ifs if i in telemetry]
+                                           for r, ifs in topology.items()}
+
+    # Initial router imbalance (using priors)
+    router_imbalance: Dict[str, float] = {}
+    for r, if_list in router_ifaces.items():
+        up_ifaces = [i for i in if_list if nodes[i]['status'] == 'up']
+        sum_rx = sum(nodes[i]['m_rx'] for i in up_ifaces)
+        sum_tx = sum(nodes[i]['m_tx'] for i in up_ifaces)
+        denom = max(sum_rx, sum_tx, 1.0)
+        router_imbalance[r] = abs(sum_tx - sum_rx) / denom
+
+    # Compute per-node measurement trust weights using peer residuals and router imbalance
+    w_meas_rx: Dict[str, float] = {}
+    w_meas_tx: Dict[str, float] = {}
+    for iface, nd in nodes.items():
+        status = nd['status']
+        r_id = nd['router_id']
+        imb = router_imbalance.get(r_id, 0.0)
+        # Default moderate trust
+        w_rx = 0.8
+        w_tx = 0.8
+        peer_id = nd['peer_id']
+        if status == 'down':
+            # Strong trust in zeroing
+            w_rx = 1.0
+            w_tx = 1.0
+        elif peer_id and peer_id in nodes and nodes[peer_id]['status'] == 'up':
+            # Use peer to estimate reliability
+            peer = nodes[peer_id]
+            # A.rx should match peer.tx; A.tx should match peer.rx
+            resid_rx = rel_diff(nd['m_rx'], peer['m_tx'])
+            resid_tx = rel_diff(nd['m_tx'], peer['m_rx'])
+            tol_rx = rate_aware_tol(nd['m_rx'], peer['m_tx'])
+            tol_tx = rate_aware_tol(nd['m_tx'], peer['m_rx'])
+            # Scale residual beyond tolerance
+            over_rx = max(0.0, (resid_rx - tol_rx) / max(tol_rx, EPS))
+            over_tx = max(0.0, (resid_tx - tol_tx) / max(tol_tx, EPS))
+            # Convert to trust weights (smaller when over tolerance)
+            w_rx = 1.0 / (1.0 + over_rx)
+            w_tx = 1.0 / (1.0 + over_tx)
+        # Penalize by router imbalance slightly
+        w_rx = max(0.15, min(1.0, w_rx * (1.0 - 0.3 * imb)))
+        w_tx = max(0.15, min(1.0, w_tx * (1.0 - 0.3 * imb)))
+        w_meas_rx[iface] = w_rx
+        w_meas_tx[iface] = w_tx
+
+    # Build link edge constraints (each pair once, but both directions)
+    # Edge structure: (iface_a, dir_a, iface_b, dir_b, weight)
+    link_edges: List[Tuple[str, str, str, str, float]] = []
+    visited_pairs = set()
+    for iface, nd in nodes.items():
+        peer_id = nd['peer_id']
+        if not (peer_id and peer_id in nodes):
+            continue
+        pair_key = tuple(sorted([iface, peer_id]))
+        if pair_key in visited_pairs:
+            continue
+        visited_pairs.add(pair_key)
+        a, b = pair_key
+        A = nodes[a]
+        B = nodes[b]
+        # Link A.rx <-> B.tx
+        tol1 = rate_aware_tol(A['m_rx'], B['m_tx'])
+        # Link A.tx <-> B.rx
+        tol2 = rate_aware_tol(A['m_tx'], B['m_rx'])
+        # Base weights from node trusts, attenuate on very low rates
+        low_rate_factor1 = 0.5 if max(A['m_rx'], B['m_tx']) < 5.0 else 1.0
+        low_rate_factor2 = 0.5 if max(A['m_tx'], B['m_rx']) < 5.0 else 1.0
+        # Weight combine: average of trusts of two endpoints for the specific directions
+        w1 = 0.5 * (w_meas_rx[a] + w_meas_tx[b]) * low_rate_factor1
+        w2 = 0.5 * (w_meas_tx[a] + w_meas_rx[b]) * low_rate_factor2
+        # Slightly strengthen edges when tolerance is tight
+        w1 *= 1.0 + (1.0 - min(1.0, tol1 / 0.2)) * 0.3
+        w2 *= 1.0 + (1.0 - min(1.0, tol2 / 0.2)) * 0.3
+        # Append both directional constraints
+        link_edges.append((a, 'rx', b, 'tx', max(0.0, min(1.5, w1))))
+        link_edges.append((a, 'tx', b, 'rx', max(0.0, min(1.5, w2))))
+
+    # Consensus gradient iterations
+    for _ in range(ITERATIONS):
+        # 1) Measurement tether
+        for iface, nd in nodes.items():
+            if nd['status'] == 'down':
+                nd['v_rx'] = 0.0
+                nd['v_tx'] = 0.0
+                continue
+            # Pull towards measurement with per-direction trust step
+            alpha_rx = MEAS_STEP_BASE * w_meas_rx[iface]
+            alpha_tx = MEAS_STEP_BASE * w_meas_tx[iface]
+            nd['v_rx'] += alpha_rx * (nd['m_rx'] - nd['v_rx'])
+            nd['v_tx'] += alpha_tx * (nd['m_tx'] - nd['v_tx'])
+            nd['v_rx'] = max(0.0, nd['v_rx'])
+            nd['v_tx'] = max(0.0, nd['v_tx'])
+
+        # 2) Link consensus: reduce residuals across edges
+        for a, da, b, db, w in link_edges:
+            A = nodes[a]
+            B = nodes[b]
+            if A['status'] != 'up' or B['status'] != 'up':
+                continue
+            va = A['v_rx'] if da == 'rx' else A['v_tx']
+            vb = B['v_rx'] if db == 'rx' else B['v_tx']
+            r = va - vb
+            step = LINK_STEP_BASE * w * r
+            # Update opposite directions
+            if da == 'rx':
+                A['v_rx'] -= step
+            else:
+                A['v_tx'] -= step
+            if db == 'rx':
+                B['v_rx'] += step
+            else:
+                B['v_tx'] += step
+            # Enforce non-negativity
+            A['v_rx'] = max(0.0, A['v_rx'])
+            A['v_tx'] = max(0.0, A['v_tx'])
+            B['v_rx'] = max(0.0, B['v_rx'])
+            B['v_tx'] = max(0.0, B['v_tx'])
+
+        # 3) Router flow-conservation: reduce (sum_tx - sum_rx)
+        for r, if_list in router_ifaces.items():
+            up_ifaces = [i for i in if_list if nodes[i]['status'] == 'up']
+            if not up_ifaces:
+                continue
+            sum_rx = sum(nodes[i]['v_rx'] for i in up_ifaces)
+            sum_tx = sum(nodes[i]['v_tx'] for i in up_ifaces)
+            denom = max(sum_rx, sum_tx, 1.0)
+            imbalance = abs(sum_tx - sum_rx) / denom
+            if imbalance <= HARDENING_THRESHOLD:
+                continue
+            # Normalize step to avoid overshoot
+            n = len(up_ifaces)
+            # Adaptive step proportional to imbalance, capped for stability
+            step_mag = min(ROUTER_STEP_CAP, 0.5 * imbalance)
+            delta = step_mag * (sum_tx - sum_rx) / max(n, 1)  # same sign as residual
+            # Apply: increase rx, decrease tx to reduce (sum_tx - sum_rx)
+            for i in up_ifaces:
+                nodes[i]['v_rx'] += delta
+                nodes[i]['v_tx'] -= delta
+                nodes[i]['v_rx'] = max(0.0, nodes[i]['v_rx'])
+                nodes[i]['v_tx'] = max(0.0, nodes[i]['v_tx'])
+
+    # Limited symmetry reconciliation pass (pull only the less-trusted side by up to 30% of residual)
+    for a, da, b, db, w in link_edges:
+        A = nodes[a]
+        B = nodes[b]
+        if A['status'] != 'up' or B['status'] != 'up':
+            continue
+        va = A['v_rx'] if da == 'rx' else A['v_tx']
+        vb = B['v_rx'] if db == 'rx' else B['v_tx']
+        # Residual assessment
+        tol = rate_aware_tol(va, vb)
+        resid = rel_diff(va, vb)
+        if resid <= tol:
+            continue
+        # Determine less trusted side using measurement weights
+        trust_a = w_meas_rx[a] if da == 'rx' else w_meas_tx[a]
+        trust_b = w_meas_rx[b] if db == 'rx' else w_meas_tx[b]
+        # Move less-trusted side 30% toward the other
+        frac = 0.30
+        if trust_a < trust_b:
+            new_va = va - frac * (va - vb)
+            if da == 'rx':
+                A['v_rx'] = max(0.0, new_va)
+            else:
+                A['v_tx'] = max(0.0, new_va)
+        else:
+            new_vb = vb - frac * (vb - va)
+            if db == 'rx':
+                B['v_rx'] = max(0.0, new_vb)
+            else:
+                B['v_tx'] = max(0.0, new_vb)
+
+    # Final router imbalance recompute for confidence
+    final_router_imbalance: Dict[str, float] = {}
+    for r, if_list in router_ifaces.items():
+        up_ifaces = [i for i in if_list if nodes[i]['status'] == 'up']
+        sum_rx = sum(nodes[i]['v_rx'] for i in up_ifaces)
+        sum_tx = sum(nodes[i]['v_tx'] for i in up_ifaces)
+        denom = max(sum_rx, sum_tx, 1.0)
+        final_router_imbalance[r] = abs(sum_tx - sum_rx) / denom
+
+    # Prepare output with calibrated confidences
+    result: Dict[str, Dict[str, Tuple]] = {}
+    for iface, data in telemetry.items():
+        status_raw = data.get('interface_status', 'unknown')
+        status = norm_status(status_raw)
         rx_orig = nz_float(data.get('rx_rate', 0.0))
         tx_orig = nz_float(data.get('tx_rate', 0.0))
-
+        rx_rep = nodes[iface]['v_rx']
+        tx_rep = nodes[iface]['v_tx']
+
+        # Enforce zero if down
+        if status == 'down':
+            rx_rep = 0.0
+            tx_rep = 0.0
+
+        # Confidence calculation
         peer_id = peers.get(iface)
-        had_peer = bool(peer_id and peer_id in telemetry)
-        peer_status = 'unknown'
-        peer_rx = peer_tx = 0.0
-
-        if had_peer:
-            pd = telemetry[peer_id]
-            peer_status = norm_status(pd.get('interface_status', 'unknown'))
-            peer_rx = nz_float(pd.get('rx_rate', 0.0))
-            peer_tx = nz_float(pd.get('tx_rate', 0.0))
-
-        pre_rx = rx_orig
-        pre_tx = tx_orig
-        rx_link_diff = 0.0
-        tx_link_diff = 0.0
-
-        # Status-aware zeroing: local down => zero traffic
-        if local_status == 'down':
-            pre_rx = 0.0
-            pre_tx = 0.0
+        router_id = data.get('local_router')
+        router_factor = max(0.2, 1.0 - final_router_imbalance.get(router_id, 0.0))
+
+        # Change penalties
+        rx_change = rel_diff(rx_orig, rx_rep)
+        tx_change = rel_diff(tx_orig, tx_rep)
+        rx_change_pen = max(0.2, 1.0 - 0.6 * min(1.5, rx_change))
+        tx_change_pen = max(0.2, 1.0 - 0.6 * min(1.5, tx_change))
+
+        # Link-based confidence via logistic mapping with rate-aware tolerance
+        def logistic_conf(residual: float, tol: float) -> float:
+            # Conf ≈ 1 when residual <= tol; decays logistically beyond tol
+            x = residual / max(tol, EPS)
+            return 1.0 / (1.0 + math.exp(3.0 * (x - 1.0)))
+
+        if (peer_id and peer_id in nodes 
+            and status == 'up' and nodes[peer_id]['status'] == 'up'):
+            # Residuals after repair
+            # A.rx vs peer.tx; A.tx vs peer.rx
+            resid_rx = rel_diff(rx_rep, nodes[peer_id]['v_tx'])
+            resid_tx = rel_diff(tx_rep, nodes[peer_id]['v_rx'])
+            tol_rx = rate_aware_tol(rx_rep, nodes[peer_id]['v_tx'])
+            tol_tx = rate_aware_tol(tx_rep, nodes[peer_id]['v_rx'])
+            rx_link_conf = logistic_conf(resid_rx, tol_rx)
+            tx_link_conf = logistic_conf(resid_tx, tol_tx)
+        elif status == 'down':
+            rx_link_conf = 0.95 if rx_rep == 0.0 else 0.5
+            tx_link_conf = 0.95 if tx_rep == 0.0 else 0.5
         else:
-            if had_peer and peer_status == 'up':
-                # Link symmetry: A.rx ≈ B.tx, A.tx ≈ B.rx
-                rx_link_diff = rel_diff(rx_orig, peer_tx)
-                tx_link_diff = rel_diff(tx_orig, peer_rx)
-
-                pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
-                pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD
-
-                # Triage: if one pair matches and the other violates, do direct substitution for the violating side
-                if pair_tx_ok and not pair_rx_ok:
-                    pre_rx = peer_tx
-                elif pair_rx_ok and not pair_tx_ok:
-                    pre_tx = peer_rx
-                elif not pair_rx_ok and not pair_tx_ok:
-                    # Multiple faults or timing skew: average redundant signals to harden
-                    pre_rx = 0.5 * (rx_orig + peer_tx)
-                    pre_tx = 0.5 * (tx_orig + peer_rx)
-                # else: both ok -> keep as is
-            else:
-                # No reliable peer signal (no peer or peer down): keep local measurements
-                rx_link_diff = 0.0
-                tx_link_diff = 0.0
-
-        pre[iface] = {
-            'pre_rx': pre_rx,
-            'pre_tx': pre_tx,
-            'rx_link_diff': rx_link_diff,
-            'tx_link_diff': tx_link_diff,
-            'local_status': local_status,
-            'peer_status': peer_status if had_peer else 'unknown',
-            'had_peer': had_peer
-        }
-
-    # Second pass: router-level flow conservation using topology (R1)
-    # Scale only the larger aggregate (RX or TX) to match the smaller when imbalance exceeds tolerance.
-    scale_rx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
-    scale_tx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
-    router_imbalance: Dict[str, float] = {}
-
-    for router_id, iface_list in topology.items():
-        # Consider only interfaces present in telemetry
-        candidate_ifaces = [i for i in iface_list if i in telemetry]
-        if not candidate_ifaces:
-            router_imbalance[router_id] = 0.0
-            continue
-
-        # Active interfaces (local up). Down links already zeroed.
-        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
-        if not up_ifaces:
-            router_imbalance[router_id] = 0.0
-            continue
-
-        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
-        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)
-
-        denom = max(sum_rx, sum_tx, 1.0)
-        imbalance = abs(sum_tx - sum_rx) / denom
-        router_imbalance[router_id] = imbalance
-
-        # Avoid scaling for tiny volumes or single-link routers
-        if (sum_rx + sum_tx) <= 1e-6 or len(up_ifaces) < 2:
-            continue
-
-        if imbalance > HARDENING_THRESHOLD:
-            if sum_tx > sum_rx:
-                k = sum_rx / max(sum_tx, EPS)
-                for i in up_ifaces:
-                    scale_tx[i] = k
-            else:
-                k = sum_tx / max(sum_rx, EPS)
-                for i in up_ifaces:
-                    scale_rx[i] = k
-
-    # Assemble final results with calibrated confidence
-    result: Dict[str, Dict[str, Tuple]] = {}
-    for iface, data in telemetry.items():
-        rx_orig = nz_float(data.get('rx_rate', 0.0))
-        tx_orig = nz_float(data.get('tx_rate', 0.0))
-        local_status = pre[iface]['local_status']
-        peer_status = pre[iface]['peer_status']
-        had_peer = pre[iface]['had_peer']
-
-        # Apply router scaling
-        rx_repaired = pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0)
-        tx_repaired = pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0)
-
-        # Down interfaces must have zero traffic
-        repaired_status = data.get('interface_status', 'unknown')
-        if norm_status(repaired_status) == 'down':
-            rx_repaired = 0.0
-            tx_repaired = 0.0
-
-        # Compute link residuals after scaling using peer's scaled counters
-        peer_id = peers.get(iface)
-        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
-            peer_tx_after = pre[peer_id]['pre_tx'] * scale_tx.get(peer_id, 1.0)
-            peer_rx_after = pre[peer_id]['pre_rx'] * scale_rx.get(peer_id, 1.0)
-            rx_resid = rel_diff(rx_repaired, peer_tx_after)
-            tx_resid = rel_diff(tx_repaired, peer_rx_after)
-            rx_link_conf = max(0.0, 1.0 - rx_resid)
-            tx_link_conf = max(0.0, 1.0 - tx_resid)
-        elif norm_status(repaired_status) == 'down':
-            rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
-            tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
-        else:
-            # No reliable peer information
             rx_link_conf = 0.6
             tx_link_conf = 0.6
 
-        # Router factor from imbalance
-        router_id = data.get('local_router')
-        imbalance = router_imbalance.get(router_id, 0.0)
-        router_factor = max(0.2, 1.0 - imbalance)
-
-        # Change penalty to avoid overconfidence on large corrections
-        rx_change = rel_diff(rx_orig, rx_repaired)
-        tx_change = rel_diff(tx_orig, tx_repaired)
-        rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
-        tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))
-
-        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor))
-        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor))
-
-        # Status handling: keep status unchanged but calibrate confidence
-        status_confidence = 1.0
-        # If peer status differs, reduce confidence
+        rx_conf = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_pen))
+        tx_conf = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_pen))
+
+        # Status confidence: keep status unchanged but calibrate based on inconsistencies
+        status_conf = 1.0
         if peer_id and peer_id in telemetry:
             peer_status_raw = norm_status(telemetry[peer_id].get('interface_status', 'unknown'))
-            if norm_status(repaired_status) != peer_status_raw:
-                status_confidence = min(status_confidence, 0.5)
-        # If interface reports down but had non-zero original counters, lower status confidence
-        if norm_status(repaired_status) == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
-            status_confidence = min(status_confidence, 0.6)
+            if status != peer_status_raw:
+                status_conf = min(status_conf, 0.5)
+        if status == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
+            status_conf = min(status_conf, 0.6)
 
         # Build output entry
         entry: Dict[str, Tuple] = {}
-        entry['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
-        entry['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
-        entry['interface_status'] = (data.get('interface_status', 'unknown'), repaired_status, status_confidence)
-
-        # Copy metadata unchanged
+        entry['rx_rate'] = (rx_orig, rx_rep, rx_conf)
+        entry['tx_rate'] = (tx_orig, tx_rep, tx_conf)
+        entry['interface_status'] = (status_raw, status_raw, status_conf)
         entry['connected_to'] = data.get('connected_to')
         entry['local_router'] = data.get('local_router')
         entry['remote_router'] = data.get('remote_router')
-
         result[iface] = entry
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
     
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
     
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
     
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
     
     result = run_repair(test_telemetry, test_topology)
     
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")
 
