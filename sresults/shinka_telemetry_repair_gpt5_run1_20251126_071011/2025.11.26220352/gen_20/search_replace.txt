<NAME>
bounded_scale_additive_and_pair_reconcile
</NAME>

<DESCRIPTION>
I propose three targeted improvements to boost counter accuracy and confidence calibration while preserving stability:

1) Replace the rigid router-wide multiplicative scaling with a two-stage repair:
   - A bounded multiplicative pre-step per interface (capped at ±15%) nudges the less-trusted direction toward balance.
   - A confidence-weighted, capacity-capped additive redistribution corrects the remaining router imbalance (caps at ±35% per interface; two passes). This targets the least reliable counters more, avoiding over-correction on trusted ones.

2) Add a limited post-router pair reconciliation pass to pull each link’s opposing counters toward each other by 30% of the residual when asymmetry exceeds tolerance. This guards against router-level edits drifting pairs apart and reinforces symmetry.

3) Improve confidence calibration:
   - Switch conf_from_residual to a logistic decay for smoother calibration.
   - Use rate-aware pair tolerances during final confidence computation to avoid over-penalizing tiny-rate links.

These changes align with the Hodor three-step flow: signal hardening via symmetry, dynamic checking via flow conservation, and calibrated confidence based on residuals and magnitude of edits. Constants are added for caps and alpha, and the implementation reuses existing structures and topology. The edits are localized to router redistribution, final confidence mapping, and a small post-redistribution reconciliation block.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    # Gentle multiplicative pre-step per-interface cap
    MULT_PRESTEP_CAP_FRAC = 0.15
    # Pair reconciliation strength after router redistribution
    PAIR_RECONCILE_ALPHA = 0.30
    # Numerical epsilon
    EPS = 1e-9
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def conf_from_residual(residual: float, tol: float) -> float:
        # Map residual to confidence: 1 at 0 residual, degrades linearly until ~0 near 5*tol
        denom = max(tol * 5.0, 1e-9)
        return clamp(1.0 - residual / denom)
=======
    def conf_from_residual(residual: float, tol: float) -> float:
        # Logistic decay for smoother, better-calibrated confidence
        tol = max(tol, 1e-9)
        x = residual / tol
        k = 3.0
        return clamp(1.0 / (1.0 + (2.718281828459045 ** (k * (x - 1.0)))))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    for router, if_list in router_ifaces.items():
        # Consider only interfaces present in telemetry
        interfaces = [i for i in if_list if i in interim]
        if not interfaces:
            continue

        # Compute sums over "up" interfaces
        sum_tx = 0.0
        sum_rx = 0.0
        tx_conf_acc = 0.0
        rx_conf_acc = 0.0
        up_count_tx = 0
        up_count_rx = 0
        for i in interfaces:
            if interim[i]['status'] == 'up':
                sum_tx += max(0.0, interim[i]['tx'])
                sum_rx += max(0.0, interim[i]['rx'])
                tx_conf_acc += interim[i]['tx_conf']
                rx_conf_acc += interim[i]['rx_conf']
                up_count_tx += 1
                up_count_rx += 1

        if up_count_tx == 0 or up_count_rx == 0:
            continue

        # Evaluate flow imbalance
        imbalance = rel_diff(sum_tx, sum_rx)
        if imbalance <= HARDENING_THRESHOLD * 2:
            # Within tolerance; no router-level scaling needed
            continue

        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)

        # Decide which direction to scale: scale the less trusted direction
        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling to avoid extreme corrections
        s_bounded = max(0.5, min(2.0, s))

        # Apply scaling and update confidences
        for i in interfaces:
            if interim[i]['status'] != 'up':
                continue
            if scale_rx:
                old_val = interim[i]['rx']
                interim[i]['rx'] = old_val * s_bounded
                # Confidence drops with imbalance and scaling magnitude
                interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, imbalance + abs(1.0 - s_bounded))))
            else:
                old_val = interim[i]['tx']
                interim[i]['tx'] = old_val * s_bounded
                interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, imbalance + abs(1.0 - s_bounded))))
=======
    for router, if_list in router_ifaces.items():
        # Consider only interfaces present in telemetry
        interfaces = [i for i in if_list if i in interim]
        if not interfaces:
            continue

        # Compute sums over "up" interfaces and collect up_list
        sum_tx = 0.0
        sum_rx = 0.0
        tx_conf_acc = 0.0
        rx_conf_acc = 0.0
        up_list = []
        for i in interfaces:
            if interim[i]['status'] == 'up':
                up_list.append(i)
                sum_tx += max(0.0, interim[i]['tx'])
                sum_rx += max(0.0, interim[i]['rx'])
                tx_conf_acc += interim[i]['tx_conf']
                rx_conf_acc += interim[i]['rx_conf']

        if not up_list:
            continue

        avg_tx_conf = tx_conf_acc / max(1, len(up_list))
        avg_rx_conf = rx_conf_acc / max(1, len(up_list))

        # Evaluate flow imbalance
        imbalance = rel_diff(sum_tx, sum_rx)
        if imbalance <= HARDENING_THRESHOLD * 2:
            # Within tolerance; no router-level scaling needed
            continue

        # Decide which direction to scale: scale the less trusted direction
        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling to avoid extreme corrections
        s_bounded = max(0.5, min(2.0, s))

        # Multiplicative pre-step with per-interface cap
        s_step = max(0.85, min(1.15, s_bounded ** 0.5))
        if abs(1.0 - s_step) > 0.01:
            for i in up_list:
                if scale_rx:
                    old_v = max(0.0, float(interim[i]['rx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['rx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    # Confidence drops with imbalance, scaling distance and per-interface change
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    old_v = max(0.0, float(interim[i]['tx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['tx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))

        # Recompute totals after multiplicative step
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx

        need = target_total - sum_old
        # Skip tiny residuals
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            continue

        # Build weights from direction-specific confidence (lower confidence -> larger weight)
        weights: Dict[str, float] = {}
        values: Dict[str, float] = {}
        caps_pos: Dict[str, float] = {}
        caps_neg: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                conf = float(interim[i]['rx_conf'])
                v = max(0.0, float(interim[i]['rx']))
            else:
                conf = float(interim[i]['tx_conf'])
                v = max(0.0, float(interim[i]['tx']))
            weights[i] = max(0.05, 1.0 - conf)
            values[i] = v
            cap = MAX_ROUTER_ADJ_FRAC * max(v, 1.0)
            caps_pos[i] = cap
            caps_neg[i] = cap

        # Two-pass capacity-capped redistribution
        for _pass in range(2):
            if abs(need) <= EPS:
                break
            elig = [i for i in up_list if (caps_pos[i] if need > 0 else caps_neg[i]) > EPS]
            if not elig:
                break
            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                break
            for i in elig:
                quota = need * (weights[i] / max(sumW, EPS))
                if need > 0:
                    d = min(max(0.0, quota), caps_pos[i])
                    caps_pos[i] -= d
                else:
                    d = -min(max(0.0, -quota), caps_neg[i])
                    caps_neg[i] -= -d
                if abs(d) <= EPS:
                    continue
                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                need -= d
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Final confidence calibration based on post-repair invariants
=======
    # Limited pair-symmetry reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue
        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']; b_rx_old = interim[b_id]['rx']
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > HARDENING_THRESHOLD:
            v_mid = (a_tx_old + b_rx_old) / 2.0
            a_tx_new = max(0.0, a_tx_old + PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old))
            b_rx_new = max(0.0, b_rx_old + PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old))
            if a_tx_new != a_tx_old:
                drel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], 1.0 - 0.5 * drel))
            if b_rx_new != b_rx_old:
                drel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], 1.0 - 0.5 * drel))
        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']; b_tx_old = interim[b_id]['tx']
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > HARDENING_THRESHOLD:
            v_mid2 = (a_rx_old + b_tx_old) / 2.0
            a_rx_new = max(0.0, a_rx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old))
            b_tx_new = max(0.0, b_tx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old))
            if a_rx_new != a_rx_old:
                drel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], 1.0 - 0.5 * drel))
            if b_tx_new != b_tx_old:
                drel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], 1.0 - 0.5 * drel))

    # Final confidence calibration based on post-repair invariants
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            pair_comp_tx = conf_from_residual(res_fwd, TOL_PAIR)
            pair_comp_rx = conf_from_residual(res_rev, TOL_PAIR)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
=======
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            # Rate-aware tolerances so low-rate links aren't over-penalized
            traffic_tx = max(r['tx'], interim[peer]['rx'])
            traffic_rx = max(r['rx'], interim[peer]['tx'])
            tol_pair_tx = max(HARDENING_THRESHOLD, 5.0 / max(traffic_tx, 1.0))
            tol_pair_rx = max(HARDENING_THRESHOLD, 5.0 / max(traffic_rx, 1.0))
            pair_comp_tx = conf_from_residual(res_fwd, tol_pair_tx)
            pair_comp_rx = conf_from_residual(res_rev, tol_pair_rx)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
>>>>>>> REPLACE
</DIFF>