<NAME>
adaptive_router_guard_and_remaining_pair_caps
</NAME>

<DESCRIPTION>
I propose three targeted improvements that strengthen both repair accuracy and confidence calibration by better aligning with the Hodor-style hardening and flow-conservation strategy:

1) Adaptive router redistribution guard: Replace the fixed 25% router delta guard with an adaptive guard that scales with residual imbalance and the difference between average TX and RX confidence on the router. This prevents over- or under-adjusting and biases redistribution where signals are less consistent. It follows potential recommendation 2.

2) Enriched additive weights and protection: Enhance the additive redistribution weights with a floor, a boost for large pair residuals (beyond 2× tolerance), and keep protections for tiny links and cap-stressed interfaces. This focuses corrections where inconsistencies are strongest while avoiding overfitting on small counters. It follows potential recommendation 3.

3) Pair reconciliation budgeted by remaining per-interface cap: Enforce that pair reconciliation consumes only the remaining per-interface budget after router passes, using pre-router baselines and tracking cumulative absolute changes (including pair edits). This ensures cumulative corrections per direction do not exceed 20% of the pre-router values, improving calibration and preventing overcorrection. It follows potential recommendation 4. Confidence is further calibrated by penalizing interfaces that consume >70–85% of their cumulative cap.

These changes are limited, consistent with the current structure, and reuse existing helper utilities (clamp, pair_tolerance). They aim to improve counter accuracy while producing well-calibrated confidence scores.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    router_scale_dir: Dict[str, str] = {}  # 'rx' or 'tx' for diagnostics
    # Track per-interface relative delta from router scaling, used for confidence calibration
    router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
=======
    router_scale_dir: Dict[str, str] = {}  # 'rx' or 'tx' for diagnostics
    # Track per-interface relative and absolute deltas from router scaling, used for confidence calibration and remaining caps
    router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
    router_delta_abs: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if dir_to_scale == 'tx':
                old = post_router[i]['tx']
                new = old * k
                # Cap per-interface multiplicative delta to ±15%
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['tx'] = max(0.0, new_capped)
                router_delta_rel[i]['tx'] = abs(post_router[i]['tx'] - old) / max(old, 1.0)
            else:
                old = post_router[i]['rx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['rx'] = max(0.0, new_capped)
                router_delta_rel[i]['rx'] = abs(post_router[i]['rx'] - old) / max(old, 1.0)
=======
            if dir_to_scale == 'tx':
                old = post_router[i]['tx']
                new = old * k
                # Cap per-interface multiplicative delta to ±15%
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['tx'] = max(0.0, new_capped)
                delta_abs = abs(post_router[i]['tx'] - old)
                router_delta_rel[i]['tx'] = delta_abs / max(old, 1.0)
                router_delta_abs[i]['tx'] += delta_abs
            else:
                old = post_router[i]['rx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['rx'] = max(0.0, new_capped)
                delta_abs = abs(post_router[i]['rx'] - old)
                router_delta_rel[i]['rx'] = delta_abs / max(old, 1.0)
                router_delta_abs[i]['rx'] += delta_abs
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Per-router total delta guard (≤ 25% of average traffic)
        router_cap_abs = 0.25 * ((sum_rx2 + sum_tx2) / 2.0)
        need = clamp(need, -router_cap_abs, router_cap_abs)
=======
        # Adaptive per-router total delta guard based on imbalance and confidence skew
        tx_confs = [max(0.0, 1.0 - pre[i]['tx_link_diff']) for i in up_ifaces]
        rx_confs = [max(0.0, 1.0 - pre[i]['rx_link_diff']) for i in up_ifaces]
        avg_tx_conf = sum(tx_confs) / len(tx_confs) if tx_confs else 0.5
        avg_rx_conf = sum(rx_confs) / len(rx_confs) if rx_confs else 0.5
        imb2 = abs(sum_tx2 - sum_rx2) / denom2
        guard_frac = clamp(0.15 + 0.5 * imb2 + 0.5 * abs(avg_tx_conf - avg_rx_conf), 0.15, 0.35)
        router_cap_abs = guard_frac * ((sum_rx2 + sum_tx2) / 2.0)
        need = clamp(need, -router_cap_abs, router_cap_abs)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            vol_term = (v_i / sum_v) if sum_v > 0 else 0.0
            w = 0.6 * (1.0 - conf_dir) + 0.25 * pair_term + 0.15 * vol_term

            # Protect tiny links and reduce weight if heavily adjusted multiplicatively already
            if v_i < 1.0:
                w *= 0.5
            prev_rel = router_delta_rel[i]['tx'] if dir_to_adj == 'tx' else router_delta_rel[i]['rx']
            if prev_rel >= 0.105:  # >70% of 15% multiplicative cap
                w *= 0.7

            weights[i] = max(0.0, w)
            caps[i] = 0.15 * max(v_i, 1.0)  # per-interface additive cap
=======
            vol_term = (v_i / sum_v) if sum_v > 0 else 0.0
            w = 0.6 * (1.0 - conf_dir) + 0.25 * pair_term + 0.15 * vol_term
            # Boost weight for large residuals far beyond tolerance
            if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                tol_pair = pair_tolerance(vals[i], post_router[peer_id]['rx'] if dir_to_adj == 'tx' else post_router[peer_id]['tx'])
                resid_pair = rel_diff(vals[i], post_router[peer_id]['rx'] if dir_to_adj == 'tx' else post_router[peer_id]['tx'])
                if resid_pair > 2.0 * tol_pair:
                    w += 0.1

            # Protect tiny links and reduce weight if heavily adjusted multiplicatively already
            if v_i < 1.0:
                w *= 0.5
            prev_rel = router_delta_rel[i]['tx'] if dir_to_adj == 'tx' else router_delta_rel[i]['rx']
            if prev_rel >= 0.105:  # >70% of 15% multiplicative cap
                w *= 0.7

            weights[i] = max(0.02, w)  # keep a small floor
            caps[i] = 0.15 * max(v_i, 1.0)  # per-interface additive cap
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if dir_to_adj == 'tx':
                oldv = post_router[i]['tx']
                post_router[i]['tx'] = max(0.0, oldv + d)
                router_delta_rel[i]['tx'] += abs(d) / max(oldv, 1.0)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['tx'] = True
            else:
                oldv = post_router[i]['rx']
                post_router[i]['rx'] = max(0.0, oldv + d)
                router_delta_rel[i]['rx'] += abs(d) / max(oldv, 1.0)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['rx'] = True
=======
            if dir_to_adj == 'tx':
                oldv = post_router[i]['tx']
                post_router[i]['tx'] = max(0.0, oldv + d)
                router_delta_rel[i]['tx'] += abs(d) / max(oldv, 1.0)
                router_delta_abs[i]['tx'] += abs(d)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['tx'] = True
            else:
                oldv = post_router[i]['rx']
                post_router[i]['rx'] = max(0.0, oldv + d)
                router_delta_rel[i]['rx'] += abs(d) / max(oldv, 1.0)
                router_delta_abs[i]['rx'] += abs(d)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['rx'] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Cap moves to remaining per-interface budget (≤ 20% of current value)
            cap_a = 0.2 * max(a_tx, 1.0)
            cap_b = 0.2 * max(b_rx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)

            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)

            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))

            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx
=======
            # Cap moves to remaining per-interface budget (≤ 20% of pre-router value minus router edits)
            base_a = pre[iface]['pre_tx']
            base_b = pre[peer_id]['pre_rx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs[iface]['tx'])
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs[peer_id]['rx'])
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)

            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)

            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))

            # Track pair adjustments into cumulative absolute deltas
            router_delta_abs[iface]['tx'] += abs(new_a_tx - a_tx)
            router_delta_abs[peer_id]['rx'] += abs(new_b_rx - b_rx)

            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            cap_a = 0.2 * max(a_rx, 1.0)
            cap_b = 0.2 * max(b_tx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)

            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)

            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))

            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
=======
            base_a = pre[iface]['pre_rx']
            base_b = pre[peer_id]['pre_tx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs[iface]['rx'])
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs[peer_id]['tx'])
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)

            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)

            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))

            # Track pair adjustments into cumulative absolute deltas
            router_delta_abs[iface]['rx'] += abs(new_a_rx - a_rx)
            router_delta_abs[peer_id]['tx'] += abs(new_b_tx - b_tx)

            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_conf = rx_link_conf * router_factor * rx_change_factor
        tx_conf = tx_link_conf * router_factor * tx_change_factor

        # Penalties for heavy router scaling usage and pair adjustments (helps calibration)
        rdel_rx = router_delta_rel[iface]['rx']
        rdel_tx = router_delta_rel[iface]['tx']
        if rdel_rx >= 0.12:
            rx_conf -= 0.03
        elif rdel_rx >= 0.07:
            rx_conf -= 0.02
        if rdel_tx >= 0.12:
            tx_conf -= 0.03
        elif rdel_tx >= 0.07:
            tx_conf -= 0.02

        padj_rx = pair_adj_rel[iface]['rx']
        padj_tx = pair_adj_rel[iface]['tx']
        rx_conf -= min(0.05, 0.25 * padj_rx)
        tx_conf -= min(0.05, 0.25 * padj_tx)

        # Penalty when additive redistribution consumed most of per-interface cap
        if 'add_cap_hit' in locals():
            if add_cap_hit.get(iface, {}).get('rx', False):
                rx_conf -= 0.04
            if add_cap_hit.get(iface, {}).get('tx', False):
                tx_conf -= 0.04
=======
        rx_conf = rx_link_conf * router_factor * rx_change_factor
        tx_conf = tx_link_conf * router_factor * tx_change_factor

        # Penalties for heavy router scaling usage and pair adjustments (helps calibration)
        rdel_rx = router_delta_rel[iface]['rx']
        rdel_tx = router_delta_rel[iface]['tx']
        if rdel_rx >= 0.12:
            rx_conf -= 0.03
        elif rdel_rx >= 0.07:
            rx_conf -= 0.02
        if rdel_tx >= 0.12:
            tx_conf -= 0.03
        elif rdel_tx >= 0.07:
            tx_conf -= 0.02

        padj_rx = pair_adj_rel[iface]['rx']
        padj_tx = pair_adj_rel[iface]['tx']
        rx_conf -= min(0.05, 0.25 * padj_rx)
        tx_conf -= min(0.05, 0.25 * padj_tx)

        # Penalty when additive redistribution consumed most of per-interface cap
        if 'add_cap_hit' in locals():
            if add_cap_hit.get(iface, {}).get('rx', False):
                rx_conf -= 0.04
            if add_cap_hit.get(iface, {}).get('tx', False):
                tx_conf -= 0.04

        # Cap-intensity penalties when cumulative edits approach remaining budget
        cap_tot_rx = 0.20 * max(pre[iface]['pre_rx'], 1.0)
        cap_tot_tx = 0.20 * max(pre[iface]['pre_tx'], 1.0)
        util_rx = (router_delta_abs[iface]['rx'] / cap_tot_rx) if cap_tot_rx > 0 else 0.0
        util_tx = (router_delta_abs[iface]['tx'] / cap_tot_tx) if cap_tot_tx > 0 else 0.0
        if util_rx > 0.85:
            rx_conf -= 0.08
        elif util_rx > 0.70:
            rx_conf -= 0.05
        if util_tx > 0.85:
            tx_conf -= 0.08
        elif util_tx > 0.70:
            tx_conf -= 0.05
>>>>>>> REPLACE
</DIFF>