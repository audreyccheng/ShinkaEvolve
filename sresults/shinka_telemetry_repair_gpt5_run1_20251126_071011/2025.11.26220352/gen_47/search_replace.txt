<NAME>
confidence_tuning_with_edit_tracking
</NAME>

<DESCRIPTION>
I propose a targeted improvement to confidence calibration without changing the repaired values, thereby protecting counter_repair_accuracy while aiming to boost confidence_calibration and overall combined_score.

Key ideas:
- Track whether each interface’s RX/TX was edited in the pre-pass, scaled at the router, and later changed by pairwise reconciliation.
- Adjust confidence with small bonuses when values were untouched (more trustworthy) and small penalties when heavy router scaling or large per-interface shifts occurred. This follows the Hodor-style calibration principle: more redundancy agreement and less change → higher confidence, and vice versa.
- This change introduces no modifications to the repair values, minimizing risk to counter accuracy, while improving the alignment of confidence scores with the quality of the repairs.

Concrete changes:
1) Record pre-pass edit flags (pre_rx_changed/pre_tx_changed).
2) Capture baseline post-scaled values and detect pairwise reconciliation edits.
3) Apply per-direction confidence bonuses/penalties:
   - +0.03 bonus if an interface’s direction was untouched by pre, scaling, and pair reconciliation.
   - -0.03 to -0.05 penalty if router scaling magnitude exceeds 25%/50%.
   - -0.03 to -0.05 penalty for large per-direction changes (>40%/>70%), supplementing the existing multiplicative change factor for better calibration.

These adjustments keep the algorithm’s repair logic intact and focus solely on more faithful confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        pre[iface] = {
            'pre_rx': pre_rx,
            'pre_tx': pre_tx,
            'rx_link_diff': rx_link_diff,
            'tx_link_diff': tx_link_diff,
            'local_status': local_status,
            'peer_status': peer_status if had_peer else 'unknown',
            'had_peer': had_peer
        }
=======
        pre[iface] = {
            'pre_rx': pre_rx,
            'pre_tx': pre_tx,
            'rx_link_diff': rx_link_diff,
            'tx_link_diff': tx_link_diff,
            'local_status': local_status,
            'peer_status': peer_status if had_peer else 'unknown',
            'had_peer': had_peer,
            # Track whether the pre-pass changed values relative to original inputs
            'pre_rx_changed': abs(pre_rx - rx_orig) > 1e-9,
            'pre_tx_changed': abs(pre_tx - tx_orig) > 1e-9,
        }
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    post: Dict[str, Dict[str, float]] = {}
    for iface in telemetry:
        post[iface] = {
            'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
            'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
        }
=======
    post: Dict[str, Dict[str, float]] = {}
    base_post: Dict[str, Dict[str, float]] = {}
    for iface in telemetry:
        base_post[iface] = {
            'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
            'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
        }
        # Start post as a copy of the base (will be potentially adjusted by reconciliation)
        post[iface] = {
            'rx': base_post[iface]['rx'],
            'tx': base_post[iface]['tx'],
        }
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Assemble final results with calibrated confidence
    result: Dict[str, Dict[str, Tuple]] = {}
=======
    # Determine which interfaces were edited during pair reconciliation
    pair_edits: Dict[str, Dict[str, bool]] = {}
    for iface in telemetry:
        base = base_post[iface]
        now = post[iface]
        pair_edits[iface] = {
            'rx_edited': abs(now['rx'] - base['rx']) > 1e-9,
            'tx_edited': abs(now['tx'] - base['tx']) > 1e-9,
        }

    # Assemble final results with calibrated confidence
    result: Dict[str, Dict[str, Tuple]] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor))
        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor))
=======
        # Apply confidence tuning with edit-tracking bonuses/penalties
        rx_confidence = rx_link_conf * router_factor * rx_change_factor
        tx_confidence = tx_link_conf * router_factor * tx_change_factor

        # Router scaling penalties per direction
        s_dev_rx = abs(scale_rx.get(iface, 1.0) - 1.0)
        s_dev_tx = abs(scale_tx.get(iface, 1.0) - 1.0)
        if s_dev_rx > 0.5:
            rx_confidence -= 0.05
        elif s_dev_rx > 0.25:
            rx_confidence -= 0.03
        if s_dev_tx > 0.5:
            tx_confidence -= 0.05
        elif s_dev_tx > 0.25:
            tx_confidence -= 0.03

        # Additional large-change penalties (complements multiplicative change factor)
        if rx_change > 0.7:
            rx_confidence -= 0.05
        elif rx_change > 0.4:
            rx_confidence -= 0.03
        if tx_change > 0.7:
            tx_confidence -= 0.05
        elif tx_change > 0.4:
            tx_confidence -= 0.03

        # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
        rx_untouched = (not pre[iface]['pre_rx_changed']) and (s_dev_rx == 0.0) and (not pair_edits.get(iface, {}).get('rx_edited', False))
        tx_untouched = (not pre[iface]['pre_tx_changed']) and (s_dev_tx == 0.0) and (not pair_edits.get(iface, {}).get('tx_edited', False))
        if rx_untouched:
            rx_confidence += 0.03
        if tx_untouched:
            tx_confidence += 0.03

        rx_confidence = max(0.0, min(1.0, rx_confidence))
        tx_confidence = max(0.0, min(1.0, tx_confidence))
>>>>>>> REPLACE
</DIFF>