# EVOLVE-BLOCK-START
"""
Alternating weighted projections for network telemetry repair.

Core differences from prior designs:
- Uses convex weighted L2 projections onto invariant sets rather than heuristic
  multiplicative/additive redistribution with caps.
- Pair symmetry is enforced via weighted least-squares averaging (projection onto
  equality subspaces) using trust-derived weights.
- Router flow conservation is enforced via a closed-form weighted projection
  (one equality constraint) with an active-set loop to honor nonnegativity.
- Confidences are derived from invariant residuals, edit magnitudes, and measured
  improvements, calibrated to avoid overconfidence.
"""
from typing import Dict, Any, Tuple, List
from math import isfinite

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    # Tolerances and constants
    HARDENING_THRESHOLD = 0.02            # Ï„h ~2%
    TRAFFIC_EVIDENCE_MIN = 0.5            # Mbps: evidence for link up
    EPS = 1e-9

    # Confidence/tolerance settings
    TOL_PAIR_BASE = HARDENING_THRESHOLD * 1.5
    TOL_ROUTER = HARDENING_THRESHOLD * 2.0
    SMALL_RATE = 1.0

    # Confidence component weights
    W_PAIR, W_ROUTER, W_STATUS = 0.6, 0.3, 0.1

    def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
        if not isfinite(x):
            return lo
        return max(lo, min(hi, x))

    def rel_diff(a: float, b: float) -> float:
        denom = max(abs(a), abs(b), 1e-9)
        return abs(a - b) / denom

    def conf_from_residual(residual: float, tol: float) -> float:
        tol = max(tol, 1e-9)
        x = residual / tol
        conf = 1.0 - min(1.0, x / 5.0)
        if x > 3.0:
            conf -= 0.1 * (x - 3.0) / 2.0
        return clamp(conf)

    # Build pairs
    visited = set()
    pairs: List[Tuple[str, str]] = []
    for if_id, data in telemetry.items():
        p = data.get('connected_to')
        if p and p in telemetry:
            key = tuple(sorted([if_id, p]))
            if key not in visited:
                visited.add(key)
                pairs.append((key[0], key[1]))

    peer_of: Dict[str, str] = {}
    paired_ids = set()
    for a_id, b_id in pairs:
        peer_of[a_id] = b_id
        peer_of[b_id] = a_id
        paired_ids.add(a_id); paired_ids.add(b_id)

    # Initialize working copy
    interim: Dict[str, Dict[str, Any]] = {}
    for if_id, d in telemetry.items():
        rx0 = float(d.get('rx_rate', 0.0))
        tx0 = float(d.get('tx_rate', 0.0))
        st0 = d.get('interface_status', 'unknown')
        interim[if_id] = {
            'rx': rx0, 'tx': tx0,
            'orig_rx': rx0, 'orig_tx': tx0, 'orig_status': st0,
            'status': st0, 'status_conf': 1.0,
            'rx_conf': 1.0, 'tx_conf': 1.0,
            'local_router': d.get('local_router'),
            'remote_router': d.get('remote_router'),
            'connected_to': d.get('connected_to'),
            # trust/weight placeholders
            'w_pen_rx': 1.0, 'w_pen_tx': 1.0,
            # edit tracking
            'edit_rx_rel': 0.0, 'edit_tx_rel': 0.0,
            'clamped_zero_rx': False, 'clamped_zero_tx': False,
        }

    # Build router->interfaces map
    if topology:
        router_ifaces: Dict[str, List[str]] = {r: [i for i in if_list if i in interim] for r, if_list in topology.items()}
    else:
        router_ifaces = {}
        for if_id, d in telemetry.items():
            r = d.get('local_router')
            if r is not None and if_id in interim:
                router_ifaces.setdefault(r, []).append(if_id)

    # Resolve status using redundancy and traffic evidence
    for a_id, b_id in pairs:
        a = telemetry[a_id]; b = telemetry[b_id]
        a_stat = a.get('interface_status', 'unknown')
        b_stat = b.get('interface_status', 'unknown')
        a_rx, a_tx = float(a.get('rx_rate', 0.0)), float(a.get('tx_rate', 0.0))
        b_rx, b_tx = float(b.get('rx_rate', 0.0)), float(b.get('tx_rate', 0.0))
        max_tr = max(a_rx, a_tx, b_rx, b_tx)
        if a_stat == b_stat:
            resolved = a_stat
            sconf = 0.95 if resolved in ('up', 'down') else 0.7
        else:
            if max_tr > TRAFFIC_EVIDENCE_MIN:
                resolved = 'up'; sconf = 0.85
            else:
                resolved = 'down'; sconf = 0.75
        interim[a_id]['status'] = resolved
        interim[b_id]['status'] = resolved
        interim[a_id]['status_conf'] = min(interim[a_id]['status_conf'], sconf)
        interim[b_id]['status_conf'] = min(interim[b_id]['status_conf'], sconf)

    # Enforce down->zero and set confidences accordingly
    for if_id, r in interim.items():
        if r['status'] == 'down':
            rx0, tx0 = r['rx'], r['tx']
            r['rx'] = 0.0; r['tx'] = 0.0
            r['rx_conf'] = 0.9 if rx0 <= TRAFFIC_EVIDENCE_MIN else 0.3
            r['tx_conf'] = 0.9 if tx0 <= TRAFFIC_EVIDENCE_MIN else 0.3

    # Compute pre-edit trust/conf using original values
    # 1) Pair residual trust
    pair_conf_tx: Dict[str, float] = {}
    pair_conf_rx: Dict[str, float] = {}
    for if_id in interim:
        pair_conf_tx[if_id] = 0.65
        pair_conf_rx[if_id] = 0.65
    for a_id, b_id in pairs:
        a0 = telemetry[a_id]; b0 = telemetry[b_id]
        # Only use when intended up (traffic evidence)
        if interim[a_id]['status'] != 'down' and interim[b_id]['status'] != 'down':
            a_tx0, b_rx0 = float(a0.get('tx_rate', 0.0)), float(b0.get('rx_rate', 0.0))
            a_rx0, b_tx0 = float(a0.get('rx_rate', 0.0)), float(b0.get('tx_rate', 0.0))
            tr_tx = max(a_tx0, b_rx0, 1.0)
            tr_rx = max(a_rx0, b_tx0, 1.0)
            tol_tx = min(0.12, max(TOL_PAIR_BASE, 5.0 / tr_tx))
            tol_rx = min(0.12, max(TOL_PAIR_BASE, 5.0 / tr_rx))
            c_tx = conf_from_residual(rel_diff(a_tx0, b_rx0), tol_tx)
            c_rx = conf_from_residual(rel_diff(a_rx0, b_tx0), tol_rx)
            pair_conf_tx[a_id] = c_tx
            pair_conf_rx[a_id] = c_rx
            pair_conf_tx[b_id] = c_rx  # symmetric mapping
            pair_conf_rx[b_id] = c_tx

    # 2) Router outlier trust (robust)
    def robust_conf(values: List[float], v: float) -> float:
        arr = [x for x in values if isfinite(x)]
        if not arr:
            return 0.7
        arr_sorted = sorted(arr)
        n = len(arr_sorted)
        med = arr_sorted[n // 2]
        abs_dev = [abs(x - med) for x in arr_sorted]
        mad = sorted(abs_dev)[n // 2] if n > 0 else 0.0
        scale = mad if mad > 1e-6 else max(1.0, abs(med))
        z = abs(v - med) / max(scale, 1e-9)
        # Map to [0,1], penalize strong outliers
        return clamp(1.0 / (1.0 + 0.5 * z))

    outlier_conf_tx: Dict[str, float] = {}
    outlier_conf_rx: Dict[str, float] = {}
    for router, if_list in router_ifaces.items():
        ups = [i for i in if_list if interim[i]['status'] == 'up']
        tx_vals = [max(0.0, interim[i]['tx']) for i in ups]
        rx_vals = [max(0.0, interim[i]['rx']) for i in ups]
        for i in ups:
            outlier_conf_tx[i] = robust_conf(tx_vals, max(0.0, interim[i]['tx']))
            outlier_conf_rx[i] = robust_conf(rx_vals, max(0.0, interim[i]['rx']))
    # Default confs for non-up or missing
    for if_id in interim:
        outlier_conf_tx.setdefault(if_id, 0.7)
        outlier_conf_rx.setdefault(if_id, 0.7)

    # Compose base directional trust and convert to penalty weights (bigger weight => resist change)
    for if_id, r in interim.items():
        if r['status'] == 'up':
            # Tiny links: don't over-penalize deviations
            tiny_tx = 0.85 if r['tx'] < SMALL_RATE else 1.0
            tiny_rx = 0.85 if r['rx'] < SMALL_RATE else 1.0
            base_tx_conf = clamp(0.55 * pair_conf_tx.get(if_id, 0.65) + 0.45 * outlier_conf_tx.get(if_id, 0.7))
            base_rx_conf = clamp(0.55 * pair_conf_rx.get(if_id, 0.65) + 0.45 * outlier_conf_rx.get(if_id, 0.7))
            # Penalty weight between ~0.6 and ~2.6
            r['w_pen_tx'] = clamp(0.6 + 2.0 * base_tx_conf, 0.6, 2.6) * tiny_tx
            r['w_pen_rx'] = clamp(0.6 + 2.0 * base_rx_conf, 0.6, 2.6) * tiny_rx
        else:
            r['w_pen_tx'] = 2.5
            r['w_pen_rx'] = 2.5

    # Alternating projections:
    # We do: pair projection -> router projection -> pair projection (2 pair passes)
    def pair_projection():
        # Project onto a.tx == b.rx and a.rx == b.tx using weighted L2 projection
        for a_id, b_id in pairs:
            a = interim[a_id]; b = interim[b_id]
            if a['status'] != 'up' or b['status'] != 'up':
                continue
            # Forward direction
            x1, x2 = a['tx'], b['rx']
            w1, w2 = a['w_pen_tx'], b['w_pen_rx']
            denom = w1 + w2
            if denom > EPS:
                t = (w1 * x1 + w2 * x2) / denom
                t = max(0.0, t)
                if abs(t - x1) > EPS:
                    a['tx'] = t
                if abs(t - x2) > EPS:
                    b['rx'] = t
            # Reverse direction
            y1, y2 = a['rx'], b['tx']
            w1r, w2r = a['w_pen_rx'], b['w_pen_tx']
            denom2 = w1r + w2r
            if denom2 > EPS:
                t2 = (w1r * y1 + w2r * y2) / denom2
                t2 = max(0.0, t2)
                if abs(t2 - y1) > EPS:
                    a['rx'] = t2
                if abs(t2 - y2) > EPS:
                    b['tx'] = t2

    def router_projection():
        # For each router, project onto sum(tx)=sum(rx) with weighted L2 and nonnegativity
        for router, if_list in router_ifaces.items():
            ups = [i for i in if_list if interim[i]['status'] == 'up']
            if not ups:
                continue
            # Build vectors
            tx_vals = [max(0.0, interim[i]['tx']) for i in ups]
            rx_vals = [max(0.0, interim[i]['rx']) for i in ups]
            w_tx = [max(EPS, interim[i]['w_pen_tx']) for i in ups]
            w_rx = [max(EPS, interim[i]['w_pen_rx']) for i in ups]
            sum_tx = sum(tx_vals); sum_rx = sum(rx_vals)
            e = sum_tx - sum_rx  # imbalance to fix
            # Skip if within tolerance
            if rel_diff(sum_tx, sum_rx) <= TOL_ROUTER:
                continue

            # Set up concatenated vectors for easier math
            v = tx_vals + rx_vals
            w = w_tx + w_rx
            a = [1.0] * len(tx_vals) + [-1.0] * len(rx_vals)

            free = [True] * len(v)

            # Active-set loop
            for _ in range(5):  # small number of iterations suffices
                # Compute current imbalance
                cur_tx = sum(v[:len(tx_vals)])
                cur_rx = sum(v[len(tx_vals):])
                e_cur = cur_tx - cur_rx
                if abs(e_cur) <= max(1.0, cur_tx + cur_rx) * (HARDENING_THRESHOLD * 0.1):
                    break
                denom = 0.0
                for i in range(len(v)):
                    if free[i]:
                        denom += (a[i] * a[i]) / w[i]
                if denom <= EPS:
                    break
                lam = e_cur / denom
                # propose d
                violation = False
                for i in range(len(v)):
                    if not free[i]:
                        continue
                    d_i = -lam * (a[i] / w[i])
                    new_i = v[i] + d_i
                    if new_i < -1e-12:
                        # clamp to zero, mark fixed
                        v[i] = 0.0
                        free[i] = False
                        if i < len(tx_vals):
                            interim[ups[i]]['clamped_zero_tx'] = True
                        else:
                            interim[ups[i - len(tx_vals)]]['clamped_zero_rx'] = True
                        violation = True
                    else:
                        v[i] = new_i
                if not violation:
                    break

            # Write back, track edits
            for k, iface in enumerate(ups):
                old_tx = interim[iface]['tx']; old_rx = interim[iface]['rx']
                new_tx = max(0.0, v[k]); new_rx = max(0.0, v[len(tx_vals) + k])
                if abs(new_tx - old_tx) > EPS:
                    interim[iface]['tx'] = new_tx
                    interim[iface]['edit_tx_rel'] = max(interim[iface]['edit_tx_rel'], rel_diff(old_tx, new_tx))
                if abs(new_rx - old_rx) > EPS:
                    interim[iface]['rx'] = new_rx
                    interim[iface]['edit_rx_rel'] = max(interim[iface]['edit_rx_rel'], rel_diff(old_rx, new_rx))

    # Alternating projections sequence
    pair_projection()
    router_projection()
    pair_projection()

    # Final invariant residuals per router
    router_final_imbalance: Dict[str, float] = {}
    router_initial_imbalance: Dict[str, float] = {}
    for router, if_list in router_ifaces.items():
        ups = [i for i in if_list if interim[i]['status'] == 'up']
        ups0 = [i for i in if_list if telemetry.get(i, {}).get('interface_status') == 'up']
        if ups:
            sum_tx = sum(max(0.0, interim[i]['tx']) for i in ups)
            sum_rx = sum(max(0.0, interim[i]['rx']) for i in ups)
            router_final_imbalance[router] = rel_diff(sum_tx, sum_rx)
        else:
            router_final_imbalance[router] = 0.0
        if ups0:
            sum_tx0 = sum(max(0.0, interim[i]['orig_tx']) for i in ups0)
            sum_rx0 = sum(max(0.0, interim[i]['orig_rx']) for i in ups0)
            router_initial_imbalance[router] = rel_diff(sum_tx0, sum_rx0)
        else:
            router_initial_imbalance[router] = 0.0

    # Confidence computation
    def finalize_conf(base: float, edit_rel: float, was_clamped_zero: bool, orig: float, new: float,
                      router_imb: float, router_imb0: float, pair_improved: bool) -> float:
        # Edit penalty two-slope
        weight = 0.4 if edit_rel < 0.15 else 0.55
        pen_factor = max(0.0, 1.0 - weight * max(0.0, edit_rel - HARDENING_THRESHOLD))
        conf = clamp(base * pen_factor)
        # Router residual penalty (post)
        conf *= (1.0 - min(0.15, max(0.0, (router_imb - TOL_ROUTER) / max(1e-6, 5 * TOL_ROUTER))))
        # Clamp penalty if projection hit nonnegativity
        if was_clamped_zero:
            conf = clamp(conf - 0.05)
        # Improvement bonus
        if pair_improved and (router_imb0 > 0.0) and (router_imb <= 0.7 * router_imb0):
            conf = clamp(conf + 0.04)
        # No-edit bonus
        if rel_diff(orig, new) <= 1e-3:
            conf = clamp(conf + 0.05)
        return clamp(conf)

    # Pre/post pair residuals for improvement detection
    def pair_residuals(if_id: str):
        peer = peer_of.get(if_id)
        if not peer:
            return (None, None, None, None)
        a0_tx = interim[if_id]['orig_tx']; a0_rx = interim[if_id]['orig_rx']
        b0_rx = telemetry.get(peer, {}).get('rx_rate', 0.0)
        b0_tx = telemetry.get(peer, {}).get('tx_rate', 0.0)
        res_fwd0 = rel_diff(a0_tx, float(b0_rx))
        res_rev0 = rel_diff(a0_rx, float(b0_tx))
        res_fwd1 = rel_diff(interim[if_id]['tx'], interim.get(peer, {}).get('rx', 0.0))
        res_rev1 = rel_diff(interim[if_id]['rx'], interim.get(peer, {}).get('tx', 0.0))
        return (res_fwd0, res_rev0, res_fwd1, res_rev1)

    # Assemble final result with calibrated confidences
    result: Dict[str, Dict[str, Tuple]] = {}
    for if_id, r in interim.items():
        router = r.get('local_router')
        peer = peer_of.get(if_id)
        resolved_status = r.get('status', 'unknown')

        # Pair components (post): allow rate-aware tol
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            tol_pair_tx = min(0.12, max(TOL_PAIR_BASE, 5.0 / max(r['tx'], interim[peer]['rx'], 1.0)))
            tol_pair_rx = min(0.12, max(TOL_PAIR_BASE, 5.0 / max(r['rx'], interim[peer]['tx'], 1.0)))
            pair_comp_tx = conf_from_residual(res_fwd, tol_pair_tx)
            pair_comp_rx = conf_from_residual(res_rev, tol_pair_rx)
        else:
            pair_comp_tx = 0.6
            pair_comp_rx = 0.6

        router_comp = conf_from_residual(router_final_imbalance.get(router, 0.0), TOL_ROUTER)
        status_comp = clamp(r.get('status_conf', 0.8))

        base_tx_conf = W_PAIR * pair_comp_tx + W_ROUTER * router_comp + W_STATUS * status_comp
        base_rx_conf = W_PAIR * pair_comp_rx + W_ROUTER * router_comp + W_STATUS * status_comp

        # Improvement flags
        res_fwd0, res_rev0, res_fwd1, res_rev1 = pair_residuals(if_id)
        improved_pair = False
        if res_fwd0 is not None and res_rev0 is not None and res_fwd1 is not None and res_rev1 is not None:
            imp_fwd = (res_fwd0 > 0.0) and (res_fwd1 <= 0.5 * res_fwd0)
            imp_rev = (res_rev0 > 0.0) and (res_rev1 <= 0.5 * res_rev0)
            improved_pair = imp_fwd and imp_rev

        final_tx_conf = finalize_conf(
            base_tx_conf,
            r.get('edit_tx_rel', 0.0),
            r.get('clamped_zero_tx', False),
            r['orig_tx'], r['tx'],
            router_final_imbalance.get(router, 0.0),
            router_initial_imbalance.get(router, 0.0),
            improved_pair
        )
        final_rx_conf = finalize_conf(
            base_rx_conf,
            r.get('edit_rx_rel', 0.0),
            r['clamped_zero_rx'],
            r['orig_rx'], r['rx'],
            router_final_imbalance.get(router, 0.0),
            router_initial_imbalance.get(router, 0.0),
            improved_pair
        )

        # Down-status confidence override
        if resolved_status == 'down':
            final_rx_conf = 0.9 if r['orig_rx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
            final_tx_conf = 0.9 if r['orig_tx'] <= TRAFFIC_EVIDENCE_MIN else 0.3

        # Subtle status calibration for idle ups
        if resolved_status == 'up':
            if r['rx'] <= TRAFFIC_EVIDENCE_MIN and r['tx'] <= TRAFFIC_EVIDENCE_MIN:
                r['status_conf'] = clamp(r['status_conf'] * 0.9)
        elif resolved_status == 'down':
            if r['rx'] > TRAFFIC_EVIDENCE_MIN or r['tx'] > TRAFFIC_EVIDENCE_MIN:
                r['status_conf'] = clamp(min(r['status_conf'], 0.3))

        # Package output
        out: Dict[str, Tuple] = {}
        out['rx_rate'] = (r['orig_rx'], r['rx'], clamp(final_rx_conf))
        out['tx_rate'] = (r['orig_tx'], r['tx'], clamp(final_tx_conf))
        out['interface_status'] = (r['orig_status'], r['status'], clamp(r['status_conf']))
        out['connected_to'] = r['connected_to']
        out['local_router'] = r['local_router']
        out['remote_router'] = r['remote_router']
        result[if_id] = out

    return result

# EVOLVE-BLOCK-END


def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    return repair_network_telemetry(telemetry, topology)


if __name__ == "__main__":
    # Simple smoke test
    test_telemetry = {
        'if1_to_if2': {
            'interface_status': 'up',
            'rx_rate': 100.0,
            'tx_rate': 95.0,
            'connected_to': 'if2_to_if1',
            'local_router': 'r1',
            'remote_router': 'r2',
        },
        'if2_to_if1': {
            'interface_status': 'up',
            'rx_rate': 95.0,
            'tx_rate': 100.0,
            'connected_to': 'if1_to_if2',
            'local_router': 'r2',
            'remote_router': 'r1',
        }
    }
    test_topology = {'r1': ['if1_to_if2'], 'r2': ['if2_to_if1']}
    repaired = run_repair(test_telemetry, test_topology)
    for if_id, d in repaired.items():
        print(if_id, d['rx_rate'], d['tx_rate'], d['interface_status'])