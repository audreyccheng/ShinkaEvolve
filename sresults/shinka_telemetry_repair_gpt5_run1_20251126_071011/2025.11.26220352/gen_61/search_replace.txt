<NAME>
calibrated_pair_tolerance_and_post_router_factor
</NAME>

<DESCRIPTION>
I propose three targeted improvements to increase counter accuracy and improve confidence calibration without destabilizing the existing repair logic:

1) Rate-aware pair reconciliation: replace the fixed 2% tolerance for link symmetry with a traffic-aware tolerance (max(Ï„h, 2.5/traffic)). This prevents overcorrection on tiny links while still correcting meaningful discrepancies on high-traffic links.

2) Post-repair router imbalance factor: compute and use router imbalance after all passes (post) for the confidence factor, providing more accurate confidence calibration based on the final, hardened state.

3) Quantified pair edit magnitude with tapered change penalties: track per-interface relative change introduced by pair reconciliation and penalize confidence proportionally (up to 0.05). Also taper the change penalty (0.4 weight for small edits < 15%, 0.5 otherwise) to avoid over-penalizing modest, justified corrections. Keep the existing bonus for untouched directions.

These changes should reduce overconfidence on heavier edits, improve confidence for well-justified small corrections, and reduce unnecessary pair edits for low-traffic links, aiming to raise combined score while preserving counter accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom
=======
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    def pair_tolerance(a: float, b: float) -> float:
        # Rate-aware tolerance: looser for very low traffic, at least HARDENING_THRESHOLD
        traffic = max(abs(a), abs(b), 1.0)
        return max(HARDENING_THRESHOLD, 2.5 / traffic)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Compute residuals after router scaling
        tx_pair_resid = rel_diff(post[iface]['tx'], post[peer_id]['rx'])  # A.tx vs B.rx
        rx_pair_resid = rel_diff(post[iface]['rx'], post[peer_id]['tx'])  # A.rx vs B.tx

        # Suspicion metric combines pre link diffs, scale magnitude, and router imbalance
        def suspicion(ifc: str, kind: str) -> float:
            rid = telemetry.get(ifc, {}).get('local_router')
            imb = router_imbalance.get(rid, 0.0)
            if kind == 'tx':
                return pre[ifc]['tx_link_diff'] + 0.5 * abs(scale_tx.get(ifc, 1.0) - 1.0) + 0.3 * imb
            else:
                return pre[ifc]['rx_link_diff'] + 0.5 * abs(scale_rx.get(ifc, 1.0) - 1.0) + 0.3 * imb

        # Reconcile A.tx <-> B.rx if residual exceeds tolerance
        if tx_pair_resid > HARDENING_THRESHOLD:
=======
        # Compute residuals after router scaling (use rate-aware tolerances)
        a_tx = post[iface]['tx']
        a_rx = post[iface]['rx']
        b_rx = post[peer_id]['rx']
        b_tx = post[peer_id]['tx']
        tx_pair_resid = rel_diff(a_tx, b_rx)  # A.tx vs B.rx
        rx_pair_resid = rel_diff(a_rx, b_tx)  # A.rx vs B.tx
        tol_tx = pair_tolerance(a_tx, b_rx)
        tol_rx = pair_tolerance(a_rx, b_tx)

        # Suspicion metric combines pre link diffs, scale magnitude, and router imbalance
        def suspicion(ifc: str, kind: str) -> float:
            rid = telemetry.get(ifc, {}).get('local_router')
            imb = router_imbalance.get(rid, 0.0)
            if kind == 'tx':
                return pre[ifc]['tx_link_diff'] + 0.5 * abs(scale_tx.get(ifc, 1.0) - 1.0) + 0.3 * imb
            else:
                return pre[ifc]['rx_link_diff'] + 0.5 * abs(scale_rx.get(ifc, 1.0) - 1.0) + 0.3 * imb

        # Reconcile A.tx <-> B.rx if residual exceeds tolerance
        if tx_pair_resid > tol_tx:
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Reconcile A.rx <-> B.tx if residual exceeds tolerance
        if rx_pair_resid > HARDENING_THRESHOLD:
=======
        # Reconcile A.rx <-> B.tx if residual exceeds tolerance
        if rx_pair_resid > tol_rx:
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Determine which interfaces were edited during pair reconciliation
    pair_edits: Dict[str, Dict[str, bool]] = {}
    for iface in telemetry:
        base = base_post[iface]
        now = post[iface]
        pair_edits[iface] = {
            'rx_edited': abs(now['rx'] - base['rx']) > 1e-9,
            'tx_edited': abs(now['tx'] - base['tx']) > 1e-9,
        }

    # Assemble final results with calibrated confidence
=======
    # Determine which interfaces were edited during pair reconciliation and by how much
    pair_edits: Dict[str, Dict[str, float]] = {}
    for iface in telemetry:
        base = base_post[iface]
        now = post[iface]
        rx_delta = abs(now['rx'] - base['rx'])
        tx_delta = abs(now['tx'] - base['tx'])
        pair_edits[iface] = {
            'rx_edited': rx_delta > 1e-9,
            'tx_edited': tx_delta > 1e-9,
            'rx_delta_rel': rx_delta / max(base['rx'], 1.0),
            'tx_delta_rel': tx_delta / max(base['tx'], 1.0),
        }

    # Compute post-repair router imbalance for confidence calibration
    router_imbalance_post: Dict[str, float] = {}
    for router_id, if_list in topology.items():
        up_ifaces = [i for i in if_list if i in telemetry and pre[i]['local_status'] == 'up']
        if not up_ifaces:
            router_imbalance_post[router_id] = 0.0
            continue
        sum_rx = sum(post[i]['rx'] for i in up_ifaces)
        sum_tx = sum(post[i]['tx'] for i in up_ifaces)
        denom = max(sum_rx, sum_tx, 1.0)
        router_imbalance_post[router_id] = abs(sum_tx - sum_rx) / denom

    # Assemble final results with calibrated confidence
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Router imbalance factor
        router_id = data.get('local_router')
        imbalance = router_imbalance.get(router_id, 0.0)
        router_factor = max(0.2, 1.0 - imbalance)
=======
        # Router imbalance factor (post-repair)
        router_id = data.get('local_router')
        imbalance_post = router_imbalance_post.get(router_id, 0.0)
        router_factor = max(0.2, 1.0 - imbalance_post)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Change penalty: reduce confidence for large changes from original
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))
=======
        # Change penalty: reduce confidence for large changes from original (tapered)
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        rx_weight = 0.4 if rx_change < 0.15 else 0.5
        tx_weight = 0.4 if tx_change < 0.15 else 0.5
        rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Additional large-change penalties (complements multiplicative change factor)
        if rx_change > 0.7:
            rx_confidence -= 0.05
        elif rx_change > 0.4:
            rx_confidence -= 0.03
        if tx_change > 0.7:
            tx_confidence -= 0.05
        elif tx_change > 0.4:
            tx_confidence -= 0.03

        # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
=======
        # Additional large-change penalties (complements multiplicative change factor)
        if rx_change > 0.7:
            rx_confidence -= 0.05
        elif rx_change > 0.4:
            rx_confidence -= 0.03
        if tx_change > 0.7:
            tx_confidence -= 0.05
        elif tx_change > 0.4:
            tx_confidence -= 0.03

        # Penalty proportional to pair reconciliation magnitude (calibration)
        rx_confidence -= min(0.05, 0.25 * pair_edits.get(iface, {}).get('rx_delta_rel', 0.0))
        tx_confidence -= min(0.05, 0.25 * pair_edits.get(iface, {}).get('tx_delta_rel', 0.0))

        # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
>>>>>>> REPLACE
</DIFF>