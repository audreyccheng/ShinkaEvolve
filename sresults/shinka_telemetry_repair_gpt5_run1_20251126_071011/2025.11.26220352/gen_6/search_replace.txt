<NAME>
substitution_link_fix_and_safe_router_scaling
</NAME>

<DESCRIPTION>
I propose three targeted changes to improve counter repair accuracy while maintaining strong confidence calibration:

1) Link repair by direct substitution instead of averaging: When link symmetry is violated beyond the hardening threshold, set my RX to peer TX (and my TX to peer RX) directly. Prior results indicated higher accuracy with substitution than averaging because one of the redundant signals is typically correct while the other is corrupted.

2) Safer router-level flow conservation: Scale only interfaces that are up, require at least two active interfaces, and skip tiny volumes to avoid noise amplification. Also compute imbalance only over up interfaces and apply scaling only to those, preventing unintended adjustments on down/absent links.

3) Case-insensitive status comparison when adjusting confidence: This prevents spurious confidence reductions due to case mismatches.

These changes align with the Hodor three-step approach: we harden link-level signals using redundancy, then apply a conservative router-level consistency correction only when there's sufficient evidence. This should increase counter repair accuracy without harming calibration or status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        else:
            # Both sides up (or no peer) -> link hardening using redundant signals if peer present
            if had_peer:
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Only adjust if violation exceeds tolerance, else leave unchanged to avoid perturbing good data
                if rx_link_diff > HARDENING_THRESHOLD:
                    pre_rx = 0.5 * (rx_orig + peer_tx)
                if tx_link_diff > HARDENING_THRESHOLD:
                    pre_tx = 0.5 * (tx_orig + peer_rx)
            else:
                rx_link_diff = 0.0
                tx_link_diff = 0.0
=======
        else:
            # Both sides up (or no peer) -> link hardening using redundant signals if peer present
            if had_peer:
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Apply direct substitution when violation exceeds tolerance (higher accuracy under single-sided faults)
                if rx_link_diff > HARDENING_THRESHOLD:
                    pre_rx = peer_tx
                if tx_link_diff > HARDENING_THRESHOLD:
                    pre_tx = peer_rx
            else:
                rx_link_diff = 0.0
                tx_link_diff = 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    for router_id, if_list in topology.items():
        # Consider only interfaces present in telemetry
        candidate_ifaces = [i for i in if_list if i in telemetry]
        if not candidate_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        # Sum only for interfaces that are up locally (down links already zeroed)
        sum_rx = 0.0
        sum_tx = 0.0
        for iface in candidate_ifaces:
            if pre[iface]['local_status'] == 'up':
                sum_rx += pre[iface]['pre_rx']
                sum_tx += pre[iface]['pre_tx']

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # If imbalance exceeds threshold, scale the larger side to match the smaller
        if imbalance > HARDENING_THRESHOLD:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, 1e-9)
                for iface in candidate_ifaces:
                    # Scale only TX values on this router
                    scale_tx[iface] = k
            else:
                k = sum_tx / max(sum_rx, 1e-9)
                for iface in candidate_ifaces:
                    # Scale only RX values on this router
                    scale_rx[iface] = k
=======
    for router_id, if_list in topology.items():
        # Consider only interfaces present in telemetry
        candidate_ifaces = [i for i in if_list if i in telemetry]
        if not candidate_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        # Consider only locally up interfaces (down were zeroed)
        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
        if not up_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Skip scaling for tiny volumes to avoid noise amplification
        if (sum_rx + sum_tx) <= 1e-6:
            continue

        # Only scale if imbalance exceeds tolerance and there are at least two active interfaces
        if imbalance > HARDENING_THRESHOLD and len(up_ifaces) >= 2:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, 1e-9)
                for i in up_ifaces:
                    # Scale only TX values on active interfaces
                    scale_tx[i] = k
            else:
                k = sum_tx / max(sum_rx, 1e-9)
                for i in up_ifaces:
                    # Scale only RX values on active interfaces
                    scale_rx[i] = k
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if repaired_status != peer_status_raw:
                status_confidence = min(status_confidence, 0.5)
=======
            if str(repaired_status).lower() != peer_status_raw:
                status_confidence = min(status_confidence, 0.5)
>>>>>>> REPLACE
</DIFF>