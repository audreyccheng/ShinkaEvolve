<NAME>
triage_average_on_double_violation
</NAME>

<DESCRIPTION>
I propose a targeted enhancement to the pre-pass link hardening step that improves counter repair accuracy while keeping our strong confidence calibration. Currently, when a link symmetry check detects violations, we substitute each violating direction with the peer's counter independently. This is optimal for single-sided faults but less effective when both directions are inconsistent, which can happen due to timing skews or correlated corruption.

Inspired by prior higher-scoring versions and the Hodor principles, I added a triage rule: when both A.rx≈B.tx and A.tx≈B.rx violate their traffic-aware tolerances simultaneously, we repair by averaging each direction with its peer counterpart instead of blindly substituting. This dampens over-corrections and yields a more robust estimate under dual-sided discrepancies.

This change is minimal and isolated to the pre-pass. It should improve counter repair accuracy without harming (and potentially improving) confidence calibration because the post-repair residuals to peers decrease. No other logic or variables are altered.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Use traffic-aware tolerance to avoid over-correcting tiny links
                tol_rx = pair_tolerance(rx_orig, peer_tx)
                tol_tx = pair_tolerance(tx_orig, peer_rx)

                # Apply direct substitution when violation exceeds tolerance (higher accuracy under single-sided faults)
                if rx_link_diff > tol_rx:
                    pre_rx = peer_tx
                if tx_link_diff > tol_tx:
                    pre_tx = peer_rx
=======
                # My RX should match peer TX; My TX should match peer RX
                rx_link_diff = rel_diff(rx_orig, peer_tx)
                tx_link_diff = rel_diff(tx_orig, peer_rx)

                # Use traffic-aware tolerance to avoid over-correcting tiny links
                tol_rx = pair_tolerance(rx_orig, peer_tx)
                tol_tx = pair_tolerance(tx_orig, peer_rx)

                # Triage:
                # - If both directions violate tolerance, average to dampen correlated errors.
                # - If only one violates, substitute that direction with the peer signal.
                if (rx_link_diff > tol_rx) and (tx_link_diff > tol_tx):
                    pre_rx = 0.5 * (rx_orig + peer_tx)
                    pre_tx = 0.5 * (tx_orig + peer_rx)
                else:
                    # Apply direct substitution when a single-sided violation exceeds tolerance
                    if rx_link_diff > tol_rx:
                        pre_rx = peer_tx
                    if tx_link_diff > tol_tx:
                        pre_tx = peer_rx
>>>>>>> REPLACE

</DIFF>