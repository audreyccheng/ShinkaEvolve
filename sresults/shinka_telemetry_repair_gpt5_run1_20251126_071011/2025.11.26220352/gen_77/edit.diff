--- a/original.py
+++ b/original.py
@@ -1,448 +1,455 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
 Takes interface telemetry data and detects/repairs inconsistencies based on
 network invariants like link symmetry and flow conservation.
 """
 from typing import Dict, Any, Tuple, List
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
     Core principle: Use network invariants to validate and repair telemetry:
     1. Link Symmetry (R3): my_tx_rate â‰ˆ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
 
     Args:
         telemetry: Dictionary where key is interface_id and value contains:
             - interface_status: "up" or "down"
             - rx_rate: receive rate in Mbps
             - tx_rate: transmit rate in Mbps
             - connected_to: interface_id this interface connects to
             - local_router: router_id this interface belongs to
             - remote_router: router_id on the other side
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary with same structure but telemetry values become tuples of:
         (original_value, repaired_value, confidence_score)
         where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
     """
     # Measurement timing tolerance (from Hodor research: ~2%)
     HARDENING_THRESHOLD = 0.02
 
     # Helpers
     def rel_diff(a: float, b: float) -> float:
         a = float(a)
         b = float(b)
         denom = max(abs(a), abs(b), 1.0)
         return abs(a - b) / denom
 
     def pair_tolerance(a: float, b: float) -> float:
         # Rate-aware tolerance: looser for very low traffic, at least HARDENING_THRESHOLD
         traffic = max(abs(a), abs(b), 1.0)
         return max(HARDENING_THRESHOLD, 2.5 / traffic)
 
     def clamp(x: float, lo: float, hi: float) -> float:
         return max(lo, min(hi, x))
 
     # Precompute peer mapping and sanitize inputs
     peers: Dict[str, str] = {}
     for iface, data in telemetry.items():
         peers[iface] = data.get('connected_to')
 
     # First pass: link-level hardening candidates and link agreement metrics
     pre: Dict[str, Dict[str, Any]] = {}
     for iface, data in telemetry.items():
         local_status = str(data.get('interface_status', 'unknown')).lower()
         if local_status not in ('up', 'down'):
             local_status = 'up'  # treat unknown as up for conservative repairs
         rx_orig = float(max(0.0, data.get('rx_rate', 0.0)))
         tx_orig = float(max(0.0, data.get('tx_rate', 0.0)))
         peer_id = peers.get(iface)
         had_peer = bool(peer_id and peer_id in telemetry)
         peer_status = 'unknown'
         peer_rx = 0.0
         peer_tx = 0.0
         if had_peer:
             peer_data = telemetry[peer_id]
             peer_status = str(peer_data.get('interface_status', 'unknown')).lower()
             if peer_status not in ('up', 'down'):
                 peer_status = 'up'
             peer_rx = float(max(0.0, peer_data.get('rx_rate', 0.0)))
             peer_tx = float(max(0.0, peer_data.get('tx_rate', 0.0)))
 
         # Defaults
         pre_rx = rx_orig
         pre_tx = tx_orig
 
         # Status-aware zeroing: zero only when the local interface is down
         if local_status == 'down':
             pre_rx = 0.0
             pre_tx = 0.0
             rx_link_diff = 0.0
             tx_link_diff = 0.0
         else:
             # Link hardening using redundant signals only if peer is present and up
             if had_peer and peer_status == 'up':
                 # My RX should match peer TX; My TX should match peer RX
                 rx_link_diff = rel_diff(rx_orig, peer_tx)
                 tx_link_diff = rel_diff(tx_orig, peer_rx)
 
                 # Use traffic-aware tolerance to avoid over-correcting tiny links
                 tol_rx = pair_tolerance(rx_orig, peer_tx)
                 tol_tx = pair_tolerance(tx_orig, peer_rx)
 
-                # Apply direct substitution when violation exceeds tolerance (higher accuracy under single-sided faults)
-                if rx_link_diff > tol_rx:
-                    pre_rx = peer_tx
-                if tx_link_diff > tol_tx:
-                    pre_tx = peer_rx
+                # Triage:
+                # - If both directions violate tolerance, average to dampen correlated errors.
+                # - If only one violates, substitute that direction with the peer signal.
+                if (rx_link_diff > tol_rx) and (tx_link_diff > tol_tx):
+                    pre_rx = 0.5 * (rx_orig + peer_tx)
+                    pre_tx = 0.5 * (tx_orig + peer_rx)
+                else:
+                    # Apply direct substitution when a single-sided violation exceeds tolerance
+                    if rx_link_diff > tol_rx:
+                        pre_rx = peer_tx
+                    if tx_link_diff > tol_tx:
+                        pre_tx = peer_rx
             else:
                 # No reliable peer signal available
                 rx_link_diff = 0.0
                 tx_link_diff = 0.0
 
         pre[iface] = {
             'pre_rx': pre_rx,
             'pre_tx': pre_tx,
             'rx_link_diff': rx_link_diff,
             'tx_link_diff': tx_link_diff,
             'local_status': local_status,
             'peer_status': peer_status if had_peer else 'unknown',
             'had_peer': had_peer,
             # Track whether the pre-pass changed values relative to original inputs
             'pre_rx_changed': abs(pre_rx - rx_orig) > 1e-9,
             'pre_tx_changed': abs(pre_tx - tx_orig) > 1e-9,
         }
 
     # Second pass: router-level flow conservation using topology
     # We use the topology to group interfaces per router.
     scale_rx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
     scale_tx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
     router_imbalance: Dict[str, float] = {}
 
     for router_id, if_list in topology.items():
         # Consider only interfaces present in telemetry
         candidate_ifaces = [i for i in if_list if i in telemetry]
         if not candidate_ifaces:
             router_imbalance[router_id] = 0.0
             continue
 
         # Consider only locally up interfaces (down were zeroed)
         up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
         if not up_ifaces:
             router_imbalance[router_id] = 0.0
             continue
 
         sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
         sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)
 
         denom = max(sum_rx, sum_tx, 1.0)
         imbalance = abs(sum_tx - sum_rx) / denom
         router_imbalance[router_id] = imbalance
 
         # Skip scaling for tiny volumes to avoid noise amplification
         if (sum_rx + sum_tx) <= 1e-6:
             continue
 
         # Only scale if imbalance exceeds tolerance and there are at least two active interfaces
         if imbalance > HARDENING_THRESHOLD and len(up_ifaces) >= 2:
             if sum_tx > sum_rx:
                 k_raw = sum_rx / max(sum_tx, 1.0e-9)
                 # Clamp router scaling to avoid overshoot on skewed aggregates
                 k = clamp(k_raw, 0.85, 1.15)
                 for i in up_ifaces:
                     # Scale only TX values on active interfaces
                     scale_tx[i] = k
             else:
                 k_raw = sum_tx / max(sum_rx, 1.0e-9)
                 k = clamp(k_raw, 0.85, 1.15)
                 for i in up_ifaces:
                     # Scale only RX values on active interfaces
                     scale_rx[i] = k
 
     # Third pass: pairwise link reconciliation to enforce link symmetry post router scaling
     # Build post-scaled values
     post: Dict[str, Dict[str, float]] = {}
     base_post: Dict[str, Dict[str, float]] = {}
     for iface in telemetry:
         base_post[iface] = {
             'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
             'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
         }
         # Start post as a copy of the base (will be potentially adjusted by reconciliation)
         post[iface] = {
             'rx': base_post[iface]['rx'],
             'tx': base_post[iface]['tx'],
         }
 
     visited_pairs = set()
     for iface, data in telemetry.items():
         peer_id = peers.get(iface)
         if not (peer_id and peer_id in telemetry):
             continue
         pair_key = tuple(sorted([iface, peer_id]))
         if pair_key in visited_pairs:
             continue
         visited_pairs.add(pair_key)
 
         # Only reconcile when both interfaces are locally up (we trust counters more in this case)
         if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
             continue
 
         # Compute residuals after router scaling (use rate-aware tolerances)
         a_tx = post[iface]['tx']
         a_rx = post[iface]['rx']
         b_rx = post[peer_id]['rx']
         b_tx = post[peer_id]['tx']
         tx_pair_resid = rel_diff(a_tx, b_rx)  # A.tx vs B.rx
         rx_pair_resid = rel_diff(a_rx, b_tx)  # A.rx vs B.tx
         tol_tx = pair_tolerance(a_tx, b_rx)
         tol_rx = pair_tolerance(a_rx, b_tx)
 
         # Suspicion metric combines pre link diffs, scale magnitude, and router imbalance
         def suspicion(ifc: str, kind: str) -> float:
             rid = telemetry.get(ifc, {}).get('local_router')
             imb = router_imbalance.get(rid, 0.0)
             if kind == 'tx':
                 return pre[ifc]['tx_link_diff'] + 0.5 * abs(scale_tx.get(ifc, 1.0) - 1.0) + 0.3 * imb
             else:
                 return pre[ifc]['rx_link_diff'] + 0.5 * abs(scale_rx.get(ifc, 1.0) - 1.0) + 0.3 * imb
 
         # Reconcile A.tx <-> B.rx if residual exceeds tolerance (partial, asymmetric move)
         if tx_pair_resid > tol_tx:
             a_tx_s = suspicion(iface, 'tx')
             b_rx_s = suspicion(peer_id, 'rx')
             # Severity factor scales move magnitude (0 at tol, up to ~1 for large residuals)
             sev = clamp((tx_pair_resid / max(tol_tx, 1e-9)) - 1.0, 0.0, 1.0)
             alpha_hi = 0.5 * (0.5 + 0.5 * sev)   # more suspicious side moves more
             alpha_lo = 0.25 * (0.5 + 0.5 * sev)  # less suspicious side moves less
             if a_tx_s >= b_rx_s:
                 post[iface]['tx'] = (1.0 - alpha_hi) * a_tx + alpha_hi * b_rx
                 post[peer_id]['rx'] = (1.0 - alpha_lo) * b_rx + alpha_lo * a_tx
             else:
                 post[peer_id]['rx'] = (1.0 - alpha_hi) * b_rx + alpha_hi * a_tx
                 post[iface]['tx'] = (1.0 - alpha_lo) * a_tx + alpha_lo * b_rx
 
         # Reconcile A.rx <-> B.tx if residual exceeds tolerance (partial, asymmetric move)
         if rx_pair_resid > tol_rx:
             a_rx_s = suspicion(iface, 'rx')
             b_tx_s = suspicion(peer_id, 'tx')
             sev2 = clamp((rx_pair_resid / max(tol_rx, 1e-9)) - 1.0, 0.0, 1.0)
             alpha_hi2 = 0.5 * (0.5 + 0.5 * sev2)
             alpha_lo2 = 0.25 * (0.5 + 0.5 * sev2)
             if a_rx_s >= b_tx_s:
                 post[iface]['rx'] = (1.0 - alpha_hi2) * a_rx + alpha_hi2 * b_tx
                 post[peer_id]['tx'] = (1.0 - alpha_lo2) * b_tx + alpha_lo2 * a_rx
             else:
                 post[peer_id]['tx'] = (1.0 - alpha_hi2) * b_tx + alpha_hi2 * a_rx
                 post[iface]['rx'] = (1.0 - alpha_lo2) * a_rx + alpha_lo2 * b_tx
 
     # Determine which interfaces were edited during pair reconciliation and by how much
     pair_edits: Dict[str, Dict[str, float]] = {}
     for iface in telemetry:
         base = base_post[iface]
         now = post[iface]
         rx_delta = abs(now['rx'] - base['rx'])
         tx_delta = abs(now['tx'] - base['tx'])
         pair_edits[iface] = {
             'rx_edited': rx_delta > 1e-9,
             'tx_edited': tx_delta > 1e-9,
             'rx_delta_rel': rx_delta / max(base['rx'], 1.0),
             'tx_delta_rel': tx_delta / max(base['tx'], 1.0),
         }
 
     # Compute post-repair router imbalance for confidence calibration
     router_imbalance_post: Dict[str, float] = {}
     for router_id, if_list in topology.items():
         up_ifaces = [i for i in if_list if i in telemetry and pre[i]['local_status'] == 'up']
         if not up_ifaces:
             router_imbalance_post[router_id] = 0.0
             continue
         sum_rx = sum(post[i]['rx'] for i in up_ifaces)
         sum_tx = sum(post[i]['tx'] for i in up_ifaces)
         denom = max(sum_rx, sum_tx, 1.0)
         router_imbalance_post[router_id] = abs(sum_tx - sum_rx) / denom
 
     # Assemble final results with calibrated confidence
     result: Dict[str, Dict[str, Tuple]] = {}
 
     for iface, data in telemetry.items():
         local_status = pre[iface]['local_status']
         peer_status = pre[iface]['peer_status']
         had_peer = pre[iface]['had_peer']
         rx_orig = float(max(0.0, data.get('rx_rate', 0.0)))
         tx_orig = float(max(0.0, data.get('tx_rate', 0.0)))
 
         # Apply post-reconciliation values
         rx_repaired = post[iface]['rx']
         tx_repaired = post[iface]['tx']
 
         # Confidence components based on post-repair residuals
         if had_peer and local_status == 'up' and (peer_status == 'up'):
             peer_id = peers.get(iface)
             # Peer repaired (post) rates
             peer_tx_after = post[peer_id]['tx']
             peer_rx_after = post[peer_id]['rx']
             rx_resid = rel_diff(rx_repaired, peer_tx_after)  # A.rx vs B.tx
             tx_resid = rel_diff(tx_repaired, peer_rx_after)  # A.tx vs B.rx
             rx_link_conf = max(0.0, 1.0 - rx_resid)
             tx_link_conf = max(0.0, 1.0 - tx_resid)
         elif local_status == 'down':
             # When locally down and we zeroed, high confidence if zeroed
             rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
             tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
         else:
             # No reliable peer information
             rx_link_conf = 0.6
             tx_link_conf = 0.6
 
         # Router imbalance factor (post-repair)
         router_id = data.get('local_router')
         imbalance_post = router_imbalance_post.get(router_id, 0.0)
         router_factor = max(0.2, 1.0 - imbalance_post)
 
         # Change penalty: reduce confidence for large changes from original (tapered)
         rx_change = rel_diff(rx_orig, rx_repaired)
         tx_change = rel_diff(tx_orig, tx_repaired)
         rx_weight = 0.4 if rx_change < 0.15 else 0.5
         tx_weight = 0.4 if tx_change < 0.15 else 0.5
         rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
         tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
 
         # Apply confidence tuning with edit-tracking bonuses/penalties
         rx_confidence = rx_link_conf * router_factor * rx_change_factor
         tx_confidence = tx_link_conf * router_factor * tx_change_factor
 
         # Router scaling penalties per direction
         s_dev_rx = abs(scale_rx.get(iface, 1.0) - 1.0)
         s_dev_tx = abs(scale_tx.get(iface, 1.0) - 1.0)
         if s_dev_rx > 0.5:
             rx_confidence -= 0.05
         elif s_dev_rx > 0.25:
             rx_confidence -= 0.03
         if s_dev_tx > 0.5:
             tx_confidence -= 0.05
         elif s_dev_tx > 0.25:
             tx_confidence -= 0.03
 
         # Additional large-change penalties (complements multiplicative change factor)
         if rx_change > 0.7:
             rx_confidence -= 0.05
         elif rx_change > 0.4:
             rx_confidence -= 0.03
         if tx_change > 0.7:
             tx_confidence -= 0.05
         elif tx_change > 0.4:
             tx_confidence -= 0.03
 
         # Penalty proportional to pair reconciliation magnitude (calibration)
         rx_confidence -= min(0.05, 0.25 * pair_edits.get(iface, {}).get('rx_delta_rel', 0.0))
         tx_confidence -= min(0.05, 0.25 * pair_edits.get(iface, {}).get('tx_delta_rel', 0.0))
 
         # Bonus for untouched directions (no pre change, no scaling, no pair reconciliation)
         rx_untouched = (not pre[iface]['pre_rx_changed']) and (s_dev_rx == 0.0) and (not pair_edits.get(iface, {}).get('rx_edited', False))
         tx_untouched = (not pre[iface]['pre_tx_changed']) and (s_dev_tx == 0.0) and (not pair_edits.get(iface, {}).get('tx_edited', False))
         if rx_untouched:
             rx_confidence += 0.03
         if tx_untouched:
             tx_confidence += 0.03
 
         rx_confidence = max(0.0, min(1.0, rx_confidence))
         tx_confidence = max(0.0, min(1.0, tx_confidence))
 
         # Status confidence adjustments (we keep status unchanged unless egregious)
         status_confidence = 1.0
         repaired_status = data.get('interface_status', 'unknown')
 
         # If statuses differ across the link, reduce confidence
         peer_id = peers.get(iface)
         if peer_id and peer_id in telemetry:
             peer_status_raw = str(telemetry[peer_id].get('interface_status', 'unknown')).lower()
             if peer_status_raw not in ('up', 'down'):
                 peer_status_raw = 'up'
             if str(repaired_status).lower() != peer_status_raw:
                 status_confidence = min(status_confidence, 0.5)
 
         # If interface reports down but had non-zero original counters, lower status confidence
         if str(repaired_status).lower() == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
             status_confidence = min(status_confidence, 0.6)
 
         # Ensure down interfaces have zero repaired rates
         if str(repaired_status).lower() == 'down':
             rx_repaired = 0.0
             tx_repaired = 0.0
 
         # Build output
         repaired_entry: Dict[str, Tuple] = {}
         repaired_entry['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
         repaired_entry['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
         repaired_entry['interface_status'] = (data.get('interface_status', 'unknown'), repaired_status, status_confidence)
 
         # Copy metadata unchanged
         repaired_entry['connected_to'] = data.get('connected_to')
         repaired_entry['local_router'] = data.get('local_router')
         repaired_entry['remote_router'] = data.get('remote_router')
 
         result[iface] = repaired_entry
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")