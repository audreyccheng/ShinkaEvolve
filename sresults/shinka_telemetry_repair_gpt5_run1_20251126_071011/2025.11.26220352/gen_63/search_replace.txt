<NAME>
weighted_router_scaling_and_confidence_refine
</NAME>

<DESCRIPTION>
I propose two targeted improvements: (1) a weighted router-level scaling that redistributes imbalance toward less-trusted interfaces instead of uniformly scaling all up interfaces, and (2) refined confidence calibration to better match actual repair quality.

Why this helps:
- Weighted scaling follows research guidance to leverage redundancy and focus corrections on suspicious counters, improving counter repair accuracy by preserving good readings and correcting bad ones more aggressively within safe caps.
- Confidence refinement introduces a two-slope change penalty, increases the untouched bonus, and adds a cumulative cap intensity penalty when an interface consumes a large portion of its adjustment budget. This should improve confidence calibration, avoiding overconfidence on heavy edits and rewarding untouched, consistent counters.

Key details:
- For the chosen router direction, per-interface weights combine: low confidence from pre link diffs, residual severity relative to traffic-aware tolerance, and a small volume-share term. Tiny links are additionally damped.
- Moves are capped by an absolute per-interface budget 0.15*max(value, 1.0), aligning with the recommended ±15% guard, with robust handling for low traffic.
- Confidence mapping uses a two-slope penalty (0.4 below 15% edit, 0.5 beyond), a +0.03 untouched bonus, and up to −0.08 extra penalty when cumulative usage of router+pair cap exceeds 70% of the combined budget.

These changes are localized and maintain all existing invariants and topology usage while improving both repair quality and calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Compute bounded router ratio and tempered factor
        if dir_to_scale == 'tx':
            s = sum_rx / max(sum_tx, EPS)
        else:
            s = sum_tx / max(sum_rx, EPS)
        s_bounded = clamp(s, 0.85, 1.15)
        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
        k = 1.0 + alpha * (s_bounded - 1.0)

        # Apply capped multiplicative scaling on chosen direction
        for i in up_ifaces:
            if dir_to_scale == 'tx':
                old = post_router[i]['tx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['tx'] = max(0.0, new_capped)
                router_delta_rel[i]['tx'] = abs(post_router[i]['tx'] - old) / max(old, 1.0)
            else:
                old = post_router[i]['rx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['rx'] = max(0.0, new_capped)
                router_delta_rel[i]['rx'] = abs(post_router[i]['rx'] - old) / max(old, 1.0)
=======
        # Compute bounded router ratio and tempered factor
        if dir_to_scale == 'tx':
            s = sum_rx / max(sum_tx, EPS)
        else:
            s = sum_tx / max(sum_rx, EPS)
        s_bounded = clamp(s, 0.85, 1.15)
        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
        k = 1.0 + alpha * (s_bounded - 1.0)

        # Weighted, capped redistribution toward less-trusted interfaces
        # Build totals on the chosen direction for volumetric weighting
        if dir_to_scale == 'tx':
            sum_dir = sum(post_router[i]['tx'] for i in up_ifaces)
        else:
            sum_dir = sum(post_router[i]['rx'] for i in up_ifaces)
        sum_dir = max(sum_dir, 1.0)

        for i in up_ifaces:
            if dir_to_scale == 'tx':
                old = post_router[i]['tx']
                # Confidence proxy and residual on pair for weighting
                peer_id = peers.get(i)
                conf_dir = max(0.0, 1.0 - pre[i]['tx_link_diff'])
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    resid = rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
                    tol = pair_tolerance(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
                    sev = min(2.0, resid / max(tol, EPS))
                else:
                    sev = 0.0
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['tx'] = new_val
                router_delta_rel[i]['tx'] = abs(move) / max(old, 1.0)
            else:
                old = post_router[i]['rx']
                peer_id = peers.get(i)
                conf_dir = max(0.0, 1.0 - pre[i]['rx_link_diff'])
                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                    resid = rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
                    tol = pair_tolerance(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
                    sev = min(2.0, resid / max(tol, EPS))
                else:
                    sev = 0.0
                vol = old / sum_dir
                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                if old < 1.0:
                    w *= 0.5
                w = max(0.02, w)
                delta_target = old * (k - 1.0)
                cap_abs = 0.15 * max(old, 1.0)
                move = clamp(delta_target * w, -cap_abs, cap_abs)
                new_val = max(0.0, old + move)
                post_router[i]['rx'] = new_val
                router_delta_rel[i]['rx'] = abs(move) / max(old, 1.0)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        # Taper change penalty slightly for small edits
        rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))
=======
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        # Two-slope change penalty: gentler for small edits (<15%)
        rx_weight = 0.4 if rx_change < 0.15 else 0.5
        tx_weight = 0.4 if tx_change < 0.15 else 0.5
        rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Penalties for heavy router scaling and pair adjustments to improve calibration
        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
        if rdel_rx >= 0.12:
            rx_confidence -= 0.03
        elif rdel_rx >= 0.07:
            rx_confidence -= 0.02
        if rdel_tx >= 0.12:
            tx_confidence -= 0.03
        elif rdel_tx >= 0.07:
            tx_confidence -= 0.02

        padj_rx = 0.0
        padj_tx = 0.0
        if 'pair_adj_rel' in locals():
            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Small bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.02
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.02
=======
        # Penalties for heavy router scaling and pair adjustments to improve calibration
        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
        if rdel_rx >= 0.12:
            rx_confidence -= 0.03
        elif rdel_rx >= 0.07:
            rx_confidence -= 0.02
        if rdel_tx >= 0.12:
            tx_confidence -= 0.03
        elif rdel_tx >= 0.07:
            tx_confidence -= 0.02

        padj_rx = 0.0
        padj_tx = 0.0
        if 'pair_adj_rel' in locals():
            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
        cum_cap = 0.35
        thresh = 0.7 * cum_cap
        cum_rx_rel = rdel_rx + padj_rx
        cum_tx_rel = rdel_tx + padj_tx
        if cum_rx_rel > thresh:
            rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
        if cum_tx_rel > thresh:
            tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))

        # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.03
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.03
>>>>>>> REPLACE

</DIFF>