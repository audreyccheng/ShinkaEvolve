--- a/original.py
+++ b/original.py
@@ -1,500 +1,686 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
 Takes interface telemetry data and detects/repairs inconsistencies based on
 network invariants like link symmetry and flow conservation.
 """
 from typing import Dict, Any, Tuple, List
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
     Core principle: Use network invariants to validate and repair telemetry:
     1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
 
     Args:
         telemetry: Dictionary where key is interface_id and value contains:
             - interface_status: "up" or "down"
             - rx_rate: receive rate in Mbps
             - tx_rate: transmit rate in Mbps
             - connected_to: interface_id this interface connects to
             - local_router: router_id this interface belongs to
             - remote_router: router_id on the other side
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary with same structure but telemetry values become tuples of:
         (original_value, repaired_value, confidence_score)
         where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
     """
-    # Measurement timing tolerance (from Hodor research: ~2%)
+    # Measurement timing tolerance (~2%)
     HARDENING_THRESHOLD = 0.02
     EPS = 1e-9
 
     # Helpers
     def norm_status(s: Any) -> str:
         s = str(s).lower()
         return s if s in ("up", "down") else "up"  # treat unknown as up conservatively
 
     def nz_float(x: Any) -> float:
         try:
             v = float(x)
         except Exception:
             v = 0.0
         return max(0.0, v)
 
     def rel_diff(a: float, b: float) -> float:
-        a = float(a)
-        b = float(b)
+        a = float(a); b = float(b)
         denom = max(abs(a), abs(b), 1.0)
         return abs(a - b) / denom
 
     def clamp(x: float, lo: float, hi: float) -> float:
         return max(lo, min(hi, x))
 
     def pair_tolerance(a: float, b: float) -> float:
         # Traffic-aware tolerance to account for timing skew on tiny links
         traffic = max(abs(a), abs(b), 1.0)
         return max(HARDENING_THRESHOLD, 2.5 / traffic)
 
-    # Precompute peer mapping
+    # Build peer mapping
     peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
 
     # First pass: link-aware hardening with status-aware zeroing and triage substitution
     pre: Dict[str, Dict[str, Any]] = {}
     for iface, data in telemetry.items():
         local_status = norm_status(data.get('interface_status', 'unknown'))
         rx_orig = nz_float(data.get('rx_rate', 0.0))
         tx_orig = nz_float(data.get('tx_rate', 0.0))
 
         peer_id = peers.get(iface)
         had_peer = bool(peer_id and peer_id in telemetry)
         peer_status = 'unknown'
         peer_rx = peer_tx = 0.0
 
         if had_peer:
             p = telemetry[peer_id]
             peer_status = norm_status(p.get('interface_status', 'unknown'))
             peer_rx = nz_float(p.get('rx_rate', 0.0))
             peer_tx = nz_float(p.get('tx_rate', 0.0))
 
         pre_rx = rx_orig
         pre_tx = tx_orig
         rx_link_diff = 0.0
         tx_link_diff = 0.0
 
         # Status-aware zeroing: only zero when local interface is down
         if local_status == 'down':
             pre_rx = 0.0
             pre_tx = 0.0
         else:
             if had_peer and peer_status == 'up':
                 # Link symmetry: A.rx ≈ B.tx, A.tx ≈ B.rx
                 rx_link_diff = rel_diff(rx_orig, peer_tx)
                 tx_link_diff = rel_diff(tx_orig, peer_rx)
 
                 pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
                 pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD
 
                 # Triage: if only one direction violates, substitute; if both violate, average
                 if pair_tx_ok and not pair_rx_ok:
                     pre_rx = peer_tx
                 elif pair_rx_ok and not pair_tx_ok:
                     pre_tx = peer_rx
                 elif not pair_rx_ok and not pair_tx_ok:
                     pre_rx = 0.5 * (rx_orig + peer_tx)
                     pre_tx = 0.5 * (tx_orig + peer_rx)
-                # else: both within tolerance -> keep as-is
+                # else both OK -> keep original
 
         pre[iface] = {
             'pre_rx': pre_rx,
             'pre_tx': pre_tx,
             'rx_link_diff': rx_link_diff,
             'tx_link_diff': tx_link_diff,
             'local_status': local_status,
             'peer_status': peer_status if had_peer else 'unknown',
             'had_peer': had_peer
         }
 
-    # Second pass: router-level flow conservation using topology (R1)
-    # Weighted multiplicative redistribution on the less-trusted direction with per-interface caps.
-    router_imbalance: Dict[str, float] = {}
+    # Early compute baseline pair residuals (for improvement bonuses)
+    baseline_pair_resid: Dict[str, Dict[str, float]] = {}
+    for iface in telemetry:
+        peer_id = peers.get(iface)
+        if peer_id and peer_id in telemetry and pre[iface]['local_status'] == 'up' and pre[peer_id]['local_status'] == 'up':
+            a_rx, a_tx = pre[iface]['pre_rx'], pre[iface]['pre_tx']
+            b_rx, b_tx = pre[peer_id]['pre_rx'], pre[peer_id]['pre_tx']
+            baseline_pair_resid[iface] = {
+                'rx': rel_diff(a_rx, b_tx),
+                'tx': rel_diff(a_tx, b_rx)
+            }
+        else:
+            baseline_pair_resid[iface] = {'rx': 0.0, 'tx': 0.0}
+
+    # Router-level flow conservation with targeted multiplicative pre-step
     post_router: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
+    router_imbalance_pre: Dict[str, float] = {}
+    # Track per-interface cumulative adjustments and caps usage
     router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
-    # Store bounded ratio per router for confidence calibration
-    s_bounded_map: Dict[str, float] = {}
+    cumul_used_abs: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
+    # Router-level stats for confidence
+    router_stats: Dict[str, Dict[str, Any]] = {}
 
     for router_id, iface_list in topology.items():
-        # Consider only interfaces present in telemetry and locally up
         up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
         if len(up_ifaces) < 2:
-            router_imbalance[router_id] = 0.0
+            router_imbalance_pre[router_id] = 0.0
+            router_stats[router_id] = {
+                's_bounded': 1.0, 'guard_rx': 0.0, 'guard_tx': 0.0,
+                'avg_conf_rx': 1.0, 'avg_conf_tx': 1.0
+            }
             continue
 
-        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
-        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)
-
-        denom = max(sum_rx, sum_tx, 1.0)
-        imbalance = abs(sum_tx - sum_rx) / denom
-        router_imbalance[router_id] = imbalance
-
-        # Avoid scaling for tiny volumes or minor imbalance
-        if (sum_rx + sum_tx) <= 1e-6 or imbalance <= HARDENING_THRESHOLD:
+        sum_rx0 = sum(pre[i]['pre_rx'] for i in up_ifaces)
+        sum_tx0 = sum(pre[i]['pre_tx'] for i in up_ifaces)
+        denom = max(sum_rx0, sum_tx0, 1.0)
+        imb0 = abs(sum_tx0 - sum_rx0) / denom
+        router_imbalance_pre[router_id] = imb0
+
+        # Direction confidences from link diffs
+        conf_rx_vals = [max(0.0, 1.0 - pre[i]['rx_link_diff']) for i in up_ifaces]
+        conf_tx_vals = [max(0.0, 1.0 - pre[i]['tx_link_diff']) for i in up_ifaces]
+        avg_conf_rx = sum(conf_rx_vals) / len(conf_rx_vals) if conf_rx_vals else 1.0
+        avg_conf_tx = sum(conf_tx_vals) / len(conf_tx_vals) if conf_tx_vals else 1.0
+
+        # Skip tiny traffic or minor imbalance
+        if (sum_rx0 + sum_tx0) <= 1e-6 or imb0 <= HARDENING_THRESHOLD:
+            router_stats[router_id] = {
+                's_bounded': 1.0, 'guard_rx': 0.0, 'guard_tx': 0.0,
+                'avg_conf_rx': avg_conf_rx, 'avg_conf_tx': avg_conf_tx
+            }
             continue
 
-        # Determine the less-trusted direction via average pair residuals where peers are up
+        # Determine less trusted direction via average pair residuals
         rx_resids: List[float] = []
         tx_resids: List[float] = []
         for i in up_ifaces:
             peer_id = peers.get(i)
             if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
-                # My TX ≈ peer RX; My RX ≈ peer TX
                 tx_resids.append(rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx']))
                 rx_resids.append(rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx']))
-
-        avg_tx_resid = sum(tx_resids) / len(tx_resids) if tx_resids else None
-        avg_rx_resid = sum(rx_resids) / len(rx_resids) if rx_resids else None
-
-        dir_to_scale = None
-        if avg_tx_resid is not None and avg_rx_resid is not None:
-            if avg_tx_resid > avg_rx_resid + 0.02:
-                dir_to_scale = 'tx'
-            elif avg_rx_resid > avg_tx_resid + 0.02:
-                dir_to_scale = 'rx'
-        if dir_to_scale is None:
-            dir_to_scale = 'tx' if sum_tx > sum_rx else 'rx'
-
-        # Compute bounded router ratio and tempered factor
+        avg_tx_resid = sum(tx_resids)/len(tx_resids) if tx_resids else 0.0
+        avg_rx_resid = sum(rx_resids)/len(rx_resids) if rx_resids else 0.0
+
+        if avg_tx_resid > avg_rx_resid + 0.02:
+            dir_to_scale = 'tx'
+        elif avg_rx_resid > avg_tx_resid + 0.02:
+            dir_to_scale = 'rx'
+        else:
+            dir_to_scale = 'tx' if sum_tx0 > sum_rx0 else 'rx'
+
+        # Ratio and aggressiveness
         if dir_to_scale == 'tx':
-            s = sum_rx / max(sum_tx, EPS)
+            s_ratio = sum_rx0 / max(sum_tx0, EPS)
         else:
-            s = sum_tx / max(sum_rx, EPS)
-        s_bounded = clamp(s, 0.85, 1.15)
-        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
-        k = 1.0 + alpha * (s_bounded - 1.0)
-        s_bounded_map[router_id] = s_bounded
-
-        # Weighted, capped redistribution toward less-trusted interfaces
-        if dir_to_scale == 'tx':
-            sum_dir = sum(post_router[i]['tx'] for i in up_ifaces)
-        else:
-            sum_dir = sum(post_router[i]['rx'] for i in up_ifaces)
-        sum_dir = max(sum_dir, 1.0)
-
+            s_ratio = sum_tx0 / max(sum_rx0, EPS)
+        s_bounded = clamp(s_ratio, 0.5, 2.0)
+        alpha = clamp(imb0 / 0.15, 0.25, 0.6)
+
+        # Identify eligible subset: bottom 40% confidence or violating pairs
+        dir_conf_map = {}
+        viol_flag = {}
         for i in up_ifaces:
+            peer_id = peers.get(i)
             if dir_to_scale == 'tx':
-                old = post_router[i]['tx']
-                peer_id = peers.get(i)
-                # Confidence proxy and residual severity
-                conf_dir = max(0.0, 1.0 - pre[i]['tx_link_diff'])
+                dir_conf_map[i] = max(0.0, 1.0 - pre[i]['tx_link_diff'])
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     resid = rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
                     tol = pair_tolerance(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
-                    sev = min(2.0, resid / max(tol, EPS))
+                    viol_flag[i] = resid > tol
                 else:
-                    resid = 0.0
-                    tol = HARDENING_THRESHOLD
-                    sev = 0.0
-                vol = old / sum_dir
-                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
-                if resid > 2.0 * tol:
-                    w += 0.1
-                if old < 1.0:
-                    w *= 0.5
-                w = max(0.02, w)
-                delta_target = old * (k - 1.0)
-                cap_abs = 0.15 * max(old, 1.0)
-                move = clamp(delta_target * w, -cap_abs, cap_abs)
-                new_val = max(0.0, old + move)
-                post_router[i]['tx'] = new_val
-                router_delta_rel[i]['tx'] = abs(move) / max(old, 1.0)
+                    viol_flag[i] = False
             else:
-                old = post_router[i]['rx']
-                peer_id = peers.get(i)
-                conf_dir = max(0.0, 1.0 - pre[i]['rx_link_diff'])
+                dir_conf_map[i] = max(0.0, 1.0 - pre[i]['rx_link_diff'])
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     resid = rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
                     tol = pair_tolerance(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
-                    sev = min(2.0, resid / max(tol, EPS))
+                    viol_flag[i] = resid > tol
                 else:
-                    resid = 0.0
-                    tol = HARDENING_THRESHOLD
-                    sev = 0.0
-                vol = old / sum_dir
-                w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
-                if resid > 2.0 * tol:
+                    viol_flag[i] = False
+
+        # Compute 40% confidence threshold
+        conf_vals_sorted = sorted(dir_conf_map[i] for i in up_ifaces)
+        idx_cut = max(0, int(0.4 * len(conf_vals_sorted)) - 1)
+        conf_cut = conf_vals_sorted[idx_cut] if conf_vals_sorted else 0.0
+
+        for i in up_ifaces:
+            # Only targeted multiplicative on less-trusted direction and eligible interfaces
+            eligible = (dir_conf_map[i] <= conf_cut) or viol_flag.get(i, False)
+            if not eligible:
+                continue
+            if dir_to_scale == 'tx':
+                old = post_router[i]['tx']
+                k = 1.0 + alpha * (s_bounded - 1.0)
+                new_val = old * k
+                # Per-interface multiplicative caps ±15% and absolute |Δ| ≤ 0.15*max(old,1)
+                cap_abs = 0.15 * max(old, 1.0)
+                new_val = clamp(new_val, old - cap_abs, old + cap_abs)
+                post_router[i]['tx'] = max(0.0, new_val)
+                delta = post_router[i]['tx'] - old
+                router_delta_rel[i]['tx'] += abs(delta) / max(old, 1.0)
+                cumul_used_abs[i]['tx'] += abs(delta)
+            else:
+                old = post_router[i]['rx']
+                k = 1.0 + alpha * (s_bounded - 1.0)
+                new_val = old * k
+                cap_abs = 0.15 * max(old, 1.0)
+                new_val = clamp(new_val, old - cap_abs, old + cap_abs)
+                post_router[i]['rx'] = max(0.0, new_val)
+                delta = post_router[i]['rx'] - old
+                router_delta_rel[i]['rx'] += abs(delta) / max(old, 1.0)
+                cumul_used_abs[i]['rx'] += abs(delta)
+
+        # Prepare router guards for additive pass (per-direction, elastic)
+        # Guard fraction with skew and confidence skew awareness
+        conf_skew = abs(avg_conf_tx - avg_conf_rx)
+        guard_frac_base = clamp(0.15 + 0.4 * imb0 + 0.4 * conf_skew, 0.15, 0.35)
+
+        # Directional guards with skew awareness (HHI)
+        def dir_guard(direction: str) -> float:
+            vals = [post_router[i][direction] for i in up_ifaces]
+            total = sum(vals) if vals else 0.0
+            if total <= 0.0:
+                return 0.0
+            shares = [(v / total) for v in vals]
+            hhi = sum(s * s for s in shares)
+            guard_dir = guard_frac_base
+            if hhi > 0.6:
+                guard_dir *= 0.85  # reduce by ~15% to avoid concentrating big moves
+            avg_traffic = (sum_rx0 + sum_tx0) / 2.0
+            return guard_dir * avg_traffic
+
+        guard_rx = dir_guard('rx')
+        guard_tx = dir_guard('tx')
+        router_stats[router_id] = {
+            's_bounded': s_bounded,
+            'guard_rx': guard_rx,
+            'guard_tx': guard_tx,
+            'avg_conf_rx': avg_conf_rx,
+            'avg_conf_tx': avg_conf_tx
+        }
+
+    # Additive redistribution: uncertainty-weighted with caps and guards
+    # Track router-level used guard per direction
+    router_used_guard = {rid: {'rx': 0.0, 'tx': 0.0} for rid in topology}
+
+    for router_id, iface_list in topology.items():
+        up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
+        if len(up_ifaces) < 2:
+            continue
+
+        # Iteratively apply additive adjustments until within tolerance or limits hit
+        for pass_idx in range(3):
+            sum_rx = sum(post_router[i]['rx'] for i in up_ifaces)
+            sum_tx = sum(post_router[i]['tx'] for i in up_ifaces)
+            denom = max(sum_rx, sum_tx, 1.0)
+            imb = abs(sum_tx - sum_rx) / denom
+            if (sum_rx + sum_tx) <= 1e-6 or imb <= HARDENING_THRESHOLD:
+                break
+
+            if sum_tx > sum_rx:
+                dir_to_adj = 'tx'
+                need = -(sum_tx - sum_rx)  # decrease TX
+            else:
+                dir_to_adj = 'rx'
+                need = +(sum_rx - sum_tx)  # increase RX
+
+            # Apply router directional guard
+            guard_total = router_stats.get(router_id, {}).get(f'guard_{dir_to_adj}', 0.0)
+            used = router_used_guard.get(router_id, {}).get(dir_to_adj, 0.0)
+            remaining_guard = max(0.0, guard_total - used)
+            if remaining_guard <= 1e-9:
+                break
+            # Limit need by remaining guard
+            need = clamp(need, -remaining_guard, remaining_guard)
+
+            # Build weights and per-interface remaining caps
+            vals = {i: post_router[i][dir_to_adj] for i in up_ifaces}
+            sum_v = max(1e-9, sum(vals.values()))
+            weights: Dict[str, float] = {}
+            rem_caps: Dict[str, float] = {}
+            for i in up_ifaces:
+                v_i = vals[i]
+                # Dir-specific confidence from pre link diffs
+                if dir_to_adj == 'tx':
+                    conf_dir_i = max(0.0, 1.0 - pre[i]['tx_link_diff'])
+                else:
+                    conf_dir_i = max(0.0, 1.0 - pre[i]['rx_link_diff'])
+
+                # Pair residual term
+                peer_id = peers.get(i)
+                if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
+                    if dir_to_adj == 'tx':
+                        resid_i = rel_diff(post_router[i]['tx'], post_router[peer_id]['rx'])
+                        tol_pair = pair_tolerance(post_router[i]['tx'], post_router[peer_id]['rx'])
+                    else:
+                        resid_i = rel_diff(post_router[i]['rx'], post_router[peer_id]['tx'])
+                        tol_pair = pair_tolerance(post_router[i]['rx'], post_router[peer_id]['tx'])
+                    pair_term = min(2.0, resid_i / max(tol_pair, EPS))
+                else:
+                    resid_i = 0.0
+                    tol_pair = HARDENING_THRESHOLD
+                    pair_term = 0.0
+
+                vol_term = (v_i / sum_v) if sum_v > 0 else 0.0
+                w = 0.6 * (1.0 - conf_dir_i) + 0.25 * pair_term + 0.15 * vol_term
+                if v_i < 1.0:
+                    w *= 0.5
+                # Boost when very inconsistent
+                if resid_i > 2.0 * tol_pair:
                     w += 0.1
-                if old < 1.0:
-                    w *= 0.5
-                w = max(0.02, w)
-                delta_target = old * (k - 1.0)
-                cap_abs = 0.15 * max(old, 1.0)
-                move = clamp(delta_target * w, -cap_abs, cap_abs)
-                new_val = max(0.0, old + move)
-                post_router[i]['rx'] = new_val
-                router_delta_rel[i]['rx'] = abs(move) / max(old, 1.0)
-
-    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
-    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
+                # Reduce weight on later passes if >70% cap already used
+                pre_base = pre[i]['pre_tx'] if dir_to_adj == 'tx' else pre[i]['pre_rx']
+                cap_total = 0.20 * max(pre_base, 1.0)
+                used_cap = cumul_used_abs[i]['tx'] if dir_to_adj == 'tx' else cumul_used_abs[i]['rx']
+                if pass_idx > 0 and cap_total > 0 and (used_cap / cap_total) >= 0.7:
+                    w *= 0.7
+                weights[i] = max(0.02, w)
+
+                # Remaining cap for this direction
+                rem_caps[i] = max(0.0, cap_total - used_cap)
+
+            # Distribute need across interfaces proportionally, honoring remaining caps
+            remaining = need
+            # Recompute weights each micro-iteration based on remaining caps
+            for _ in range(3):
+                if abs(remaining) <= 1e-6:
+                    break
+                active = [i for i in up_ifaces if rem_caps[i] > 1e-9 and weights[i] > 0.0]
+                if not active:
+                    break
+                wsum = sum(weights[i] for i in active)
+                if wsum <= 0.0:
+                    break
+                for i in active:
+                    if abs(remaining) <= 1e-6:
+                        break
+                    share = weights[i] / wsum
+                    prop = remaining * share
+                    # Cap per-interface
+                    prop = clamp(prop, -rem_caps[i], rem_caps[i])
+                    # Apply
+                    if dir_to_adj == 'tx':
+                        oldv = post_router[i]['tx']
+                        post_router[i]['tx'] = max(0.0, oldv + prop)
+                        cumul_used_abs[i]['tx'] += abs(prop)
+                        router_delta_rel[i]['tx'] += abs(prop) / max(oldv, 1.0)
+                    else:
+                        oldv = post_router[i]['rx']
+                        post_router[i]['rx'] = max(0.0, oldv + prop)
+                        cumul_used_abs[i]['rx'] += abs(prop)
+                        router_delta_rel[i]['rx'] += abs(prop) / max(oldv, 1.0)
+                    rem_caps[i] = max(0.0, rem_caps[i] - abs(prop))
+                    remaining -= prop
+                # Recompute weights lightly for next iteration, penalize those nearing cap
+                for i in active:
+                    if rem_caps[i] <= 1e-6:
+                        weights[i] *= 0.7  # de-emphasize exhausted entries
+            # Update router used guard
+            router_used_guard[router_id][dir_to_adj] += abs(need) - abs(remaining)
+
+    # Post values after router passes
+    post = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
+
+    # Targeted pair reconciliation per touched pairs with remaining budget
     pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
 
+    def dir_conf(i: str, direction: str) -> float:
+        if direction == 'tx':
+            return max(0.0, 1.0 - pre[i]['tx_link_diff'])
+        else:
+            return max(0.0, 1.0 - pre[i]['rx_link_diff'])
+
+    # Determine touched interfaces
+    touched = set(i for i in telemetry if (cumul_used_abs[i]['rx'] > 0.0 or cumul_used_abs[i]['tx'] > 0.0))
+
     visited_pairs = set()
-    for iface, data in telemetry.items():
+    for iface in telemetry:
         peer_id = peers.get(iface)
         if not (peer_id and peer_id in telemetry):
             continue
         pair_key = tuple(sorted([iface, peer_id]))
         if pair_key in visited_pairs:
             continue
         visited_pairs.add(pair_key)
 
-        # Only reconcile when both interfaces are locally up
-        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
+        if pre[iface]['local_status'] != 'up' or pre[peer_id]['local_status'] != 'up':
             continue
 
-        # Residuals after router scaling
-        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
-        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
-
-        # A.tx ↔ B.rx
-        resid_tx = rel_diff(a_tx, b_rx)
-        tol_tx = pair_tolerance(a_tx, b_rx)
-        if resid_tx > tol_tx:
-            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
-            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
-            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
-            # Lower-confidence side moves more toward midpoint
-            if conf_a_tx <= conf_b_rx:
-                alpha_low, alpha_high = 0.35, 0.20
-                move_a = alpha_low * (b_rx - a_tx)
-                move_b = alpha_high * (a_tx - b_rx)
-            else:
-                alpha_low, alpha_high = 0.35, 0.20
-                move_a = alpha_high * (b_rx - a_tx)
-                move_b = alpha_low * (a_tx - b_rx)
-            # Cap moves (≤ 20% of current value)
-            cap_a = 0.2 * max(a_tx, 1.0)
-            cap_b = 0.2 * max(b_rx, 1.0)
-            move_a = clamp(move_a, -cap_a, cap_a)
-            move_b = clamp(move_b, -cap_b, cap_b)
-            new_a_tx = max(0.0, a_tx + move_a)
-            new_b_rx = max(0.0, b_rx + move_b)
-            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
-            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
-            post[iface]['tx'] = new_a_tx
-            post[peer_id]['rx'] = new_b_rx
-
-        # A.rx ↔ B.tx
-        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
-        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
-        resid_rx = rel_diff(a_rx, b_tx)
-        tol_rx = pair_tolerance(a_rx, b_tx)
-        if resid_rx > tol_rx:
-            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
-            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
-            if conf_a_rx <= conf_b_tx:
-                alpha_low, alpha_high = 0.35, 0.20
-                move_a = alpha_low * (b_tx - a_rx)
-                move_b = alpha_high * (a_rx - b_tx)
-            else:
-                alpha_low, alpha_high = 0.35, 0.20
-                move_a = alpha_high * (b_tx - a_rx)
-                move_b = alpha_low * (a_rx - b_tx)
-            cap_a = 0.2 * max(a_rx, 1.0)
-            cap_b = 0.2 * max(b_tx, 1.0)
-            move_a = clamp(move_a, -cap_a, cap_a)
-            move_b = clamp(move_b, -cap_b, cap_b)
-            new_a_rx = max(0.0, a_rx + move_a)
-            new_b_tx = max(0.0, b_tx + move_b)
-            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
-            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
-            post[iface]['rx'] = new_a_rx
-            post[peer_id]['tx'] = new_b_tx
+        if (iface not in touched) and (peer_id not in touched):
+            continue  # preserve no-edit bonus on untouched pairs
+
+        # Up to two micro-iterations per direction
+        for _ in range(2):
+            # A.tx ↔ B.rx
+            a_tx = post[iface]['tx']; b_rx = post[peer_id]['rx']
+            resid_tx = rel_diff(a_tx, b_rx); tol_tx = pair_tolerance(a_tx, b_rx)
+            if resid_tx > tol_tx + 1e-12:
+                c_a = dir_conf(iface, 'tx'); c_b = dir_conf(peer_id, 'rx')
+                low_is_a = (c_a <= c_b)
+                scale = min(2.0, resid_tx / max(tol_tx, EPS))
+                alpha_low = min(0.6, 0.40 * scale)
+                alpha_high = min(0.5, 0.20 * scale)
+                # Desired moves toward agreement
+                move_a = (b_rx - a_tx) * (alpha_low if low_is_a else alpha_high)
+                move_b = (a_tx - b_rx) * (alpha_high if low_is_a else alpha_low)
+                # Remaining caps
+                cap_a = max(0.0, 0.20 * max(pre[iface]['pre_tx'], 1.0) - cumul_used_abs[iface]['tx'])
+                cap_b = max(0.0, 0.20 * max(pre[peer_id]['pre_rx'], 1.0) - cumul_used_abs[peer_id]['rx'])
+                move_a = clamp(move_a, -cap_a, cap_a)
+                move_b = clamp(move_b, -cap_b, cap_b)
+                if abs(move_a) > 0.0 or abs(move_b) > 0.0:
+                    new_a_tx = max(0.0, a_tx + move_a)
+                    new_b_rx = max(0.0, b_rx + move_b)
+                    pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
+                    pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
+                    post[iface]['tx'] = new_a_tx; post[peer_id]['rx'] = new_b_rx
+                    cumul_used_abs[iface]['tx'] += abs(move_a)
+                    cumul_used_abs[peer_id]['rx'] += abs(move_b)
+
+            # A.rx ↔ B.tx
+            a_rx = post[iface]['rx']; b_tx = post[peer_id]['tx']
+            resid_rx = rel_diff(a_rx, b_tx); tol_rx = pair_tolerance(a_rx, b_tx)
+            if resid_rx > tol_rx + 1e-12:
+                c_a = dir_conf(iface, 'rx'); c_b = dir_conf(peer_id, 'tx')
+                low_is_a = (c_a <= c_b)
+                scale = min(2.0, resid_rx / max(tol_rx, EPS))
+                alpha_low = min(0.6, 0.40 * scale)
+                alpha_high = min(0.5, 0.20 * scale)
+                move_a = (b_tx - a_rx) * (alpha_low if low_is_a else alpha_high)
+                move_b = (a_rx - b_tx) * (alpha_high if low_is_a else alpha_low)
+                cap_a = max(0.0, 0.20 * max(pre[iface]['pre_rx'], 1.0) - cumul_used_abs[iface]['rx'])
+                cap_b = max(0.0, 0.20 * max(pre[peer_id]['pre_tx'], 1.0) - cumul_used_abs[peer_id]['tx'])
+                move_a = clamp(move_a, -cap_a, cap_a)
+                move_b = clamp(move_b, -cap_b, cap_b)
+                if abs(move_a) > 0.0 or abs(move_b) > 0.0:
+                    new_a_rx = max(0.0, a_rx + move_a)
+                    new_b_tx = max(0.0, b_tx + move_b)
+                    pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
+                    pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
+                    post[iface]['rx'] = new_a_rx; post[peer_id]['tx'] = new_b_tx
+                    cumul_used_abs[iface]['rx'] += abs(move_a)
+                    cumul_used_abs[peer_id]['tx'] += abs(move_b)
+
+            # Early stop if both directions within tolerance
+            a_tx = post[iface]['tx']; b_rx = post[peer_id]['rx']
+            a_rx = post[iface]['rx']; b_tx = post[peer_id]['tx']
+            if rel_diff(a_tx, b_rx) <= pair_tolerance(a_tx, b_rx) and rel_diff(a_rx, b_tx) <= pair_tolerance(a_rx, b_tx):
+                break
+
+    # Router post-imbalance for confidence factors
+    router_imbalance_post: Dict[str, float] = {}
+    for rid, iface_list in topology.items():
+        up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
+        if not up_ifaces:
+            router_imbalance_post[rid] = 0.0
+            continue
+        sum_rx = sum(post[i]['rx'] for i in up_ifaces)
+        sum_tx = sum(post[i]['tx'] for i in up_ifaces)
+        denom = max(sum_rx, sum_tx, 1.0)
+        router_imbalance_post[rid] = abs(sum_tx - sum_rx) / denom
 
     # Assemble final results with calibrated confidence (post-repair residuals)
     result: Dict[str, Dict[str, Tuple]] = {}
-
     for iface, data in telemetry.items():
         local_status = pre[iface]['local_status']
-        peer_status = pre[iface]['peer_status']
-        had_peer = pre[iface]['had_peer']
+        peer_id = peers.get(iface)
+        had_peer = bool(peer_id and peer_id in telemetry)
+        peer_status = norm_status(telemetry[peer_id].get('interface_status', 'unknown')) if had_peer else 'unknown'
+
         rx_orig = nz_float(data.get('rx_rate', 0.0))
         tx_orig = nz_float(data.get('tx_rate', 0.0))
 
         rx_repaired = post[iface]['rx']
         tx_repaired = post[iface]['tx']
 
         # Enforce zero on down interfaces
         repaired_status = data.get('interface_status', 'unknown')
         if norm_status(repaired_status) == 'down':
             rx_repaired = 0.0
             tx_repaired = 0.0
 
-        # Confidence based on post-repair residuals vs peer
-        peer_id = peers.get(iface)
-        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
+        # Pair residuals after repair
+        if had_peer and local_status == 'up' and peer_status == 'up':
             peer_tx_after = post[peer_id]['tx']
             peer_rx_after = post[peer_id]['rx']
-            rx_resid = rel_diff(rx_repaired, peer_tx_after)
-            tx_resid = rel_diff(tx_repaired, peer_rx_after)
-            rx_link_conf = max(0.0, 1.0 - rx_resid)
-            tx_link_conf = max(0.0, 1.0 - tx_resid)
+            rx_resid_post = rel_diff(rx_repaired, peer_tx_after)   # my RX vs peer TX
+            tx_resid_post = rel_diff(tx_repaired, peer_rx_after)   # my TX vs peer RX
+            rx_link_conf = max(0.0, 1.0 - rx_resid_post)
+            tx_link_conf = max(0.0, 1.0 - tx_resid_post)
         elif norm_status(repaired_status) == 'down':
             rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
             tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
+            rx_resid_post = tx_resid_post = 0.0
         else:
             rx_link_conf = 0.6
             tx_link_conf = 0.6
-
-        # Recompute router imbalance post-repair for confidence
-        # Build per-router sums using final post values
-        # Note: computed lazily once; cache on first use
-        if 'router_imbalance_post' not in locals():
-            router_imbalance_post: Dict[str, float] = {}
-            for rid, if_list in topology.items():
-                up_ifaces_r = [i for i in if_list if i in telemetry and pre[i]['local_status'] == 'up']
-                if not up_ifaces_r:
-                    router_imbalance_post[rid] = 0.0
-                    continue
-                sum_rx_r = sum(post[i]['rx'] for i in up_ifaces_r)
-                sum_tx_r = sum(post[i]['tx'] for i in up_ifaces_r)
-                denom_r = max(sum_rx_r, sum_tx_r, 1.0)
-                router_imbalance_post[rid] = abs(sum_tx_r - sum_rx_r) / denom_r
-
+            rx_resid_post = tx_resid_post = 0.0
+
+        # Improvement bonuses based on baseline residuals
+        base_rx_resid = baseline_pair_resid.get(iface, {}).get('rx', 0.0)
+        base_tx_resid = baseline_pair_resid.get(iface, {}).get('tx', 0.0)
+        rx_improve = (base_rx_resid - rx_resid_post) if base_rx_resid > 0 else 0.0
+        tx_improve = (base_tx_resid - tx_resid_post) if base_tx_resid > 0 else 0.0
+        rx_improve_frac = (rx_improve / base_rx_resid) if base_rx_resid > 0 else 0.0
+        tx_improve_frac = (tx_improve / base_tx_resid) if base_tx_resid > 0 else 0.0
+
+        # Router imbalance factor (post)
         router_id = data.get('local_router')
         imb_post = router_imbalance_post.get(router_id, 0.0)
+        imb_pre = router_imbalance_pre.get(router_id, 0.0)
         router_factor = max(0.2, 1.0 - imb_post)
-
-        # Change penalty: reduce confidence for large corrections from original
-        rx_change = rel_diff(rx_orig, rx_repaired)
-        tx_change = rel_diff(tx_orig, tx_repaired)
-        # Two-slope change penalty: gentler for small edits (<15%)
-        rx_weight = 0.4 if rx_change < 0.15 else 0.5
-        tx_weight = 0.4 if tx_change < 0.15 else 0.5
-        rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
-        tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
-
-        rx_confidence = rx_link_conf * router_factor * rx_change_factor
-        tx_confidence = tx_link_conf * router_factor * tx_change_factor
-
-        # Penalty for aggressive router scaling at this node (bounded ratio intensity)
-        if 's_bounded_map' in locals():
-            s_b = s_bounded_map.get(router_id, 1.0)
-            if abs(1.0 - s_b) > 0.25:
-                pen = min(0.05, 0.2 * abs(1.0 - s_b))
-                rx_confidence -= pen
-                tx_confidence -= pen
-
-        # Penalties for heavy router scaling and pair adjustments to improve calibration
-        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
-        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
-        if rdel_rx >= 0.12:
-            rx_confidence -= 0.03
-        elif rdel_rx >= 0.07:
-            rx_confidence -= 0.02
-        if rdel_tx >= 0.12:
-            tx_confidence -= 0.03
-        elif rdel_tx >= 0.07:
-            tx_confidence -= 0.02
-
-        padj_rx = 0.0
-        padj_tx = 0.0
-        if 'pair_adj_rel' in locals():
-            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
-            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
-        rx_confidence -= min(0.05, 0.25 * padj_rx)
-        tx_confidence -= min(0.05, 0.25 * padj_tx)
-
-        # Small bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
-        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
-            rx_confidence += 0.03
-        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
-            tx_confidence += 0.03
-
-        rx_confidence = max(0.0, min(1.0, rx_confidence))
-        tx_confidence = max(0.0, min(1.0, tx_confidence))
-
-        # Status confidence adjustments (keep status unchanged; calibrate confidence)
+        imb_improve_frac = (imb_pre - imb_post) / imb_pre if imb_pre > 1e-12 else 0.0
+
+        # Change penalty: taper with two-slope weights (0.4 small, 0.55 larger)
+        def change_penalty_weight(edit_rel: float) -> float:
+            return 0.4 if edit_rel < 0.15 else 0.55
+
+        rx_change_rel = rel_diff(rx_orig, rx_repaired)
+        tx_change_rel = rel_diff(tx_orig, tx_repaired)
+        rx_change_factor = max(0.2, 1.0 - change_penalty_weight(rx_change_rel) * min(1.0, rx_change_rel))
+        tx_change_factor = max(0.2, 1.0 - change_penalty_weight(tx_change_rel) * min(1.0, tx_change_rel))
+
+        rx_conf = rx_link_conf * router_factor * rx_change_factor
+        tx_conf = tx_link_conf * router_factor * tx_change_factor
+
+        # Router scaling/guard usage penalties
+        s_bounded_router = router_stats.get(router_id, {}).get('s_bounded', 1.0)
+        if abs(1.0 - s_bounded_router) > 0.25:
+            rx_conf -= 0.03
+            tx_conf -= 0.03
+
+        # Penalty if router nearly exhausted its guard in either direction
+        guards = router_stats.get(router_id, {})
+        used_guard = router_used_guard.get(router_id, {'rx': 0.0, 'tx': 0.0})
+        for d in ('rx', 'tx'):
+            guard = guards.get(f'guard_{d}', 0.0)
+            used = used_guard.get(d, 0.0)
+            if guard > 0 and used >= 0.9 * guard:
+                if d == 'rx':
+                    rx_conf -= 0.05
+                else:
+                    tx_conf -= 0.05
+
+        # Penalty if interface consumed >70% of its cumulative cap across passes
+        rx_cap_total = 0.20 * max(pre[iface]['pre_rx'], 1.0)
+        tx_cap_total = 0.20 * max(pre[iface]['pre_tx'], 1.0)
+        if rx_cap_total > 0 and (cumul_used_abs[iface]['rx'] / rx_cap_total) >= 0.7:
+            rx_conf -= 0.04
+        if tx_cap_total > 0 and (cumul_used_abs[iface]['tx'] / tx_cap_total) >= 0.7:
+            tx_conf -= 0.04
+
+        # Bonus when both pair residuals drop by ≥50% and router imbalance decreases by ≥30%
+        if rx_improve_frac >= 0.5 and tx_improve_frac >= 0.5 and imb_improve_frac >= 0.3:
+            rx_conf += 0.04
+            tx_conf += 0.04
+
+        # Bonus when untouched across all passes
+        pre_unchanged_rx = abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9
+        pre_unchanged_tx = abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9
+        if pre_unchanged_rx and cumul_used_abs[iface]['rx'] == 0.0 and pair_adj_rel[iface]['rx'] == 0.0:
+            rx_conf += 0.03
+        if pre_unchanged_tx and cumul_used_abs[iface]['tx'] == 0.0 and pair_adj_rel[iface]['tx'] == 0.0:
+            tx_conf += 0.03
+
+        rx_confidence = max(0.0, min(1.0, rx_conf))
+        tx_confidence = max(0.0, min(1.0, tx_conf))
+
+        # Status confidence adjustments (keep status unchanged; calibrate)
         status_confidence = 1.0
-
         if peer_id and peer_id in telemetry:
             peer_status_raw = norm_status(telemetry[peer_id].get('interface_status', 'unknown'))
             if norm_status(repaired_status) != peer_status_raw:
                 status_confidence = min(status_confidence, 0.5)
-
         if norm_status(repaired_status) == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
             status_confidence = min(status_confidence, 0.6)
 
         # Build output
         repaired_entry: Dict[str, Tuple] = {}
         repaired_entry['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
         repaired_entry['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
         repaired_entry['interface_status'] = (data.get('interface_status', 'unknown'), repaired_status, status_confidence)
-
         # Copy metadata unchanged
         repaired_entry['connected_to'] = data.get('connected_to')
         repaired_entry['local_router'] = data.get('local_router')
         repaired_entry['remote_router'] = data.get('remote_router')
 
         result[iface] = repaired_entry
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")