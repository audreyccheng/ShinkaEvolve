--- a/original.py
+++ b/original.py
@@ -1,339 +1,455 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
+Novel approach:
+- Rate-aware tolerance and logistic confidence
+- Bounded multiplicative router pre-step, then confidence-weighted additive redistribution with ramped caps
+- Limited post-router link symmetry reconciliation
+- Change/cap/scale penalties for confidence calibration
 """
 from typing import Dict, Any, Tuple, List
+import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
-    Core principle: Use network invariants to validate and repair telemetry:
+    Core principles (invariants):
     1. Link Symmetry (R3): my_tx_rate â‰ˆ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
 
     Args:
-        telemetry: Dictionary where key is interface_id and value contains:
+        telemetry: Dictionary per interface_id with:
             - interface_status: "up" or "down"
             - rx_rate: receive rate in Mbps
             - tx_rate: transmit rate in Mbps
-            - connected_to: interface_id this interface connects to
-            - local_router: router_id this interface belongs to
-            - remote_router: router_id on the other side
-        topology: Dictionary where key is router_id and value contains a list of interface_ids
+            - connected_to: peer interface_id
+            - local_router: owning router_id
+            - remote_router: remote router_id
+        topology: Dictionary router_id -> list of interface_ids
 
     Returns:
-        Dictionary with same structure but telemetry values become tuples of:
-        (original_value, repaired_value, confidence_score)
-        where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
+        Dictionary where telemetry fields become tuples: (original_value, repaired_value, confidence)
+        Non-telemetry fields (connected_to, local_router, remote_router) are copied unchanged.
     """
-    # Measurement timing tolerance (from Hodor research: ~2%)
-    HARDENING_THRESHOLD = 0.02
-
-    # Helpers
+    # Tuning constants
+    HARDENING_THRESHOLD = 0.02  # base tolerance for timing skew
+    EPS = 1e-9
+
+    # Helper functions
+    def norm_status(s: Any) -> str:
+        s = str(s).lower()
+        return s if s in ("up", "down") else "up"
+
+    def nz_float(x: Any) -> float:
+        try:
+            v = float(x)
+        except Exception:
+            v = 0.0
+        return max(0.0, v)
+
     def rel_diff(a: float, b: float) -> float:
         a = float(a)
         b = float(b)
         denom = max(abs(a), abs(b), 1.0)
         return abs(a - b) / denom
 
-    # Precompute peer mapping and sanitize inputs
-    peers: Dict[str, str] = {}
-    for iface, data in telemetry.items():
-        peers[iface] = data.get('connected_to')
-
-    # First pass: link-level hardening candidates and link agreement metrics
+    def clamp(x: float, lo: float, hi: float) -> float:
+        return max(lo, min(hi, x))
+
+    def pair_tolerance(a: float, b: float) -> float:
+        # Rate-aware tolerance: at least HARDENING_THRESHOLD and looser for low traffic (~5 Mbps)
+        traffic = max(abs(a), abs(b), 1.0)
+        return max(HARDENING_THRESHOLD, 5.0 / traffic)
+
+    def conf_from_residual(residual: float, tol: float, k: float = 3.0) -> float:
+        # Logistic decay: high confidence within tolerance, lower beyond
+        x = residual / max(tol, 1e-9)
+        return 1.0 / (1.0 + math.exp(k * (x - 1.0)))
+
+    # Build peer mapping
+    peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
+
+    # First pass: link-level signal hardening (R3) with status-aware zeroing
     pre: Dict[str, Dict[str, Any]] = {}
     for iface, data in telemetry.items():
-        local_status = str(data.get('interface_status', 'unknown')).lower()
-        if local_status not in ('up', 'down'):
-            local_status = 'up'  # treat unknown as up for conservative repairs
-        rx_orig = float(max(0.0, data.get('rx_rate', 0.0)))
-        tx_orig = float(max(0.0, data.get('tx_rate', 0.0)))
+        status = norm_status(data.get('interface_status', 'unknown'))
+        rx_orig = nz_float(data.get('rx_rate', 0.0))
+        tx_orig = nz_float(data.get('tx_rate', 0.0))
+
         peer_id = peers.get(iface)
         had_peer = bool(peer_id and peer_id in telemetry)
         peer_status = 'unknown'
-        peer_rx = 0.0
-        peer_tx = 0.0
+        peer_rx = peer_tx = 0.0
         if had_peer:
-            peer_data = telemetry[peer_id]
-            peer_status = str(peer_data.get('interface_status', 'unknown')).lower()
-            if peer_status not in ('up', 'down'):
-                peer_status = 'up'
-            peer_rx = float(max(0.0, peer_data.get('rx_rate', 0.0)))
-            peer_tx = float(max(0.0, peer_data.get('tx_rate', 0.0)))
-
-        # Defaults
+            p = telemetry[peer_id]
+            peer_status = norm_status(p.get('interface_status', 'unknown'))
+            peer_rx = nz_float(p.get('rx_rate', 0.0))
+            peer_tx = nz_float(p.get('tx_rate', 0.0))
+
         pre_rx = rx_orig
         pre_tx = tx_orig
-
-        # Status-aware zeroing: only zero when local interface is down
-        if local_status == 'down':
+        rx_resid = 0.0
+        tx_resid = 0.0
+        rx_tol = HARDENING_THRESHOLD
+        tx_tol = HARDENING_THRESHOLD
+
+        if status == 'down':
+            # Down interfaces cannot carry traffic
             pre_rx = 0.0
             pre_tx = 0.0
-            rx_link_diff = 0.0
-            tx_link_diff = 0.0
         else:
-            # Link hardening using redundant signals only if peer is present and up
             if had_peer and peer_status == 'up':
                 # My RX should match peer TX; My TX should match peer RX
-                rx_link_diff = rel_diff(rx_orig, peer_tx)
-                tx_link_diff = rel_diff(tx_orig, peer_rx)
-
-                pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
-                pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD
-
-                # Targeted substitution: fix only the violating side; if both violate, average
-                if pair_tx_ok and not pair_rx_ok:
+                rx_resid = rel_diff(rx_orig, peer_tx)
+                tx_resid = rel_diff(tx_orig, peer_rx)
+                rx_tol = pair_tolerance(rx_orig, peer_tx)
+                tx_tol = pair_tolerance(tx_orig, peer_rx)
+
+                # Triage substitution vs averaging
+                if tx_resid <= tx_tol and rx_resid > rx_tol:
                     pre_rx = peer_tx
-                elif pair_rx_ok and not pair_tx_ok:
+                elif rx_resid <= rx_tol and tx_resid > tx_tol:
                     pre_tx = peer_rx
-                elif not pair_rx_ok and not pair_tx_ok:
+                elif rx_resid > rx_tol and tx_resid > tx_tol:
                     pre_rx = 0.5 * (rx_orig + peer_tx)
                     pre_tx = 0.5 * (tx_orig + peer_rx)
-                # else: both ok -> keep as is
-            else:
-                rx_link_diff = 0.0
-                tx_link_diff = 0.0
 
         pre[iface] = {
             'pre_rx': pre_rx,
             'pre_tx': pre_tx,
-            'rx_link_diff': rx_link_diff,
-            'tx_link_diff': tx_link_diff,
-            'local_status': local_status,
+            'rx_resid': rx_resid,
+            'tx_resid': tx_resid,
+            'rx_tol': rx_tol,
+            'tx_tol': tx_tol,
+            'local_status': status,
             'peer_status': peer_status if had_peer else 'unknown',
             'had_peer': had_peer
         }
 
-    # Second pass: router-level flow conservation using topology
+    # Working store for subsequent adjustments
+    work: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
+
+    # Penalty bookkeeping for confidence calibration
+    penalties: Dict[str, Dict[str, float]] = {
+        i: {'rx_cap': 0.0, 'tx_cap': 0.0, 'rx_pair_adj': 0.0, 'tx_pair_adj': 0.0,
+            'rx_scale': 0.0, 'tx_scale': 0.0}
+        for i in telemetry
+    }
+
+    # Second pass: router-level flow conservation (R1)
     # We use the topology to group interfaces per router.
-    scale_rx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
-    scale_tx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
-    router_imbalance: Dict[str, float] = {}
-
-    for router_id, if_list in topology.items():
-        # Consider only interfaces present in telemetry
-        candidate_ifaces = [i for i in if_list if i in telemetry]
-        if not candidate_ifaces:
-            router_imbalance[router_id] = 0.0
-            continue
-
-        # Active interfaces that are up locally (down links already zeroed)
-        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
-
-        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
-        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)
+    router_final_imbalance: Dict[str, float] = {}
+
+    for router_id, iface_list in topology.items():
+        # consider only known interfaces
+        ifaces = [i for i in iface_list if i in telemetry]
+        if not ifaces:
+            router_final_imbalance[router_id] = 0.0
+            continue
+
+        # Use only locally up interfaces (down already zeroed)
+        up_ifaces = [i for i in ifaces if pre[i]['local_status'] == 'up']
+        if not up_ifaces:
+            router_final_imbalance[router_id] = 0.0
+            continue
+
+        def router_sums() -> Tuple[float, float]:
+            srx = sum(work[i]['rx'] for i in up_ifaces)
+            stx = sum(work[i]['tx'] for i in up_ifaces)
+            return srx, stx
+
+        sum_rx, sum_tx = router_sums()
+        if (sum_rx + sum_tx) <= 1e-9:
+            router_final_imbalance[router_id] = 0.0
+            continue
 
         denom = max(sum_rx, sum_tx, 1.0)
-        imbalance = abs(sum_tx - sum_rx) / denom
-        router_imbalance[router_id] = imbalance
-
-        # Only scale if there are at least two active interfaces and non-trivial traffic
-        if imbalance > HARDENING_THRESHOLD and len(up_ifaces) >= 2 and (sum_rx + sum_tx) > 1e-6:
+        imb = abs(sum_tx - sum_rx) / denom
+
+        # Bounded multiplicative pre-step (gentle move toward balance)
+        if imb > HARDENING_THRESHOLD and len(up_ifaces) >= 2:
             if sum_tx > sum_rx:
-                k = sum_rx / max(sum_tx, 1e-9)
-                for iface in up_ifaces:
-                    # Scale only TX values on active interfaces for this router
-                    scale_tx[iface] = k
+                target = clamp(sum_rx / max(sum_tx, EPS), 0.85, 1.15)
+                s_step = target ** 0.5
+                for i in up_ifaces:
+                    old = work[i]['tx']
+                    work[i]['tx'] = max(0.0, old * s_step)
+                    penalties[i]['tx_scale'] = max(penalties[i]['tx_scale'], abs(1.0 - s_step))
             else:
-                k = sum_tx / max(sum_rx, 1e-9)
-                for iface in up_ifaces:
-                    # Scale only RX values on active interfaces for this router
-                    scale_rx[iface] = k
-
-    # Third pass: pairwise link reconciliation to enforce link symmetry post router scaling
-    # Build post-scaled values
-    post: Dict[str, Dict[str, float]] = {}
+                target = clamp(sum_tx / max(sum_rx, EPS), 0.85, 1.15)
+                s_step = target ** 0.5
+                for i in up_ifaces:
+                    old = work[i]['rx']
+                    work[i]['rx'] = max(0.0, old * s_step)
+                    penalties[i]['rx_scale'] = max(penalties[i]['rx_scale'], abs(1.0 - s_step))
+
+        # Recompute imbalance after pre-step
+        sum_rx, sum_tx = router_sums()
+        need = sum_tx - sum_rx
+        need_abs = abs(need)
+        denom = max(sum_rx, sum_tx, 1.0)
+
+        # Confidence-weighted additive redistribution with ramped caps
+        if need_abs / denom > HARDENING_THRESHOLD and len(up_ifaces) >= 2:
+            total_traffic = sum_rx + sum_tx
+            router_cap_total = 0.25 * total_traffic  # per-router total edit cap
+            remaining = min(need_abs, router_cap_total)
+
+            over_dir = 'tx' if need > 0 else 'rx'
+            opp_dir = 'rx' if over_dir == 'tx' else 'tx'
+            values = {i: work[i][over_dir] for i in up_ifaces}
+            sum_v = sum(values.values()) + EPS
+
+            # Directional confidence and residual vs peer
+            dir_conf: Dict[str, float] = {}
+            dir_resid: Dict[str, float] = {}
+            for i in up_ifaces:
+                peer_id = peers.get(i)
+                if peer_id and peer_id in telemetry and pre.get(peer_id, {}).get('local_status') == 'up':
+                    if over_dir == 'tx':
+                        resid = rel_diff(work[i]['tx'], work[peer_id]['rx'])
+                        tol = pair_tolerance(work[i]['tx'], work[peer_id]['rx'])
+                    else:
+                        resid = rel_diff(work[i]['rx'], work[peer_id]['tx'])
+                        tol = pair_tolerance(work[i]['rx'], work[peer_id]['tx'])
+                    dir_resid[i] = resid
+                    dir_conf[i] = conf_from_residual(resid, tol)
+                else:
+                    dir_resid[i] = 0.0
+                    dir_conf[i] = 0.6  # moderate default
+
+            pass_caps = [0.25, 0.35, 0.45]
+            for pass_idx, max_frac in enumerate(pass_caps):
+                if remaining <= 1e-9:
+                    break
+
+                # Build weights emphasizing low confidence and high residual; de-emphasize near-idle
+                weights: Dict[str, float] = {}
+                for i in up_ifaces:
+                    v = values[i]
+                    resid = dir_resid.get(i, 0.0)
+                    conf_d = dir_conf.get(i, 0.6)
+                    w = 0.5 * (1.0 - conf_d) + 0.3 * resid + 0.2 * (v / sum_v)
+                    if v < 5.0:
+                        w *= 0.5  # avoid over-editing idle links
+                    # In the last pass, allow large caps only for low-confidence or tiny baselines
+                    if pass_idx == 2 and not (conf_d < 0.6 or v < 5.0):
+                        w *= 0.1
+                    weights[i] = max(w, 1e-6)
+
+                sum_w = sum(weights.values())
+                if sum_w <= 0:
+                    break
+
+                # Allocate edits this pass
+                to_apply = remaining
+                for i in up_ifaces:
+                    if to_apply <= 1e-9:
+                        break
+                    v = values[i]
+                    alloc = to_apply * (weights[i] / sum_w)
+                    cap_i = max(0.1, v * max_frac)
+                    delta_i = min(alloc, cap_i, v)  # do not cross zero
+                    if delta_i <= 0:
+                        continue
+                    if over_dir == 'tx':
+                        work[i]['tx'] = max(0.0, work[i]['tx'] - delta_i)
+                        # penalize if we hit cap or nearly zeroed
+                        if abs(delta_i - cap_i) < 1e-9 or delta_i >= v - 1e-9:
+                            penalties[i]['tx_cap'] = max(penalties[i]['tx_cap'], 0.15)
+                    else:
+                        work[i]['rx'] = max(0.0, work[i]['rx'] - delta_i)
+                        if abs(delta_i - cap_i) < 1e-9 or delta_i >= v - 1e-9:
+                            penalties[i]['rx_cap'] = max(penalties[i]['rx_cap'], 0.15)
+                    values[i] = max(0.0, v - delta_i)
+                    remaining -= delta_i
+
+        # Final imbalance after router adjustments
+        sum_rx, sum_tx = router_sums()
+        router_final_imbalance[router_id] = abs(sum_tx - sum_rx) / max(sum_rx, sum_tx, 1.0)
+
+    # Third pass: limited link reconciliation after router edits (sustain R3)
+    visited = set()
     for iface in telemetry:
-        post[iface] = {
-            'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
-            'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
-        }
-
-    visited_pairs = set()
-    for iface, data in telemetry.items():
         peer_id = peers.get(iface)
         if not (peer_id and peer_id in telemetry):
             continue
-        pair_key = tuple(sorted([iface, peer_id]))
-        if pair_key in visited_pairs:
-            continue
-        visited_pairs.add(pair_key)
-
-        # Both sides must be locally up to trust counters for reconciliation
+        key = tuple(sorted([iface, peer_id]))
+        if key in visited:
+            continue
+        visited.add(key)
+
         if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
             continue
 
-        # Compute current residuals
-        tx_pair_resid = rel_diff(post[iface]['tx'], post[peer_id]['rx'])
-        rx_pair_resid = rel_diff(post[iface]['rx'], post[peer_id]['tx'])
-
-        # Suspicion metrics combine link residuals and router-level signals
-        def susp(ifc: str, kind: str) -> float:
-            router_id_local = telemetry.get(ifc, {}).get('local_router')
-            imb = router_imbalance.get(router_id_local, 0.0)
-            if kind == 'tx':
-                return pre[ifc]['tx_link_diff'] + 0.5 * abs(scale_tx.get(ifc, 1.0) - 1.0) + 0.3 * imb
-            else:
-                return pre[ifc]['rx_link_diff'] + 0.5 * abs(scale_rx.get(ifc, 1.0) - 1.0) + 0.3 * imb
-
-        # Reconcile A.tx <-> B.rx if needed
-        if tx_pair_resid > HARDENING_THRESHOLD:
-            a_tx_s = susp(iface, 'tx')
-            b_rx_s = susp(peer_id, 'rx')
-            if a_tx_s >= b_rx_s:
-                # Adjust the more suspicious side to match its peer
-                post[iface]['tx'] = post[peer_id]['rx']
-            else:
-                post[peer_id]['rx'] = post[iface]['tx']
-
-        # Reconcile A.rx <-> B.tx if needed
-        if rx_pair_resid > HARDENING_THRESHOLD:
-            a_rx_s = susp(iface, 'rx')
-            b_tx_s = susp(peer_id, 'tx')
-            if a_rx_s >= b_tx_s:
-                post[iface]['rx'] = post[peer_id]['tx']
-            else:
-                post[peer_id]['tx'] = post[iface]['rx']
-
-    # Assemble final results with calibrated confidence (based on post-reconciliation values)
+        # A.tx <-> B.rx reconciliation
+        a_tx = work[iface]['tx']
+        b_rx = work[peer_id]['rx']
+        tol_tx = pair_tolerance(a_tx, b_rx)
+        resid_tx = rel_diff(a_tx, b_rx)
+        if resid_tx > tol_tx:
+            alpha = 0.3
+            a_tx_new = a_tx + alpha * (b_rx - a_tx)
+            b_rx_new = b_rx + alpha * (a_tx - b_rx)
+            work[iface]['tx'] = max(0.0, a_tx_new)
+            work[peer_id]['rx'] = max(0.0, b_rx_new)
+            penalties[iface]['tx_pair_adj'] = max(penalties[iface]['tx_pair_adj'], 0.1)
+            penalties[peer_id]['rx_pair_adj'] = max(penalties[peer_id]['rx_pair_adj'], 0.1)
+
+        # A.rx <-> B.tx reconciliation
+        a_rx = work[iface]['rx']
+        b_tx = work[peer_id]['tx']
+        tol_rx = pair_tolerance(a_rx, b_tx)
+        resid_rx = rel_diff(a_rx, b_tx)
+        if resid_rx > tol_rx:
+            alpha = 0.3
+            a_rx_new = a_rx + alpha * (b_tx - a_rx)
+            b_tx_new = b_tx + alpha * (a_rx - b_tx)
+            work[iface]['rx'] = max(0.0, a_rx_new)
+            work[peer_id]['tx'] = max(0.0, b_tx_new)
+            penalties[iface]['rx_pair_adj'] = max(penalties[iface]['rx_pair_adj'], 0.1)
+            penalties[peer_id]['tx_pair_adj'] = max(penalties[peer_id]['tx_pair_adj'], 0.1)
+
+    # Recompute final router imbalances for confidence (post pair reconciliation)
+    for router_id, iface_list in topology.items():
+        ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
+        if not ifaces:
+            router_final_imbalance[router_id] = router_final_imbalance.get(router_id, 0.0)
+        else:
+            sum_rx = sum(work[i]['rx'] for i in ifaces)
+            sum_tx = sum(work[i]['tx'] for i in ifaces)
+            router_final_imbalance[router_id] = abs(sum_tx - sum_rx) / max(sum_rx, sum_tx, 1.0)
+
+    # Assemble results with calibrated confidence
     result: Dict[str, Dict[str, Tuple]] = {}
-
     for iface, data in telemetry.items():
-        local_status = pre[iface]['local_status']
-        peer_status = pre[iface]['peer_status']
-        had_peer = pre[iface]['had_peer']
-        rx_orig = float(max(0.0, data.get('rx_rate', 0.0)))
-        tx_orig = float(max(0.0, data.get('tx_rate', 0.0)))
-
-        rx_repaired = post[iface]['rx']
-        tx_repaired = post[iface]['tx']
-
-        # Confidence components based on post-repair residuals
+        status_raw = data.get('interface_status', 'unknown')
+        status = norm_status(status_raw)
+        rx_orig = nz_float(data.get('rx_rate', 0.0))
+        tx_orig = nz_float(data.get('tx_rate', 0.0))
+
+        # Apply final values
+        rx_repaired = work[iface]['rx']
+        tx_repaired = work[iface]['tx']
+
+        # Enforce zero for down status
+        if status == 'down':
+            rx_repaired = 0.0
+            tx_repaired = 0.0
+
+        # Link-based confidence using final residuals
         peer_id = peers.get(iface)
-        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
-            peer_tx_after = post[peer_id]['tx']
-            peer_rx_after = post[peer_id]['rx']
-            rx_resid = rel_diff(rx_repaired, peer_tx_after)
-            tx_resid = rel_diff(tx_repaired, peer_rx_after)
-            rx_link_conf = max(0.0, 1.0 - rx_resid)
-            tx_link_conf = max(0.0, 1.0 - tx_resid)
-        elif local_status == 'down':
-            # When locally down and we zeroed, high confidence if zeroed
-            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
-            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
+        if peer_id and peer_id in telemetry and pre[iface]['local_status'] == 'up' and pre.get(peer_id, {}).get('local_status') == 'up':
+            peer_tx_final = work[peer_id]['tx']
+            peer_rx_final = work[peer_id]['rx']
+            rx_resid_f = rel_diff(rx_repaired, peer_tx_final)
+            tx_resid_f = rel_diff(tx_repaired, peer_rx_final)
+            rx_tol_f = pair_tolerance(rx_repaired, peer_tx_final)
+            tx_tol_f = pair_tolerance(tx_repaired, peer_rx_final)
+            rx_link_conf = conf_from_residual(rx_resid_f, rx_tol_f)
+            tx_link_conf = conf_from_residual(tx_resid_f, tx_tol_f)
+        elif status == 'down':
+            rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
+            tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
         else:
-            # No reliable peer information
             rx_link_conf = 0.6
             tx_link_conf = 0.6
 
         # Router imbalance factor
         router_id = data.get('local_router')
-        imbalance = router_imbalance.get(router_id, 0.0)
-        router_factor = max(0.2, 1.0 - imbalance)
-
-        # Change penalty: reduce confidence for large changes from original
+        r_factor = max(0.2, 1.0 - router_final_imbalance.get(router_id, 0.0))
+
+        # Change penalty from original
         rx_change = rel_diff(rx_orig, rx_repaired)
         tx_change = rel_diff(tx_orig, tx_repaired)
         rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
         tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))
 
-        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor))
-        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor))
-
-        # Status confidence adjustments (we keep status unchanged unless egregious)
+        # Cap/scale/reconciliation penalties
+        cap_pen_rx = 1.0 - min(0.3, penalties[iface]['rx_cap'] + 0.2 * penalties[iface]['rx_pair_adj'] + 0.2 * penalties[iface]['rx_scale'])
+        cap_pen_tx = 1.0 - min(0.3, penalties[iface]['tx_cap'] + 0.2 * penalties[iface]['tx_pair_adj'] + 0.2 * penalties[iface]['tx_scale'])
+
+        rx_confidence = max(0.0, min(1.0, rx_link_conf * r_factor * rx_change_factor * cap_pen_rx))
+        tx_confidence = max(0.0, min(1.0, tx_link_conf * r_factor * tx_change_factor * cap_pen_tx))
+
+        # Status confidence: keep status unchanged but calibrate
         status_confidence = 1.0
-        repaired_status = data.get('interface_status', 'unknown')
-
-        # If statuses differ across the link, reduce confidence
-        peer_id = peers.get(iface)
         if peer_id and peer_id in telemetry:
-            peer_status_raw = str(telemetry[peer_id].get('interface_status', 'unknown')).lower()
-            if peer_status_raw not in ('up', 'down'):
-                peer_status_raw = 'up'
-            if str(repaired_status).lower() != peer_status_raw:
+            peer_status_raw = norm_status(telemetry[peer_id].get('interface_status', 'unknown'))
+            if status != peer_status_raw:
                 status_confidence = min(status_confidence, 0.5)
-
-        # If interface reports down but had non-zero original counters, lower status confidence
-        if str(repaired_status).lower() == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
+        if status == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
             status_confidence = min(status_confidence, 0.6)
 
-        # Ensure down interfaces have zero repaired rates
-        if str(repaired_status).lower() == 'down':
-            rx_repaired = 0.0
-            tx_repaired = 0.0
-
         # Build output
-        repaired_entry: Dict[str, Tuple] = {}
-        repaired_entry['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
-        repaired_entry['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
-        repaired_entry['interface_status'] = (data.get('interface_status', 'unknown'), repaired_status, status_confidence)
+        out: Dict[str, Tuple] = {}
+        out['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
+        out['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
+        out['interface_status'] = (status_raw, status_raw, status_confidence)
 
         # Copy metadata unchanged
-        repaired_entry['connected_to'] = data.get('connected_to')
-        repaired_entry['local_router'] = data.get('local_router')
-        repaired_entry['remote_router'] = data.get('remote_router')
-
-        result[iface] = repaired_entry
+        out['connected_to'] = data.get('connected_to')
+        out['local_router'] = data.get('local_router')
+        out['remote_router'] = data.get('remote_router')
+
+        result[iface] = out
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")