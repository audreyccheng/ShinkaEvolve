<NAME>
pair_reconcile_and_logistic_conf
</NAME>

<DESCRIPTION>
I propose two targeted improvements that align with the Hodor validation principles and previous recommendations, aiming to improve counter repair accuracy while better calibrating confidence:

1) Limited pair symmetry reconciliation after router redistribution: After the router-level additive redistribution, we run a small correction pass over each up pair to pull both endpoints toward their midpoint by a modest fraction (alpha = 0.3) when pair residual exceeds the hardening threshold. This preserves link symmetry (R3) without large corrections and avoids drifting pairs apart due to router-level adjustments. We adjust per-direction confidences with a small change penalty to avoid overconfidence where we applied nontrivial edits.

2) Rate-aware, logistic confidence mapping for final confidences: Replace the linear residual-to-confidence mapping with a logistic function and use rate-aware pair tolerances tol_pair = max(0.02, 5.0 / max(traffic, 1.0)). This makes confidence scores smoother and better calibrated, especially for low-rate links where a fixed 2% tolerance is too strict. The logistic mapping improves calibration robustness by avoiding sharp drops or overconfidence.

These changes are minimal and isolated:
- A new constant PAIR_RECONCILE_ALPHA is added.
- A pair reconciliation block is inserted before final confidence computation.
- The confidence function conf_from_residual is updated (and imports exp).
- The final pair-based confidence components use dynamic rate-aware tolerances.

This should retain or improve counter_repair_accuracy and raise confidence_calibration without regressing status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from typing import Dict, Any, Tuple, List
=======
from typing import Dict, Any, Tuple, List
from math import exp
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    EPS = 1e-9
=======
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    # Limited reconciliation strength to pull pair endpoints toward symmetry
    PAIR_RECONCILE_ALPHA = 0.30
    EPS = 1e-9
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def conf_from_residual(residual: float, tol: float) -> float:
        # Map residual to confidence: 1 at 0 residual, degrades linearly until ~0 near 5*tol
        denom = max(tol * 5.0, 1e-9)
        return clamp(1.0 - residual / denom)
=======
    def conf_from_residual(residual: float, tol: float) -> float:
        # Logistic decay for smoother, better-calibrated confidence
        # residual ~ tol -> ~0.5; residual << tol -> close to 1; residual >> tol -> close to 0
        tol = max(tol, 1e-9)
        x = residual / tol
        k = 3.0
        return clamp(1.0 / (1.0 + exp(k * (x - 1.0))))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Final confidence calibration based on post-repair invariants
    # Compute per-router imbalance residuals
=======
    # Limited pair-symmetry reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']
        b_rx_old = interim[b_id]['rx']
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > HARDENING_THRESHOLD:
            v_mid = 0.5 * (a_tx_old + b_rx_old)
            a_tx_new = max(0.0, a_tx_old + PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old))
            b_rx_new = max(0.0, b_rx_old + PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old))
            if a_tx_new != a_tx_old:
                drel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], 1.0 - min(1.0, 0.5 * drel)))
            if b_rx_new != b_rx_old:
                drel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], 1.0 - min(1.0, 0.5 * drel)))

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']
        b_tx_old = interim[b_id]['tx']
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > HARDENING_THRESHOLD:
            v_mid2 = 0.5 * (a_rx_old + b_tx_old)
            a_rx_new = max(0.0, a_rx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old))
            b_tx_new = max(0.0, b_tx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old))
            if a_rx_new != a_rx_old:
                drel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], 1.0 - min(1.0, 0.5 * drel)))
            if b_tx_new != b_tx_old:
                drel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], 1.0 - min(1.0, 0.5 * drel)))

    # Final confidence calibration based on post-repair invariants
    # Compute per-router imbalance residuals
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            pair_comp_tx = conf_from_residual(res_fwd, TOL_PAIR)
            pair_comp_rx = conf_from_residual(res_rev, TOL_PAIR)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
=======
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            # Rate-aware pair tolerances to avoid over-penalizing low-rate links
            traffic_tx = max(r['tx'], interim[peer]['rx'], 1.0)
            traffic_rx = max(r['rx'], interim[peer]['tx'], 1.0)
            tol_pair_tx = max(HARDENING_THRESHOLD, 5.0 / traffic_tx)
            tol_pair_rx = max(HARDENING_THRESHOLD, 5.0 / traffic_rx)
            pair_comp_tx = conf_from_residual(res_fwd, tol_pair_tx)
            pair_comp_rx = conf_from_residual(res_rev, tol_pair_rx)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
>>>>>>> REPLACE

</DIFF>