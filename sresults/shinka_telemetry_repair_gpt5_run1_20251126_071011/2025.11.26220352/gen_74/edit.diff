--- a/original.py
+++ b/original.py
@@ -1,527 +1,644 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
 Takes interface telemetry data and detects/repairs inconsistencies based on
 network invariants like link symmetry and flow conservation.
 """
 from typing import Dict, Any, Tuple, List
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
     Core principle: Use network invariants to validate and repair telemetry:
     1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
 
     Args:
         telemetry: Dictionary where key is interface_id and value contains:
             - interface_status: "up" or "down"
             - rx_rate: receive rate in Mbps
             - tx_rate: transmit rate in Mbps
             - connected_to: interface_id this interface connects to
             - local_router: router_id this interface belongs to
             - remote_router: router_id on the other side
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary with same structure but telemetry values become tuples of:
         (original_value, repaired_value, confidence_score)
         where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
     """
     # Measurement timing tolerance (from Hodor research: ~2%)
     HARDENING_THRESHOLD = 0.02
     EPS = 1e-9
 
     # Helpers
     def norm_status(s: Any) -> str:
         s = str(s).lower()
         return s if s in ("up", "down") else "up"  # treat unknown as up conservatively
 
     def nz_float(x: Any) -> float:
         try:
             v = float(x)
         except Exception:
             v = 0.0
         return max(0.0, v)
 
     def rel_diff(a: float, b: float) -> float:
         a = float(a)
         b = float(b)
         denom = max(abs(a), abs(b), 1.0)
         return abs(a - b) / denom
 
     def clamp(x: float, lo: float, hi: float) -> float:
         return max(lo, min(hi, x))
 
     def pair_tolerance(a: float, b: float) -> float:
         # Traffic-aware tolerance to account for timing skew on tiny links
         traffic = max(abs(a), abs(b), 1.0)
         return max(HARDENING_THRESHOLD, 2.5 / traffic)
 
     # Precompute peer mapping
     peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
 
     # First pass: link-aware hardening with status-aware zeroing and triage substitution
     pre: Dict[str, Dict[str, Any]] = {}
     for iface, data in telemetry.items():
         local_status = norm_status(data.get('interface_status', 'unknown'))
         rx_orig = nz_float(data.get('rx_rate', 0.0))
         tx_orig = nz_float(data.get('tx_rate', 0.0))
 
         peer_id = peers.get(iface)
         had_peer = bool(peer_id and peer_id in telemetry)
         peer_status = 'unknown'
         peer_rx = peer_tx = 0.0
 
         if had_peer:
             p = telemetry[peer_id]
             peer_status = norm_status(p.get('interface_status', 'unknown'))
             peer_rx = nz_float(p.get('rx_rate', 0.0))
             peer_tx = nz_float(p.get('tx_rate', 0.0))
 
         pre_rx = rx_orig
         pre_tx = tx_orig
         rx_link_diff = 0.0
         tx_link_diff = 0.0
 
         # Status-aware zeroing: only zero when local interface is down
         if local_status == 'down':
             pre_rx = 0.0
             pre_tx = 0.0
         else:
             if had_peer and peer_status == 'up':
                 # Link symmetry: A.rx ≈ B.tx, A.tx ≈ B.rx
                 rx_link_diff = rel_diff(rx_orig, peer_tx)
                 tx_link_diff = rel_diff(tx_orig, peer_rx)
 
                 pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
                 pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD
 
                 # Triage: if only one direction violates, substitute; if both violate, average
                 if pair_tx_ok and not pair_rx_ok:
                     pre_rx = peer_tx
                 elif pair_rx_ok and not pair_tx_ok:
                     pre_tx = peer_rx
                 elif not pair_rx_ok and not pair_tx_ok:
                     pre_rx = 0.5 * (rx_orig + peer_tx)
                     pre_tx = 0.5 * (tx_orig + peer_rx)
                 # else: both within tolerance -> keep as-is
 
         pre[iface] = {
             'pre_rx': pre_rx,
             'pre_tx': pre_tx,
             'rx_link_diff': rx_link_diff,
             'tx_link_diff': tx_link_diff,
             'local_status': local_status,
             'peer_status': peer_status if had_peer else 'unknown',
             'had_peer': had_peer
         }
 
     # Second pass: router-level flow conservation using topology (R1)
     # Bounded multiplicative pre-step on the less-trusted direction with per-interface caps.
     router_imbalance: Dict[str, float] = {}
     post_router: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
     router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
     # Track absolute deltas from router edits to compute remaining budget for pair reconciliation
     router_delta_abs: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
     # Store bounded router ratio per router for confidence calibration
     s_bounded_map: Dict[str, float] = {}
 
     for router_id, iface_list in topology.items():
         # Consider only interfaces present in telemetry and locally up
         up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
         if len(up_ifaces) < 2:
             router_imbalance[router_id] = 0.0
             continue
 
         sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
         sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)
 
         denom = max(sum_rx, sum_tx, 1.0)
         imbalance = abs(sum_tx - sum_rx) / denom
         router_imbalance[router_id] = imbalance
 
         # Avoid scaling for tiny volumes or minor imbalance
         if (sum_rx + sum_tx) <= 1e-6 or imbalance <= HARDENING_THRESHOLD:
             continue
 
         # Determine the less-trusted direction via average pair residuals where peers are up
         rx_resids: List[float] = []
         tx_resids: List[float] = []
         for i in up_ifaces:
             peer_id = peers.get(i)
             if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                 # My TX ≈ peer RX; My RX ≈ peer TX
                 tx_resids.append(rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx']))
                 rx_resids.append(rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx']))
 
         avg_tx_resid = sum(tx_resids) / len(tx_resids) if tx_resids else None
         avg_rx_resid = sum(rx_resids) / len(rx_resids) if rx_resids else None
 
         dir_to_scale = None
         if avg_tx_resid is not None and avg_rx_resid is not None:
             if avg_tx_resid > avg_rx_resid + 0.02:
                 dir_to_scale = 'tx'
             elif avg_rx_resid > avg_tx_resid + 0.02:
                 dir_to_scale = 'rx'
         if dir_to_scale is None:
             dir_to_scale = 'tx' if sum_tx > sum_rx else 'rx'
 
         # Compute bounded router ratio and tempered factor
         if dir_to_scale == 'tx':
             s = sum_rx / max(sum_tx, EPS)
         else:
             s = sum_tx / max(sum_rx, EPS)
         s_bounded = clamp(s, 0.85, 1.15)
         alpha = clamp(imbalance / 0.15, 0.25, 0.6)
         k = 1.0 + alpha * (s_bounded - 1.0)
         # Save for later confidence calibration
         s_bounded_map[router_id] = s_bounded
 
         # Weighted, capped redistribution toward less-trusted interfaces
         # Build totals on the chosen direction for volumetric weighting
         if dir_to_scale == 'tx':
             sum_dir = sum(post_router[i]['tx'] for i in up_ifaces)
         else:
             sum_dir = sum(post_router[i]['rx'] for i in up_ifaces)
         sum_dir = max(sum_dir, 1.0)
 
         for i in up_ifaces:
             if dir_to_scale == 'tx':
                 old = post_router[i]['tx']
                 # Confidence proxy and residual on pair for weighting
                 peer_id = peers.get(i)
                 conf_dir = max(0.0, 1.0 - pre[i]['tx_link_diff'])
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     resid = rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
                     tol = pair_tolerance(pre[i]['pre_tx'], pre[peer_id]['pre_rx'])
                     sev = min(2.0, resid / max(tol, EPS))
                 else:
                     sev = 0.0
                 vol = old / sum_dir
                 w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                 # Small boost for highly inconsistent pairs
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     if resid > 2.0 * tol:
                         w += 0.1
                 if old < 1.0:
                     w *= 0.5
                 w = max(0.02, w)
                 delta_target = old * (k - 1.0)
                 cap_abs = 0.15 * max(old, 1.0)
                 move = clamp(delta_target * w, -cap_abs, cap_abs)
                 new_val = max(0.0, old + move)
                 post_router[i]['tx'] = new_val
                 router_delta_rel[i]['tx'] = abs(move) / max(old, 1.0)
                 router_delta_abs[i]['tx'] += abs(move)
             else:
                 old = post_router[i]['rx']
                 peer_id = peers.get(i)
                 conf_dir = max(0.0, 1.0 - pre[i]['rx_link_diff'])
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     resid = rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
                     tol = pair_tolerance(pre[i]['pre_rx'], pre[peer_id]['pre_tx'])
                     sev = min(2.0, resid / max(tol, EPS))
                 else:
                     sev = 0.0
                 vol = old / sum_dir
                 w = 0.6 * (1.0 - conf_dir) + 0.25 * sev + 0.15 * vol
                 # Small boost for highly inconsistent pairs
                 if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                     if resid > 2.0 * tol:
                         w += 0.1
                 if old < 1.0:
                     w *= 0.5
                 w = max(0.02, w)
                 delta_target = old * (k - 1.0)
                 cap_abs = 0.15 * max(old, 1.0)
                 move = clamp(delta_target * w, -cap_abs, cap_abs)
                 new_val = max(0.0, old + move)
                 post_router[i]['rx'] = new_val
                 router_delta_rel[i]['rx'] = abs(move) / max(old, 1.0)
                 router_delta_abs[i]['rx'] += abs(move)
 
+    # Additive router redistribution pass (uncertainty-weighted) to close remaining imbalance
+    add_cap_hit: Dict[str, Dict[str, bool]] = {i: {'rx': False, 'tx': False} for i in telemetry}
+    for router_id, iface_list in topology.items():
+        up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
+        if len(up_ifaces) < 2:
+            continue
+
+        sum_rx2 = sum(post_router[i]['rx'] for i in up_ifaces)
+        sum_tx2 = sum(post_router[i]['tx'] for i in up_ifaces)
+        denom2 = max(sum_rx2, sum_tx2, 1.0)
+        if (sum_rx2 + sum_tx2) <= 1e-6:
+            continue
+
+        # Residual after multiplicative scaling
+        resid = abs(sum_tx2 - sum_rx2) / denom2
+        if resid <= HARDENING_THRESHOLD:
+            continue
+
+        # Choose direction and compute needed adjustment (positive need means increase that direction)
+        if sum_tx2 > sum_rx2:
+            dir_to_adj = 'tx'
+            need = -(sum_tx2 - sum_rx2)  # decrease TX to match RX
+        else:
+            dir_to_adj = 'rx'
+            need = +(sum_rx2 - sum_tx2)  # increase RX to match TX
+
+        # Per-router total delta guard (≤ 25% of average traffic)
+        router_cap_abs = 0.25 * ((sum_rx2 + sum_tx2) / 2.0)
+        need = clamp(need, -router_cap_abs, router_cap_abs)
+
+        # Prepare weights and per-interface caps
+        vals = {i: post_router[i][dir_to_adj] for i in up_ifaces}
+        sum_v = max(1e-9, sum(vals.values()))
+        weights: Dict[str, float] = {}
+        caps: Dict[str, float] = {}
+        for i in up_ifaces:
+            v_i = vals[i]
+            # Confidence proxy from pre link diffs
+            if dir_to_adj == 'tx':
+                conf_dir = max(0.0, 1.0 - pre[i]['tx_link_diff'])
+            else:
+                conf_dir = max(0.0, 1.0 - pre[i]['rx_link_diff'])
+
+            # Pair residual after multiplicative scaling
+            peer_id = peers.get(i)
+            if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
+                if dir_to_adj == 'tx':
+                    resid_pair = rel_diff(post_router[i]['tx'], post_router[peer_id]['rx'])
+                    tol_pair = pair_tolerance(post_router[i]['tx'], post_router[peer_id]['rx'])
+                else:
+                    resid_pair = rel_diff(post_router[i]['rx'], post_router[peer_id]['tx'])
+                    tol_pair = pair_tolerance(post_router[i]['rx'], post_router[peer_id]['tx'])
+                pair_term = min(2.0, resid_pair / max(tol_pair, 1e-6))
+            else:
+                pair_term = 0.0
+
+            vol_term = (v_i / sum_v) if sum_v > 0 else 0.0
+            w = 0.6 * (1.0 - conf_dir) + 0.25 * pair_term + 0.15 * vol_term
+
+            # Protect tiny links and reduce weight if heavily adjusted multiplicatively already
+            if v_i < 1.0:
+                w *= 0.5
+            prev_rel = router_delta_rel[i]['tx'] if dir_to_adj == 'tx' else router_delta_rel[i]['rx']
+            if prev_rel >= 0.105:  # >70% of 15% multiplicative cap
+                w *= 0.7
+
+            weights[i] = max(0.0, w)
+            caps[i] = 0.15 * max(v_i, 1.0)  # per-interface additive cap
+
+        # Distribute need with caps and weights (iterative to honor caps)
+        applied: Dict[str, float] = {i: 0.0 for i in up_ifaces}
+        remaining = need
+        for _ in range(4):  # a few iterations suffice
+            active = [i for i in up_ifaces if weights[i] > 0.0 and (caps[i] - abs(applied[i])) > 1e-12]
+            if not active or abs(remaining) <= 1e-6:
+                break
+            wsum = sum(weights[i] for i in active)
+            if wsum <= 0.0:
+                break
+            for i in active:
+                if abs(remaining) <= 1e-6:
+                    break
+                rem_cap_i = caps[i] - abs(applied[i])
+                share = weights[i] / wsum
+                prop = remaining * share
+                prop = clamp(prop, -rem_cap_i, rem_cap_i)
+                applied[i] += prop
+                remaining -= prop
+            if abs(remaining) <= 1e-6:
+                break
+
+        # Apply additive adjustments
+        for i, d in applied.items():
+            if abs(d) <= 0.0:
+                continue
+            if dir_to_adj == 'tx':
+                oldv = post_router[i]['tx']
+                post_router[i]['tx'] = max(0.0, oldv + d)
+                router_delta_rel[i]['tx'] += abs(d) / max(oldv, 1.0)
+                router_delta_abs[i]['tx'] += abs(d)
+                if abs(d) >= 0.7 * caps[i]:
+                    add_cap_hit[i]['tx'] = True
+            else:
+                oldv = post_router[i]['rx']
+                post_router[i]['rx'] = max(0.0, oldv + d)
+                router_delta_rel[i]['rx'] += abs(d) / max(oldv, 1.0)
+                router_delta_abs[i]['rx'] += abs(d)
+                if abs(d) >= 0.7 * caps[i]:
+                    add_cap_hit[i]['rx'] = True
+
     # Third pass: tolerance-gated, partial pair reconciliation after router scaling
     post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
     pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
 
     visited_pairs = set()
     for iface, data in telemetry.items():
         peer_id = peers.get(iface)
         if not (peer_id and peer_id in telemetry):
             continue
         pair_key = tuple(sorted([iface, peer_id]))
         if pair_key in visited_pairs:
             continue
         visited_pairs.add(pair_key)
 
         # Only reconcile when both interfaces are locally up
         if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
             continue
 
         # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
         touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                    router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                    router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                    router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
         if not touched:
             continue
 
         # Residuals after router scaling
         a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
         b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
 
         # A.tx ↔ B.rx
         resid_tx = rel_diff(a_tx, b_rx)
         tol_tx = pair_tolerance(a_tx, b_rx)
         if resid_tx > tol_tx:
             # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
             conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
             conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
             # Lower-confidence side moves more toward midpoint
             if conf_a_tx <= conf_b_rx:
                 alpha_low, alpha_high = 0.35, 0.20
                 move_a = alpha_low * (b_rx - a_tx)
                 move_b = alpha_high * (a_tx - b_rx)
             else:
                 alpha_low, alpha_high = 0.35, 0.20
                 move_a = alpha_high * (b_rx - a_tx)
                 move_b = alpha_low * (a_tx - b_rx)
             # Cap moves using remaining cap (≤ 20% of pre-router value minus router edits)
             base_a = pre[iface]['pre_tx']
             base_b = pre[peer_id]['pre_rx']
             cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
             cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))
             move_a = clamp(move_a, -cap_a, cap_a)
             move_b = clamp(move_b, -cap_b, cap_b)
             new_a_tx = max(0.0, a_tx + move_a)
             new_b_rx = max(0.0, b_rx + move_b)
             pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
             pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
             post[iface]['tx'] = new_a_tx
             post[peer_id]['rx'] = new_b_rx
 
         # A.rx ↔ B.tx
         a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
         b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
         resid_rx = rel_diff(a_rx, b_tx)
         tol_rx = pair_tolerance(a_rx, b_tx)
         if resid_rx > tol_rx:
             conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
             conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
             if conf_a_rx <= conf_b_tx:
                 alpha_low, alpha_high = 0.35, 0.20
                 move_a = alpha_low * (b_tx - a_rx)
                 move_b = alpha_high * (a_rx - b_tx)
             else:
                 alpha_low, alpha_high = 0.35, 0.20
                 move_a = alpha_high * (b_tx - a_rx)
                 move_b = alpha_low * (a_rx - b_tx)
             base_a = pre[iface]['pre_rx']
             base_b = pre[peer_id]['pre_tx']
             cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
             cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))
             move_a = clamp(move_a, -cap_a, cap_a)
             move_b = clamp(move_b, -cap_b, cap_b)
             new_a_rx = max(0.0, a_rx + move_a)
             new_b_tx = max(0.0, b_tx + move_b)
             pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
             pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
             post[iface]['rx'] = new_a_rx
             post[peer_id]['tx'] = new_b_tx
 
     # Assemble final results with calibrated confidence (post-repair residuals)
     result: Dict[str, Dict[str, Tuple]] = {}
 
     for iface, data in telemetry.items():
         local_status = pre[iface]['local_status']
         peer_status = pre[iface]['peer_status']
         had_peer = pre[iface]['had_peer']
         rx_orig = nz_float(data.get('rx_rate', 0.0))
         tx_orig = nz_float(data.get('tx_rate', 0.0))
 
         rx_repaired = post[iface]['rx']
         tx_repaired = post[iface]['tx']
 
         # Enforce zero on down interfaces
         repaired_status = data.get('interface_status', 'unknown')
         if norm_status(repaired_status) == 'down':
             rx_repaired = 0.0
             tx_repaired = 0.0
 
         # Confidence based on post-repair residuals vs peer
         peer_id = peers.get(iface)
         if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
             peer_tx_after = post[peer_id]['tx']
             peer_rx_after = post[peer_id]['rx']
             rx_resid = rel_diff(rx_repaired, peer_tx_after)
             tx_resid = rel_diff(tx_repaired, peer_rx_after)
             rx_link_conf = max(0.0, 1.0 - rx_resid)
             tx_link_conf = max(0.0, 1.0 - tx_resid)
         elif norm_status(repaired_status) == 'down':
             rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
             tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
         else:
             rx_link_conf = 0.6
             tx_link_conf = 0.6
 
         # Recompute router imbalance post-repair for confidence
         # Build per-router sums using final post values
         # Note: computed lazily once; cache on first use
         if 'router_imbalance_post' not in locals():
             router_imbalance_post: Dict[str, float] = {}
             for rid, if_list in topology.items():
                 up_ifaces_r = [i for i in if_list if i in telemetry and pre[i]['local_status'] == 'up']
                 if not up_ifaces_r:
                     router_imbalance_post[rid] = 0.0
                     continue
                 sum_rx_r = sum(post[i]['rx'] for i in up_ifaces_r)
                 sum_tx_r = sum(post[i]['tx'] for i in up_ifaces_r)
                 denom_r = max(sum_rx_r, sum_tx_r, 1.0)
                 router_imbalance_post[rid] = abs(sum_tx_r - sum_rx_r) / denom_r
 
         router_id = data.get('local_router')
         imb_post = router_imbalance_post.get(router_id, 0.0)
         router_factor = max(0.2, 1.0 - imb_post)
 
         # Change penalty: reduce confidence for large corrections from original
         rx_change = rel_diff(rx_orig, rx_repaired)
         tx_change = rel_diff(tx_orig, tx_repaired)
         # Two-slope change penalty: gentler for small edits (<15%)
         rx_weight = 0.4 if rx_change < 0.15 else 0.5
         tx_weight = 0.4 if tx_change < 0.15 else 0.5
         rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
         tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
 
         rx_confidence = rx_link_conf * router_factor * rx_change_factor
         tx_confidence = tx_link_conf * router_factor * tx_change_factor
 
         # Router scale intensity penalty using bounded ratio (helps calibration)
         s_b = s_bounded_map.get(router_id, 1.0)
         if abs(1.0 - s_b) > 0.25:
             pen = min(0.05, 0.2 * abs(1.0 - s_b))
             rx_confidence -= pen
             tx_confidence -= pen
 
         # Penalties for heavy router scaling and pair adjustments to improve calibration
         rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
         rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
         if rdel_rx >= 0.12:
             rx_confidence -= 0.03
         elif rdel_rx >= 0.07:
             rx_confidence -= 0.02
         if rdel_tx >= 0.12:
             tx_confidence -= 0.03
         elif rdel_tx >= 0.07:
             tx_confidence -= 0.02
 
         padj_rx = 0.0
         padj_tx = 0.0
         if 'pair_adj_rel' in locals():
             padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
             padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
         rx_confidence -= min(0.05, 0.25 * padj_rx)
         tx_confidence -= min(0.05, 0.25 * padj_tx)
 
+        # Penalty when additive redistribution consumed most of per-interface cap
+        if 'add_cap_hit' in locals():
+            if add_cap_hit.get(iface, {}).get('rx', False):
+                rx_confidence -= 0.04
+            if add_cap_hit.get(iface, {}).get('tx', False):
+                tx_confidence -= 0.04
+
         # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
         cum_cap = 0.35
         thresh = 0.7 * cum_cap
         cum_rx_rel = rdel_rx + padj_rx
         cum_tx_rel = rdel_tx + padj_tx
         if cum_rx_rel > thresh:
             rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
         if cum_tx_rel > thresh:
             tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))
 
         # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
         if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
             rx_confidence += 0.03
         if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
             tx_confidence += 0.03
 
         rx_confidence = max(0.0, min(1.0, rx_confidence))
         tx_confidence = max(0.0, min(1.0, tx_confidence))
 
         # Status confidence adjustments (keep status unchanged; calibrate confidence)
         status_confidence = 1.0
 
         if peer_id and peer_id in telemetry:
             peer_status_raw = norm_status(telemetry[peer_id].get('interface_status', 'unknown'))
             if norm_status(repaired_status) != peer_status_raw:
                 status_confidence = min(status_confidence, 0.5)
 
         if norm_status(repaired_status) == 'down' and (rx_orig > 0.0 or tx_orig > 0.0):
             status_confidence = min(status_confidence, 0.6)
 
         # Build output
         repaired_entry: Dict[str, Tuple] = {}
         repaired_entry['rx_rate'] = (rx_orig, rx_repaired, rx_confidence)
         repaired_entry['tx_rate'] = (tx_orig, tx_repaired, tx_confidence)
         repaired_entry['interface_status'] = (data.get('interface_status', 'unknown'), repaired_status, status_confidence)
 
         # Copy metadata unchanged
         repaired_entry['connected_to'] = data.get('connected_to')
         repaired_entry['local_router'] = data.get('local_router')
         repaired_entry['remote_router'] = data.get('remote_router')
 
         result[iface] = repaired_entry
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")