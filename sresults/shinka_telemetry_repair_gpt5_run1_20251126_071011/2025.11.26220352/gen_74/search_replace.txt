<NAME>
add_router_additive_pass_and_confidence_penalty
</NAME>

<DESCRIPTION>
I propose adding an uncertainty-weighted additive router redistribution pass after the current multiplicative router scaling to better satisfy flow conservation (R1) and reduce residual router imbalances. This pass distributes the remaining imbalance on the less-trusted direction using calibrated per-interface caps (15% of volume) and weights that consider confidence, pair inconsistency, and volume, protecting tiny links and links already heavily adjusted. This improves counter repair accuracy while limiting risky edits.

To maintain and improve confidence calibration, I also add a confidence penalty when an interface consumes most of its per-interface additive cap (≥70%), which reflects repair intensity. This penalty was effective in previous iterations and complements existing scale and pair adjustment penalties. The changes are minimal and targeted: insert the additive pass before pair reconciliation, track cap hits, and apply a small penalty during confidence assembly.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
    pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
        touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
        if not touched:
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves using remaining cap (≤ 20% of pre-router value minus router edits)
            base_a = pre[iface]['pre_tx']
            base_b = pre[peer_id]['pre_rx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            base_a = pre[iface]['pre_rx']
            base_b = pre[peer_id]['pre_tx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
=======
    # Additive router redistribution pass (uncertainty-weighted) to close remaining imbalance
    add_cap_hit: Dict[str, Dict[str, bool]] = {i: {'rx': False, 'tx': False} for i in telemetry}
    for router_id, iface_list in topology.items():
        up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
        if len(up_ifaces) < 2:
            continue

        sum_rx2 = sum(post_router[i]['rx'] for i in up_ifaces)
        sum_tx2 = sum(post_router[i]['tx'] for i in up_ifaces)
        denom2 = max(sum_rx2, sum_tx2, 1.0)
        if (sum_rx2 + sum_tx2) <= 1e-6:
            continue

        # Residual after multiplicative scaling
        resid = abs(sum_tx2 - sum_rx2) / denom2
        if resid <= HARDENING_THRESHOLD:
            continue

        # Choose direction and compute needed adjustment (positive need means increase that direction)
        if sum_tx2 > sum_rx2:
            dir_to_adj = 'tx'
            need = -(sum_tx2 - sum_rx2)  # decrease TX to match RX
        else:
            dir_to_adj = 'rx'
            need = +(sum_rx2 - sum_tx2)  # increase RX to match TX

        # Per-router total delta guard (≤ 25% of average traffic)
        router_cap_abs = 0.25 * ((sum_rx2 + sum_tx2) / 2.0)
        need = clamp(need, -router_cap_abs, router_cap_abs)

        # Prepare weights and per-interface caps
        vals = {i: post_router[i][dir_to_adj] for i in up_ifaces}
        sum_v = max(1e-9, sum(vals.values()))
        weights: Dict[str, float] = {}
        caps: Dict[str, float] = {}
        for i in up_ifaces:
            v_i = vals[i]
            # Confidence proxy from pre link diffs
            if dir_to_adj == 'tx':
                conf_dir = max(0.0, 1.0 - pre[i]['tx_link_diff'])
            else:
                conf_dir = max(0.0, 1.0 - pre[i]['rx_link_diff'])

            # Pair residual after multiplicative scaling
            peer_id = peers.get(i)
            if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                if dir_to_adj == 'tx':
                    resid_pair = rel_diff(post_router[i]['tx'], post_router[peer_id]['rx'])
                    tol_pair = pair_tolerance(post_router[i]['tx'], post_router[peer_id]['rx'])
                else:
                    resid_pair = rel_diff(post_router[i]['rx'], post_router[peer_id]['tx'])
                    tol_pair = pair_tolerance(post_router[i]['rx'], post_router[peer_id]['tx'])
                pair_term = min(2.0, resid_pair / max(tol_pair, 1e-6))
            else:
                pair_term = 0.0

            vol_term = (v_i / sum_v) if sum_v > 0 else 0.0
            w = 0.6 * (1.0 - conf_dir) + 0.25 * pair_term + 0.15 * vol_term

            # Protect tiny links and reduce weight if heavily adjusted multiplicatively already
            if v_i < 1.0:
                w *= 0.5
            prev_rel = router_delta_rel[i]['tx'] if dir_to_adj == 'tx' else router_delta_rel[i]['rx']
            if prev_rel >= 0.105:  # >70% of 15% multiplicative cap
                w *= 0.7

            weights[i] = max(0.0, w)
            caps[i] = 0.15 * max(v_i, 1.0)  # per-interface additive cap

        # Distribute need with caps and weights (iterative to honor caps)
        applied: Dict[str, float] = {i: 0.0 for i in up_ifaces}
        remaining = need
        for _ in range(4):  # a few iterations suffice
            active = [i for i in up_ifaces if weights[i] > 0.0 and (caps[i] - abs(applied[i])) > 1e-12]
            if not active or abs(remaining) <= 1e-6:
                break
            wsum = sum(weights[i] for i in active)
            if wsum <= 0.0:
                break
            for i in active:
                if abs(remaining) <= 1e-6:
                    break
                rem_cap_i = caps[i] - abs(applied[i])
                share = weights[i] / wsum
                prop = remaining * share
                prop = clamp(prop, -rem_cap_i, rem_cap_i)
                applied[i] += prop
                remaining -= prop
            if abs(remaining) <= 1e-6:
                break

        # Apply additive adjustments
        for i, d in applied.items():
            if abs(d) <= 0.0:
                continue
            if dir_to_adj == 'tx':
                oldv = post_router[i]['tx']
                post_router[i]['tx'] = max(0.0, oldv + d)
                router_delta_rel[i]['tx'] += abs(d) / max(oldv, 1.0)
                router_delta_abs[i]['tx'] += abs(d)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['tx'] = True
            else:
                oldv = post_router[i]['rx']
                post_router[i]['rx'] = max(0.0, oldv + d)
                router_delta_rel[i]['rx'] += abs(d) / max(oldv, 1.0)
                router_delta_abs[i]['rx'] += abs(d)
                if abs(d) >= 0.7 * caps[i]:
                    add_cap_hit[i]['rx'] = True

    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
    pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
        touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
        if not touched:
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves using remaining cap (≤ 20% of pre-router value minus router edits)
            base_a = pre[iface]['pre_tx']
            base_b = pre[peer_id]['pre_rx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            base_a = pre[iface]['pre_rx']
            base_b = pre[peer_id]['pre_tx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
        cum_cap = 0.35
        thresh = 0.7 * cum_cap
        cum_rx_rel = rdel_rx + padj_rx
        cum_tx_rel = rdel_tx + padj_tx
        if cum_rx_rel > thresh:
            rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
        if cum_tx_rel > thresh:
            tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))
=======
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Penalty when additive redistribution consumed most of per-interface cap
        if 'add_cap_hit' in locals():
            if add_cap_hit.get(iface, {}).get('rx', False):
                rx_confidence -= 0.04
            if add_cap_hit.get(iface, {}).get('tx', False):
                tx_confidence -= 0.04

        # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
        cum_cap = 0.35
        thresh = 0.7 * cum_cap
        cum_rx_rel = rdel_rx + padj_rx
        cum_tx_rel = rdel_tx + padj_tx
        if cum_rx_rel > thresh:
            rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
        if cum_tx_rel > thresh:
            tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))
>>>>>>> REPLACE

</DIFF>