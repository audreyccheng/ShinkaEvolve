--- a/original.py
+++ b/original.py
@@ -1,444 +1,418 @@
 # EVOLVE-BLOCK-START
 """
-Network telemetry repair algorithm that detects and corrects inconsistencies
-in network interface telemetry data using topology relationships.
-
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
+Network telemetry repair via robust global consensus projections.
+
+Algorithm summary:
+- Resolve status with redundant link evidence.
+- Gentle router multiplicative pre-step toward balance on the less-trusted direction.
+- Iterative robust projections:
+  * Link projection: weighted consensus for (my_tx <-> peer_rx) and (my_rx <-> peer_tx).
+  * Router projection: exact flow conservation via closed-form minimum-weight adjustment
+    with non-negativity handled by iterative clamping (water-filling style).
+- Confidence: rate-aware tolerances, logistic decay from residuals, and change penalties.
+
+This is a fundamentally different approach from prior local-heuristic redistribution: it
+uses alternating projections (IRLS/ADMM flavor) to enforce invariants globally.
 """
 from typing import Dict, Any, Tuple, List
 
-
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
-    """
-    Repair network interface telemetry by detecting and correcting inconsistencies.
-
-    Core principle: Use network invariants to validate and repair telemetry:
-    1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
-    2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
-    3. Interface Consistency: Status should be consistent across connected pairs
-
-    Args:
-        telemetry: Dictionary where key is interface_id and value contains:
-            - interface_status: "up" or "down"
-            - rx_rate: receive rate in Mbps
-            - tx_rate: transmit rate in Mbps
-            - connected_to: interface_id this interface connects to
-            - local_router: router_id this interface belongs to
-            - remote_router: router_id on the other side
-        topology: Dictionary where key is router_id and value contains a list of interface_ids
-
-    Returns:
-        Dictionary with same structure but telemetry values become tuples of:
-        (original_value, repaired_value, confidence_score)
-        where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
-    """
-
-    # Measurement timing tolerance (from Hodor research: ~2%)
-    HARDENING_THRESHOLD = 0.02
-    # Small traffic level used to infer link up when statuses disagree (Mbps)
-    TRAFFIC_EVIDENCE_MIN = 0.5
-    # Max fractional per-interface adjustment during router redistribution
-    MAX_ROUTER_ADJ_FRAC = 0.35
+    # Parameters
+    TAU_H = 0.02                  # hardening tolerance baseline (2%)
+    TRAFFIC_EVIDENCE_MIN = 0.5    # Mbps threshold to infer link up when statuses disagree
+    PRESTEP_CAP = 0.15            # max multiplicative step per router prestep (±15%)
+    LINK_RELAX = 0.8              # partial step in link projection to avoid oscillations
+    ITERATIONS = 3                # number of alternating projection rounds
+    HUBER_DELTA = 0.03            # Huber-like threshold for downweighting large residuals (3%)
+    CHANGE_PENALTY_WEIGHT = 0.6   # confidence penalty weight for large edits
     EPS = 1e-9
 
     def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
         return max(lo, min(hi, x))
 
     def rel_diff(a: float, b: float) -> float:
-        denom = max(abs(a), abs(b), 1e-9)
+        denom = max(abs(a), abs(b), EPS)
         return abs(a - b) / denom
 
-    def conf_from_residual(residual: float, tol: float) -> float:
-        # Map residual to confidence: 1 at 0 residual, degrades linearly until ~0 near 5*tol
-        denom = max(tol * 5.0, 1e-9)
-        return clamp(1.0 - residual / denom)
-
-    # Initialize structures
-    result: Dict[str, Dict[str, Tuple]] = {}
-    # Store interim repaired values and confidences per interface before router-level hardening
-    interim: Dict[str, Dict[str, Any]] = {}
-
-    # Build connected pairs
+    def rate_aware_tol_pair(traffic: float) -> float:
+        # Wider tolerance at very low traffic; minimum is TAU_H
+        return max(TAU_H, 5.0 / max(traffic, 1.0))
+
+    def rate_aware_tol_router(total: float) -> float:
+        # Router tolerance scaled by total traffic through the router
+        return max(TAU_H * 2.0, 5.0 / max(total, 1.0))
+
+    def logistic_conf(residual: float, tol: float, k: float = 3.0) -> float:
+        # Map residual to [0,1] with smoother, calibrated decay
+        # x = residual / tol; x=1 roughly mid, x<<1 -> high conf, x>>1 -> low conf
+        x = residual / max(tol, EPS)
+        return 1.0 / (1.0 + pow(2.718281828, k * (x - 1.0)))
+
+    # Build pairs
     visited = set()
     pairs: List[Tuple[str, str]] = []
     for if_id, data in telemetry.items():
         peer = data.get('connected_to')
         if peer and peer in telemetry:
-            # Use ordered tuple to avoid duplicates
-            key = tuple(sorted([if_id, peer]))
+            key = tuple(sorted((if_id, peer)))
             if key not in visited:
                 visited.add(key)
                 pairs.append((key[0], key[1]))
 
-    # Map each interface to its peer for quick lookup and record paired IDs
     peer_of: Dict[str, str] = {}
-    paired_ids = set()
     for a_id, b_id in pairs:
         peer_of[a_id] = b_id
         peer_of[b_id] = a_id
-        paired_ids.add(a_id)
-        paired_ids.add(b_id)
-
-    # Initialize defaults for all interfaces
+
+    # Build router_ifaces from topology if provided, else from metadata
+    if topology:
+        router_ifaces: Dict[str, List[str]] = {r: [i for i in ifs if i in telemetry] for r, ifs in topology.items()}
+    else:
+        router_ifaces = {}
+        for if_id, data in telemetry.items():
+            r = data.get('local_router')
+            if r is not None:
+                router_ifaces.setdefault(r, []).append(if_id)
+
+    # Initialize state
+    state: Dict[str, Dict[str, Any]] = {}
     for if_id, data in telemetry.items():
-        interim[if_id] = {
-            'rx': float(data.get('rx_rate', 0.0)),
-            'tx': float(data.get('tx_rate', 0.0)),
-            'rx_conf': 1.0,
-            'tx_conf': 1.0,
-            'status': data.get('interface_status', 'unknown'),
+        rx0 = float(data.get('rx_rate', 0.0))
+        tx0 = float(data.get('tx_rate', 0.0))
+        st0 = data.get('interface_status', 'unknown')
+        state[if_id] = {
+            'rx': rx0,
+            'tx': tx0,
+            'orig_rx': rx0,
+            'orig_tx': tx0,
+            'status': st0,
             'status_conf': 1.0,
             'connected_to': data.get('connected_to'),
             'local_router': data.get('local_router'),
             'remote_router': data.get('remote_router'),
-            # Keep originals for output tuples
-            'orig_rx': float(data.get('rx_rate', 0.0)),
-            'orig_tx': float(data.get('tx_rate', 0.0)),
-            'orig_status': data.get('interface_status', 'unknown'),
         }
 
-    # Pair-level hardening using link symmetry (R3) and interface consistency
+    # Resolve status with redundant evidence
     for a_id, b_id in pairs:
-        a = telemetry[a_id]
-        b = telemetry[b_id]
-        a_stat = a.get('interface_status', 'unknown')
-        b_stat = b.get('interface_status', 'unknown')
-        a_rx, a_tx = float(a.get('rx_rate', 0.0)), float(a.get('tx_rate', 0.0))
-        b_rx, b_tx = float(b.get('rx_rate', 0.0)), float(b.get('tx_rate', 0.0))
-        max_traffic = max(a_rx, a_tx, b_rx, b_tx)
-
-        # Resolve interface status consistency across the link
+        a = state[a_id]
+        b = state[b_id]
+        a_stat = a['status']
+        b_stat = b['status']
+        a_rx, a_tx = a['rx'], a['tx']
+        b_rx, b_tx = b['rx'], b['tx']
+        traffic_max = max(a_rx, a_tx, b_rx, b_tx)
+
         if a_stat == b_stat:
-            resolved_status = a_stat
-            status_conf = 0.95 if resolved_status in ('up', 'down') else 0.7
+            resolved = a_stat
+            sconf = 0.95 if resolved in ('up', 'down') else 0.7
         else:
-            # Use traffic evidence: if there is noticeable traffic, link must be up
-            if max_traffic > TRAFFIC_EVIDENCE_MIN:
-                resolved_status = 'up'
-                status_conf = 0.85
+            if traffic_max > TRAFFIC_EVIDENCE_MIN:
+                resolved = 'up'
+                sconf = 0.85
             else:
-                resolved_status = 'down'
-                status_conf = 0.75
-
-        # Apply status to both ends
-        interim[a_id]['status'] = resolved_status
-        interim[b_id]['status'] = resolved_status
-        interim[a_id]['status_conf'] = min(interim[a_id]['status_conf'], status_conf) if interim[a_id]['status_conf'] else status_conf
-        interim[b_id]['status_conf'] = min(interim[b_id]['status_conf'], status_conf) if interim[b_id]['status_conf'] else status_conf
-
-        if resolved_status == 'down':
-            # Down interfaces cannot send or receive
-            # Confidence is high if original values were already near zero, lower otherwise.
-            for ifid, rx0, tx0 in [(a_id, a_rx, a_tx), (b_id, b_rx, b_tx)]:
-                interim[ifid]['rx'] = 0.0
-                interim[ifid]['tx'] = 0.0
-                interim[ifid]['rx_conf'] = clamp(0.9 if rx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
-                interim[ifid]['tx_conf'] = clamp(0.9 if tx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
-            continue  # No need to harden rates if link is down
-
-        # Link is up: harden both directions using symmetry
-        # Forward direction: a.tx should match b.rx
-        d_fwd = rel_diff(a_tx, b_rx)
-        if d_fwd <= HARDENING_THRESHOLD:
-            v = 0.5 * (a_tx + b_rx)
-            conf = clamp(1.0 - 0.5 * d_fwd)  # near 1 when very close
+                resolved = 'down'
+                sconf = 0.75
+
+        for if_id in (a_id, b_id):
+            prev = state[if_id]['status_conf']
+            state[if_id]['status'] = resolved
+            state[if_id]['status_conf'] = min(prev, sconf) if prev is not None else sconf
+
+        if resolved == 'down':
+            for if_id, rxv, txv in [(a_id, a_rx, a_tx), (b_id, b_rx, b_tx)]:
+                state[if_id]['rx'] = 0.0
+                state[if_id]['tx'] = 0.0
+                # no need to set confidences here; final calibration will handle
+
+    # Seed trust from pair agreement
+    seed_tx_conf: Dict[str, float] = {}
+    seed_rx_conf: Dict[str, float] = {}
+    for if_id, r in state.items():
+        peer = peer_of.get(if_id)
+        if peer and state[if_id]['status'] == 'up' and state[peer]['status'] == 'up':
+            res_fwd = rel_diff(state[if_id]['tx'], state[peer]['rx'])
+            res_rev = rel_diff(state[if_id]['rx'], state[peer]['tx'])
+            seed_tx_conf[if_id] = clamp(1.0 - res_fwd)
+            seed_rx_conf[if_id] = clamp(1.0 - res_rev)
         else:
-            # Choose peer's counterpart as stronger signal
-            v = b_rx if abs(b_rx) > 0 else a_tx
-            conf = clamp(1.0 - d_fwd)  # lower confidence for larger violation
-        interim[a_id]['tx'] = v
-        interim[b_id]['rx'] = v
-        interim[a_id]['tx_conf'] = min(interim[a_id]['tx_conf'], conf)
-        interim[b_id]['rx_conf'] = min(interim[b_id]['rx_conf'], conf)
-
-        # Reverse direction: a.rx should match b.tx
-        d_rev = rel_diff(a_rx, b_tx)
-        if d_rev <= HARDENING_THRESHOLD:
-            v2 = 0.5 * (a_rx + b_tx)
-            conf2 = clamp(1.0 - 0.5 * d_rev)
+            seed_tx_conf[if_id] = 0.6
+            seed_rx_conf[if_id] = 0.6
+
+    # Gentle router multiplicative pre-step (bounded), scale less-trusted direction
+    for router, if_list in router_ifaces.items():
+        up_ifaces = [i for i in if_list if state.get(i, {}).get('status') == 'up']
+        if not up_ifaces:
+            continue
+        sum_tx = sum(max(0.0, state[i]['tx']) for i in up_ifaces)
+        sum_rx = sum(max(0.0, state[i]['rx']) for i in up_ifaces)
+        if max(sum_tx, sum_rx) <= EPS:
+            continue
+        avg_tx_trust = sum(seed_tx_conf.get(i, 0.6) for i in up_ifaces) / len(up_ifaces)
+        avg_rx_trust = sum(seed_rx_conf.get(i, 0.6) for i in up_ifaces) / len(up_ifaces)
+        # scale less trusted direction toward balance
+        if avg_tx_trust >= avg_rx_trust and sum_rx > 0.0:
+            s = sum_tx / max(sum_rx, EPS)
+            s_bounded = max(1.0 - PRESTEP_CAP, min(1.0 + PRESTEP_CAP, s ** 0.5))
+            for i in up_ifaces:
+                state[i]['rx'] = max(0.0, state[i]['rx'] * s_bounded)
+        elif avg_rx_trust > avg_tx_trust and sum_tx > 0.0:
+            s = sum_rx / max(sum_tx, EPS)
+            s_bounded = max(1.0 - PRESTEP_CAP, min(1.0 + PRESTEP_CAP, s ** 0.5))
+            for i in up_ifaces:
+                state[i]['tx'] = max(0.0, state[i]['tx'] * s_bounded)
+
+    # Alternating projections: link -> router, repeated
+    for it in range(ITERATIONS):
+        # 1) Link projection (R3)
+        for a_id, b_id in pairs:
+            if state[a_id]['status'] != 'up' or state[b_id]['status'] != 'up':
+                # down links already zero; nothing to do
+                continue
+            # Forward: a.tx <-> b.rx
+            w_a_tx = 0.5 + 0.5 * seed_tx_conf.get(a_id, 0.6)
+            w_b_rx = 0.5 + 0.5 * seed_rx_conf.get(b_id, 0.6)
+            denom = max(w_a_tx + w_b_rx, EPS)
+            v_fwd = (w_a_tx * state[a_id]['tx'] + w_b_rx * state[b_id]['rx']) / denom
+            # Relaxed projection
+            state[a_id]['tx'] = max(0.0, state[a_id]['tx'] + LINK_RELAX * (v_fwd - state[a_id]['tx']))
+            state[b_id]['rx'] = max(0.0, state[b_id]['rx'] + LINK_RELAX * (v_fwd - state[b_id]['rx']))
+
+            # Reverse: a.rx <-> b.tx
+            w_a_rx = 0.5 + 0.5 * seed_rx_conf.get(a_id, 0.6)
+            w_b_tx = 0.5 + 0.5 * seed_tx_conf.get(b_id, 0.6)
+            denom2 = max(w_a_rx + w_b_tx, EPS)
+            v_rev = (w_a_rx * state[a_id]['rx'] + w_b_tx * state[b_id]['tx']) / denom2
+            state[a_id]['rx'] = max(0.0, state[a_id]['rx'] + LINK_RELAX * (v_rev - state[a_id]['rx']))
+            state[b_id]['tx'] = max(0.0, state[b_id]['tx'] + LINK_RELAX * (v_rev - state[b_id]['tx']))
+
+        # 2) Router projection (R1) with exact conservation and non-negativity
+        for router, if_list in router_ifaces.items():
+            up_ifaces = [i for i in if_list if state.get(i, {}).get('status') == 'up']
+            if not up_ifaces:
+                continue
+            # compute imbalance
+            sum_tx = [max(0.0, state[i]['tx']) for i in up_ifaces]
+            sum_rx = [max(0.0, state[i]['rx']) for i in up_ifaces]
+            total_tx = sum(sum_tx)
+            total_rx = sum(sum_rx)
+            if max(total_tx, total_rx) <= EPS:
+                continue
+            B = total_tx - total_rx
+            rel_imb = abs(B) / max(total_tx, total_rx, EPS)
+            tol_r = rate_aware_tol_router(total_tx + total_rx)
+            if rel_imb <= tol_r * 0.5:
+                continue
+
+            # Weights: higher for trusted or near-zero to protect them
+            w_tx = {}
+            w_rx = {}
+            for i in up_ifaces:
+                conf_tx = seed_tx_conf.get(i, 0.6)
+                conf_rx = seed_rx_conf.get(i, 0.6)
+                # Protect near-zero values more (avoid negative)
+                prot_tx = 0.5 if state[i]['tx'] <= 1.0 else 0.0
+                prot_rx = 0.5 if state[i]['rx'] <= 1.0 else 0.0
+                w_tx[i] = 0.5 + 0.5 * conf_tx + prot_tx
+                w_rx[i] = 0.5 + 0.5 * conf_rx + prot_rx
+
+            # Solve min sum w_tx*dx^2 + sum w_rx*dy^2 s.t. sum(dx) - sum(dy) = -B with non-negativity
+            # Iterative clamp-and-recompute
+            active_tx = set(up_ifaces)
+            active_rx = set(up_ifaces)
+            # capacities (lower bounds are -current values)
+            cap_low_tx = {i: -state[i]['tx'] for i in up_ifaces}
+            cap_low_rx = {i: -state[i]['rx'] for i in up_ifaces}
+
+            target = -B
+            for _ in range(20):  # limit iterations
+                denom = 0.0
+                for i in active_tx:
+                    denom += 1.0 / max(w_tx[i], EPS)
+                for i in active_rx:
+                    denom += 1.0 / max(w_rx[i], EPS)
+                if denom <= EPS:
+                    break
+                lam = 2.0 * target / denom
+                # propose deltas
+                dx = {}
+                dy = {}
+                violated = False
+                for i in up_ifaces:
+                    if i in active_tx:
+                        d = -lam / (2.0 * max(w_tx[i], EPS))
+                        if d < cap_low_tx[i] - 1e-12:
+                            d = cap_low_tx[i]
+                            violated = True
+                        dx[i] = d
+                    else:
+                        dx[i] = 0.0
+                    if i in active_rx:
+                        d2 = lam / (2.0 * max(w_rx[i], EPS))
+                        if d2 < cap_low_rx[i] - 1e-12:
+                            d2 = cap_low_rx[i]
+                            violated = True
+                        dy[i] = d2
+                    else:
+                        dy[i] = 0.0
+                # if any violated lower bounds, freeze them and recompute lambda
+                if violated:
+                    for i in up_ifaces:
+                        if i in active_tx and dx[i] <= cap_low_tx[i] + 1e-12:
+                            active_tx.remove(i)
+                            target -= dx[i]
+                        if i in active_rx and dy[i] <= cap_low_rx[i] + 1e-12:
+                            active_rx.remove(i)
+                            target += dy[i]
+                    continue
+                # feasible; apply
+                for i in up_ifaces:
+                    state[i]['tx'] = max(0.0, state[i]['tx'] + dx[i])
+                    state[i]['rx'] = max(0.0, state[i]['rx'] + dy[i])
+                break  # done
+
+    # Final confidence calibration
+    # Compute pair residuals and router residuals after repair
+    router_residuals: Dict[str, float] = {}
+    for router, if_list in router_ifaces.items():
+        up_ifaces = [i for i in if_list if state.get(i, {}).get('status') == 'up']
+        if not up_ifaces:
+            router_residuals[router] = 0.0
+            continue
+        ttx = sum(max(0.0, state[i]['tx']) for i in up_ifaces)
+        trx = sum(max(0.0, state[i]['rx']) for i in up_ifaces)
+        router_residuals[router] = rel_diff(ttx, trx)
+
+    # Assemble output with calibrated confidences
+    result: Dict[str, Dict[str, Tuple]] = {}
+    for if_id, r in state.items():
+        peer = peer_of.get(if_id)
+        resolved_status = r.get('status', 'unknown')
+
+        # Pair components
+        if peer and state.get(peer, {}).get('status') == resolved_status:
+            # Use rate-aware tolerance
+            traffic_pair = max(r['rx'], r['tx'], state[peer]['rx'], state[peer]['tx'])
+            tol_pair = rate_aware_tol_pair(traffic_pair)
+            res_fwd = rel_diff(r['tx'], state[peer]['rx'])
+            res_rev = rel_diff(r['rx'], state[peer]['tx'])
+            pair_conf_tx = logistic_conf(res_fwd, tol_pair)
+            pair_conf_rx = logistic_conf(res_rev, tol_pair)
         else:
-            v2 = b_tx if abs(b_tx) > 0 else a_rx
-            conf2 = clamp(1.0 - d_rev)
-        interim[a_id]['rx'] = v2
-        interim[b_id]['tx'] = v2
-        interim[a_id]['rx_conf'] = min(interim[a_id]['rx_conf'], conf2)
-        interim[b_id]['tx_conf'] = min(interim[b_id]['tx_conf'], conf2)
-
-    # Enforce "down implies zero traffic" also for unpaired interfaces
-    for if_id, r in interim.items():
-        if if_id not in paired_ids and r.get('status') == 'down':
-            rx0 = r['rx']
-            tx0 = r['tx']
-            r['rx'] = 0.0
-            r['tx'] = 0.0
-            r['rx_conf'] = clamp(0.9 if rx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
-            r['tx_conf'] = clamp(0.9 if tx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
-
-    # Router-level dynamic flow conservation (R1)
-    # Build router to interfaces map (use provided topology if available, else derive from telemetry)
-    router_ifaces: Dict[str, List[str]] = {}
-    if topology:
-        router_ifaces = {r: [i for i in if_list if i in interim] for r, if_list in topology.items()}
-    else:
-        # If topology not provided, derive from telemetry metadata
-        # Note: Topology helps flow conservation; we derive a best-effort map when absent.
-        for if_id, data in telemetry.items():
-            r = data.get('local_router')
-            if r is not None:
-                router_ifaces.setdefault(r, []).append(if_id)
-
-    for router, if_list in router_ifaces.items():
-        # Consider only interfaces present in telemetry
-        interfaces = [i for i in if_list if i in interim]
-        if not interfaces:
-            continue
-
-        # Compute sums over "up" interfaces
-        sum_tx = 0.0
-        sum_rx = 0.0
-        tx_conf_acc = 0.0
-        rx_conf_acc = 0.0
-        up_count_tx = 0
-        up_count_rx = 0
-        for i in interfaces:
-            if interim[i]['status'] == 'up':
-                sum_tx += max(0.0, interim[i]['tx'])
-                sum_rx += max(0.0, interim[i]['rx'])
-                tx_conf_acc += interim[i]['tx_conf']
-                rx_conf_acc += interim[i]['rx_conf']
-                up_count_tx += 1
-                up_count_rx += 1
-
-        if up_count_tx == 0 or up_count_rx == 0:
-            continue
-
-        # Evaluate flow imbalance
-        imbalance = rel_diff(sum_tx, sum_rx)
-        if imbalance <= HARDENING_THRESHOLD * 2:
-            # Within tolerance; no router-level scaling needed
-            continue
-
-        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
-        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)
-
-        # Decide which direction to scale: scale the less trusted direction
-        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
-        if scale_rx and sum_rx > 0.0:
-            s = sum_tx / sum_rx
-        elif (not scale_rx) and sum_tx > 0.0:
-            s = sum_rx / sum_tx
-        else:
-            s = 1.0
-
-        # Bound scaling to avoid extreme corrections
-        s_bounded = max(0.5, min(2.0, s))
-
-        # Weighted additive redistribution toward target using lower-trust interfaces more
-        # Prepare per-interface values and weights
-        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
-        if not up_list:
-            continue
-        # Current totals and target delta
-        if scale_rx:
-            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
-            target_total = sum_tx
-        else:
-            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
-            target_total = sum_rx
-        need = target_total - sum_old
-        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
-            # Tiny residual; skip redistribution
-            continue
-
-        # Build weights from direction-specific confidence (lower confidence -> larger weight)
-        weights: Dict[str, float] = {}
-        caps_pos: Dict[str, float] = {}
-        caps_neg: Dict[str, float] = {}
-        values: Dict[str, float] = {}
-        for i in up_list:
-            if scale_rx:
-                conf = float(interim[i]['rx_conf'])
-                v = max(0.0, float(interim[i]['rx']))
-            else:
-                conf = float(interim[i]['tx_conf'])
-                v = max(0.0, float(interim[i]['tx']))
-            w = max(0.05, 1.0 - conf)
-            weights[i] = w
-            cap = MAX_ROUTER_ADJ_FRAC * max(v, 1.0)
-            caps_pos[i] = cap
-            caps_neg[i] = cap
-            values[i] = v
-
-        # Iterative allocation with capacity clipping
-        alloc_passes = 2
-        for _alloc in range(alloc_passes):
-            if abs(need) <= EPS:
-                break
-            # Eligible interfaces based on remaining capacity in needed direction
-            if need > 0:
-                elig = [i for i in up_list if caps_pos[i] > EPS]
-            else:
-                elig = [i for i in up_list if caps_neg[i] > EPS]
-            if not elig:
-                break
-            sumW = sum(weights[i] for i in elig)
-            if sumW <= EPS:
-                break
-            for i in elig:
-                quota = need * (weights[i] / sumW)
-                if need > 0:
-                    d = min(max(0.0, quota), caps_pos[i])
-                    caps_pos[i] -= d
-                else:
-                    d = max(min(0.0, quota), -caps_neg[i])
-                    caps_neg[i] -= -d
-                if abs(d) <= EPS:
-                    continue
-                old_v = values[i]
-                new_v = max(0.0, old_v + d)
-                values[i] = new_v
-                # Confidence drops with global imbalance, scaling magnitude and per-interface change
-                delta_rel = rel_diff(old_v, new_v)
-                if scale_rx:
-                    interim[i]['rx'] = new_v
-                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
-                else:
-                    interim[i]['tx'] = new_v
-                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
-                need -= d
-
-    # Final confidence calibration based on post-repair invariants
-    # Compute per-router imbalance residuals
-    router_final_imbalance: Dict[str, float] = {}
-    for router, if_list in router_ifaces.items():
-        # only consider interfaces that are in interim and up
-        up_ifaces = [i for i in if_list if i in interim and interim[i].get('status') == 'up']
-        if not up_ifaces:
-            router_final_imbalance[router] = 0.0
-            continue
-        sum_tx = sum(max(0.0, interim[i]['tx']) for i in up_ifaces)
-        sum_rx = sum(max(0.0, interim[i]['rx']) for i in up_ifaces)
-        router_final_imbalance[router] = rel_diff(sum_tx, sum_rx)
-
-    # Weights and tolerances for confidence components
-    w_pair, w_router, w_status = 0.6, 0.3, 0.1
-    TOL_PAIR = HARDENING_THRESHOLD * 1.5
-    TOL_ROUTER = HARDENING_THRESHOLD * 2.0
-
-    for if_id, r in interim.items():
+            pair_conf_tx = 0.6
+            pair_conf_rx = 0.6
+
+        # Router component
         router = r.get('local_router')
-        peer = peer_of.get(if_id)
-
-        status_comp = clamp(r.get('status_conf', 0.8))
-        resolved_status = r.get('status', 'unknown')
-
-        if peer and interim.get(peer, {}).get('status') == resolved_status:
-            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
-            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
-            pair_comp_tx = conf_from_residual(res_fwd, TOL_PAIR)
-            pair_comp_rx = conf_from_residual(res_rev, TOL_PAIR)
-        else:
-            pair_comp_tx = 0.55
-            pair_comp_rx = 0.55
-
-        router_imb = router_final_imbalance.get(router, 0.0)
-        router_comp = conf_from_residual(router_imb, TOL_ROUTER)
-
-        base_tx_conf = w_pair * pair_comp_tx + w_router * router_comp + w_status * status_comp
-        base_rx_conf = w_pair * pair_comp_rx + w_router * router_comp + w_status * status_comp
-
-        # Change penalty to discourage overconfidence on large edits
-        delta_tx_rel = rel_diff(r['orig_tx'], r['tx'])
-        delta_rx_rel = rel_diff(r['orig_rx'], r['rx'])
-        pen_tx = max(0.0, delta_tx_rel - HARDENING_THRESHOLD)
-        pen_rx = max(0.0, delta_rx_rel - HARDENING_THRESHOLD)
-        CHANGE_PENALTY_WEIGHT = 0.5
+        total_router = 0.0
+        if router in router_ifaces:
+            for i in router_ifaces[router]:
+                if state.get(i, {}).get('status') == 'up':
+                    total_router += state[i]['tx'] + state[i]['rx']
+        tol_router = rate_aware_tol_router(total_router)
+        router_res = router_residuals.get(router, 0.0)
+        router_conf = logistic_conf(router_res, tol_router)
+
+        # Status component
+        status_conf = clamp(r.get('status_conf', 0.8))
+        if resolved_status == 'up':
+            if r['rx'] <= TRAFFIC_EVIDENCE_MIN and r['tx'] <= TRAFFIC_EVIDENCE_MIN:
+                status_conf = clamp(status_conf * 0.9)
+        elif resolved_status == 'down':
+            # If any traffic remains, lower status confidence
+            if r['rx'] > TRAFFIC_EVIDENCE_MIN or r['tx'] > TRAFFIC_EVIDENCE_MIN:
+                status_conf = clamp(min(status_conf, 0.3))
+
+        # Aggregate
+        w_pair, w_router, w_status = 0.6, 0.3, 0.1
+        base_tx_conf = w_pair * pair_conf_tx + w_router * router_conf + w_status * status_conf
+        base_rx_conf = w_pair * pair_conf_rx + w_router * router_conf + w_status * status_conf
+
+        # Change penalty
+        dtx = rel_diff(state[if_id]['orig_tx'], r['tx'])
+        drx = rel_diff(state[if_id]['orig_rx'], r['rx'])
+        pen_tx = max(0.0, dtx - TAU_H)
+        pen_rx = max(0.0, drx - TAU_H)
         final_tx_conf = clamp(base_tx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_tx))
         final_rx_conf = clamp(base_rx_conf * (1.0 - CHANGE_PENALTY_WEIGHT * pen_rx))
 
+        # Status overrides for down links: trust zeros if already near zero
         if resolved_status == 'down':
-            final_rx_conf = 0.9 if r['orig_rx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
-            final_tx_conf = 0.9 if r['orig_tx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
-
-        r['tx_conf'] = final_tx_conf
-        r['rx_conf'] = final_rx_conf
-
-        # Subtle status calibration: if up but effectively idle, reduce status confidence slightly
-        if resolved_status == 'up':
-            if r['rx'] <= TRAFFIC_EVIDENCE_MIN and r['tx'] <= TRAFFIC_EVIDENCE_MIN:
-                r['status_conf'] = clamp(r['status_conf'] * 0.9)
-        elif resolved_status == 'down':
-            if r['rx'] > TRAFFIC_EVIDENCE_MIN or r['tx'] > TRAFFIC_EVIDENCE_MIN:
-                r['status_conf'] = clamp(min(r['status_conf'], 0.3))
-
-    # Assemble final result with (original, repaired, confidence) tuples and unchanged metadata
-    for if_id, data in telemetry.items():
-        repaired_data: Dict[str, Tuple] = {}
-        r = interim[if_id]
-
-        repaired_data['rx_rate'] = (r['orig_rx'], r['rx'], clamp(r['rx_conf']))
-        repaired_data['tx_rate'] = (r['orig_tx'], r['tx'], clamp(r['tx_conf']))
-        repaired_data['interface_status'] = (r['orig_status'], r['status'], clamp(r['status_conf']))
-
-        # Copy metadata unchanged
-        repaired_data['connected_to'] = r['connected_to']
-        repaired_data['local_router'] = r['local_router']
-        repaired_data['remote_router'] = r['remote_router']
-
-        result[if_id] = repaired_data
+            final_rx_conf = 0.9 if state[if_id]['orig_rx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
+            final_tx_conf = 0.9 if state[if_id]['orig_tx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
+
+        # Package result tuples and copy metadata
+        out: Dict[str, Tuple] = {}
+        out['rx_rate'] = (state[if_id]['orig_rx'], r['rx'], final_rx_conf)
+        out['tx_rate'] = (state[if_id]['orig_tx'], r['tx'], final_tx_conf)
+        out['interface_status'] = (telemetry[if_id].get('interface_status', 'unknown'),
+                                   resolved_status,
+                                   status_conf)
+        out['connected_to'] = r['connected_to']
+        out['local_router'] = r['local_router']
+        out['remote_router'] = r['remote_router']
+        result[if_id] = out
+
+    # For interfaces without peers that remained down, ensure zero rates are enforced
+    for if_id, out in result.items():
+        repaired_status = out['interface_status'][1]
+        if repaired_status == 'down':
+            # Ensure zeros are output (already enforced during status resolution)
+            rx_orig, rx_rep, rx_conf = out['rx_rate']
+            tx_orig, tx_rep, tx_conf = out['tx_rate']
+            out['rx_rate'] = (rx_orig, 0.0, rx_conf)
+            out['tx_rate'] = (tx_orig, 0.0, tx_conf)
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")