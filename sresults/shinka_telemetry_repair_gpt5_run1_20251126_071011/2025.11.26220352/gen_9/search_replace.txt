<NAME>
targeted_router_scaling_and_confidence_tweak
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter accuracy and confidence calibration:

1) Targeted router-level repair: Instead of uniformly scaling all interfaces on a router when flow conservation (R1) is violated, detect the most likely faulty interface using link symmetry residuals (tx_link_diff or rx_link_diff) and adjust only that interface to restore balance. This aligns with the repair strategy that leverages redundancy to identify the faulty signal and minimizes collateral damage to correct counters. If a single targeted adjustment cannot fix the imbalance (e.g., required factor is non-positive), we fall back to uniform scaling. After applying scaling, we recompute the router's post-scaling imbalance and use it for confidence, improving calibration.

2) Confidence calibration for down interfaces: Reduce the base confidence for zeroed-down interfaces slightly from 0.9 to 0.85 to avoid overconfidence and better reflect realistic certainty, improving calibration without harming status accuracy.

These changes preserve the existing logic but enhance precision and calibration through more surgical repairs and more conservative confidence on down interfaces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    for router_id, iface_list in topology.items():
        # Consider only interfaces present in telemetry
        candidate_ifaces = [i for i in iface_list if i in telemetry]
        if not candidate_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        # Active interfaces (local up). Down links already zeroed.
        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
        if not up_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Avoid scaling for tiny volumes or single-link routers
        if (sum_rx + sum_tx) <= 1e-6 or len(up_ifaces) < 2:
            continue

        if imbalance > HARDENING_THRESHOLD:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, EPS)
                for i in up_ifaces:
                    scale_tx[i] = k
            else:
                k = sum_tx / max(sum_rx, EPS)
                for i in up_ifaces:
                    scale_rx[i] = k
=======
    for router_id, iface_list in topology.items():
        # Consider only interfaces present in telemetry
        candidate_ifaces = [i for i in iface_list if i in telemetry]
        if not candidate_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        # Active interfaces (local up). Down links already zeroed.
        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
        if not up_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Avoid scaling for tiny volumes or single-link routers
        if (sum_rx + sum_tx) <= 1e-6 or len(up_ifaces) < 2:
            continue

        if imbalance > HARDENING_THRESHOLD:
            applied_targeted = False
            if sum_tx > sum_rx:
                # Prefer to correct the most suspicious TX interface based on link symmetry residual
                suspects = [i for i in up_ifaces if pre[i]['pre_tx'] > 0.0]
                if suspects:
                    sus = max(suspects, key=lambda i: pre[i]['tx_link_diff'])
                    tx_sus = pre[sus]['pre_tx']
                    # Choose factor to make router TX equal RX after adjusting only the suspect
                    k_sus = (sum_rx - (sum_tx - tx_sus)) / max(tx_sus, EPS)
                    if 0.0 < k_sus < 1.0:
                        scale_tx[sus] = k_sus
                        applied_targeted = True
                if not applied_targeted:
                    # Fallback to uniform scaling of TX if a single-target fix is infeasible
                    k = sum_rx / max(sum_tx, EPS)
                    for i in up_ifaces:
                        scale_tx[i] = k
            else:
                # sum_rx > sum_tx: correct the most suspicious RX interface
                suspects = [i for i in up_ifaces if pre[i]['pre_rx'] > 0.0]
                if suspects:
                    sus = max(suspects, key=lambda i: pre[i]['rx_link_diff'])
                    rx_sus = pre[sus]['pre_rx']
                    k_sus = (sum_tx - (sum_rx - rx_sus)) / max(rx_sus, EPS)
                    if 0.0 < k_sus < 1.0:
                        scale_rx[sus] = k_sus
                        applied_targeted = True
                if not applied_targeted:
                    # Fallback to uniform scaling of RX
                    k = sum_tx / max(sum_rx, EPS)
                    for i in up_ifaces:
                        scale_rx[i] = k

        # Recompute post-scaling imbalance for this router for confidence calibration
        new_sum_rx = sum(pre[i]['pre_rx'] * scale_rx.get(i, 1.0) for i in up_ifaces)
        new_sum_tx = sum(pre[i]['pre_tx'] * scale_tx.get(i, 1.0) for i in up_ifaces)
        new_denom = max(new_sum_rx, new_sum_tx, 1.0)
        router_imbalance[router_id] = abs(new_sum_tx - new_sum_rx) / new_denom
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        elif norm_status(repaired_status) == 'down':
            rx_link_conf = 0.9 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.9 if tx_repaired == 0.0 else 0.5
=======
        elif norm_status(repaired_status) == 'down':
            rx_link_conf = 0.85 if rx_repaired == 0.0 else 0.5
            tx_link_conf = 0.85 if tx_repaired == 0.0 else 0.5
>>>>>>> REPLACE

</DIFF>