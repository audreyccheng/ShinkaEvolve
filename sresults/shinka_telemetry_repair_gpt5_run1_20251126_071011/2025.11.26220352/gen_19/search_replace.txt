<NAME>
pairwise_reconcile_rateaware_confidence
</NAME>

<DESCRIPTION>
I propose three targeted improvements to increase counter repair accuracy and improve confidence calibration while maintaining status accuracy:

1) Rate-aware tolerance: Replace the fixed 2% tolerance with a dynamic tolerance function tol_pair = max(0.02, 5.0 / traffic), where traffic is derived from the compared rates. This prevents over-editing of low-rate links and makes checks stricter for high-rate links, improving both detection and calibration.

2) Limited pairwise reconciliation after router scaling: Router-level scaling can reintroduce asymmetry between connected interfaces. I add a constrained correction pass that pulls each endpoint of a link toward its peer by up to 30% of the residual only when the residual exceeds the rate-aware tolerance. This mitigates drift and reinforces link symmetry without overcorrection.

3) Smoother, calibrated confidence via logistic mapping: Replace the linear 1 - residual mapping with a logistic function relative to the tolerance, conf = 1 / (1 + exp(k*(residual/tol - 1))) with k=3. This yields high confidence within tolerance, moderate confidence near the threshold, and reduced confidence beyond it. I also incorporate a small penalty in confidence when an interface was adjusted during the reconciliation pass, and retain the existing change and router-imbalance penalties.

These changes are minimal and focused: add helper functions, swap tolerance in pre-pass decisions, run a light pairwise reconciliation after router scaling, use post-reconciliation values for confidence, and adjust confidence aggregation. This should increase counter accuracy and confidence calibration without negatively impacting status handling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from typing import Dict, Any, Tuple, List
=======
from typing import Dict, Any, Tuple, List
import math
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom
=======
    # Helpers
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    def pair_tolerance(a: float, b: float) -> float:
        # Rate-aware tolerance: at least HARDENING_THRESHOLD and looser for low traffic (â‰ˆ5 Mbps)
        traffic = max(abs(a), abs(b), 1.0)
        return max(HARDENING_THRESHOLD, 5.0 / traffic)

    def conf_from_residual(residual: float, tol: float, k: float = 3.0) -> float:
        # Logistic decay: 0.5 at residual == tol, higher when within tol, lower beyond
        x = residual / max(tol, 1e-9)
        return 1.0 / (1.0 + math.exp(k * (x - 1.0)))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
                pair_rx_ok = rx_link_diff <= HARDENING_THRESHOLD
                pair_tx_ok = tx_link_diff <= HARDENING_THRESHOLD
=======
                rx_tol = pair_tolerance(rx_orig, peer_tx)
                tx_tol = pair_tolerance(tx_orig, peer_rx)
                pair_rx_ok = rx_link_diff <= rx_tol
                pair_tx_ok = tx_link_diff <= tx_tol
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Assemble final results with calibrated confidence
    result: Dict[str, Dict[str, Tuple]] = {}
=======
    # Build post-scaled values for a reconciliation pass
    post: Dict[str, Dict[str, float]] = {}
    for iface in telemetry:
        post[iface] = {
            'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
            'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
        }

    # Pairwise limited reconciliation to sustain link symmetry after router scaling
    adj_penalty: Dict[str, Dict[str, float]] = {iface: {'rx': 0.0, 'tx': 0.0} for iface in telemetry}
    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        key = tuple(sorted([iface, peer_id]))
        if key in visited_pairs:
            continue
        visited_pairs.add(key)

        # Only reconcile when both local interfaces are up
        if pre[iface]['local_status'] != 'up' or pre[peer_id]['local_status'] != 'up':
            continue

        # Reconcile A.tx <-> B.rx
        a_tx0 = post[iface]['tx']
        b_rx0 = post[peer_id]['rx']
        resid_tx = rel_diff(a_tx0, b_rx0)
        tol_tx = pair_tolerance(a_tx0, b_rx0)
        if resid_tx > tol_tx:
            alpha = 0.3
            a_tx_new = a_tx0 + alpha * (b_rx0 - a_tx0)
            b_rx_new = b_rx0 + alpha * (a_tx0 - b_rx0)
            post[iface]['tx'] = max(0.0, a_tx_new)
            post[peer_id]['rx'] = max(0.0, b_rx_new)
            adj_penalty[iface]['tx'] = max(adj_penalty[iface]['tx'], 0.1)
            adj_penalty[peer_id]['rx'] = max(adj_penalty[peer_id]['rx'], 0.1)

        # Reconcile A.rx <-> B.tx
        a_rx0 = post[iface]['rx']
        b_tx0 = post[peer_id]['tx']
        resid_rx = rel_diff(a_rx0, b_tx0)
        tol_rx = pair_tolerance(a_rx0, b_tx0)
        if resid_rx > tol_rx:
            alpha = 0.3
            a_rx_new = a_rx0 + alpha * (b_tx0 - a_rx0)
            b_tx_new = b_tx0 + alpha * (a_rx0 - b_tx0)
            post[iface]['rx'] = max(0.0, a_rx_new)
            post[peer_id]['tx'] = max(0.0, b_tx_new)
            adj_penalty[iface]['rx'] = max(adj_penalty[iface]['rx'], 0.1)
            adj_penalty[peer_id]['tx'] = max(adj_penalty[peer_id]['tx'], 0.1)

    # Assemble final results with calibrated confidence
    result: Dict[str, Dict[str, Tuple]] = {}
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Apply router scaling
        rx_repaired = pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0)
        tx_repaired = pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0)
=======
        # Apply reconciled post-scaling values
        rx_repaired = post[iface]['rx']
        tx_repaired = post[iface]['tx']
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Confidence components based on post-repair residuals
        peer_id = peers.get(iface)
        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
            peer_tx_after = pre[peer_id]['pre_tx'] * scale_tx.get(peer_id, 1.0)
            peer_rx_after = pre[peer_id]['pre_rx'] * scale_rx.get(peer_id, 1.0)
            rx_resid = rel_diff(rx_repaired, peer_tx_after)
            tx_resid = rel_diff(tx_repaired, peer_rx_after)
            rx_link_conf = max(0.0, 1.0 - rx_resid)
            tx_link_conf = max(0.0, 1.0 - tx_resid)
=======
        # Confidence components based on post-repair residuals
        peer_id = peers.get(iface)
        if had_peer and peer_id in pre and local_status == 'up' and (peer_status == 'up'):
            peer_tx_after = post[peer_id]['tx']
            peer_rx_after = post[peer_id]['rx']
            rx_resid = rel_diff(rx_repaired, peer_tx_after)
            tx_resid = rel_diff(tx_repaired, peer_rx_after)
            rx_tol = pair_tolerance(rx_repaired, peer_tx_after)
            tx_tol = pair_tolerance(tx_repaired, peer_rx_after)
            rx_link_conf = conf_from_residual(rx_resid, rx_tol)
            tx_link_conf = conf_from_residual(tx_resid, tx_tol)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor))
        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor))
=======
        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor * (1.0 - adj_penalty.get(iface, {}).get('rx', 0.0))))
        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor * (1.0 - adj_penalty.get(iface, {}).get('tx', 0.0))))
>>>>>>> REPLACE

</DIFF>