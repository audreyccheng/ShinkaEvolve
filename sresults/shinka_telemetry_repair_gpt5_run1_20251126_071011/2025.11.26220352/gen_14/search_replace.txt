<NAME>
weighted_router_redistribution
</NAME>

<DESCRIPTION>
I propose improving the router-level flow conservation step by replacing the uniform multiplicative scaling with a weighted additive redistribution that adjusts less-trusted interfaces more and caps per-interface adjustments. This change targets counter_repair_accuracy while improving confidence calibration by:
- Using direction-specific confidence to weight adjustments (lower confidence => larger correction).
- Applying per-interface capacity caps to avoid extreme corrections.
- Allocating the total required correction iteratively across eligible interfaces with remaining capacity.

This better leverages redundant signals (pair-based confidences) and the topology (per-router conservation) to repair faulty counters more accurately, without over-adjusting well-aligned interfaces. I also added small constants for numerical stability and adjustment bounds. The rest of the algorithm remains intact, including pair-level symmetry hardening and final confidence calibration based on invariant residuals.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    EPS = 1e-9
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Apply scaling and update confidences
        for i in interfaces:
            if interim[i]['status'] != 'up':
                continue
            if scale_rx:
                old_val = interim[i]['rx']
                interim[i]['rx'] = old_val * s_bounded
                # Confidence drops with imbalance and scaling magnitude
                interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, imbalance + abs(1.0 - s_bounded))))
            else:
                old_val = interim[i]['tx']
                interim[i]['tx'] = old_val * s_bounded
                interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, imbalance + abs(1.0 - s_bounded))))
=======
        # Weighted additive redistribution toward target using lower-trust interfaces more
        # Prepare per-interface values and weights
        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
        if not up_list:
            continue
        # Current totals and target delta
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx
        need = target_total - sum_old
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            # Tiny residual; skip redistribution
            continue

        # Build weights from direction-specific confidence (lower confidence -> larger weight)
        weights: Dict[str, float] = {}
        caps_pos: Dict[str, float] = {}
        caps_neg: Dict[str, float] = {}
        values: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                conf = float(interim[i]['rx_conf'])
                v = max(0.0, float(interim[i]['rx']))
            else:
                conf = float(interim[i]['tx_conf'])
                v = max(0.0, float(interim[i]['tx']))
            w = max(0.05, 1.0 - conf)
            weights[i] = w
            cap = MAX_ROUTER_ADJ_FRAC * max(v, 1.0)
            caps_pos[i] = cap
            caps_neg[i] = cap
            values[i] = v

        # Iterative allocation with capacity clipping
        alloc_passes = 2
        for _alloc in range(alloc_passes):
            if abs(need) <= EPS:
                break
            # Eligible interfaces based on remaining capacity in needed direction
            if need > 0:
                elig = [i for i in up_list if caps_pos[i] > EPS]
            else:
                elig = [i for i in up_list if caps_neg[i] > EPS]
            if not elig:
                break
            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                break
            for i in elig:
                quota = need * (weights[i] / sumW)
                if need > 0:
                    d = min(max(0.0, quota), caps_pos[i])
                    caps_pos[i] -= d
                else:
                    d = max(min(0.0, quota), -caps_neg[i])
                    caps_neg[i] -= -d
                if abs(d) <= EPS:
                    continue
                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                # Confidence drops with global imbalance, scaling magnitude and per-interface change
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
                need -= d
>>>>>>> REPLACE
</DIFF>