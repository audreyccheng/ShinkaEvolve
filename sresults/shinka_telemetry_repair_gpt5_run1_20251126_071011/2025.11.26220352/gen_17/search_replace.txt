<NAME>
bounded_multistep_ramp_and_pair_reconcile
</NAME>

<DESCRIPTION>
I propose three coordinated upgrades that build directly on the Hodor principles and the recommendations:

1) Add a bounded multiplicative pre-step before the existing additive redistribution at each router for the less-trusted direction. We move gently toward the target scale s using s_step = clamp(s_bounded**0.5, 0.85, 1.15), capped per-interface by 15% to remain conservative. This reduces router imbalances faster while preserving stability.

2) Make additive redistribution caps adaptive and ramped across three passes with a per-router total delta cap. We start with 25% capacity, then allow 35%, and finally up to 45% only for low-confidence interfaces or tiny baselines, while enforcing a per-router total delta cap of 25% of the routerâ€™s traffic. This targets edits where data is unreliable and avoids over-correction.

3) Reconcile link symmetry after router redistribution with a limited correction pass. If pair residuals remain above tolerance, we nudge each endpoint 30% toward agreement. We also introduce a smoother logistic confidence mapping and rate-aware pair tolerances in the final confidence calibration. This improves both counter accuracy and confidence calibration by aligning confidence with residuals at realistic rate scales.

These changes are minimal, localized, and consistent with the current structure. They should raise counter accuracy by reducing residuals while maintaining stable, calibrated confidence.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from typing import Dict, Any, Tuple, List
=======
from typing import Dict, Any, Tuple, List
from math import exp
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution
    MAX_ROUTER_ADJ_FRAC = 0.35
    EPS = 1e-9
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Small traffic level used to infer link up when statuses disagree (Mbps)
    TRAFFIC_EVIDENCE_MIN = 0.5
    # Max fractional per-interface adjustment during router redistribution (base cap)
    MAX_ROUTER_ADJ_FRAC = 0.35
    # Gentle multiplicative pre-step per-interface cap
    MULT_PRESTEP_CAP_FRAC = 0.15
    # Ramped per-interface caps across passes
    CAP_RAMP_FRACS = [0.25, 0.35, 0.45]
    # Per-router total delta cap for additive redistribution
    ROUTER_TOTAL_DELTA_FRAC = 0.25
    # Pair reconciliation strength (fraction of residual pulled)
    PAIR_RECONCILE_ALPHA = 0.30
    EPS = 1e-9
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def conf_from_residual(residual: float, tol: float) -> float:
        # Map residual to confidence: 1 at 0 residual, degrades linearly until ~0 near 5*tol
        denom = max(tol * 5.0, 1e-9)
        return clamp(1.0 - residual / denom)
=======
    def conf_from_residual(residual: float, tol: float) -> float:
        # Logistic decay for smoother, better-calibrated confidence
        # residual ~ tol -> ~0.5; residual << tol -> close to 1; residual >> tol -> close to 0
        tol = max(tol, 1e-9)
        x = residual / tol
        k = 3.0
        return clamp(1.0 / (1.0 + exp(k * (x - 1.0))))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    for router, if_list in router_ifaces.items():
        # Consider only interfaces present in telemetry
        interfaces = [i for i in if_list if i in interim]
        if not interfaces:
            continue

        # Compute sums over "up" interfaces
        sum_tx = 0.0
        sum_rx = 0.0
        tx_conf_acc = 0.0
        rx_conf_acc = 0.0
        up_count_tx = 0
        up_count_rx = 0
        for i in interfaces:
            if interim[i]['status'] == 'up':
                sum_tx += max(0.0, interim[i]['tx'])
                sum_rx += max(0.0, interim[i]['rx'])
                tx_conf_acc += interim[i]['tx_conf']
                rx_conf_acc += interim[i]['rx_conf']
                up_count_tx += 1
                up_count_rx += 1

        if up_count_tx == 0 or up_count_rx == 0:
            continue

        # Evaluate flow imbalance
        imbalance = rel_diff(sum_tx, sum_rx)
        if imbalance <= HARDENING_THRESHOLD * 2:
            # Within tolerance; no router-level scaling needed
            continue

        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)

        # Decide which direction to scale: scale the less trusted direction
        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling to avoid extreme corrections
        s_bounded = max(0.5, min(2.0, s))

        # Weighted additive redistribution toward target using lower-trust interfaces more
        # Prepare per-interface values and weights
        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
        if not up_list:
            continue
        # Current totals and target delta
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx
        need = target_total - sum_old
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            # Tiny residual; skip redistribution
            continue

        # Build weights from direction-specific confidence (lower confidence -> larger weight)
        weights: Dict[str, float] = {}
        caps_pos: Dict[str, float] = {}
        caps_neg: Dict[str, float] = {}
        values: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                conf = float(interim[i]['rx_conf'])
                v = max(0.0, float(interim[i]['rx']))
            else:
                conf = float(interim[i]['tx_conf'])
                v = max(0.0, float(interim[i]['tx']))
            w = max(0.05, 1.0 - conf)
            weights[i] = w
            cap = MAX_ROUTER_ADJ_FRAC * max(v, 1.0)
            caps_pos[i] = cap
            caps_neg[i] = cap
            values[i] = v

        # Iterative allocation with capacity clipping
        alloc_passes = 2
        for _alloc in range(alloc_passes):
            if abs(need) <= EPS:
                break
            # Eligible interfaces based on remaining capacity in needed direction
            if need > 0:
                elig = [i for i in up_list if caps_pos[i] > EPS]
            else:
                elig = [i for i in up_list if caps_neg[i] > EPS]
            if not elig:
                break
            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                break
            for i in elig:
                quota = need * (weights[i] / sumW)
                if need > 0:
                    d = min(max(0.0, quota), caps_pos[i])
                    caps_pos[i] -= d
                else:
                    d = max(min(0.0, quota), -caps_neg[i])
                    caps_neg[i] -= -d
                if abs(d) <= EPS:
                    continue
                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                # Confidence drops with global imbalance, scaling magnitude and per-interface change
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'], 1.0 - min(1.0, imbalance + 0.5 * delta_rel + abs(1.0 - s_bounded) * 0.5)))
                need -= d
=======
    for router, if_list in router_ifaces.items():
        # Consider only interfaces present in telemetry
        interfaces = [i for i in if_list if i in interim]
        if not interfaces:
            continue

        # Compute sums over "up" interfaces
        sum_tx = 0.0
        sum_rx = 0.0
        tx_conf_acc = 0.0
        rx_conf_acc = 0.0
        up_count_tx = 0
        up_count_rx = 0
        for i in interfaces:
            if interim[i]['status'] == 'up':
                sum_tx += max(0.0, interim[i]['tx'])
                sum_rx += max(0.0, interim[i]['rx'])
                tx_conf_acc += interim[i]['tx_conf']
                rx_conf_acc += interim[i]['rx_conf']
                up_count_tx += 1
                up_count_rx += 1

        if up_count_tx == 0 or up_count_rx == 0:
            continue

        # Evaluate flow imbalance
        imbalance = rel_diff(sum_tx, sum_rx)
        if imbalance <= HARDENING_THRESHOLD * 2:
            # Within tolerance; no router-level scaling needed
            continue

        avg_tx_conf = tx_conf_acc / max(1, up_count_tx)
        avg_rx_conf = rx_conf_acc / max(1, up_count_rx)

        # Decide which direction to scale: scale the less trusted direction
        scale_rx = avg_tx_conf >= avg_rx_conf  # if TX more trusted, scale RX to match TX
        if scale_rx and sum_rx > 0.0:
            s = sum_tx / sum_rx
        elif (not scale_rx) and sum_tx > 0.0:
            s = sum_rx / sum_tx
        else:
            s = 1.0

        # Bound scaling to avoid extreme corrections
        s_bounded = max(0.5, min(2.0, s))

        # Prepare list of up interfaces and values for the chosen direction
        up_list = [i for i in interfaces if interim[i]['status'] == 'up']
        if not up_list:
            continue

        # Multiplicative pre-step: gentle move toward target scale with per-interface cap
        s_step = max(0.85, min(1.15, s_bounded ** 0.5))
        if abs(1.0 - s_step) > 0.01:
            for i in up_list:
                if scale_rx:
                    old_v = max(0.0, float(interim[i]['rx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['rx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    old_v = max(0.0, float(interim[i]['tx']))
                    delta = old_v * (s_step - 1.0)
                    cap = MULT_PRESTEP_CAP_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    new_v = max(0.0, old_v + delta)
                    interim[i]['tx'] = new_v
                    delta_rel = rel_diff(old_v, new_v)
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, 0.5 * imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))

        # Recompute current totals after multiplicative step
        if scale_rx:
            sum_old = sum(max(0.0, interim[i]['rx']) for i in up_list)
            target_total = sum_tx
        else:
            sum_old = sum(max(0.0, interim[i]['tx']) for i in up_list)
            target_total = sum_rx

        need = target_total - sum_old
        if abs(need) <= max(sum_old, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
            # Tiny residual; skip redistribution
            continue

        # Per-router total delta cap for additive redistribution
        router_total = max(sum_old, target_total, 1.0)
        router_delta_remaining = ROUTER_TOTAL_DELTA_FRAC * router_total

        # Build weights from direction-specific confidence (lower confidence -> larger weight)
        weights: Dict[str, float] = {}
        values: Dict[str, float] = {}
        base_confs: Dict[str, float] = {}
        for i in up_list:
            if scale_rx:
                conf = float(interim[i]['rx_conf'])
                v = max(0.0, float(interim[i]['rx']))
            else:
                conf = float(interim[i]['tx_conf'])
                v = max(0.0, float(interim[i]['tx']))
            w = max(0.05, 1.0 - conf)
            weights[i] = w
            values[i] = v
            base_confs[i] = conf

        # Ramped per-interface caps across passes
        pos_rem: Dict[str, float] = {i: CAP_RAMP_FRACS[0] * max(values[i], 1.0) for i in up_list}
        neg_rem: Dict[str, float] = {i: CAP_RAMP_FRACS[0] * max(values[i], 1.0) for i in up_list}
        inc_pass2: Dict[str, float] = {i: (CAP_RAMP_FRACS[1] - CAP_RAMP_FRACS[0]) * max(values[i], 1.0) for i in up_list}
        inc_pass3: Dict[str, float] = {}
        for i in up_list:
            v0 = values[i]
            conf0 = base_confs[i]
            allow_more = (conf0 < 0.6) or (v0 < 5.0)
            inc_pass3[i] = ((CAP_RAMP_FRACS[2] - CAP_RAMP_FRACS[1]) * max(v0, 1.0)) if allow_more else 0.0

        for pass_idx in range(3):
            if abs(need) <= EPS or router_delta_remaining <= EPS:
                break
            # Increase capacities for this pass
            if pass_idx == 1:
                for i in up_list:
                    pos_rem[i] += inc_pass2[i]
                    neg_rem[i] += inc_pass2[i]
            elif pass_idx == 2:
                for i in up_list:
                    pos_rem[i] += inc_pass3[i]
                    neg_rem[i] += inc_pass3[i]

            # Eligible interfaces based on remaining capacity in needed direction
            if need > 0:
                elig = [i for i in up_list if pos_rem[i] > EPS]
            else:
                elig = [i for i in up_list if neg_rem[i] > EPS]
            if not elig:
                continue

            sumW = sum(weights[i] for i in elig)
            if sumW <= EPS:
                continue

            for i in elig:
                if abs(need) <= EPS or router_delta_remaining <= EPS:
                    break
                quota = need * (weights[i] / sumW)
                if need > 0:
                    d = min(max(0.0, quota), pos_rem[i], router_delta_remaining)
                    pos_rem[i] -= d
                else:
                    d = -min(max(0.0, -quota), neg_rem[i], router_delta_remaining)
                    neg_rem[i] -= -d

                if abs(d) <= EPS:
                    continue

                old_v = values[i]
                new_v = max(0.0, old_v + d)
                values[i] = new_v
                router_delta_remaining -= abs(d)

                # Confidence drops with global imbalance, scaling magnitude and per-interface change
                delta_rel = rel_diff(old_v, new_v)
                if scale_rx:
                    interim[i]['rx'] = new_v
                    interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                else:
                    interim[i]['tx'] = new_v
                    interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                      1.0 - min(1.0, imbalance + 0.5 * delta_rel + 0.5 * abs(1.0 - s_bounded))))
                need -= d
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Final confidence calibration based on post-repair invariants
=======
    # Limited pair-symmetry reconciliation after router redistribution
    for a_id, b_id in pairs:
        if a_id not in interim or b_id not in interim:
            continue
        if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
            continue

        # Forward direction: a.tx vs b.rx
        a_tx_old = interim[a_id]['tx']
        b_rx_old = interim[b_id]['rx']
        res_fwd = rel_diff(a_tx_old, b_rx_old)
        if res_fwd > HARDENING_THRESHOLD:
            v_mid = (a_tx_old + b_rx_old) / 2.0
            a_tx_new = a_tx_old + PAIR_RECONCILE_ALPHA * (v_mid - a_tx_old)
            b_rx_new = b_rx_old + PAIR_RECONCILE_ALPHA * (v_mid - b_rx_old)
            a_tx_new = max(0.0, a_tx_new)
            b_rx_new = max(0.0, b_rx_new)
            if a_tx_new != a_tx_old:
                delta_rel = rel_diff(a_tx_old, a_tx_new)
                interim[a_id]['tx'] = a_tx_new
                interim[a_id]['tx_conf'] = clamp(min(interim[a_id]['tx_conf'], 1.0 - 0.5 * delta_rel))
            if b_rx_new != b_rx_old:
                delta_rel = rel_diff(b_rx_old, b_rx_new)
                interim[b_id]['rx'] = b_rx_new
                interim[b_id]['rx_conf'] = clamp(min(interim[b_id]['rx_conf'], 1.0 - 0.5 * delta_rel))

        # Reverse direction: a.rx vs b.tx
        a_rx_old = interim[a_id]['rx']
        b_tx_old = interim[b_id]['tx']
        res_rev = rel_diff(a_rx_old, b_tx_old)
        if res_rev > HARDENING_THRESHOLD:
            v_mid2 = (a_rx_old + b_tx_old) / 2.0
            a_rx_new = a_rx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - a_rx_old)
            b_tx_new = b_tx_old + PAIR_RECONCILE_ALPHA * (v_mid2 - b_tx_old)
            a_rx_new = max(0.0, a_rx_new)
            b_tx_new = max(0.0, b_tx_new)
            if a_rx_new != a_rx_old:
                delta_rel = rel_diff(a_rx_old, a_rx_new)
                interim[a_id]['rx'] = a_rx_new
                interim[a_id]['rx_conf'] = clamp(min(interim[a_id]['rx_conf'], 1.0 - 0.5 * delta_rel))
            if b_tx_new != b_tx_old:
                delta_rel = rel_diff(b_tx_old, b_tx_new)
                interim[b_id]['tx'] = b_tx_new
                interim[b_id]['tx_conf'] = clamp(min(interim[b_id]['tx_conf'], 1.0 - 0.5 * delta_rel))

    # Final confidence calibration based on post-repair invariants
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Weights and tolerances for confidence components
    w_pair, w_router, w_status = 0.6, 0.3, 0.1
    TOL_PAIR = HARDENING_THRESHOLD * 1.5
    TOL_ROUTER = HARDENING_THRESHOLD * 2.0
=======
    # Weights and tolerances for confidence components
    w_pair, w_router, w_status = 0.6, 0.3, 0.1
    TOL_PAIR = HARDENING_THRESHOLD * 1.5  # kept for backward compatibility; dynamic tol used below
    TOL_ROUTER = HARDENING_THRESHOLD * 2.0
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            pair_comp_tx = conf_from_residual(res_fwd, TOL_PAIR)
            pair_comp_rx = conf_from_residual(res_rev, TOL_PAIR)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
=======
        if peer and interim.get(peer, {}).get('status') == resolved_status:
            res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
            res_rev = rel_diff(r['rx'], interim[peer]['tx'])
            # Rate-aware pair tolerance: relax tolerance on very low rates
            traffic_tx = max(r['tx'], interim[peer]['rx'])
            traffic_rx = max(r['rx'], interim[peer]['tx'])
            tol_pair_tx = max(HARDENING_THRESHOLD, 5.0 / max(traffic_tx, 1.0))
            tol_pair_rx = max(HARDENING_THRESHOLD, 5.0 / max(traffic_rx, 1.0))
            pair_comp_tx = conf_from_residual(res_fwd, tol_pair_tx)
            pair_comp_rx = conf_from_residual(res_rev, tol_pair_rx)
        else:
            pair_comp_tx = 0.55
            pair_comp_rx = 0.55
>>>>>>> REPLACE

</DIFF>