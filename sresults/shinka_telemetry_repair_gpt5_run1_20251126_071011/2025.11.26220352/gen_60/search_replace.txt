<NAME>
bounded_router_scaling_and_partial_pair_reconcile
</NAME>

<DESCRIPTION>
I introduce two targeted improvements inspired by redundancy-based hardening and calibrated reconciliation:

1) Bounded multiplicative router pre-scaling with per-interface caps: Instead of instantly scaling an entire direction to match the other, we compute a bounded router ratio and apply a tempered multiplicative factor only on the less-trusted direction (chosen via pair residuals). Each interface is limited to ±15% change. This improves counter repair accuracy by avoiding overshoot and aligns with flow conservation while respecting measurement jitter.

2) Partial, asymmetrical pair reconciliation with tolerance: Replace hard substitution with a tolerance-gated pull toward midpoint, moving the lower-confidence side more and capping per-move to 20%. This reduces aggressive corrections and yields better calibration.

Additionally, I:
- Add traffic-aware pair tolerance and a clamp helper.
- Track per-interface router deltas and pair adjustments to adjust confidence (penalize heavy edits, small bonus when untouched).
- Recompute router imbalance post-repair for confidence so calibration reflects final state.

These changes follow the Hodor three-step approach (collect, harden, dynamically check) and previous high-performing patterns, improving counter accuracy without hurting status and tightening confidence calibration.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    # Precompute peer mapping
    peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
=======
    def rel_diff(a: float, b: float) -> float:
        a = float(a)
        b = float(b)
        denom = max(abs(a), abs(b), 1.0)
        return abs(a - b) / denom

    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def pair_tolerance(a: float, b: float) -> float:
        # Traffic-aware tolerance to account for timing skew on tiny links
        traffic = max(abs(a), abs(b), 1.0)
        return max(HARDENING_THRESHOLD, 2.5 / traffic)

    # Precompute peer mapping
    peers: Dict[str, str] = {iface: data.get('connected_to') for iface, data in telemetry.items()}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Second pass: router-level flow conservation using topology (R1)
    # Scale only the larger aggregate to match the smaller when imbalance exceeds tolerance.
    scale_rx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
    scale_tx: Dict[str, float] = {iface: 1.0 for iface in telemetry}
    router_imbalance: Dict[str, float] = {}

    for router_id, iface_list in topology.items():
        # Consider only interfaces present in telemetry
        candidate_ifaces = [i for i in iface_list if i in telemetry]
        if not candidate_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        # Active interfaces (local up). Down links already zeroed.
        up_ifaces = [i for i in candidate_ifaces if pre[i]['local_status'] == 'up']
        if not up_ifaces:
            router_imbalance[router_id] = 0.0
            continue

        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Avoid scaling for tiny volumes or single-link routers
        if (sum_rx + sum_tx) <= 1e-6 or len(up_ifaces) < 2:
            continue

        if imbalance > HARDENING_THRESHOLD:
            if sum_tx > sum_rx:
                k = sum_rx / max(sum_tx, EPS)
                for i in up_ifaces:
                    scale_tx[i] = k
            else:
                k = sum_tx / max(sum_rx, EPS)
                for i in up_ifaces:
                    scale_rx[i] = k

    # Third pass: pairwise reconciliation to enforce link symmetry post router scaling
    post: Dict[str, Dict[str, float]] = {}
    for iface in telemetry:
        post[iface] = {
            'rx': pre[iface]['pre_rx'] * scale_rx.get(iface, 1.0),
            'tx': pre[iface]['pre_tx'] * scale_tx.get(iface, 1.0),
        }

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Residuals after router scaling
        resid_tx = rel_diff(post[iface]['tx'], post[peer_id]['rx'])  # A.tx vs B.rx
        resid_rx = rel_diff(post[iface]['rx'], post[peer_id]['tx'])  # A.rx vs B.tx

        def suspicion(ifc: str, kind: str) -> float:
            rid = telemetry.get(ifc, {}).get('local_router')
            imb = router_imbalance.get(rid, 0.0)
            if kind == 'tx':
                return pre[ifc]['tx_link_diff'] + 0.5 * abs(scale_tx.get(ifc, 1.0) - 1.0) + 0.3 * imb
            else:
                return pre[ifc]['rx_link_diff'] + 0.5 * abs(scale_rx.get(ifc, 1.0) - 1.0) + 0.3 * imb

        # Reconcile A.tx <-> B.rx
        if resid_tx > HARDENING_THRESHOLD:
            a_tx_s = suspicion(iface, 'tx')
            b_rx_s = suspicion(peer_id, 'rx')
            if a_tx_s >= b_rx_s:
                post[iface]['tx'] = post[peer_id]['rx']
            else:
                post[peer_id]['rx'] = post[iface]['tx']

        # Reconcile A.rx <-> B.tx
        if resid_rx > HARDENING_THRESHOLD:
            a_rx_s = suspicion(iface, 'rx')
            b_tx_s = suspicion(peer_id, 'tx')
            if a_rx_s >= b_tx_s:
                post[iface]['rx'] = post[peer_id]['tx']
            else:
                post[peer_id]['tx'] = post[iface]['rx']
=======
    # Second pass: router-level flow conservation using topology (R1)
    # Bounded multiplicative pre-step on the less-trusted direction with per-interface caps.
    router_imbalance: Dict[str, float] = {}
    post_router: Dict[str, Dict[str, float]] = {i: {'rx': pre[i]['pre_rx'], 'tx': pre[i]['pre_tx']} for i in telemetry}
    router_delta_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}

    for router_id, iface_list in topology.items():
        # Consider only interfaces present in telemetry and locally up
        up_ifaces = [i for i in iface_list if i in telemetry and pre[i]['local_status'] == 'up']
        if len(up_ifaces) < 2:
            router_imbalance[router_id] = 0.0
            continue

        sum_rx = sum(pre[i]['pre_rx'] for i in up_ifaces)
        sum_tx = sum(pre[i]['pre_tx'] for i in up_ifaces)

        denom = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_tx - sum_rx) / denom
        router_imbalance[router_id] = imbalance

        # Avoid scaling for tiny volumes or minor imbalance
        if (sum_rx + sum_tx) <= 1e-6 or imbalance <= HARDENING_THRESHOLD:
            continue

        # Determine the less-trusted direction via average pair residuals where peers are up
        rx_resids: List[float] = []
        tx_resids: List[float] = []
        for i in up_ifaces:
            peer_id = peers.get(i)
            if peer_id and peer_id in telemetry and pre[peer_id]['local_status'] == 'up':
                # My TX ≈ peer RX; My RX ≈ peer TX
                tx_resids.append(rel_diff(pre[i]['pre_tx'], pre[peer_id]['pre_rx']))
                rx_resids.append(rel_diff(pre[i]['pre_rx'], pre[peer_id]['pre_tx']))

        avg_tx_resid = sum(tx_resids) / len(tx_resids) if tx_resids else None
        avg_rx_resid = sum(rx_resids) / len(rx_resids) if rx_resids else None

        dir_to_scale = None
        if avg_tx_resid is not None and avg_rx_resid is not None:
            if avg_tx_resid > avg_rx_resid + 0.02:
                dir_to_scale = 'tx'
            elif avg_rx_resid > avg_tx_resid + 0.02:
                dir_to_scale = 'rx'
        if dir_to_scale is None:
            dir_to_scale = 'tx' if sum_tx > sum_rx else 'rx'

        # Compute bounded router ratio and tempered factor
        if dir_to_scale == 'tx':
            s = sum_rx / max(sum_tx, EPS)
        else:
            s = sum_tx / max(sum_rx, EPS)
        s_bounded = clamp(s, 0.85, 1.15)
        alpha = clamp(imbalance / 0.15, 0.25, 0.6)
        k = 1.0 + alpha * (s_bounded - 1.0)

        # Apply capped multiplicative scaling on chosen direction
        for i in up_ifaces:
            if dir_to_scale == 'tx':
                old = post_router[i]['tx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['tx'] = max(0.0, new_capped)
                router_delta_rel[i]['tx'] = abs(post_router[i]['tx'] - old) / max(old, 1.0)
            else:
                old = post_router[i]['rx']
                new = old * k
                new_capped = clamp(new, old * 0.85, old * 1.15)
                post_router[i]['rx'] = max(0.0, new_capped)
                router_delta_rel[i]['rx'] = abs(post_router[i]['rx'] - old) / max(old, 1.0)

    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
    pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves (≤ 20% of current value)
            cap_a = 0.2 * max(a_tx, 1.0)
            cap_b = 0.2 * max(b_rx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            cap_a = 0.2 * max(a_rx, 1.0)
            cap_b = 0.2 * max(b_tx, 1.0)
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Router imbalance factor
        router_id = data.get('local_router')
        imbalance = router_imbalance.get(router_id, 0.0)
        router_factor = max(0.2, 1.0 - imbalance)

        # Change penalty: reduce confidence for large corrections from original
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))

        rx_confidence = max(0.0, min(1.0, rx_link_conf * router_factor * rx_change_factor))
        tx_confidence = max(0.0, min(1.0, tx_link_conf * router_factor * tx_change_factor))
=======
        # Recompute router imbalance post-repair for confidence
        # Build per-router sums using final post values
        # Note: computed lazily once; cache on first use
        if 'router_imbalance_post' not in locals():
            router_imbalance_post: Dict[str, float] = {}
            for rid, if_list in topology.items():
                up_ifaces_r = [i for i in if_list if i in telemetry and pre[i]['local_status'] == 'up']
                if not up_ifaces_r:
                    router_imbalance_post[rid] = 0.0
                    continue
                sum_rx_r = sum(post[i]['rx'] for i in up_ifaces_r)
                sum_tx_r = sum(post[i]['tx'] for i in up_ifaces_r)
                denom_r = max(sum_rx_r, sum_tx_r, 1.0)
                router_imbalance_post[rid] = abs(sum_tx_r - sum_rx_r) / denom_r

        router_id = data.get('local_router')
        imb_post = router_imbalance_post.get(router_id, 0.0)
        router_factor = max(0.2, 1.0 - imb_post)

        # Change penalty: reduce confidence for large corrections from original
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        # Taper change penalty slightly for small edits
        rx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - 0.5 * min(1.0, tx_change))

        rx_confidence = rx_link_conf * router_factor * rx_change_factor
        tx_confidence = tx_link_conf * router_factor * tx_change_factor

        # Penalties for heavy router scaling and pair adjustments to improve calibration
        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
        if rdel_rx >= 0.12:
            rx_confidence -= 0.03
        elif rdel_rx >= 0.07:
            rx_confidence -= 0.02
        if rdel_tx >= 0.12:
            tx_confidence -= 0.03
        elif rdel_tx >= 0.07:
            tx_confidence -= 0.02

        padj_rx = 0.0
        padj_tx = 0.0
        if 'pair_adj_rel' in locals():
            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Small bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.02
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.02

        rx_confidence = max(0.0, min(1.0, rx_confidence))
        tx_confidence = max(0.0, min(1.0, tx_confidence))
>>>>>>> REPLACE
</DIFF>