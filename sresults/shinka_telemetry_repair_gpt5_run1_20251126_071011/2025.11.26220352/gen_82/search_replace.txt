<NAME>
iterative_pair_bonus_and_conf_tuning
</NAME>

<DESCRIPTION>
I propose two targeted improvements: (1) strengthen the pairwise reconciliation via up to two micro-iterations per touched link pair with remaining per-direction caps, which reduces residuals more reliably without exceeding budgets; and (2) refine confidence calibration by adding a well-conditioned improvement bonus when both pair residuals drop by at least 50% and the router’s imbalance decreases by at least 30%. Additionally, I slightly increase the large-edit penalty slope from 0.5 to 0.55 to improve calibration under bigger edits. These changes aim to increase counter repair accuracy by better pair alignment and to improve confidence calibration by rewarding genuine improvements while penalizing large edits a bit more.

Key points:
- Micro-iterations strictly respect remaining per-interface caps (20% minus router edits) and stop early on tolerance satisfaction.
- The improvement bonus is gated by both pair-level residual improvement and router-level flow-conservation improvement, reducing overconfidence risk.
- The adjusted penalty slope (0.55) modestly reduces overconfidence for large edits.

These updates preserve the existing use of topology and invariants (link symmetry R3, flow conservation R1) while making the solver more effective and better calibrated.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
    pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
        touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
        if not touched:
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # A.tx ↔ B.rx
        resid_tx = rel_diff(a_tx, b_rx)
        tol_tx = pair_tolerance(a_tx, b_rx)
        if resid_tx > tol_tx:
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint
            if conf_a_tx <= conf_b_rx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_rx - a_tx)
                move_b = alpha_high * (a_tx - b_rx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_rx - a_tx)
                move_b = alpha_low * (a_tx - b_rx)
            # Cap moves using remaining cap (≤ 20% of pre-router value minus router edits)
            base_a = pre[iface]['pre_tx']
            base_b = pre[peer_id]['pre_rx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_tx = max(0.0, a_tx + move_a)
            new_b_rx = max(0.0, b_rx + move_b)
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(new_a_tx - a_tx) / max(a_tx, 1.0))
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(new_b_rx - b_rx) / max(b_rx, 1.0))
            post[iface]['tx'] = new_a_tx
            post[peer_id]['rx'] = new_b_rx

        # A.rx ↔ B.tx
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']
        resid_rx = rel_diff(a_rx, b_tx)
        tol_rx = pair_tolerance(a_rx, b_tx)
        if resid_rx > tol_rx:
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            if conf_a_rx <= conf_b_tx:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_low * (b_tx - a_rx)
                move_b = alpha_high * (a_rx - b_tx)
            else:
                alpha_low, alpha_high = 0.35, 0.20
                move_a = alpha_high * (b_tx - a_rx)
                move_b = alpha_low * (a_rx - b_tx)
            base_a = pre[iface]['pre_rx']
            base_b = pre[peer_id]['pre_tx']
            cap_a = max(0.0, 0.20 * max(base_a, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
            cap_b = max(0.0, 0.20 * max(base_b, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))
            move_a = clamp(move_a, -cap_a, cap_a)
            move_b = clamp(move_b, -cap_b, cap_b)
            new_a_rx = max(0.0, a_rx + move_a)
            new_b_tx = max(0.0, b_tx + move_b)
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(new_a_rx - a_rx) / max(a_rx, 1.0))
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(new_b_tx - b_tx) / max(b_tx, 1.0))
            post[iface]['rx'] = new_a_rx
            post[peer_id]['tx'] = new_b_tx
=======
    # Third pass: tolerance-gated, partial pair reconciliation after router scaling
    post: Dict[str, Dict[str, float]] = {i: {'rx': post_router[i]['rx'], 'tx': post_router[i]['tx']} for i in telemetry}
    pair_adj_rel: Dict[str, Dict[str, float]] = {i: {'rx': 0.0, 'tx': 0.0} for i in telemetry}
    # Track per-interface pair improvement for confidence bonus
    pair_improve: Dict[str, Dict[str, Any]] = {}

    visited_pairs = set()
    for iface, data in telemetry.items():
        peer_id = peers.get(iface)
        if not (peer_id and peer_id in telemetry):
            continue
        pair_key = tuple(sorted([iface, peer_id]))
        if pair_key in visited_pairs:
            continue
        visited_pairs.add(pair_key)

        # Only reconcile when both interfaces are locally up
        if pre[iface]['local_status'] != 'up' or pre.get(peer_id, {}).get('local_status') != 'up':
            continue

        # Only reconcile pairs touched by router edits to preserve calibration bonus on untouched links
        touched = (router_delta_rel.get(iface, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(iface, {}).get('tx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('rx', 0.0) > 0.0 or
                   router_delta_rel.get(peer_id, {}).get('tx', 0.0) > 0.0)
        if not touched:
            continue

        # Residuals after router scaling
        a_rx, a_tx = post[iface]['rx'], post[iface]['tx']
        b_rx, b_tx = post[peer_id]['rx'], post[peer_id]['tx']

        # Record initial residuals for improvement measurement
        resid_tx0 = rel_diff(a_tx, b_rx)
        resid_rx0 = rel_diff(a_rx, b_tx)

        # A.tx ↔ B.rx micro-iterations with remaining caps
        base_a_tx = pre[iface]['pre_tx']
        base_b_rx = pre[peer_id]['pre_rx']
        rem_a_tx = max(0.0, 0.20 * max(base_a_tx, 1.0) - router_delta_abs.get(iface, {}).get('tx', 0.0))
        rem_b_rx = max(0.0, 0.20 * max(base_b_rx, 1.0) - router_delta_abs.get(peer_id, {}).get('rx', 0.0))

        a_tx_init = post[iface]['tx']
        b_rx_init = post[peer_id]['rx']

        for _ in range(2):
            a_tx_cur = post[iface]['tx']
            b_rx_cur = post[peer_id]['rx']
            resid_tx = rel_diff(a_tx_cur, b_rx_cur)
            tol_tx = pair_tolerance(a_tx_cur, b_rx_cur)
            if resid_tx <= tol_tx or (rem_a_tx <= 1e-12 and rem_b_rx <= 1e-12):
                break
            # Confidence proxies from pre-pass diffs (smaller diff => higher confidence)
            conf_a_tx = max(0.0, 1.0 - pre[iface]['tx_link_diff'])
            conf_b_rx = max(0.0, 1.0 - pre[peer_id]['rx_link_diff'])
            # Lower-confidence side moves more toward midpoint; scale with severity
            sev = clamp((resid_tx / max(tol_tx, EPS)) - 1.0, 0.0, 1.0)
            scale = 0.5 + 0.5 * sev
            alpha_low = 0.35 * scale
            alpha_high = 0.20 * scale
            if conf_a_tx <= conf_b_rx:
                desired_move_a = alpha_low * (b_rx_cur - a_tx_cur)
                desired_move_b = alpha_high * (a_tx_cur - b_rx_cur)
            else:
                desired_move_a = alpha_high * (b_rx_cur - a_tx_cur)
                desired_move_b = alpha_low * (a_tx_cur - b_rx_cur)
            # Respect remaining caps
            move_a = clamp(desired_move_a, -rem_a_tx, rem_a_tx)
            move_b = clamp(desired_move_b, -rem_b_rx, rem_b_rx)
            post[iface]['tx'] = max(0.0, a_tx_cur + move_a)
            post[peer_id]['rx'] = max(0.0, b_rx_cur + move_b)
            rem_a_tx = max(0.0, rem_a_tx - abs(move_a))
            rem_b_rx = max(0.0, rem_b_rx - abs(move_b))

        # Record relative adjustments for this direction
        if a_tx_init > 0.0:
            pair_adj_rel[iface]['tx'] = max(pair_adj_rel[iface]['tx'], abs(post[iface]['tx'] - a_tx_init) / max(a_tx_init, 1.0))
        if b_rx_init > 0.0:
            pair_adj_rel[peer_id]['rx'] = max(pair_adj_rel[peer_id]['rx'], abs(post[peer_id]['rx'] - b_rx_init) / max(b_rx_init, 1.0))

        # A.rx ↔ B.tx micro-iterations with remaining caps
        base_a_rx = pre[iface]['pre_rx']
        base_b_tx = pre[peer_id]['pre_tx']
        rem_a_rx = max(0.0, 0.20 * max(base_a_rx, 1.0) - router_delta_abs.get(iface, {}).get('rx', 0.0))
        rem_b_tx = max(0.0, 0.20 * max(base_b_tx, 1.0) - router_delta_abs.get(peer_id, {}).get('tx', 0.0))

        a_rx_init = post[iface]['rx']
        b_tx_init = post[peer_id]['tx']

        for _ in range(2):
            a_rx_cur = post[iface]['rx']
            b_tx_cur = post[peer_id]['tx']
            resid_rx = rel_diff(a_rx_cur, b_tx_cur)
            tol_rx = pair_tolerance(a_rx_cur, b_tx_cur)
            if resid_rx <= tol_rx or (rem_a_rx <= 1e-12 and rem_b_tx <= 1e-12):
                break
            conf_a_rx = max(0.0, 1.0 - pre[iface]['rx_link_diff'])
            conf_b_tx = max(0.0, 1.0 - pre[peer_id]['tx_link_diff'])
            sev2 = clamp((resid_rx / max(tol_rx, EPS)) - 1.0, 0.0, 1.0)
            scale2 = 0.5 + 0.5 * sev2
            alpha_low2 = 0.35 * scale2
            alpha_high2 = 0.20 * scale2
            if conf_a_rx <= conf_b_tx:
                desired_move_a = alpha_low2 * (b_tx_cur - a_rx_cur)
                desired_move_b = alpha_high2 * (a_rx_cur - b_tx_cur)
            else:
                desired_move_a = alpha_high2 * (b_tx_cur - a_rx_cur)
                desired_move_b = alpha_low2 * (a_rx_cur - b_tx_cur)
            move_a = clamp(desired_move_a, -rem_a_rx, rem_a_rx)
            move_b = clamp(desired_move_b, -rem_b_tx, rem_b_tx)
            post[iface]['rx'] = max(0.0, a_rx_cur + move_a)
            post[peer_id]['tx'] = max(0.0, b_tx_cur + move_b)
            rem_a_rx = max(0.0, rem_a_rx - abs(move_a))
            rem_b_tx = max(0.0, rem_b_tx - abs(move_b))

        if a_rx_init > 0.0:
            pair_adj_rel[iface]['rx'] = max(pair_adj_rel[iface]['rx'], abs(post[iface]['rx'] - a_rx_init) / max(a_rx_init, 1.0))
        if b_tx_init > 0.0:
            pair_adj_rel[peer_id]['tx'] = max(pair_adj_rel[peer_id]['tx'], abs(post[peer_id]['tx'] - b_tx_init) / max(b_tx_init, 1.0))

        # Compute final residuals and mark improvements for confidence bonus
        resid_tx1 = rel_diff(post[iface]['tx'], post[peer_id]['rx'])
        resid_rx1 = rel_diff(post[iface]['rx'], post[peer_id]['tx'])
        improved_tx = (resid_tx0 > 0.0) and (resid_tx1 <= 0.5 * resid_tx0)
        improved_rx = (resid_rx0 > 0.0) and (resid_rx1 <= 0.5 * resid_rx0)
        both50 = bool(improved_tx and improved_rx)
        pair_improve[iface] = {'both50': both50}
        pair_improve[peer_id] = {'both50': both50}
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Change penalty: reduce confidence for large corrections from original
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        # Two-slope change penalty: gentler for small edits (<15%)
        rx_weight = 0.4 if rx_change < 0.15 else 0.5
        tx_weight = 0.4 if tx_change < 0.15 else 0.5
        rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
=======
        # Change penalty: reduce confidence for large corrections from original
        rx_change = rel_diff(rx_orig, rx_repaired)
        tx_change = rel_diff(tx_orig, tx_repaired)
        # Two-slope change penalty: gentler for small edits (<15%), harsher for larger edits
        rx_weight = 0.4 if rx_change < 0.15 else 0.55
        tx_weight = 0.4 if tx_change < 0.15 else 0.55
        rx_change_factor = max(0.2, 1.0 - rx_weight * min(1.0, rx_change))
        tx_change_factor = max(0.2, 1.0 - tx_weight * min(1.0, tx_change))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Router scale intensity penalty using bounded ratio (helps calibration)
        s_b = s_bounded_map.get(router_id, 1.0)
        if abs(1.0 - s_b) > 0.25:
            pen = min(0.05, 0.2 * abs(1.0 - s_b))
            rx_confidence -= pen
            tx_confidence -= pen

        # Penalties for heavy router scaling and pair adjustments to improve calibration
        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
        if rdel_rx >= 0.12:
            rx_confidence -= 0.03
        elif rdel_rx >= 0.07:
            rx_confidence -= 0.02
        if rdel_tx >= 0.12:
            tx_confidence -= 0.03
        elif rdel_tx >= 0.07:
            tx_confidence -= 0.02

        padj_rx = 0.0
        padj_tx = 0.0
        if 'pair_adj_rel' in locals():
            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
        cum_cap = 0.35
        thresh = 0.7 * cum_cap
        cum_rx_rel = rdel_rx + padj_rx
        cum_tx_rel = rdel_tx + padj_tx
        if cum_rx_rel > thresh:
            rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
        if cum_tx_rel > thresh:
            tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))

        # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.03
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.03

        rx_confidence = max(0.0, min(1.0, rx_confidence))
        tx_confidence = max(0.0, min(1.0, tx_confidence))
=======
        # Router scale intensity penalty using bounded ratio (helps calibration)
        s_b = s_bounded_map.get(router_id, 1.0)
        if abs(1.0 - s_b) > 0.25:
            pen = min(0.05, 0.2 * abs(1.0 - s_b))
            rx_confidence -= pen
            tx_confidence -= pen

        # Penalties for heavy router scaling and pair adjustments to improve calibration
        rdel_rx = router_delta_rel.get(iface, {}).get('rx', 0.0)
        rdel_tx = router_delta_rel.get(iface, {}).get('tx', 0.0)
        if rdel_rx >= 0.12:
            rx_confidence -= 0.03
        elif rdel_rx >= 0.07:
            rx_confidence -= 0.02
        if rdel_tx >= 0.12:
            tx_confidence -= 0.03
        elif rdel_tx >= 0.07:
            tx_confidence -= 0.02

        padj_rx = 0.0
        padj_tx = 0.0
        if 'pair_adj_rel' in locals():
            padj_rx = pair_adj_rel.get(iface, {}).get('rx', 0.0)
            padj_tx = pair_adj_rel.get(iface, {}).get('tx', 0.0)
        rx_confidence -= min(0.05, 0.25 * padj_rx)
        tx_confidence -= min(0.05, 0.25 * padj_tx)

        # Cumulative cap intensity penalty when consuming >70% of total per-direction budget (15% router + 20% pair)
        cum_cap = 0.35
        thresh = 0.7 * cum_cap
        cum_rx_rel = rdel_rx + padj_rx
        cum_tx_rel = rdel_tx + padj_tx
        if cum_rx_rel > thresh:
            rx_confidence -= min(0.08, 0.76 * (cum_rx_rel - thresh))
        if cum_tx_rel > thresh:
            tx_confidence -= min(0.08, 0.76 * (cum_tx_rel - thresh))

        # Bonus when untouched across passes (no pre change, no router scaling, no pair adjustment)
        if abs(pre[iface]['pre_rx'] - rx_orig) < 1e-9 and rdel_rx == 0.0 and padj_rx == 0.0:
            rx_confidence += 0.03
        if abs(pre[iface]['pre_tx'] - tx_orig) < 1e-9 and rdel_tx == 0.0 and padj_tx == 0.0:
            tx_confidence += 0.03

        # Improvement bonus when pair residuals and router imbalance both improve significantly
        if 'router_imbalance_post' in locals():
            if 'router_improve_frac_map' not in locals():
                router_improve_frac_map = {}
                for rid in topology:
                    before = router_imbalance.get(rid, 0.0)
                    after = router_imbalance_post.get(rid, 0.0)
                    if before <= 0.0:
                        router_improve_frac_map[rid] = 0.0
                    else:
                        router_improve_frac_map[rid] = max(0.0, (before - after) / before)
            if pair_improve.get(iface, {}).get('both50', False) and router_improve_frac_map.get(router_id, 0.0) >= 0.30:
                rx_confidence += 0.04
                tx_confidence += 0.04

        rx_confidence = max(0.0, min(1.0, rx_confidence))
        tx_confidence = max(0.0, min(1.0, tx_confidence))
>>>>>>> REPLACE

</DIFF>