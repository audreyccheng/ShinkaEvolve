<NAME>
elastic_guard_targeted_prestep_and_conf_calibration
</NAME>

<DESCRIPTION>
I propose four targeted improvements to improve counter repair accuracy and confidence calibration:

1) Targeted multiplicative pre-step: Instead of scaling all interfaces in the chosen direction, scale only interfaces in the bottom 40% confidence or with high pair residual. This reduces unnecessary edits.

2) Elastic per-router guard with fairness: Replace the fixed router guard with an elastic guard based on imbalance and trust gap, and reduce the guard when per-direction traffic concentration (HHI) is high to avoid concentrating edits.

3) Pair reconciliation refinements: Use residual-proportional alphas with up to two micro-iterations and enforce a cumulative per-interface budget relative to pre-router values (≤45%), preventing overcorrections.

4) Confidence calibration: Track and penalize high guard usage, and add an improvement bonus when both pair residuals and router imbalance notably decrease. Also record initial router imbalance.

These changes are consistent with the Hodor principles and leverage topology invariants R1 and R3.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Track router scale deviation for confidence penalty
    router_scale_dev: Dict[str, float] = {}
=======
    # Track router scale deviation for confidence penalty
    router_scale_dev: Dict[str, float] = {}
    # Track per-router guard usage fraction and initial imbalance for confidence calibration
    router_guard_used_frac: Dict[str, float] = {}
    router_initial_imbalance: Dict[str, float] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Router-level dynamic flow conservation (R1)
    # Build router to interfaces map (use provided topology if available, else derive from telemetry)
=======
    # Snapshot pre-router counters for cumulative caps in reconciliation
    for _if in interim.keys():
        interim[_if]['pre_router_rx'] = interim[_if]['rx']
        interim[_if]['pre_router_tx'] = interim[_if]['tx']

    # Router-level dynamic flow conservation (R1)
    # Build router to interfaces map (use provided topology if available, else derive from telemetry)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if not up_list:
            router_scale_dev[router] = 0.0
            continue
=======
        if not up_list:
            router_scale_dev[router] = 0.0
            router_guard_used_frac[router] = 0.0
            continue
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        imbalance = rel_diff(sum_tx, sum_rx)
        avg_tx_conf = sum(interim[i]['tx_conf'] for i in up_list) / max(1, len(up_list))
        avg_rx_conf = sum(interim[i]['rx_conf'] for i in up_list) / max(1, len(up_list))
=======
        imbalance = rel_diff(sum_tx, sum_rx)
        # Initialize guard usage fraction and record initial router imbalance for calibration
        router_guard_used_frac[router] = 0.0
        router_initial_imbalance[router] = imbalance
        avg_tx_conf = sum(interim[i]['tx_conf'] for i in up_list) / max(1, len(up_list))
        avg_rx_conf = sum(interim[i]['rx_conf'] for i in up_list) / max(1, len(up_list))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Multiplicative pre-step (imbalance-tuned)
            if scale_rx and sum_rx > 0:
                s_raw = sum_tx / sum_rx
            elif (not scale_rx) and sum_tx > 0:
                s_raw = sum_rx / sum_tx
            else:
                s_raw = 1.0
            s_bounded = max(0.5, min(2.0, s_raw))
            alpha = clamp(imbalance / 0.15, 0.25, 0.6)
            router_scale_dev[router] = abs(1.0 - s_bounded)

            # Apply pre-step with per-interface cap ±15%
            if scale_rx:
                for i in up_list:
                    old_v = max(0.0, float(interim[i]['rx']))
                    target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                    delta = target_v - old_v
                    cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    if abs(delta) > EPS:
                        new_v = max(0.0, old_v + delta)
                        interim[i]['rx'] = new_v
                        interim[i]['touched'] = True
                        # Mild penalty proportional to pre-step delta
                        drel = rel_diff(old_v, new_v)
                        interim[i]['rx_conf'] = clamp(interim[i]['rx_conf'] - 0.1 * drel)
            else:
                for i in up_list:
                    old_v = max(0.0, float(interim[i]['tx']))
                    target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                    delta = target_v - old_v
                    cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    if abs(delta) > EPS:
                        new_v = max(0.0, old_v + delta)
                        interim[i]['tx'] = new_v
                        interim[i]['touched'] = True
                        drel = rel_diff(old_v, new_v)
                        interim[i]['tx_conf'] = clamp(interim[i]['tx_conf'] - 0.1 * drel)
=======
            # Multiplicative pre-step (imbalance-tuned), targeted to low-trust or high-residual ports
            if scale_rx and sum_rx > 0:
                s_raw = sum_tx / sum_rx
            elif (not scale_rx) and sum_tx > 0:
                s_raw = sum_rx / sum_tx
            else:
                s_raw = 1.0
            s_bounded = max(0.5, min(2.0, s_raw))
            alpha = clamp(imbalance / 0.15, 0.25, 0.6)
            router_scale_dev[router] = abs(1.0 - s_bounded)

            if scale_rx:
                # bottom 40% confidence or pair residual > tol are eligible
                dir_confs = [float(interim[x]['rx_conf']) for x in up_list]
                dir_confs_sorted = sorted(dir_confs)
                cut_idx = max(0, min(len(dir_confs_sorted) - 1, int(len(dir_confs_sorted) * 0.4) - 1))
                low_conf_cut = dir_confs_sorted[cut_idx] if dir_confs_sorted else 0.0
                for i in up_list:
                    old_v = max(0.0, float(interim[i]['rx']))
                    resid_i, tol_i = pair_residual_dir(i, 'rx')
                    conf_i = float(interim[i]['rx_conf'])
                    eligible = (conf_i <= low_conf_cut) or (resid_i > tol_i)
                    if not eligible:
                        continue
                    target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                    delta = target_v - old_v
                    cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    if abs(delta) > EPS:
                        new_v = max(0.0, old_v + delta)
                        interim[i]['rx'] = new_v
                        interim[i]['touched'] = True
                        drel = rel_diff(old_v, new_v)
                        interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded))))
            else:
                dir_confs = [float(interim[x]['tx_conf']) for x in up_list]
                dir_confs_sorted = sorted(dir_confs)
                cut_idx = max(0, min(len(dir_confs_sorted) - 1, int(len(dir_confs_sorted) * 0.4) - 1))
                low_conf_cut = dir_confs_sorted[cut_idx] if dir_confs_sorted else 0.0
                for i in up_list:
                    old_v = max(0.0, float(interim[i]['tx']))
                    resid_i, tol_i = pair_residual_dir(i, 'tx')
                    conf_i = float(interim[i]['tx_conf'])
                    eligible = (conf_i <= low_conf_cut) or (resid_i > tol_i)
                    if not eligible:
                        continue
                    target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                    delta = target_v - old_v
                    cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                    delta = max(-cap, min(cap, delta))
                    if abs(delta) > EPS:
                        new_v = max(0.0, old_v + delta)
                        interim[i]['tx'] = new_v
                        interim[i]['touched'] = True
                        drel = rel_diff(old_v, new_v)
                        interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded))))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Router guard budget
            avg_up_traffic = 0.5 * (sum_tx + sum_rx)
            router_guard_budget = ROUTER_TOTAL_DELTA_GUARD * avg_up_traffic
            router_guard_used = 0.0
=======
            # Router guard budget (elastic with fairness)
            avg_tx_conf2 = sum(interim[i]['tx_conf'] for i in up_list) / max(1, len(up_list))
            avg_rx_conf2 = sum(interim[i]['rx_conf'] for i in up_list) / max(1, len(up_list))
            guard_frac = clamp(0.18 + 0.45 * imbalance + 0.30 * abs(avg_tx_conf2 - avg_rx_conf2), 0.18, 0.36)
            avg_up_traffic = 0.5 * (sum_tx + sum_rx)
            # HHI to avoid concentrating moves on a single port
            vals = [max(0.0, interim[i][dir_key]) for i in up_list]
            sum_vals = sum(vals) + EPS
            hhi = sum((v / sum_vals) ** 2 for v in vals) if sum_vals > 0 else 0.0
            if hhi > 0.60:
                guard_frac *= 0.82  # reduce by ~18%
            router_guard_budget = guard_frac * avg_up_traffic
            router_guard_used = 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Update edit magnitude relative to original after router stage
=======
        # Record guard usage for calibration
        if 'router_guard_budget' in locals() and router_guard_budget > 0:
            router_guard_used_frac[router] = router_guard_used / max(router_guard_budget, EPS)
        else:
            router_guard_used_frac[router] = 0.0

        # Update edit magnitude relative to original after router stage
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        def reconcile_dir(val_a: float, conf_a: float, val_b: float, conf_b: float,
                          set_a_key: Tuple[str, str], set_b_key: Tuple[str, str]):
            # set_*_key: (iface_id, field_name 'tx'/'rx')
            traffic = max(val_a, val_b, 1.0)
            tol = max(0.02, 2.5 / traffic)
            resid = rel_diff(val_a, val_b)
            if resid <= tol:
                return
            v_mid = 0.5 * (val_a + val_b)
            # Determine sides: lower-confidence gets stronger pull
            if conf_a <= conf_b:
                alpha_a, alpha_b = PAIR_RECONCILE_ALPHA_LOW, PAIR_RECONCILE_ALPHA_HIGH
            else:
                alpha_a, alpha_b = PAIR_RECONCILE_ALPHA_HIGH, PAIR_RECONCILE_ALPHA_LOW
            # Caps
            cap_a = PAIR_RECONCILE_CAP_FRAC * max(val_a, 1.0)
            cap_b = PAIR_RECONCILE_CAP_FRAC * max(val_b, 1.0)
            move_a = clamp(alpha_a * (v_mid - val_a), -cap_a, cap_a)
            move_b = clamp(alpha_b * (v_mid - val_b), -cap_b, cap_b)
            new_a = max(0.0, val_a + move_a)
            new_b = max(0.0, val_b + move_b)

            # Apply and penalize confidence only on sides that were already edited
            a_id2, field_a = set_a_key
            b_id2, field_b = set_b_key
            if new_a != val_a:
                drel_a = rel_diff(val_a, new_a)
                interim[a_id2][field_a] = new_a
                # Penalize only if side was touched earlier
                if interim[a_id2].get('touched'):
                    interim[a_id2][f'{field_a}_conf'] = clamp(interim[a_id2][f'{field_a}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
                interim[a_id2]['edit_' + field_a + '_rel'] = max(interim[a_id2]['edit_' + field_a + '_rel'], drel_a)
            if new_b != val_b:
                drel_b = rel_diff(val_b, new_b)
                interim[b_id2][field_b] = new_b
                if interim[b_id2].get('touched'):
                    interim[b_id2][f'{field_b}_conf'] = clamp(interim[b_id2][f'{field_b}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
                interim[b_id2]['edit_' + field_b + '_rel'] = max(interim[b_id2]['edit_' + field_b + '_rel'], drel_b)
=======
        def reconcile_dir(val_a: float, conf_a: float, val_b: float, conf_b: float,
                          set_a_key: Tuple[str, str], set_b_key: Tuple[str, str]):
            # set_*_key: (iface_id, field_name 'tx'/'rx')
            # Up to two micro-iterations with residual-proportional alphas and cumulative caps
            a_id2, field_a = set_a_key
            b_id2, field_b = set_b_key
            for _iter in range(2):
                traffic = max(val_a, val_b, 1.0)
                tol = max(0.02, 2.5 / traffic)
                resid = rel_diff(val_a, val_b)
                if resid <= tol:
                    break
                v_mid = 0.5 * (val_a + val_b)
                # Lower-confidence side gets stronger pull; scale by residual/tol
                if conf_a <= conf_b:
                    alpha_a_base, alpha_b_base = PAIR_RECONCILE_ALPHA_LOW, PAIR_RECONCILE_ALPHA_HIGH
                else:
                    alpha_a_base, alpha_b_base = PAIR_RECONCILE_ALPHA_HIGH, PAIR_RECONCILE_ALPHA_LOW
                scale_fac = min(2.0, resid / tol)
                alpha_a = alpha_a_base * scale_fac
                alpha_b = alpha_b_base * scale_fac
                # Per-move caps and remaining cumulative budgets relative to pre-router
                cap_a = PAIR_RECONCILE_CAP_FRAC * max(val_a, 1.0)
                cap_b = PAIR_RECONCILE_CAP_FRAC * max(val_b, 1.0)
                pre_a = interim[a_id2]['pre_router_rx'] if field_a == 'rx' else interim[a_id2]['pre_router_tx']
                pre_b = interim[b_id2]['pre_router_rx'] if field_b == 'rx' else interim[b_id2]['pre_router_tx']
                total_budget_a = 0.45 * max(pre_a, 1.0)
                total_budget_b = 0.45 * max(pre_b, 1.0)
                used_a = abs(interim[a_id2][field_a] - pre_a)
                used_b = abs(interim[b_id2][field_b] - pre_b)
                rem_a = max(0.0, total_budget_a - used_a)
                rem_b = max(0.0, total_budget_b - used_b)

                move_a = clamp(alpha_a * (v_mid - val_a), -cap_a, cap_a)
                move_b = clamp(alpha_b * (v_mid - val_b), -cap_b, cap_b)
                # Enforce remaining cumulative budget
                move_a = max(-rem_a, min(rem_a, move_a))
                move_b = max(-rem_b, min(rem_b, move_b))

                new_a = max(0.0, val_a + move_a)
                new_b = max(0.0, val_b + move_b)

                # Apply and penalize confidence only on sides that were already edited
                if new_a != val_a:
                    drel_a = rel_diff(val_a, new_a)
                    interim[a_id2][field_a] = new_a
                    if interim[a_id2].get('touched'):
                        interim[a_id2][f'{field_a}_conf'] = clamp(interim[a_id2][f'{field_a}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
                    interim[a_id2]['edit_' + field_a + '_rel'] = max(interim[a_id2]['edit_' + field_a + '_rel'], drel_a)
                    val_a = new_a  # update for next iteration
                if new_b != val_b:
                    drel_b = rel_diff(val_b, new_b)
                    interim[b_id2][field_b] = new_b
                    if interim[b_id2].get('touched'):
                        interim[b_id2][f'{field_b}_conf'] = clamp(interim[b_id2][f'{field_b}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
                    interim[b_id2]['edit_' + field_b + '_rel'] = max(interim[b_id2]['edit_' + field_b + '_rel'], drel_b)
                    val_b = new_b
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        final_tx_conf = finalize_conf(base_tx_conf, r.get('edit_tx_rel', 0.0),
                                      cap_used_tx, cap_total_tx,
                                      r['orig_tx'], r['tx'], router_dev, untouched_bonus)
        final_rx_conf = finalize_conf(base_rx_conf, r.get('edit_rx_rel', 0.0),
                                      cap_used_rx, cap_total_rx,
                                      r['orig_rx'], r['rx'], router_dev, untouched_bonus)
=======
        final_tx_conf = finalize_conf(base_tx_conf, r.get('edit_tx_rel', 0.0),
                                      cap_used_tx, cap_total_tx,
                                      r['orig_tx'], r['tx'], router_dev, untouched_bonus)
        final_rx_conf = finalize_conf(base_rx_conf, r.get('edit_rx_rel', 0.0),
                                      cap_used_rx, cap_total_rx,
                                      r['orig_rx'], r['rx'], router_dev, untouched_bonus)

        # Additional guard usage penalty
        guard_used = router_guard_used_frac.get(router, 0.0)
        if guard_used >= 0.9:
            final_tx_conf = clamp(final_tx_conf - 0.05)
            final_rx_conf = clamp(final_rx_conf - 0.05)
        elif guard_used >= 0.75:
            final_tx_conf = clamp(final_tx_conf - 0.03)
            final_rx_conf = clamp(final_rx_conf - 0.03)

        # Improvement bonus: if both pair residuals drop by ≥50% and router imbalance decreases by ≥30%
        peer = peer_of.get(if_id)
        if peer:
            res_fwd_orig = rel_diff(r['orig_tx'], float(telemetry.get(peer, {}).get('rx_rate', 0.0)))
            res_rev_orig = rel_diff(r['orig_rx'], float(telemetry.get(peer, {}).get('tx_rate', 0.0)))
            res_fwd_now = rel_diff(r['tx'], interim.get(peer, {}).get('rx', 0.0))
            res_rev_now = rel_diff(r['rx'], interim.get(peer, {}).get('tx', 0.0))
            improved_pair = False
            if res_fwd_orig > 0 and res_rev_orig > 0:
                improved_pair = ((res_fwd_orig - res_fwd_now) / res_fwd_orig >= 0.5) and ((res_rev_orig - res_rev_now) / res_rev_orig >= 0.5)
        else:
            improved_pair = False
        init_imb = router_initial_imbalance.get(router, 0.0)
        final_imb = router_final_imbalance.get(router, 0.0)
        improved_router = (init_imb > 0 and (init_imb - final_imb) / init_imb >= 0.3)
        if improved_pair and improved_router:
            final_tx_conf = clamp(final_tx_conf + 0.04)
            final_rx_conf = clamp(final_rx_conf + 0.04)
>>>>>>> REPLACE
</DIFF>