--- a/original.py
+++ b/original.py
@@ -1,642 +1,735 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
 Novel improvements:
 - Imbalance-tuned multiplicative pre-step with per-interface caps
 - Adaptive, three-pass additive redistribution with router total-delta guard
 - Enriched weights (uncertainty + pair residual + volume share)
 - Targeted, asymmetrical pair reconciliation only on touched links
 - Refined confidence calibration with scale/cap penalties and tapered change penalty
 """
 from typing import Dict, Any, Tuple, List
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
     Core principle: Use network invariants to validate and repair telemetry:
     1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
     """
 
     # Measurement timing tolerance (Hodor: ~2%)
     HARDENING_THRESHOLD = 0.02
     # Small traffic level used to infer link up when statuses disagree (Mbps)
     TRAFFIC_EVIDENCE_MIN = 0.5
 
     # Router redistribution controls
     PASS_CAPS = [0.25, 0.35, 0.45]  # staged per-interface caps across passes
     ROUTER_TOTAL_DELTA_GUARD = 0.25  # ≤25% of average up-traffic as total router delta
     MAX_MULT_PRE_FRAC = 0.15         # per-interface multiplicative pre-step cap (±15%)
     # Pair reconciliation
     PAIR_RECONCILE_ALPHA_LOW = 0.35
     PAIR_RECONCILE_ALPHA_HIGH = 0.20
     PAIR_RECONCILE_CAP_FRAC = 0.20
     # Confidence/weighting helpers
     TIE_EPS_CONF = 0.05
     TOL_PAIR_BASE = HARDENING_THRESHOLD * 1.5
     TOL_ROUTER = HARDENING_THRESHOLD * 2.0
     EPS = 1e-9
 
     def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
         return max(lo, min(hi, x))
 
     def rel_diff(a: float, b: float) -> float:
         denom = max(abs(a), abs(b), 1e-9)
         return abs(a - b) / denom
 
     def conf_from_residual(residual: float, tol: float) -> float:
         # Two-slope residual-to-confidence:
         # - near 0 residual -> ~1
         # - residual ≈ tol -> ~0.8
         # - large residuals decay faster to avoid overconfidence
         tol = max(tol, 1e-9)
         x = residual / tol
         conf = 1.0 - min(1.0, x / 5.0)
         if x > 3.0:
             conf -= 0.1 * (x - 3.0) / 2.0
         return clamp(conf)
 
     def rate_aware_tol(v: float) -> float:
         # Relax tolerance at low traffic; cap at 12%
         return min(0.12, max(HARDENING_THRESHOLD, 5.0 / max(v, 1.0)))
 
     # Initialize structures
     result: Dict[str, Dict[str, Tuple]] = {}
     interim: Dict[str, Dict[str, Any]] = {}
 
     # Build connected pairs
     visited = set()
     pairs: List[Tuple[str, str]] = []
     for if_id, data in telemetry.items():
         peer = data.get('connected_to')
         if peer and peer in telemetry:
             key = tuple(sorted([if_id, peer]))
             if key not in visited:
                 visited.add(key)
                 pairs.append((key[0], key[1]))
 
     # Map each interface to its peer for quick lookup and record paired IDs
     peer_of: Dict[str, str] = {}
     paired_ids = set()
     for a_id, b_id in pairs:
         peer_of[a_id] = b_id
         peer_of[b_id] = a_id
         paired_ids.add(a_id)
         paired_ids.add(b_id)
 
     # Initialize defaults for all interfaces
     for if_id, data in telemetry.items():
         rx0 = float(data.get('rx_rate', 0.0))
         tx0 = float(data.get('tx_rate', 0.0))
         st0 = data.get('interface_status', 'unknown')
         interim[if_id] = {
             'rx': rx0,
             'tx': tx0,
             'rx_conf': 1.0,
             'tx_conf': 1.0,
             'status': st0,
             'status_conf': 1.0,
             'connected_to': data.get('connected_to'),
             'local_router': data.get('local_router'),
             'remote_router': data.get('remote_router'),
             # Keep originals for output tuples
             'orig_rx': rx0,
             'orig_tx': tx0,
             'orig_status': st0,
             # Edit tracking for confidence calibration
             'edit_rx_rel': 0.0,
             'edit_tx_rel': 0.0,
             'cap_hit_rx': False,
             'cap_hit_tx': False,
             'touched': False,
             # Router-cap tracking (directional)
             'cap_total_rx': 0.0, 'cap_used_rx': 0.0,
             'cap_total_tx': 0.0, 'cap_used_tx': 0.0,
         }
 
     # Pair-level status resolution and hardening (R3 and interface consistency)
     for a_id, b_id in pairs:
         a = telemetry[a_id]; b = telemetry[b_id]
         a_stat = a.get('interface_status', 'unknown')
         b_stat = b.get('interface_status', 'unknown')
         a_rx, a_tx = float(a.get('rx_rate', 0.0)), float(a.get('tx_rate', 0.0))
         b_rx, b_tx = float(b.get('rx_rate', 0.0)), float(b.get('tx_rate', 0.0))
         max_traffic = max(a_rx, a_tx, b_rx, b_tx)
 
         # Resolve interface status consistency across the link
         if a_stat == b_stat:
             resolved_status = a_stat
             status_conf = 0.95 if resolved_status in ('up', 'down') else 0.7
         else:
             if max_traffic > TRAFFIC_EVIDENCE_MIN:
                 resolved_status = 'up'
                 status_conf = 0.85
             else:
                 resolved_status = 'down'
                 status_conf = 0.75
 
         interim[a_id]['status'] = resolved_status
         interim[b_id]['status'] = resolved_status
         interim[a_id]['status_conf'] = min(interim[a_id]['status_conf'], status_conf) if interim[a_id]['status_conf'] else status_conf
         interim[b_id]['status_conf'] = min(interim[b_id]['status_conf'], status_conf) if interim[b_id]['status_conf'] else status_conf
 
         if resolved_status == 'down':
             # Enforce zero traffic on down interfaces
             for ifid, rxv, txv in [(a_id, a_rx, a_tx), (b_id, b_rx, b_tx)]:
                 interim[ifid]['rx'] = 0.0
                 interim[ifid]['tx'] = 0.0
                 interim[ifid]['rx_conf'] = clamp(0.9 if rxv <= TRAFFIC_EVIDENCE_MIN else 0.3)
                 interim[ifid]['tx_conf'] = clamp(0.9 if txv <= TRAFFIC_EVIDENCE_MIN else 0.3)
             continue
 
         # Harden rates using pair symmetry
         # Forward: a.tx should match b.rx
         d_fwd = rel_diff(a_tx, b_rx)
         if d_fwd <= HARDENING_THRESHOLD:
             v = 0.5 * (a_tx + b_rx)
             conf = clamp(1.0 - 0.5 * d_fwd)
         else:
             v = b_rx if b_rx > 0 else a_tx
             conf = clamp(1.0 - d_fwd)
         interim[a_id]['tx'] = v
         interim[b_id]['rx'] = v
         interim[a_id]['tx_conf'] = min(interim[a_id]['tx_conf'], conf)
         interim[b_id]['rx_conf'] = min(interim[b_id]['rx_conf'], conf)
 
         # Reverse: a.rx should match b.tx
         d_rev = rel_diff(a_rx, b_tx)
         if d_rev <= HARDENING_THRESHOLD:
             v2 = 0.5 * (a_rx + b_tx)
             conf2 = clamp(1.0 - 0.5 * d_rev)
         else:
             v2 = b_tx if b_tx > 0 else a_rx
             conf2 = clamp(1.0 - d_rev)
         interim[a_id]['rx'] = v2
         interim[b_id]['tx'] = v2
         interim[a_id]['rx_conf'] = min(interim[a_id]['rx_conf'], conf2)
         interim[b_id]['tx_conf'] = min(interim[b_id]['tx_conf'], conf2)
 
     # Enforce "down implies zero traffic" for unpaired interfaces
     for if_id, r in interim.items():
         if if_id not in paired_ids and r.get('status') == 'down':
             rx0 = r['rx']; tx0 = r['tx']
             r['rx'] = 0.0; r['tx'] = 0.0
             r['rx_conf'] = clamp(0.9 if rx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
             r['tx_conf'] = clamp(0.9 if tx0 <= TRAFFIC_EVIDENCE_MIN else 0.3)
 
+    # Snapshot pre-router counters for cumulative caps in reconciliation
+    for _if in interim.keys():
+        interim[_if]['pre_router_rx'] = interim[_if]['rx']
+        interim[_if]['pre_router_tx'] = interim[_if]['tx']
+
     # Router-level dynamic flow conservation (R1)
     # Build router to interfaces map (use provided topology if available, else derive from telemetry)
     router_ifaces: Dict[str, List[str]] = {}
     if topology:
         router_ifaces = {r: [i for i in if_list if i in interim] for r, if_list in topology.items()}
     else:
         # If topology not provided, derive from telemetry metadata
         for if_id, data in telemetry.items():
             r = data.get('local_router')
             if r is not None:
                 router_ifaces.setdefault(r, []).append(if_id)
 
     # Helper to compute pair residual for a given interface and direction
     def pair_residual_dir(iface_id: str, direction: str) -> Tuple[float, float]:
         peer = peer_of.get(iface_id)
         if not peer or interim.get(peer) is None:
             return 0.0, 1.0  # residual, tol
         if interim[iface_id]['status'] != 'up' or interim[peer]['status'] != 'up':
             return 0.0, 1.0
         if direction == 'rx':
             a = interim[iface_id]['rx']; b = interim[peer]['tx']
         else:
             a = interim[iface_id]['tx']; b = interim[peer]['rx']
         resid = rel_diff(a, b)
         tol = rate_aware_tol(max(a, b, 1.0))
         return resid, tol
 
     # Track router scale deviation for confidence penalty
     router_scale_dev: Dict[str, float] = {}
+    # Track per-router guard usage fraction and initial imbalance for confidence calibration
+    router_guard_used_frac: Dict[str, float] = {}
+    router_initial_imbalance: Dict[str, float] = {}
 
     # Router-level repair
     for router, if_list in router_ifaces.items():
         up_list = [i for i in if_list if interim[i]['status'] == 'up']
         if not up_list:
             router_scale_dev[router] = 0.0
+            router_guard_used_frac[router] = 0.0
             continue
 
         sum_tx = sum(max(0.0, interim[i]['tx']) for i in up_list)
         sum_rx = sum(max(0.0, interim[i]['rx']) for i in up_list)
         imbalance = rel_diff(sum_tx, sum_rx)
+        # Initialize guard usage fraction and record initial router imbalance for calibration
+        router_guard_used_frac[router] = 0.0
+        router_initial_imbalance[router] = imbalance
         avg_tx_conf = sum(interim[i]['tx_conf'] for i in up_list) / max(1, len(up_list))
         avg_rx_conf = sum(interim[i]['rx_conf'] for i in up_list) / max(1, len(up_list))
 
         if imbalance <= HARDENING_THRESHOLD * 2:
             router_scale_dev[router] = 0.0
         else:
             # Decide scaling direction: less-trusted direction; tie-break by larger absolute need
             need_rx = sum_tx - sum_rx  # positive means scale RX up
             need_tx = -need_rx
             if abs(avg_tx_conf - avg_rx_conf) < TIE_EPS_CONF:
                 scale_rx = abs(need_rx) >= abs(need_tx)
             else:
                 scale_rx = avg_tx_conf >= avg_rx_conf
 
-            # Multiplicative pre-step (imbalance-tuned)
+            # Multiplicative pre-step (imbalance-tuned), targeted to low-trust or high-residual ports
             if scale_rx and sum_rx > 0:
                 s_raw = sum_tx / sum_rx
             elif (not scale_rx) and sum_tx > 0:
                 s_raw = sum_rx / sum_tx
             else:
                 s_raw = 1.0
             s_bounded = max(0.5, min(2.0, s_raw))
             alpha = clamp(imbalance / 0.15, 0.25, 0.6)
             router_scale_dev[router] = abs(1.0 - s_bounded)
 
-            # Apply pre-step with per-interface cap ±15%
             if scale_rx:
+                # bottom 40% confidence or pair residual > tol are eligible
+                dir_confs = [float(interim[x]['rx_conf']) for x in up_list]
+                dir_confs_sorted = sorted(dir_confs)
+                cut_idx = max(0, min(len(dir_confs_sorted) - 1, int(len(dir_confs_sorted) * 0.4) - 1))
+                low_conf_cut = dir_confs_sorted[cut_idx] if dir_confs_sorted else 0.0
                 for i in up_list:
                     old_v = max(0.0, float(interim[i]['rx']))
+                    resid_i, tol_i = pair_residual_dir(i, 'rx')
+                    conf_i = float(interim[i]['rx_conf'])
+                    eligible = (conf_i <= low_conf_cut) or (resid_i > tol_i)
+                    if not eligible:
+                        continue
                     target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                     delta = target_v - old_v
                     cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                     delta = max(-cap, min(cap, delta))
                     if abs(delta) > EPS:
                         new_v = max(0.0, old_v + delta)
                         interim[i]['rx'] = new_v
                         interim[i]['touched'] = True
-                        # Mild penalty proportional to pre-step delta
                         drel = rel_diff(old_v, new_v)
-                        interim[i]['rx_conf'] = clamp(interim[i]['rx_conf'] - 0.1 * drel)
+                        interim[i]['rx_conf'] = clamp(min(interim[i]['rx_conf'],
+                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded))))
             else:
+                dir_confs = [float(interim[x]['tx_conf']) for x in up_list]
+                dir_confs_sorted = sorted(dir_confs)
+                cut_idx = max(0, min(len(dir_confs_sorted) - 1, int(len(dir_confs_sorted) * 0.4) - 1))
+                low_conf_cut = dir_confs_sorted[cut_idx] if dir_confs_sorted else 0.0
                 for i in up_list:
                     old_v = max(0.0, float(interim[i]['tx']))
+                    resid_i, tol_i = pair_residual_dir(i, 'tx')
+                    conf_i = float(interim[i]['tx_conf'])
+                    eligible = (conf_i <= low_conf_cut) or (resid_i > tol_i)
+                    if not eligible:
+                        continue
                     target_v = old_v * (1.0 + alpha * (s_bounded - 1.0))
                     delta = target_v - old_v
                     cap = MAX_MULT_PRE_FRAC * max(old_v, 1.0)
                     delta = max(-cap, min(cap, delta))
                     if abs(delta) > EPS:
                         new_v = max(0.0, old_v + delta)
                         interim[i]['tx'] = new_v
                         interim[i]['touched'] = True
                         drel = rel_diff(old_v, new_v)
-                        interim[i]['tx_conf'] = clamp(interim[i]['tx_conf'] - 0.1 * drel)
+                        interim[i]['tx_conf'] = clamp(min(interim[i]['tx_conf'],
+                                                          1.0 - min(1.0, 0.5 * imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded))))
 
             # Recompute after pre-step
             sum_tx = sum(max(0.0, interim[i]['tx']) for i in up_list)
             sum_rx = sum(max(0.0, interim[i]['rx']) for i in up_list)
 
             # Adaptive additive redistribution with router delta guard and staged caps
             if scale_rx:
                 dir_key = 'rx'
                 target_total = sum_tx
             else:
                 dir_key = 'tx'
                 target_total = sum_rx
 
             # Base values at start of pass 1 for cap accounting
             base_v = {i: max(0.0, interim[i][dir_key]) for i in up_list}
             # Precompute total caps across passes per-interface
             cap_total: Dict[str, float] = {i: PASS_CAPS[-1] * max(base_v[i], 1.0) for i in up_list}
             cap_used: Dict[str, float] = {i: 0.0 for i in up_list}
             # Track cap fields in interim for confidence penalties
             for i in up_list:
                 if dir_key == 'rx':
                     interim[i]['cap_total_rx'] = cap_total[i]
                 else:
                     interim[i]['cap_total_tx'] = cap_total[i]
 
-            # Router guard budget
+            # Router guard budget (elastic with fairness)
+            avg_tx_conf2 = sum(interim[i]['tx_conf'] for i in up_list) / max(1, len(up_list))
+            avg_rx_conf2 = sum(interim[i]['rx_conf'] for i in up_list) / max(1, len(up_list))
+            guard_frac = clamp(0.18 + 0.45 * imbalance + 0.30 * abs(avg_tx_conf2 - avg_rx_conf2), 0.18, 0.36)
             avg_up_traffic = 0.5 * (sum_tx + sum_rx)
-            router_guard_budget = ROUTER_TOTAL_DELTA_GUARD * avg_up_traffic
+            # HHI to avoid concentrating moves on a single port
+            vals = [max(0.0, interim[i][dir_key]) for i in up_list]
+            sum_vals = sum(vals) + EPS
+            hhi = sum((v / sum_vals) ** 2 for v in vals) if sum_vals > 0 else 0.0
+            if hhi > 0.60:
+                guard_frac *= 0.82  # reduce by ~18%
+            router_guard_budget = guard_frac * avg_up_traffic
             router_guard_used = 0.0
 
             # Recompute need each pass and allocate
             for pidx, cap_frac in enumerate(PASS_CAPS):
                 # Compute need based on current values
                 cur_sum = sum(max(0.0, interim[i][dir_key]) for i in up_list)
                 need = target_total - cur_sum
                 if abs(need) <= max(cur_sum, target_total, 1.0) * (HARDENING_THRESHOLD * 0.5):
                     break
                 if router_guard_used >= router_guard_budget - EPS:
                     break
 
                 # Build weights with uncertainty, pair residuals, volume share
                 sum_v = cur_sum + EPS
                 weights: Dict[str, float] = {}
                 caps_pos: Dict[str, float] = {}
                 caps_neg: Dict[str, float] = {}
                 # Compute remaining cap per-if in this pass and eligibility
                 elig_candidates: List[str] = []
                 for i in up_list:
                     conf = float(interim[i][f'{dir_key}_conf'])
                     v = max(0.0, interim[i][dir_key])
                     resid, tol_pair = pair_residual_dir(i, dir_key)
                     pr_term = min(2.0, resid / max(tol_pair, 1e-9))
                     w = 0.6 * (1.0 - conf) + 0.25 * pr_term + 0.15 * (v / sum_v)
                     if v < 1.0:
                         w *= 0.5
                     # Cap for this pass relative to base
                     pass_cap = cap_frac * max(base_v[i], 1.0) - cap_used[i]
                     pass_cap = max(0.0, pass_cap)
                     # Reduce weight in later passes if heavy prior usage
                     if pidx > 0 and cap_total[i] > 0 and cap_used[i] >= 0.7 * cap_total[i]:
                         w *= 0.7
                     weights[i] = max(0.02, w)
                     caps_pos[i] = pass_cap
                     caps_neg[i] = pass_cap
                     if pass_cap > EPS:
                         elig_candidates.append(i)
 
                 if not elig_candidates:
                     continue
 
                 # Freeze interfaces with >80% total cap used unless no other capacity remains
                 elig = [i for i in elig_candidates if not (cap_total[i] > 0 and cap_used[i] >= 0.8 * cap_total[i])]
                 if not elig:
                     elig = elig_candidates  # fallback if all frozen
 
                 # Two rounds of allocation per pass
                 for _round in range(2):
                     if abs(need) <= EPS or router_guard_used >= router_guard_budget - EPS:
                         break
                     if need > 0:
                         elig_round = [i for i in elig if caps_pos[i] > EPS]
                     else:
                         elig_round = [i for i in elig if caps_neg[i] > EPS]
                     if not elig_round:
                         break
                     sumW = sum(weights[i] for i in elig_round) + EPS
                     for i in elig_round:
                         if abs(need) <= EPS or router_guard_used >= router_guard_budget - EPS:
                             break
                         quota = need * (weights[i] / sumW)
                         if need > 0:
                             d = min(max(0.0, quota), caps_pos[i], router_guard_budget - router_guard_used)
                             caps_pos[i] -= d
                         else:
                             d = -min(max(0.0, -quota), caps_neg[i], router_guard_budget - router_guard_used)
                             caps_neg[i] -= -d
                         if abs(d) <= EPS:
                             continue
                         old_v = max(0.0, interim[i][dir_key])
                         new_v = max(0.0, old_v + d)
                         interim[i][dir_key] = new_v
                         need -= d
                         router_guard_used += abs(d)
                         cap_used[i] += abs(d)
 
                         # Confidence penalty proportional to relative change
                         drel = rel_diff(old_v, new_v)
                         interim[i][f'{dir_key}_conf'] = clamp(
                             min(interim[i][f'{dir_key}_conf'], 1.0 - min(1.0, imbalance + 0.5 * drel + 0.5 * abs(1.0 - s_bounded)))
                         )
                         interim[i]['touched'] = True
                         # Track cap hits
                         if (need > 0 and caps_pos[i] <= EPS) or (need < 0 and caps_neg[i] <= EPS):
                             if dir_key == 'rx':
                                 interim[i]['cap_hit_rx'] = True
                             else:
                                 interim[i]['cap_hit_tx'] = True
 
                 # Store cap usage for penalties
                 for i in up_list:
                     if dir_key == 'rx':
                         interim[i]['cap_used_rx'] = cap_used[i]
                     else:
                         interim[i]['cap_used_tx'] = cap_used[i]
 
+        # Record guard usage for calibration
+        if 'router_guard_budget' in locals() and router_guard_budget > 0:
+            router_guard_used_frac[router] = router_guard_used / max(router_guard_budget, EPS)
+        else:
+            router_guard_used_frac[router] = 0.0
+
         # Update edit magnitude relative to original after router stage
         for i in up_list:
             interim[i]['edit_tx_rel'] = max(interim[i]['edit_tx_rel'], rel_diff(interim[i]['orig_tx'], interim[i]['tx']))
             interim[i]['edit_rx_rel'] = max(interim[i]['edit_rx_rel'], rel_diff(interim[i]['orig_rx'], interim[i]['rx']))
 
     # Targeted, asymmetrical pair reconciliation only on links touched by router edits
     for a_id, b_id in pairs:
         if interim[a_id].get('status') != 'up' or interim[b_id].get('status') != 'up':
             continue
         # Only reconcile if either side was touched by router redistribution
         if not (interim[a_id].get('touched') or interim[b_id].get('touched')):
             continue
 
         # Helper to apply asymmetrical move with caps and penalties
         def reconcile_dir(val_a: float, conf_a: float, val_b: float, conf_b: float,
                           set_a_key: Tuple[str, str], set_b_key: Tuple[str, str]):
             # set_*_key: (iface_id, field_name 'tx'/'rx')
-            traffic = max(val_a, val_b, 1.0)
-            tol = max(0.02, 2.5 / traffic)
-            resid = rel_diff(val_a, val_b)
-            if resid <= tol:
-                return
-            v_mid = 0.5 * (val_a + val_b)
-            # Determine sides: lower-confidence gets stronger pull
-            if conf_a <= conf_b:
-                alpha_a, alpha_b = PAIR_RECONCILE_ALPHA_LOW, PAIR_RECONCILE_ALPHA_HIGH
-            else:
-                alpha_a, alpha_b = PAIR_RECONCILE_ALPHA_HIGH, PAIR_RECONCILE_ALPHA_LOW
-            # Caps
-            cap_a = PAIR_RECONCILE_CAP_FRAC * max(val_a, 1.0)
-            cap_b = PAIR_RECONCILE_CAP_FRAC * max(val_b, 1.0)
-            move_a = clamp(alpha_a * (v_mid - val_a), -cap_a, cap_a)
-            move_b = clamp(alpha_b * (v_mid - val_b), -cap_b, cap_b)
-            new_a = max(0.0, val_a + move_a)
-            new_b = max(0.0, val_b + move_b)
-
-            # Apply and penalize confidence only on sides that were already edited
+            # Up to two micro-iterations with residual-proportional alphas and cumulative caps
             a_id2, field_a = set_a_key
             b_id2, field_b = set_b_key
-            if new_a != val_a:
-                drel_a = rel_diff(val_a, new_a)
-                interim[a_id2][field_a] = new_a
-                # Penalize only if side was touched earlier
-                if interim[a_id2].get('touched'):
-                    interim[a_id2][f'{field_a}_conf'] = clamp(interim[a_id2][f'{field_a}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
-                interim[a_id2]['edit_' + field_a + '_rel'] = max(interim[a_id2]['edit_' + field_a + '_rel'], drel_a)
-            if new_b != val_b:
-                drel_b = rel_diff(val_b, new_b)
-                interim[b_id2][field_b] = new_b
-                if interim[b_id2].get('touched'):
-                    interim[b_id2][f'{field_b}_conf'] = clamp(interim[b_id2][f'{field_b}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
-                interim[b_id2]['edit_' + field_b + '_rel'] = max(interim[b_id2]['edit_' + field_b + '_rel'], drel_b)
+            for _iter in range(2):
+                traffic = max(val_a, val_b, 1.0)
+                tol = max(0.02, 2.5 / traffic)
+                resid = rel_diff(val_a, val_b)
+                if resid <= tol:
+                    break
+                v_mid = 0.5 * (val_a + val_b)
+                # Lower-confidence side gets stronger pull; scale by residual/tol
+                if conf_a <= conf_b:
+                    alpha_a_base, alpha_b_base = PAIR_RECONCILE_ALPHA_LOW, PAIR_RECONCILE_ALPHA_HIGH
+                else:
+                    alpha_a_base, alpha_b_base = PAIR_RECONCILE_ALPHA_HIGH, PAIR_RECONCILE_ALPHA_LOW
+                scale_fac = min(2.0, resid / tol)
+                alpha_a = alpha_a_base * scale_fac
+                alpha_b = alpha_b_base * scale_fac
+                # Per-move caps and remaining cumulative budgets relative to pre-router
+                cap_a = PAIR_RECONCILE_CAP_FRAC * max(val_a, 1.0)
+                cap_b = PAIR_RECONCILE_CAP_FRAC * max(val_b, 1.0)
+                pre_a = interim[a_id2]['pre_router_rx'] if field_a == 'rx' else interim[a_id2]['pre_router_tx']
+                pre_b = interim[b_id2]['pre_router_rx'] if field_b == 'rx' else interim[b_id2]['pre_router_tx']
+                total_budget_a = 0.45 * max(pre_a, 1.0)
+                total_budget_b = 0.45 * max(pre_b, 1.0)
+                used_a = abs(interim[a_id2][field_a] - pre_a)
+                used_b = abs(interim[b_id2][field_b] - pre_b)
+                rem_a = max(0.0, total_budget_a - used_a)
+                rem_b = max(0.0, total_budget_b - used_b)
+
+                move_a = clamp(alpha_a * (v_mid - val_a), -cap_a, cap_a)
+                move_b = clamp(alpha_b * (v_mid - val_b), -cap_b, cap_b)
+                # Enforce remaining cumulative budget
+                move_a = max(-rem_a, min(rem_a, move_a))
+                move_b = max(-rem_b, min(rem_b, move_b))
+
+                new_a = max(0.0, val_a + move_a)
+                new_b = max(0.0, val_b + move_b)
+
+                # Apply and penalize confidence only on sides that were already edited
+                if new_a != val_a:
+                    drel_a = rel_diff(val_a, new_a)
+                    interim[a_id2][field_a] = new_a
+                    if interim[a_id2].get('touched'):
+                        interim[a_id2][f'{field_a}_conf'] = clamp(interim[a_id2][f'{field_a}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
+                    interim[a_id2]['edit_' + field_a + '_rel'] = max(interim[a_id2]['edit_' + field_a + '_rel'], drel_a)
+                    val_a = new_a  # update for next iteration
+                if new_b != val_b:
+                    drel_b = rel_diff(val_b, new_b)
+                    interim[b_id2][field_b] = new_b
+                    if interim[b_id2].get('touched'):
+                        interim[b_id2][f'{field_b}_conf'] = clamp(interim[b_id2][f'{field_b}_conf'] * (1.0 - 0.3 * min(1.0, resid / tol)))
+                    interim[b_id2]['edit_' + field_b + '_rel'] = max(interim[b_id2]['edit_' + field_b + '_rel'], drel_b)
+                    val_b = new_b
 
         # Forward: a.tx vs b.rx
         reconcile_dir(interim[a_id]['tx'], interim[a_id]['tx_conf'],
                       interim[b_id]['rx'], interim[b_id]['rx_conf'],
                       (a_id, 'tx'), (b_id, 'rx'))
         # Reverse: a.rx vs b.tx
         reconcile_dir(interim[a_id]['rx'], interim[a_id]['rx_conf'],
                       interim[b_id]['tx'], interim[b_id]['tx_conf'],
                       (a_id, 'rx'), (b_id, 'tx'))
 
     # Final confidence calibration based on post-repair invariants
     # Compute per-router imbalance residuals
     router_final_imbalance: Dict[str, float] = {}
     for router, if_list in router_ifaces.items():
         up_ifaces = [i for i in if_list if i in interim and interim[i].get('status') == 'up']
         if not up_ifaces:
             router_final_imbalance[router] = 0.0
             continue
         sum_tx = sum(max(0.0, interim[i]['tx']) for i in up_ifaces)
         sum_rx = sum(max(0.0, interim[i]['rx']) for i in up_ifaces)
         router_final_imbalance[router] = rel_diff(sum_tx, sum_rx)
 
     # Weights for confidence components
     w_pair, w_router, w_status = 0.6, 0.3, 0.1
 
     def finalize_conf(base: float, edit_rel: float, cap_used: float, cap_total: float,
                       orig_val: float, new_val: float, router_dev: float, untouched_bonus: bool) -> float:
         # Tapered change penalty: milder for small edits
         if edit_rel < 0.15:
             w_change = 0.4
         else:
             w_change = 0.5
         pen_factor = max(0.0, 1.0 - w_change * max(0.0, edit_rel - HARDENING_THRESHOLD))
         conf = clamp(base * pen_factor)
 
         # Router scale penalty when pre-step deviation was large
         if router_dev > 0.25:
             # subtract 0.03..0.05 depending on severity
             extra = clamp((router_dev - 0.25) / 0.75, 0.0, 1.0)  # 0..1 scale
             conf = clamp(conf - (0.03 + 0.02 * extra))
 
         # Cap usage penalty up to 0.08 when >70% of total cap consumed
         cap_pen = 0.0
         if cap_total > 0:
             frac = cap_used / cap_total
             if frac > 0.7:
                 cap_pen = clamp(0.08 * ((frac - 0.7) / 0.3), 0.0, 0.08)
         conf = clamp(conf - cap_pen)
 
         # No-edit/untouched bonus
         if rel_diff(orig_val, new_val) <= 1e-3:
             conf = clamp(conf + 0.05)
         if untouched_bonus:
             conf = clamp(conf + 0.03)
 
         return clamp(conf)
 
     for if_id, r in interim.items():
         router = r.get('local_router')
         peer = peer_of.get(if_id)
         status_comp = clamp(r.get('status_conf', 0.8))
         resolved_status = r.get('status', 'unknown')
 
         if peer and interim.get(peer, {}).get('status') == resolved_status:
             res_fwd = rel_diff(r['tx'], interim[peer]['rx'])
             res_rev = rel_diff(r['rx'], interim[peer]['tx'])
             tol_pair_tx = rate_aware_tol(max(r['tx'], interim[peer]['rx'], 1.0))
             tol_pair_rx = rate_aware_tol(max(r['rx'], interim[peer]['tx'], 1.0))
             pair_comp_tx = conf_from_residual(res_fwd, tol_pair_tx)
             pair_comp_rx = conf_from_residual(res_rev, tol_pair_rx)
         else:
             pair_comp_tx = 0.55
             pair_comp_rx = 0.55
 
         router_imb = router_final_imbalance.get(router, 0.0)
         router_comp = conf_from_residual(router_imb, TOL_ROUTER)
 
         base_tx_conf = w_pair * pair_comp_tx + w_router * router_comp + w_status * status_comp
         base_rx_conf = w_pair * pair_comp_rx + w_router * router_comp + w_status * status_comp
 
         # Determine per-direction cap usage for penalties
         cap_used_tx = r.get('cap_used_tx', 0.0)
         cap_total_tx = r.get('cap_total_tx', 0.0)
         cap_used_rx = r.get('cap_used_rx', 0.0)
         cap_total_rx = r.get('cap_total_rx', 0.0)
 
         router_dev = router_scale_dev.get(router, 0.0)
         untouched_bonus = not r.get('touched', False)
 
         final_tx_conf = finalize_conf(base_tx_conf, r.get('edit_tx_rel', 0.0),
                                       cap_used_tx, cap_total_tx,
                                       r['orig_tx'], r['tx'], router_dev, untouched_bonus)
         final_rx_conf = finalize_conf(base_rx_conf, r.get('edit_rx_rel', 0.0),
                                       cap_used_rx, cap_total_rx,
                                       r['orig_rx'], r['rx'], router_dev, untouched_bonus)
+
+        # Additional guard usage penalty
+        guard_used = router_guard_used_frac.get(router, 0.0)
+        if guard_used >= 0.9:
+            final_tx_conf = clamp(final_tx_conf - 0.05)
+            final_rx_conf = clamp(final_rx_conf - 0.05)
+        elif guard_used >= 0.75:
+            final_tx_conf = clamp(final_tx_conf - 0.03)
+            final_rx_conf = clamp(final_rx_conf - 0.03)
+
+        # Improvement bonus: if both pair residuals drop by ≥50% and router imbalance decreases by ≥30%
+        peer = peer_of.get(if_id)
+        if peer:
+            res_fwd_orig = rel_diff(r['orig_tx'], float(telemetry.get(peer, {}).get('rx_rate', 0.0)))
+            res_rev_orig = rel_diff(r['orig_rx'], float(telemetry.get(peer, {}).get('tx_rate', 0.0)))
+            res_fwd_now = rel_diff(r['tx'], interim.get(peer, {}).get('rx', 0.0))
+            res_rev_now = rel_diff(r['rx'], interim.get(peer, {}).get('tx', 0.0))
+            improved_pair = False
+            if res_fwd_orig > 0 and res_rev_orig > 0:
+                improved_pair = ((res_fwd_orig - res_fwd_now) / res_fwd_orig >= 0.5) and ((res_rev_orig - res_rev_now) / res_rev_orig >= 0.5)
+        else:
+            improved_pair = False
+        init_imb = router_initial_imbalance.get(router, 0.0)
+        final_imb = router_final_imbalance.get(router, 0.0)
+        improved_router = (init_imb > 0 and (init_imb - final_imb) / init_imb >= 0.3)
+        if improved_pair and improved_router:
+            final_tx_conf = clamp(final_tx_conf + 0.04)
+            final_rx_conf = clamp(final_rx_conf + 0.04)
 
         if resolved_status == 'down':
             final_rx_conf = 0.9 if r['orig_rx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
             final_tx_conf = 0.9 if r['orig_tx'] <= TRAFFIC_EVIDENCE_MIN else 0.3
 
         r['tx_conf'] = clamp(final_tx_conf)
         r['rx_conf'] = clamp(final_rx_conf)
 
         # Subtle status calibration: if up but effectively idle, reduce status confidence slightly
         if resolved_status == 'up':
             if r['rx'] <= TRAFFIC_EVIDENCE_MIN and r['tx'] <= TRAFFIC_EVIDENCE_MIN:
                 r['status_conf'] = clamp(r['status_conf'] * 0.9)
         elif resolved_status == 'down':
             if r['rx'] > TRAFFIC_EVIDENCE_MIN or r['tx'] > TRAFFIC_EVIDENCE_MIN:
                 r['status_conf'] = clamp(min(r['status_conf'], 0.3))
 
     # Assemble final result with (original, repaired, confidence) tuples and unchanged metadata
     for if_id, data in telemetry.items():
         repaired_data: Dict[str, Tuple] = {}
         r = interim[if_id]
 
         repaired_data['rx_rate'] = (r['orig_rx'], r['rx'], clamp(r['rx_conf']))
         repaired_data['tx_rate'] = (r['orig_tx'], r['tx'], clamp(r['tx_conf']))
         repaired_data['interface_status'] = (r['orig_status'], r['status'], clamp(r['status_conf']))
 
         # Copy metadata unchanged
         repaired_data['connected_to'] = r['connected_to']
         repaired_data['local_router'] = r['local_router']
         repaired_data['remote_router'] = r['remote_router']
 
         result[if_id] = repaired_data
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")