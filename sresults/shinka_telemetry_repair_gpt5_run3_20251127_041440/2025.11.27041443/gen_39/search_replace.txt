<NAME>
two_tier_dominance_cap_confidence_refine
</NAME>

<DESCRIPTION>
I propose three targeted improvements aligned with the research recommendations to improve counter repair accuracy and confidence calibration without rewriting the algorithm:

1) Two-tier router correction with dominance cap:
   - After the existing per-router correction pass, run a second-tier spillover pass when residual router imbalance remains > 0.5*τ_router. This pass only adjusts mid-confidence interfaces (0.70 ≤ conf < 0.85), further closing gaps conservatively.
   - Add a dominance cap so no single interface can take more than 50% of a pass’s distributed correction by capping per-interface weight shares and re-normalizing. This reduces over-reliance on one link and improves calibration.

2) Re-sync attenuation by router imbalance:
   - During the confidence-gap re-sync step, attenuate the nudge factor by adjacent routers’ current imbalance: f *= clamp01(1 − router_imbalance). This avoids double-adjusting links connected to imbalanced routers, preserving router conservation.

3) Confidence calibration refinements:
   - Apply a clip-hit-like penalty when effective scaling exceeded ±10% in a direction.
   - Add a small untouched boost when a direction changed <1% and final link symmetry is good, capped at 0.98. These adjustments align confidences better with actual repair quality.

These changes follow the two-tier targeted scaling and calibration refinements from the research, aiming to increase counter_repair_accuracy and maintain strong confidence_calibration. The edits are localized and backwards-compatible with the current function.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    STRONG_SCALE_GUARD = 0.08  # guard for re-sync when strong router scaling applied
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
    WEIGHT_FOCUS = 0.70      # focus router corrections on lowest-confidence 70% weight
=======
    STRONG_SCALE_GUARD = 0.08  # guard for re-sync when strong router scaling applied
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
    WEIGHT_FOCUS = 0.70      # focus router corrections on lowest-confidence 70% weight
    DOMINANCE_CAP = 0.50     # cap any single interface's share of a pass's correction to ≤50%
    CLIP_HIT_PENALTY = 0.95  # confidence penalty multiplier when strong scaling/clipping hit
    UNTOUCHED_BOOST = 0.02   # confidence boost for untouched, well-synced counters
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Track cumulative router scaling factors for re-sync guard and confidence
    scaled_rx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    scaled_tx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
=======
    # Track cumulative router scaling factors for re-sync guard and confidence
    scaled_rx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    scaled_tx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    # Track if a direction hit clipping (±10% per-pass cap)
    clip_hit_rx: Dict[str, bool] = {i: False for i in telemetry}
    clip_hit_tx: Dict[str, bool] = {i: False for i in telemetry}
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                adj_nm = total_adjust * (nm_total_w / focus_total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = weights[i] / nm_total_w
                    adj_i = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i, -cap), cap)
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        prev = hardened_rx[i]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[i] *= (v_new / prev)
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[i]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[i] *= (v_new / prev)
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
=======
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                # Apply dominance cap on weight shares within this pass
                cap_per = DOMINANCE_CAP * nm_total_w
                eff_weights = {i: min(weights[i], cap_per) for i in non_majority}
                eff_total_w = max(1e-9, sum(eff_weights.values()))
                adj_nm = total_adjust * (nm_total_w / focus_total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = eff_weights[i] / eff_total_w
                    adj_i_raw = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i_raw, -cap), cap)
                    # Mark clip-hit when cap engaged
                    if abs(adj_i) >= cap - 1e-12:
                        if adjust_side == 'rx':
                            clip_hit_rx[i] = True
                        else:
                            clip_hit_tx[i] = True
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        prev = hardened_rx[i]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[i] *= (v_new / prev)
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[i]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[i] *= (v_new / prev)
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        else:
            # No dominant bundle: targeted per-interface corrections only over focus_set
            for i in focus_set:
                v_old = side_vals[i]
                w_i = weights[i] / focus_total_w
                adj_i = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i, -cap), cap)
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    prev = hardened_rx[i]
                    if prev > ZERO_EPS:
                        scaled_rx_factor[i] *= (v_new / prev)
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    prev = hardened_tx[i]
                    if prev > ZERO_EPS:
                        scaled_tx_factor[i] *= (v_new / prev)
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
=======
        else:
            # No dominant bundle: targeted per-interface corrections only over focus_set
            # Apply dominance cap on per-interface weight shares within this pass
            cap_per = DOMINANCE_CAP * focus_total_w
            eff_weights = {i: min(weights[i], cap_per) for i in focus_set}
            eff_total_w = max(1e-9, sum(eff_weights.values()))
            for i in focus_set:
                v_old = side_vals[i]
                w_i = eff_weights[i] / eff_total_w
                adj_i_raw = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i_raw, -cap), cap)
                # Mark clip-hit when cap engaged
                if abs(adj_i) >= cap - 1e-12:
                    if adjust_side == 'rx':
                        clip_hit_rx[i] = True
                    else:
                        clip_hit_tx[i] = True
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    prev = hardened_rx[i]
                    if prev > ZERO_EPS:
                        scaled_rx_factor[i] *= (v_new / prev)
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    prev = hardened_tx[i]
                    if prev > ZERO_EPS:
                        scaled_tx_factor[i] *= (v_new / prev)
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Stage 3: Confidence-gap-proportional re-sync with scaling guard
=======
    # Stage 2b: Second-tier spillover for mid-confidence interfaces if residual remains
    for r, ifs in router_ifaces.items():
        up_ifs = [i for i in ifs if status.get(i) == 'up']
        if len(up_ifs) < 2:
            continue
        sum_rx = sum(hardened_rx[i] for i in up_ifs)
        sum_tx = sum(hardened_tx[i] for i in up_ifs)
        denom = max(1.0, sum_rx, sum_tx)
        imbalance = (sum_rx - sum_tx)
        rel_gap = abs(imbalance) / denom
        # Adaptive router tolerance
        n_active = len(up_ifs)
        tau_router = min(0.07, max(0.03, 0.05 * (2.0 / max(2, n_active)) ** 0.5))
        if rel_gap <= 0.5 * tau_router:
            continue
        # Choose the lower-confidence side for this spillover
        avg_rx_conf = sum(conf_rx[i] for i in up_ifs) / len(up_ifs)
        avg_tx_conf = sum(conf_tx[i] for i in up_ifs) / len(up_ifs)
        adjust_side = 'rx' if avg_rx_conf < avg_tx_conf else 'tx'
        total_adjust2 = (-imbalance if adjust_side == 'rx' else imbalance) * DAMP_ROUTER

        # Build mid-confidence candidate set: 0.70 ≤ conf < 0.85 and active
        side_vals = {i: (hardened_rx[i] if adjust_side == 'rx' else hardened_tx[i]) for i in up_ifs}
        side_confs = {i: (conf_rx[i] if adjust_side == 'rx' else conf_tx[i]) for i in up_ifs}
        mid_set = [i for i in up_ifs if 0.70 <= side_confs[i] < 0.85]
        if not mid_set:
            continue

        # Weights with dominance cap
        weights2 = {i: (1.0 - clamp01(side_confs[i])) * max(side_vals[i], ZERO_THRESH) + 1e-9 for i in mid_set}
        total_w2 = sum(weights2.values())
        if total_w2 <= 0:
            continue
        cap_per2 = DOMINANCE_CAP * total_w2
        eff_weights2 = {i: min(weights2[i], cap_per2) for i in mid_set}
        eff_total_w2 = max(1e-9, sum(eff_weights2.values()))

        for i in mid_set:
            v_old = side_vals[i]
            w_i = eff_weights2[i] / eff_total_w2
            adj_i_raw = total_adjust2 * w_i
            cap = PER_LINK_CLIP * v_old
            adj_i = min(max(adj_i_raw, -cap), cap)
            if abs(adj_i) >= cap - 1e-12:
                if adjust_side == 'rx':
                    clip_hit_rx[i] = True
                else:
                    clip_hit_tx[i] = True
            v_new = max(0.0, v_old + adj_i)
            if adjust_side == 'rx':
                prev = hardened_rx[i]
                if prev > ZERO_EPS:
                    scaled_rx_factor[i] *= (v_new / prev)
                hardened_rx[i] = v_new
                relc = abs(adj_i) / max(1.0, abs(v_old))
                conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
            else:
                prev = hardened_tx[i]
                if prev > ZERO_EPS:
                    scaled_tx_factor[i] *= (v_new / prev)
                hardened_tx[i] = v_new
                relc = abs(adj_i) / max(1.0, abs(v_old))
                conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))

    # Compute per-router residuals for re-sync attenuation
    router_residual_mid: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        ups = [i for i in ifs if status.get(i) == 'up']
        if not ups:
            router_residual_mid[r] = 0.0
        else:
            srx = sum(hardened_rx[i] for i in ups)
            stx = sum(hardened_tx[i] for i in ups)
            denomr = max(1.0, srx, stx)
            router_residual_mid[r] = abs(srx - stx) / denomr

    # Stage 3: Confidence-gap-proportional re-sync with scaling guard
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Direction 1: a.tx vs b.rx
=======
    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue
        # Attenuation factor based on adjacent routers' imbalance
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = clamp01(1.0 - max(router_residual_mid.get(ra, 0.0), router_residual_mid.get(rb, 0.0)))

        # Direction 1: a.tx vs b.rx
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb))
=======
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca))
=======
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb))
=======
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca))
=======
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
=======
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
        # Clip-hit penalty when strong scaling occurred (>=10%) or cap hit
        if abs(scaled_rx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_rx.get(i, False):
            conf_rx[i] = clamp01(conf_rx[i] * CLIP_HIT_PENALTY)
        if abs(scaled_tx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_tx.get(i, False):
            conf_tx[i] = clamp01(conf_tx[i] * CLIP_HIT_PENALTY)

        # Untouched boost when minimal change (<1%) and good final symmetry on link
        p = peer_of.get(i)
        if p and p in telemetry and status.get(i) == 'up' and status.get(p) == 'up':
            # RX direction check against peer TX
            if abs(scaled_rx_factor.get(i, 1.0) - 1.0) < 0.01:
                link_res_rx = rel_diff(hardened_rx[i], hardened_tx[p])
                if link_res_rx <= adaptive_tau(hardened_rx[i], hardened_tx[p]):
                    conf_rx[i] = min(0.98, conf_rx[i] + UNTOUCHED_BOOST)
            # TX direction check against peer RX
            if abs(scaled_tx_factor.get(i, 1.0) - 1.0) < 0.01:
                link_res_tx = rel_diff(hardened_tx[i], hardened_rx[p])
                if link_res_tx <= adaptive_tau(hardened_tx[i], hardened_rx[p]):
                    conf_tx[i] = min(0.98, conf_tx[i] + UNTOUCHED_BOOST)
>>>>>>> REPLACE

</DIFF>