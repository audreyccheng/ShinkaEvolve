<NAME>
median_centered_bundle_align
</NAME>

<DESCRIPTION>
I propose a targeted improvement to the conservation-preserving bundle finishing pass (Stage 2.6). Currently, bundle residuals e_i are centered using the mean residual. This can be sensitive to outliers within parallel-link bundles and may lead to suboptimal corrections that slightly degrade counter accuracy or slow convergence.

Drawing from robust statistics and the recommended strategy, I replace the mean residual center with a median residual center. This reduces outlier influence while still preserving the zero-sum property across the bundle, maintaining router conservation. The rest of the pass remains unchanged: direction-wise residuals, weights w_i = (1 − conf_i)·rate_i, adaptive gamma = min(0.25, 0.5·TAU_H/rel_diff(...)), and per-link clipping ±3%·rate. This should tighten intra-bundle symmetry corrections, improving counter repair accuracy and the downstream confidence calibration (as confidence already incorporates final symmetry residuals).

The change is minimal, localized, and consistent with the existing algorithmic design and thresholds.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def bundle_direction_align(pairs: List[Tuple[str, str]], ab_dir: bool = True):
        if not pairs:
            return
        es = []
        ws = []
        rs = []
        idxs = []
        for (a, b) in pairs:
            if ab_dir:
                tx = hard_tx.get(a, 0.0)
                rx = hard_rx.get(b, 0.0)
                conf = 0.5 * (clamp01(conf_tx_link.get(a, 0.6)) + clamp01(conf_rx_link.get(b, 0.6)))
            else:
                tx = hard_tx.get(b, 0.0)
                rx = hard_rx.get(a, 0.0)
                conf = 0.5 * (clamp01(conf_tx_link.get(b, 0.6)) + clamp01(conf_rx_link.get(a, 0.6)))
            if max(tx, rx) < ZERO_THRESH:
                continue
            e = tx - rx
            rate = max(tx, rx)
            w = (1.0 - conf) * rate
            es.append(e)
            ws.append(w)
            rs.append(rate)
            idxs.append((a, b))
        if len(es) <= 1:
            return
        mean_e = sum(es) / len(es)
        base = []
        for k, e in enumerate(es):
            if ab_dir:
                tx = hard_tx.get(idxs[k][0], 0.0)
                rx = hard_rx.get(idxs[k][1], 0.0)
            else:
                tx = hard_tx.get(idxs[k][1], 0.0)
                rx = hard_rx.get(idxs[k][0], 0.0)
            mismatch = rel_diff(tx, rx)
            gamma = min(0.25, 0.5 * TAU_H / max(mismatch, 1e-9))
            base.append(-gamma * (e - mean_e))
        wbar = (sum(ws) / len(ws)) if ws else 0.0
        scaled = [base[k] * (ws[k] / max(wbar, EPS)) for k in range(len(base))]
        mean_scaled = sum(scaled) / len(scaled)
        deltas = [d - mean_scaled for d in scaled]
        for k, (a, b) in enumerate(idxs):
            clip = 0.03 * rs[k]
            di = max(-clip, min(clip, deltas[k]))
            if ab_dir:
                hard_tx[a] = max(0.0, hard_tx.get(a, 0.0) + di)
                hard_rx[b] = max(0.0, hard_rx.get(b, 0.0) - di)
            else:
                hard_tx[b] = max(0.0, hard_tx.get(b, 0.0) + di)
                hard_rx[a] = max(0.0, hard_rx.get(a, 0.0) - di)
=======
    def bundle_direction_align(pairs: List[Tuple[str, str]], ab_dir: bool = True):
        if not pairs:
            return
        es = []
        ws = []
        rs = []
        idxs = []
        for (a, b) in pairs:
            if ab_dir:
                tx = hard_tx.get(a, 0.0)
                rx = hard_rx.get(b, 0.0)
                conf = 0.5 * (clamp01(conf_tx_link.get(a, 0.6)) + clamp01(conf_rx_link.get(b, 0.6)))
            else:
                tx = hard_tx.get(b, 0.0)
                rx = hard_rx.get(a, 0.0)
                conf = 0.5 * (clamp01(conf_tx_link.get(b, 0.6)) + clamp01(conf_rx_link.get(a, 0.6)))
            if max(tx, rx) < ZERO_THRESH:
                continue
            e = tx - rx
            rate = max(tx, rx)
            w = (1.0 - conf) * rate
            es.append(e)
            ws.append(w)
            rs.append(rate)
            idxs.append((a, b))
        if len(es) <= 1:
            return
        # Robust center using median residual to reduce outlier influence
        es_sorted = sorted(es)
        mid = len(es_sorted) // 2
        if len(es_sorted) % 2 == 1:
            e_center = es_sorted[mid]
        else:
            e_center = 0.5 * (es_sorted[mid - 1] + es_sorted[mid])
        base = []
        for k, e in enumerate(es):
            if ab_dir:
                tx = hard_tx.get(idxs[k][0], 0.0)
                rx = hard_rx.get(idxs[k][1], 0.0)
            else:
                tx = hard_tx.get(idxs[k][1], 0.0)
                rx = hard_rx.get(idxs[k][0], 0.0)
            mismatch = rel_diff(tx, rx)
            gamma = min(0.25, 0.5 * TAU_H / max(mismatch, 1e-9))
            base.append(-gamma * (e - e_center))
        # Weight deltas and re-center to keep bundle zero-sum
        wbar = (sum(ws) / len(ws)) if ws else 0.0
        scaled = [base[k] * (ws[k] / max(wbar, EPS)) for k in range(len(base))]
        mean_scaled = sum(scaled) / len(scaled)
        deltas = [d - mean_scaled for d in scaled]
        for k, (a, b) in enumerate(idxs):
            clip = 0.03 * rs[k]
            di = max(-clip, min(clip, deltas[k]))
            if ab_dir:
                hard_tx[a] = max(0.0, hard_tx.get(a, 0.0) + di)
                hard_rx[b] = max(0.0, hard_rx.get(b, 0.0) - di)
            else:
                hard_tx[b] = max(0.0, hard_tx.get(b, 0.0) + di)
                hard_rx[a] = max(0.0, hard_rx.get(a, 0.0) - di)
>>>>>>> REPLACE

</DIFF>