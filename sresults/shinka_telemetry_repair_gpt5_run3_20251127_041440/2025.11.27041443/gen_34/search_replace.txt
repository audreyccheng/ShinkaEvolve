<NAME>
adaptive_sync_and_confidence_refinements
</NAME>

<DESCRIPTION>
I propose targeted improvements that strengthen both counter repair accuracy and confidence calibration without rewriting the entire algorithm:

1) Adaptive hardening tolerance: Introduce tau_h_dir() to make the symmetry threshold stricter at high rates and looser at low rates or low confidence. Use it in link fusion and re-sync to reduce unnecessary changes and better respect timing jitter.

2) Strong-scaling guard with tighter clips: Track per-direction strong scaling (>|8%|) at the router projection stage and skip re-sync on those directions to avoid double-adjustment. Also tighten scaling clips from [0.85–1.15] to [0.90–1.10] for both uniform and per-interface scaling to reduce overshoot, improving both accuracy and calibration.

3) Soft-zero stabilization: Add a soft-zero rule that snaps tiny bi-directional links to zero with high confidence when all four directions are near zero, reducing noise-induced oscillations.

4) Confidence calibration refinements: Add a scale penalty term to confidence blending to penalize large scaling, apply a mild penalty for clip hits (>10%), add a small untouched boost when minimal change and strong final symmetry, and add peer confidence smoothing (10%) after the final invariant touch-up.

These changes are consistent with Hodor’s principles and the provided recommendations, aiming to improve counter repairs and produce better-calibrated confidences.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def clamp01(x: float) -> float:
        if x < 0.0: return 0.0
        if x > 1.0: return 1.0
        return x
=======
    def clamp01(x: float) -> float:
        if x < 0.0: return 0.0
        if x > 1.0: return 1.0
        return x

    def tau_h_dir(v1: float, v2: float, c1: float = None, c2: float = None) -> float:
        """
        Adaptive hardening tolerance:
        - 1.5% when both directions are high-rate (>100 Mbps) and confidences (if provided) are high (>=0.8)
        - 3% when either direction is low-rate (<1 Mbps) or any confidence is low (<0.7)
        - 2% baseline otherwise
        """
        high = (v1 > 100.0 and v2 > 100.0)
        low = (v1 < 1.0 or v2 < 1.0)
        high_conf = (c1 is not None and c2 is not None and c1 >= 0.8 and c2 >= 0.8)
        low_conf = (c1 is not None and c2 is not None and (c1 < 0.7 or c2 < 0.7))
        if high and high_conf:
            return 0.015
        if low or low_conf:
            return 0.03
        return 0.02
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)

        # Both near-zero => zero with high confidence
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within hardening tolerance, keep local reading (minimal change)
        if mismatch <= TAU_H:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero and the other is not, take the non-zero
        if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
=======
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)
        th = tau_h_dir(v_local, v_peer)

        # Both near-zero => zero with high confidence
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within adaptive hardening tolerance, keep local reading (minimal change)
        if mismatch <= th:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero and the other is not, take the non-zero
        if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    router_imbalance_before: Dict[str, float] = {}
    scaled_tx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
    scaled_rx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
=======
    router_imbalance_before: Dict[str, float] = {}
    scaled_tx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
    scaled_rx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
    # Track directions that received strong scaling to guard against double-adjustment in Stage 2.5
    strong_scaled_tx: Dict[str, bool] = {if_id: False for if_id in telemetry}
    strong_scaled_rx: Dict[str, bool] = {if_id: False for if_id in telemetry}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_tx[i] *= alpha_eff
                        scaled_tx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                    alpha = target / max(current, EPS)
                    alpha = max(0.90, min(1.10, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_tx[i] *= alpha_eff
                        scaled_tx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                        if penalty > 0.08:
                            strong_scaled_tx[i] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                        scale_i = 1.0 + 0.6 * (k * w)
                        # Clip per-interface scaling to avoid overcorrection
                        scale_i = max(0.85, min(1.15, scale_i))
                        hard_tx[i] = v * scale_i
                        scaled_tx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                        scale_i = 1.0 + 0.6 * (k * w)
                        # Clip per-interface scaling to avoid overcorrection
                        scale_i = max(0.90, min(1.10, scale_i))
                        hard_tx[i] = v * scale_i
                        scaled_tx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                        if penalty > 0.08:
                            strong_scaled_tx[i] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_rx[i] *= alpha_eff
                        scaled_rx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                    alpha = target / max(current, EPS)
                    alpha = max(0.90, min(1.10, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_rx[i] *= alpha_eff
                        scaled_rx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                        if penalty > 0.08:
                            strong_scaled_rx[i] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.85, min(1.15, scale_i))
                        hard_rx[i] = v * scale_i
                        scaled_rx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.90, min(1.10, scale_i))
                        hard_rx[i] = v * scale_i
                        scaled_rx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                        if penalty > 0.08:
                            strong_scaled_rx[i] = True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ab = rel_diff(tx_a, rx_b)
        if diff_ab > TAU_H and max(tx_a, rx_b) >= ZERO_THRESH:
            mean_ab = 0.5 * (tx_a + rx_b)
            ca = conf_tx_link.get(a, 0.6)
            cb = conf_rx_link.get(b, 0.6)
=======
        diff_ab = rel_diff(tx_a, rx_b)
        ca = conf_tx_link.get(a, 0.6)
        cb = conf_rx_link.get(b, 0.6)
        th_ab = tau_h_dir(tx_a, rx_b, ca, cb)
        recent_strong_scale = (abs(scaled_tx_factor.get(a, 1.0) - 1.0) > 0.08) or (abs(scaled_rx_factor.get(b, 1.0) - 1.0) > 0.08)
        if diff_ab > th_ab and max(tx_a, rx_b) >= ZERO_THRESH and not recent_strong_scale:
            mean_ab = 0.5 * (tx_a + rx_b)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ba = rel_diff(tx_b, rx_a)
        if diff_ba > TAU_H and max(tx_b, rx_a) >= ZERO_THRESH:
            mean_ba = 0.5 * (tx_b + rx_a)
            cb_tx = conf_tx_link.get(b, 0.6)
            ca_rx = conf_rx_link.get(a, 0.6)
=======
        diff_ba = rel_diff(tx_b, rx_a)
        cb_tx = conf_tx_link.get(b, 0.6)
        ca_rx = conf_rx_link.get(a, 0.6)
        th_ba = tau_h_dir(tx_b, rx_a, cb_tx, ca_rx)
        recent_strong_scale_ba = (abs(scaled_tx_factor.get(b, 1.0) - 1.0) > 0.08) or (abs(scaled_rx_factor.get(a, 1.0) - 1.0) > 0.08)
        if diff_ba > th_ba and max(tx_b, rx_a) >= ZERO_THRESH and not recent_strong_scale_ba:
            mean_ba = 0.5 * (tx_b + rx_a)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Status repair (conservative and symmetry-aware)
=======
    # Soft-zero rule: if both directions on a link are tiny, snap all four to 0 with high confidence
    processed_pairs = set()
    for a, data_a in telemetry.items():
        b = data_a.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs:
            continue
        processed_pairs.add(key)
        tx_a = hard_tx.get(a, 0.0)
        rx_b = hard_rx.get(b, 0.0)
        tx_b = hard_tx.get(b, 0.0)
        rx_a = hard_rx.get(a, 0.0)
        if max(tx_a, rx_b, tx_b, rx_a) < 2.0 * ZERO_THRESH:
            hard_tx[a] = 0.0
            hard_rx[b] = 0.0
            hard_tx[b] = 0.0
            hard_rx[a] = 0.0
            conf_tx_link[a] = max(conf_tx_link.get(a, 0.6), 0.95)
            conf_rx_link[b] = max(conf_rx_link.get(b, 0.6), 0.95)
            conf_tx_link[b] = max(conf_tx_link.get(b, 0.6), 0.95)
            conf_rx_link[a] = max(conf_rx_link.get(a, 0.6), 0.95)

    # Status repair (conservative and symmetry-aware)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Blend confidence components with emphasis on final invariant satisfaction
        conf_tx_final = clamp01(
            0.25 * base_tx_conf +
            0.20 * red_tx +
            0.30 * fin_sym_tx +
            0.15 * ch_tx +
            0.10 * router_factor_after
        )
        conf_rx_final = clamp01(
            0.25 * base_rx_conf +
            0.20 * red_rx +
            0.30 * fin_sym_rx +
            0.15 * ch_rx +
            0.10 * router_factor_after
        )
=======
        # Blend confidence components with emphasis on final invariant satisfaction and scale penalty
        scale_tx_term = clamp01(1.0 - min(0.5, abs(scaled_tx_factor.get(if_id, 1.0) - 1.0)))
        scale_rx_term = clamp01(1.0 - min(0.5, abs(scaled_rx_factor.get(if_id, 1.0) - 1.0)))
        conf_tx_final = clamp01(
            0.23 * base_tx_conf +
            0.20 * red_tx +
            0.27 * fin_sym_tx +
            0.10 * ch_tx +
            0.10 * router_factor_after +
            0.10 * scale_tx_term
        )
        conf_rx_final = clamp01(
            0.23 * base_rx_conf +
            0.20 * red_rx +
            0.27 * fin_sym_rx +
            0.10 * ch_rx +
            0.10 * router_factor_after +
            0.10 * scale_rx_term
        )

        # Confidence refinements: clip-hit penalty and untouched boost
        if abs(scaled_tx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_tx_final *= 0.95
        if abs(scaled_rx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_rx_final *= 0.95
        if change_tx < 0.01 and fin_sym_tx >= (1.0 - TAU_H):
            conf_tx_final = min(0.98, conf_tx_final + 0.02)
        if change_rx < 0.01 and fin_sym_rx >= (1.0 - TAU_H):
            conf_rx_final = min(0.98, conf_rx_final + 0.02)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    for i, data in telemetry.items():
        peer = data.get('connected_to')
        if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
            continue
        if result[i]['interface_status'][1] != 'up' or result[peer]['interface_status'][1] != 'up':
            continue
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.7 * old_tx_c + 0.3 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.7 * old_rx_c + 0.3 * clamp01(1.0 - mis_rx))
        )

    return result
=======
    for i, data in telemetry.items():
        peer = data.get('connected_to')
        if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
            continue
        if result[i]['interface_status'][1] != 'up' or result[peer]['interface_status'][1] != 'up':
            continue
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.7 * old_tx_c + 0.3 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.7 * old_rx_c + 0.3 * clamp01(1.0 - mis_rx))
        )

    # Peer confidence smoothing (10%) when both ends are up
    for i, data in telemetry.items():
        p = data.get('connected_to')
        if not isinstance(p, str) or p not in telemetry:
            continue
        if i not in result or p not in result:
            continue
        if result[i]['interface_status'][1] != 'up' or result[p]['interface_status'][1] != 'up':
            continue
        my_tx_c = clamp01(result[i]['tx_rate'][2])
        my_rx_c = clamp01(result[i]['rx_rate'][2])
        peer_rx_c = clamp01(result[p]['rx_rate'][2])
        peer_tx_c = clamp01(result[p]['tx_rate'][2])
        result[i]['tx_rate'] = (result[i]['tx_rate'][0], result[i]['tx_rate'][1],
                                clamp01(0.90 * my_tx_c + 0.10 * peer_rx_c))
        result[i]['rx_rate'] = (result[i]['rx_rate'][0], result[i]['rx_rate'][1],
                                clamp01(0.90 * my_rx_c + 0.10 * peer_tx_c))

    return result
>>>>>>> REPLACE
</DIFF>