<NAME>
post_projection_link_resync
</NAME>

<DESCRIPTION>
I add a targeted Stage 2.5 that gently re-synchronizes link directions after the router-level projection and calibrates confidence using final residual symmetry. Router projection can introduce small asymmetries (my_tx ≈ their_rx) because routers are adjusted independently. The new pass uses redundant signals to nudge only the lower-confidence side of each link direction toward the mean, with damped adjustments and minor confidence penalties. Then, it blends each counter’s confidence with a residual-based score (1 - final mismatch) to better reflect invariant satisfaction. This should improve counter accuracy and confidence calibration without disrupting the conservative router projection or status handling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Final pass: status enforcement - down implies zero counters with calibrated confidence
    for i, data in telemetry.items():
        status = data.get('interface_status', 'unknown')
        if i not in result:
            continue
        if status == 'down':
            orig_tx = safe_rate(result[i]['tx_rate'][0])
            orig_rx = safe_rate(result[i]['rx_rate'][0])
            result[i]['tx_rate'] = (
                result[i]['tx_rate'][0],
                0.0,
                0.9 if (orig_tx < ZERO_THRESH and orig_rx < ZERO_THRESH) else min(result[i]['tx_rate'][2], 0.7)
            )
            result[i]['rx_rate'] = (
                result[i]['rx_rate'][0],
                0.0,
                0.9 if (orig_tx < ZERO_THRESH and orig_rx < ZERO_THRESH) else min(result[i]['rx_rate'][2], 0.7)
            )

    return result
=======
    # Stage 2.5: Post-projection gentle link re-sync and confidence calibration
    processed_pairs = set()
    for a, data_a in telemetry.items():
        b = data_a.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs:
            continue
        processed_pairs.add(key)

        # a->b direction: my_tx[a] vs their_rx[b]
        if a in result and b in result:
            tx_a = safe_rate(result[a]['tx_rate'][1])
            rx_b = safe_rate(result[b]['rx_rate'][1])
            diff_ab = rel_diff(tx_a, rx_b)
            if diff_ab > HARDENING_THRESHOLD and max(tx_a, rx_b) >= ZERO_THRESH:
                ca = clamp01(result[a]['tx_rate'][2])
                cb = clamp01(result[b]['rx_rate'][2])
                mean_ab = 0.5 * (tx_a + rx_b)
                if ca < cb:
                    # Nudge lower-confidence side toward mean
                    new_tx_a = 0.5 * mean_ab + 0.5 * tx_a
                    result[a]['tx_rate'] = (result[a]['tx_rate'][0], new_tx_a, clamp01(ca * 0.95))
                elif cb < ca:
                    new_rx_b = 0.5 * mean_ab + 0.5 * rx_b
                    result[b]['rx_rate'] = (result[b]['rx_rate'][0], new_rx_b, clamp01(cb * 0.95))
                else:
                    # Both similar and low confidence: cautiously set both to mean
                    if ca < 0.7:
                        result[a]['tx_rate'] = (result[a]['tx_rate'][0], mean_ab, clamp01(ca * 0.93))
                        result[b]['rx_rate'] = (result[b]['rx_rate'][0], mean_ab, clamp01(cb * 0.93))

        # b->a direction: my_tx[b] vs their_rx[a]
        if a in result and b in result:
            tx_b = safe_rate(result[b]['tx_rate'][1])
            rx_a = safe_rate(result[a]['rx_rate'][1])
            diff_ba = rel_diff(tx_b, rx_a)
            if diff_ba > HARDENING_THRESHOLD and max(tx_b, rx_a) >= ZERO_THRESH:
                cb_tx = clamp01(result[b]['tx_rate'][2])
                ca_rx = clamp01(result[a]['rx_rate'][2])
                mean_ba = 0.5 * (tx_b + rx_a)
                if cb_tx < ca_rx:
                    new_tx_b = 0.5 * mean_ba + 0.5 * tx_b
                    result[b]['tx_rate'] = (result[b]['tx_rate'][0], new_tx_b, clamp01(cb_tx * 0.95))
                elif ca_rx < cb_tx:
                    new_rx_a = 0.5 * mean_ba + 0.5 * rx_a
                    result[a]['rx_rate'] = (result[a]['rx_rate'][0], new_rx_a, clamp01(ca_rx * 0.95))
                else:
                    if cb_tx < 0.7:
                        result[b]['tx_rate'] = (result[b]['tx_rate'][0], mean_ba, clamp01(cb_tx * 0.93))
                        result[a]['rx_rate'] = (result[a]['rx_rate'][0], mean_ba, clamp01(ca_rx * 0.93))

    # Final confidence touch-up: incorporate final symmetry residuals
    for i, data in telemetry.items():
        peer = data.get('connected_to')
        if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
            continue
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.7 * clamp01(result[i]['tx_rate'][2]) + 0.3 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.7 * clamp01(result[i]['rx_rate'][2]) + 0.3 * clamp01(1.0 - mis_rx))
        )

    # Final pass: status enforcement - down implies zero counters with calibrated confidence
    for i, data in telemetry.items():
        status = data.get('interface_status', 'unknown')
        if i not in result:
            continue
        if status == 'down':
            orig_tx = safe_rate(result[i]['tx_rate'][0])
            orig_rx = safe_rate(result[i]['rx_rate'][0])
            result[i]['tx_rate'] = (
                result[i]['tx_rate'][0],
                0.0,
                0.9 if (orig_tx < ZERO_THRESH and orig_rx < ZERO_THRESH) else min(result[i]['tx_rate'][2], 0.7)
            )
            result[i]['rx_rate'] = (
                result[i]['rx_rate'][0],
                0.0,
                0.9 if (orig_tx < ZERO_THRESH and orig_rx < ZERO_THRESH) else min(result[i]['rx_rate'][2], 0.7)
            )

    return result
>>>>>>> REPLACE

</DIFF>