<NAME>
adaptive_tau_and_conf_touchup
</NAME>

<DESCRIPTION>
I propose three targeted improvements:
1) Use the adaptive symmetry tolerance inside Stage 1 fusion. The function adapt_tau_h was defined but unused in fuse_direction, causing over/under-triggering of changes, especially at low/high rates. Using adaptive thresholds should reduce unnecessary modifications and improve counter accuracy.

2) Slightly widen the per-interface scaling clip in the targeted router projection from [0.90, 1.10] to [0.85, 1.15]. Since we already damp corrections (60%), this gives the router projection more room to reconcile imbalances on tough scenarios, improving flow conservation without destabilizing links. Confidence is penalized via the scale term, keeping calibration in check.

3) Simplify the final confidence touch-up to a residual-weighted 70/30 blend (remove the peer-confidence blend). This mirrors the best-calibrated prior variant and should improve confidence calibration by aligning it more directly with final symmetry residuals.

These changes are consistent and minimal, focusing on improving counter repair accuracy and confidence calibration without altering the overall architecture.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Within tolerance, keep local reading
        if mismatch <= TAU_H_BASE:
            return v_local, 0.95
=======
        # Within tolerance, keep local reading (use adaptive tolerance based on rates)
        th_local = adapt_tau_h(v_local, v_peer, 0.8, 0.8)
        if mismatch <= th_local:
            return v_local, 0.95
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                alpha = clamp(target / max(current, EPS), 0.90, 1.10)
=======
                alpha = clamp(target / max(current, EPS), 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                    scale_i = clamp(new_v / v, 0.90, 1.10)
=======
                    scale_i = clamp(new_v / v, 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                        mean_scale = clamp(mean_scale, 0.90, 1.10)
=======
                        mean_scale = clamp(mean_scale, 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                alpha = clamp(target / max(current, EPS), 0.90, 1.10)
=======
                alpha = clamp(target / max(current, EPS), 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                    scale_i = clamp(new_v / v, 0.90, 1.10)
=======
                    scale_i = clamp(new_v / v, 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                        mean_scale = clamp(mean_scale, 0.90, 1.10)
=======
                        mean_scale = clamp(mean_scale, 0.85, 1.15)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Final confidence touch-up: peer-aware smoothing when both ends are up
    for i, data in telemetry.items():
        peer = data.get('connected_to')
        if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
            continue
        if result[i]['interface_status'][1] != 'up' or result[peer]['interface_status'][1] != 'up':
            continue
        # Symmetry residuals
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        # 10% blend from opposite peer direction + residual-informed touch
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        peer_rx_c = clamp01(result[peer]['rx_rate'][2])
        peer_tx_c = clamp01(result[peer]['tx_rate'][2])
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.80 * old_tx_c + 0.10 * peer_rx_c + 0.10 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.80 * old_rx_c + 0.10 * peer_tx_c + 0.10 * clamp01(1.0 - mis_rx))
        )
=======
    # Final confidence touch-up: residual-weighted 70/30 blend when both ends are up
    for i, data in telemetry.items():
        peer = data.get('connected_to')
        if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
            continue
        if result[i]['interface_status'][1] != 'up' or result[peer]['interface_status'][1] != 'up':
            continue
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.70 * old_tx_c + 0.30 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.70 * old_rx_c + 0.30 * clamp01(1.0 - mis_rx))
        )
>>>>>>> REPLACE

</DIFF>