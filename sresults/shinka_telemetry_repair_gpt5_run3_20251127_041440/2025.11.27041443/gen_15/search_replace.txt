<NAME>
weighted_router_projection
</NAME>

<DESCRIPTION>
I introduce a weighted router-level projection that adjusts only the less trustworthy interfaces more strongly when enforcing flow conservation (Σtx ≈ Σrx) at each router. Previously, the algorithm applied a uniform scaling factor to all interfaces on the adjusted side, which could unnecessarily distort accurate counters and hurt counter-repair accuracy.

The new approach:
- Uses per-interface weights derived from confidence (w_i ≈ 1 - conf_i) and traffic presence to concentrate corrections on low-confidence, non-zero interfaces.
- Computes a global correction k such that new_i = old_i * (1 + 0.6 * k * w_i) with damping and per-interface clamping to [0.85, 1.15] to avoid overcorrection.
- Applies per-interface confidence penalties proportional to the magnitude of the applied adjustment.

This preserves the Hodor principles: it uses redundancy for detection (link symmetry), applies conservative corrections, and leverages topology (router-level invariants), but now with finer-grained adjustments that should improve counter accuracy and maintain or improve confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        if mismatch > TAU_ROUTER:
            # Choose side with lower aggregate link confidence to adjust
            c_tx_total = sum(conf_tx_link.get(i, 0.5) for i in if_list)
            c_rx_total = sum(conf_rx_link.get(i, 0.5) for i in if_list)
            adjust_side = "tx" if c_tx_total < c_rx_total else "rx"

            if adjust_side == "tx" and sum_tx > 0:
                alpha = sum_rx / max(sum_tx, EPS)
                # Clip and damp scaling to avoid overcorrection
                alpha = max(0.85, min(1.15, alpha))
                alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                for i in if_list:
                    hard_tx[i] *= alpha_eff
                    scaled_tx_factor[i] *= alpha_eff
                    penalty = clamp01(abs(alpha_eff - 1.0))
                    conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
            elif adjust_side == "rx" and sum_rx > 0:
                alpha = sum_tx / max(sum_rx, EPS)
                alpha = max(0.85, min(1.15, alpha))
                alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                for i in if_list:
                    hard_rx[i] *= alpha_eff
                    scaled_rx_factor[i] *= alpha_eff
                    penalty = clamp01(abs(alpha_eff - 1.0))
                    conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
        if mismatch > TAU_ROUTER:
            # Choose side with lower aggregate link confidence to adjust
            c_tx_total = sum(conf_tx_link.get(i, 0.5) for i in if_list)
            c_rx_total = sum(conf_rx_link.get(i, 0.5) for i in if_list)
            adjust_side = "tx" if c_tx_total < c_rx_total else "rx"

            if adjust_side == "tx" and sum_tx > 0:
                # Weighted projection: scale low-confidence, non-zero interfaces more
                vals = [hard_tx.get(i, 0.0) for i in if_list]
                confs = [conf_tx_link.get(i, 0.6) for i in if_list]
                weights = []
                for v, c in zip(vals, confs):
                    w = max(0.0, 1.0 - clamp01(c))
                    # Do not scale interfaces with near-zero traffic to avoid noise
                    if v < ZERO_THRESH:
                        w = 0.0
                    # Ensure a tiny weight if all weights become zero later
                    weights.append(w)
                denom = sum(v * w for v, w in zip(vals, weights))
                target = sum_rx
                current = sum_tx
                if denom < EPS:
                    # Fallback to uniform damped scaling if weighting not feasible
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_tx[i] *= alpha_eff
                        scaled_tx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                else:
                    # Compute global correction and apply per-interface damped/clipped scaling
                    k = (target - current) / denom
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        scale_i = 1.0 + 0.6 * (k * w)
                        # Clip per-interface scaling to avoid overcorrection
                        scale_i = max(0.85, min(1.15, scale_i))
                        hard_tx[i] = v * scale_i
                        scaled_tx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
            elif adjust_side == "rx" and sum_rx > 0:
                vals = [hard_rx.get(i, 0.0) for i in if_list]
                confs = [conf_rx_link.get(i, 0.6) for i in if_list]
                weights = []
                for v, c in zip(vals, confs):
                    w = max(0.0, 1.0 - clamp01(c))
                    if v < ZERO_THRESH:
                        w = 0.0
                    weights.append(w)
                denom = sum(v * w for v, w in zip(vals, weights))
                target = sum_tx
                current = sum_rx
                if denom < EPS:
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_rx[i] *= alpha_eff
                        scaled_rx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                else:
                    k = (target - current) / denom
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.85, min(1.15, scale_i))
                        hard_rx[i] = v * scale_i
                        scaled_rx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
>>>>>>> REPLACE

</DIFF>