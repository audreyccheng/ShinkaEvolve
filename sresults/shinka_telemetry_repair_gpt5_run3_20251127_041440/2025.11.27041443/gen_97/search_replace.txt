<NAME>
two_pass_micro_resync
</NAME>

<DESCRIPTION>
I add a second, saturating micro re-sync pass (Stage 2.7) after the late soft-zero step and before status/confidence calibration. This pass targets stubborn residual asymmetries that remain larger than 1.5× the adaptive hardening tolerance after all previous steps, and only when both adjacent routers are already within their adaptive flow-conservation tolerances. It adjusts only the lower-confidence side of each direction, skips directions that had strong router scaling or clipping in Stage 2, and caps each move to ±1% of the local reference to preserve stability and calibration. This should tighten link symmetry without disturbing router conservation, improving counter accuracy while keeping confidence well-calibrated.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Soft-zero rule (late pass): dynamic thresholds based on router totals
    processed_pairs = set()
    router_thr_late = compute_router_thresholds()
    for a, data_a in telemetry.items():
        b = data_a.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs:
            continue
        processed_pairs.add(key)
        ra = router_of.get(a)
        rb = router_of.get(b)
        thr_pair = 1.5 * max(router_thr_late.get(ra, ZERO_THRESH), router_thr_late.get(rb, ZERO_THRESH))
        tx_a = hard_tx.get(a, 0.0)
        rx_b = hard_rx.get(b, 0.0)
        tx_b = hard_tx.get(b, 0.0)
        rx_a = hard_rx.get(a, 0.0)
        if max(tx_a, rx_b, tx_b, rx_a) < thr_pair:
            def tau_for_router(rid: str) -> float:
                if rid not in router_ifaces:
                    return TAU_ROUTER
                ifs = router_ifaces[rid]
                n_tx = sum(1 for i in ifs if hard_tx.get(i, 0.0) >= ZERO_THRESH)
                n_rx = sum(1 for i in ifs if hard_rx.get(i, 0.0) >= ZERO_THRESH)
                return tau_router(max(n_tx, n_rx))
            if router_imbalance(ra) <= tau_for_router(ra) and router_imbalance(rb) <= tau_for_router(rb):
                hard_tx[a] = 0.0
                hard_rx[b] = 0.0
                hard_tx[b] = 0.0
                hard_rx[a] = 0.0
                conf_tx_link[a] = max(conf_tx_link.get(a, 0.6), 0.95)
                conf_rx_link[b] = max(conf_rx_link.get(b, 0.6), 0.95)
                conf_tx_link[b] = max(conf_tx_link.get(b, 0.6), 0.95)
                conf_rx_link[a] = max(conf_rx_link.get(a, 0.6), 0.95)

    # Status repair (conservative and symmetry-aware)
=======
    # Soft-zero rule (late pass): dynamic thresholds based on router totals
    processed_pairs = set()
    router_thr_late = compute_router_thresholds()
    for a, data_a in telemetry.items():
        b = data_a.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs:
            continue
        processed_pairs.add(key)
        ra = router_of.get(a)
        rb = router_of.get(b)
        thr_pair = 1.5 * max(router_thr_late.get(ra, ZERO_THRESH), router_thr_late.get(rb, ZERO_THRESH))
        tx_a = hard_tx.get(a, 0.0)
        rx_b = hard_rx.get(b, 0.0)
        tx_b = hard_tx.get(b, 0.0)
        rx_a = hard_rx.get(a, 0.0)
        if max(tx_a, rx_b, tx_b, rx_a) < thr_pair:
            def tau_for_router(rid: str) -> float:
                if rid not in router_ifaces:
                    return TAU_ROUTER
                ifs = router_ifaces[rid]
                n_tx = sum(1 for i in ifs if hard_tx.get(i, 0.0) >= ZERO_THRESH)
                n_rx = sum(1 for i in ifs if hard_rx.get(i, 0.0) >= ZERO_THRESH)
                return tau_router(max(n_tx, n_rx))
            if router_imbalance(ra) <= tau_for_router(ra) and router_imbalance(rb) <= tau_for_router(rb):
                hard_tx[a] = 0.0
                hard_rx[b] = 0.0
                hard_tx[b] = 0.0
                hard_rx[a] = 0.0
                conf_tx_link[a] = max(conf_tx_link.get(a, 0.6), 0.95)
                conf_rx_link[b] = max(conf_rx_link.get(b, 0.6), 0.95)
                conf_tx_link[b] = max(conf_tx_link.get(b, 0.6), 0.95)
                conf_rx_link[a] = max(conf_rx_link.get(a, 0.6), 0.95)

    # Stage 2.7: Two-pass, saturating micro re-sync for stubborn residuals
    # Only adjust when both adjacent routers are within tolerance; adjust lower-confidence side with ±1% caps.
    def _router_tau_local(rid: str) -> float:
        if not isinstance(rid, str) or rid not in router_ifaces:
            return 0.05
        ifs = router_ifaces[rid]
        n_tx = sum(1 for i in ifs if hard_tx.get(i, 0.0) >= ZERO_THRESH)
        n_rx = sum(1 for i in ifs if hard_rx.get(i, 0.0) >= ZERO_THRESH)
        return tau_router(max(n_tx, n_rx))

    def _router_in_tol(rid: str) -> bool:
        if not isinstance(rid, str):
            return True
        ifs = router_ifaces.get(rid, [])
        stx = sum(hard_tx.get(i, 0.0) for i in ifs)
        srx = sum(hard_rx.get(i, 0.0) for i in ifs)
        return rel_diff(stx, srx) <= _router_tau_local(rid)

    processed_pairs_micro = set()
    for a, data_a in telemetry.items():
        b = data_a.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs_micro:
            continue
        processed_pairs_micro.add(key)
        ra = router_of.get(a, "")
        rb = router_of.get(b, "")

        # Gate on router stability
        if not (_router_in_tol(ra) and _router_in_tol(rb)):
            continue

        # a->b direction
        tx_a = hard_tx.get(a, 0.0)
        rx_b = hard_rx.get(b, 0.0)
        if max(tx_a, rx_b) >= ZERO_THRESH:
            ca = clamp01(conf_tx_link.get(a, 0.6))
            cb = clamp01(conf_rx_link.get(b, 0.6))
            th_ab = tau_h_dir(tx_a, rx_b, ca, cb)
            mis_ab = rel_diff(tx_a, rx_b)
            if mis_ab > 1.5 * th_ab:
                mean_ab = 0.5 * (tx_a + rx_b)
                # Skip if strong-scaled or clip-hit on the side to be adjusted
                if ca < cb and not (strong_scaled_tx.get(a, False) or clip_hit_tx.get(a, False)):
                    # Lower-confidence side is tx[a]
                    gap_norm = clamp01((mis_ab - 1.5 * th_ab) / max(1.5 * th_ab, 1e-9))
                    f2 = 0.2 * min(0.20, gap_norm)
                    prop = (1.0 - f2) * tx_a + f2 * mean_ab
                    delta = prop - tx_a
                    cap_abs = 0.01 * max(tx_a, rx_b, 1.0)
                    delta = max(-cap_abs, min(cap_abs, delta))
                    hard_tx[a] = max(0.0, tx_a + delta)
                    conf_tx_link[a] *= 0.98
                elif cb <= ca and not (strong_scaled_rx.get(b, False) or clip_hit_rx.get(b, False)):
                    # Lower-confidence side is rx[b]
                    gap_norm = clamp01((mis_ab - 1.5 * th_ab) / max(1.5 * th_ab, 1e-9))
                    f2 = 0.2 * min(0.20, gap_norm)
                    prop = (1.0 - f2) * rx_b + f2 * mean_ab
                    delta = prop - rx_b
                    cap_abs = 0.01 * max(tx_a, rx_b, 1.0)
                    delta = max(-cap_abs, min(cap_abs, delta))
                    hard_rx[b] = max(0.0, rx_b + delta)
                    conf_rx_link[b] *= 0.98

        # b->a direction
        tx_b = hard_tx.get(b, 0.0)
        rx_a = hard_rx.get(a, 0.0)
        if max(tx_b, rx_a) >= ZERO_THRESH:
            cb_tx = clamp01(conf_tx_link.get(b, 0.6))
            ca_rx = clamp01(conf_rx_link.get(a, 0.6))
            th_ba = tau_h_dir(tx_b, rx_a, cb_tx, ca_rx)
            mis_ba = rel_diff(tx_b, rx_a)
            if mis_ba > 1.5 * th_ba:
                mean_ba = 0.5 * (tx_b + rx_a)
                if cb_tx < ca_rx and not (strong_scaled_tx.get(b, False) or clip_hit_tx.get(b, False)):
                    gap_norm = clamp01((mis_ba - 1.5 * th_ba) / max(1.5 * th_ba, 1e-9))
                    f2 = 0.2 * min(0.20, gap_norm)
                    prop = (1.0 - f2) * tx_b + f2 * mean_ba
                    delta = prop - tx_b
                    cap_abs = 0.01 * max(tx_b, rx_a, 1.0)
                    delta = max(-cap_abs, min(cap_abs, delta))
                    hard_tx[b] = max(0.0, tx_b + delta)
                    conf_tx_link[b] *= 0.98
                elif ca_rx <= cb_tx and not (strong_scaled_rx.get(a, False) or clip_hit_rx.get(a, False)):
                    gap_norm = clamp01((mis_ba - 1.5 * th_ba) / max(1.5 * th_ba, 1e-9))
                    f2 = 0.2 * min(0.20, gap_norm)
                    prop = (1.0 - f2) * rx_a + f2 * mean_ba
                    delta = prop - rx_a
                    cap_abs = 0.01 * max(tx_b, rx_a, 1.0)
                    delta = max(-cap_abs, min(cap_abs, delta))
                    hard_rx[a] = max(0.0, rx_a + delta)
                    conf_rx_link[a] *= 0.98

    # Status repair (conservative and symmetry-aware)
>>>>>>> REPLACE

</DIFF>