<NAME>
dominance_cap_and_micro_finisher
</NAME>

<DESCRIPTION>
We add three localized improvements:

1) Adaptive snap-to-peer in link fusion: for large mismatches, use a mismatch/status/zero-aware weight to bias more toward the peer when appropriate, improving link symmetry resolution without overcorrection.

2) Dominance-aware targeted scaling in router projection: when distributing delta within a router, cap any single interface’s applied change to at most 50% of the router’s total correction for that pass. This prevents over-reliance on a single skewed interface, improving stability and accuracy. Applied to both TX and RX targeted loops.

3) Micro high-confidence finishing tier: after targeted scaling (in both denom<eps and weighted branches), if residual router mismatch remains significant (>0.6×TAU_ROUTER_LOCAL), apply a tiny, damped adjustment (≤3% clip, 0.25 damping) to only high-confidence (≥0.85) active interfaces on the adjusted side to close stubborn gaps while preserving calibration.

These edits are minimal and consistent with existing thresholds and confidence logic.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
=======
        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        # Adaptive snap strength grows with mismatch and zero/status cues
        beta = 0.7 + 0.2 * clamp01((mismatch - 0.10) / 0.20)
        if (s_local == "down") or (v_local < ZERO_THRESH and v_peer >= ZERO_THRESH):
            beta += 0.1
        if s_peer == "down":
            beta -= 0.1
        beta = max(0.7, min(0.9, beta))
        fused = (1.0 - beta) * v_local + beta * v_peer
        return fused, clamp01(1.0 - mismatch)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if denom < EPS:
                    # Fallback to uniform damped scaling
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_tx[i] *= alpha_eff
                        scaled_tx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                else:
                    k = delta / denom
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        if v < EPS or w <= 0.0:
                            continue
                        # Damped, clipped per-interface scaling
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.90, min(1.10, scale_i))
                        hard_tx[i] = v * scale_i
                        scaled_tx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                if denom < EPS:
                    # Fallback to uniform damped scaling
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_tx[i] *= alpha_eff
                        scaled_tx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                    # Micro high-confidence finishing tier to close stubborn gaps
                    sum_tx_cur = sum(hard_tx.get(j, 0.0) for j in if_list)
                    sum_rx_cur = sum(hard_rx.get(j, 0.0) for j in if_list)
                    mismatch_cur = rel_diff(sum_tx_cur, sum_rx_cur)
                    if mismatch_cur > 0.6 * TAU_ROUTER_LOCAL:
                        delta_res = sum_rx_cur - sum_tx_cur
                        elig = [j for j in if_list if hard_tx.get(j, 0.0) >= ZERO_THRESH and clamp01(conf_tx_link.get(j, 0.6)) >= 0.85]
                        sum_elig = sum(hard_tx.get(j, 0.0) for j in elig)
                        if sum_elig > EPS:
                            s_micro = 1.0 + 0.25 * (delta_res / sum_elig)
                            s_micro = max(0.97, min(1.03, s_micro))
                            for j in elig:
                                vj = hard_tx[j]
                                hard_tx[j] = vj * s_micro
                                scaled_tx_factor[j] *= s_micro
                                pen = clamp01(abs(s_micro - 1.0))
                                conf_tx_link[j] *= clamp01(1.0 - 0.2 * pen)
                else:
                    k = delta / denom
                    elig_count = sum(1 for w in weights if w > 0.0)
                    cap_abs = 0.5 * abs(delta) if elig_count >= 2 else None
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        if v < EPS or w <= 0.0:
                            continue
                        # Damped, clipped per-interface scaling with dominance cap
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.90, min(1.10, scale_i))
                        change_i = v * (scale_i - 1.0)
                        if cap_abs is not None and abs(change_i) > cap_abs:
                            scale_i = 1.0 + math.copysign(cap_abs, change_i) / max(v, EPS)
                            change_i = v * (scale_i - 1.0)
                        hard_tx[i] = v * scale_i
                        scaled_tx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                    # Micro high-confidence finishing tier to close stubborn gaps
                    sum_tx_cur = sum(hard_tx.get(j, 0.0) for j in if_list)
                    sum_rx_cur = sum(hard_rx.get(j, 0.0) for j in if_list)
                    mismatch_cur = rel_diff(sum_tx_cur, sum_rx_cur)
                    if mismatch_cur > 0.6 * TAU_ROUTER_LOCAL:
                        delta_res = sum_rx_cur - sum_tx_cur
                        elig = [j for j in if_list if hard_tx.get(j, 0.0) >= ZERO_THRESH and clamp01(conf_tx_link.get(j, 0.6)) >= 0.85]
                        sum_elig = sum(hard_tx.get(j, 0.0) for j in elig)
                        if sum_elig > EPS:
                            s_micro = 1.0 + 0.25 * (delta_res / sum_elig)
                            s_micro = max(0.97, min(1.03, s_micro))
                            for j in elig:
                                vj = hard_tx[j]
                                hard_tx[j] = vj * s_micro
                                scaled_tx_factor[j] *= s_micro
                                pen = clamp01(abs(s_micro - 1.0))
                                conf_tx_link[j] *= clamp01(1.0 - 0.2 * pen)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if denom < EPS:
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_rx[i] *= alpha_eff
                        scaled_rx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                else:
                    k = delta / denom
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        if v < EPS or w <= 0.0:
                            continue
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.90, min(1.10, scale_i))
                        hard_rx[i] = v * scale_i
                        scaled_rx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
=======
                if denom < EPS:
                    alpha = target / max(current, EPS)
                    alpha = max(0.85, min(1.15, alpha))
                    alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                    for i in if_list:
                        hard_rx[i] *= alpha_eff
                        scaled_rx_factor[i] *= alpha_eff
                        penalty = clamp01(abs(alpha_eff - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                    # Micro high-confidence finishing tier to close stubborn gaps
                    sum_tx_cur = sum(hard_tx.get(j, 0.0) for j in if_list)
                    sum_rx_cur = sum(hard_rx.get(j, 0.0) for j in if_list)
                    mismatch_cur = rel_diff(sum_tx_cur, sum_rx_cur)
                    if mismatch_cur > 0.6 * TAU_ROUTER_LOCAL:
                        delta_res = sum_tx_cur - sum_rx_cur
                        elig = [j for j in if_list if hard_rx.get(j, 0.0) >= ZERO_THRESH and clamp01(conf_rx_link.get(j, 0.6)) >= 0.85]
                        sum_elig = sum(hard_rx.get(j, 0.0) for j in elig)
                        if sum_elig > EPS:
                            s_micro = 1.0 + 0.25 * (delta_res / sum_elig)
                            s_micro = max(0.97, min(1.03, s_micro))
                            for j in elig:
                                vj = hard_rx[j]
                                hard_rx[j] = vj * s_micro
                                scaled_rx_factor[j] *= s_micro
                                pen = clamp01(abs(s_micro - 1.0))
                                conf_rx_link[j] *= clamp01(1.0 - 0.2 * pen)
                else:
                    k = delta / denom
                    elig_count = sum(1 for w in weights if w > 0.0)
                    cap_abs = 0.5 * abs(delta) if elig_count >= 2 else None
                    for idx, i in enumerate(if_list):
                        v = vals[idx]
                        w = weights[idx]
                        if v < EPS or w <= 0.0:
                            continue
                        # Damped, clipped per-interface scaling with dominance cap
                        scale_i = 1.0 + 0.6 * (k * w)
                        scale_i = max(0.90, min(1.10, scale_i))
                        change_i = v * (scale_i - 1.0)
                        if cap_abs is not None and abs(change_i) > cap_abs:
                            scale_i = 1.0 + math.copysign(cap_abs, change_i) / max(v, EPS)
                            change_i = v * (scale_i - 1.0)
                        hard_rx[i] = v * scale_i
                        scaled_rx_factor[i] *= scale_i
                        penalty = clamp01(abs(scale_i - 1.0))
                        conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
                    # Micro high-confidence finishing tier to close stubborn gaps
                    sum_tx_cur = sum(hard_tx.get(j, 0.0) for j in if_list)
                    sum_rx_cur = sum(hard_rx.get(j, 0.0) for j in if_list)
                    mismatch_cur = rel_diff(sum_tx_cur, sum_rx_cur)
                    if mismatch_cur > 0.6 * TAU_ROUTER_LOCAL:
                        delta_res = sum_tx_cur - sum_rx_cur
                        elig = [j for j in if_list if hard_rx.get(j, 0.0) >= ZERO_THRESH and clamp01(conf_rx_link.get(j, 0.6)) >= 0.85]
                        sum_elig = sum(hard_rx.get(j, 0.0) for j in elig)
                        if sum_elig > EPS:
                            s_micro = 1.0 + 0.25 * (delta_res / sum_elig)
                            s_micro = max(0.97, min(1.03, s_micro))
                            for j in elig:
                                vj = hard_rx[j]
                                hard_rx[j] = vj * s_micro
                                scaled_rx_factor[j] *= s_micro
                                pen = clamp01(abs(s_micro - 1.0))
                                conf_rx_link[j] *= clamp01(1.0 - 0.2 * pen)
>>>>>>> REPLACE
</DIFF>