<NAME>
weighted_symmetry_and_linkdown_zeroing
</NAME>

<DESCRIPTION>
I propose two targeted changes to improve counter repair accuracy while maintaining strong confidence calibration and status accuracy:

1) Link-down zeroing using peer status: Previously, if my interface was up but the peer reported down, we would keep my local counters and only reduce confidence. In a physical link, if either side is down, the link cannot carry traffic. I change the pairwise hardening logic to force traffic to 0 when either endpoint reports down (when the peer is known), with appropriately high confidence. This should noticeably improve accuracy in asymmetric-down scenarios.

2) Confidence-weighted final symmetry (R3): Router-level flow conservation may perturb per-link symmetry. I add a final pass that enforces a.tx == b.rx and a.rx == b.tx using confidence-weighted averaging, rather than simple averaging. This uses the more reliable signal more heavily and slightly penalizes confidence in proportion to the applied adjustment. This should raise counter accuracy and preserve calibration.

These changes are conservative, localized, and adhere to the Hodor principles: using redundancy, enforcing invariants, and calibrating confidence based on the magnitude of correction.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        else:
            # If peer missing or either side is down/unknown: rely on local, but reduce confidence
            if my_up:
                hardened_tx_val = my_tx
                hardened_rx_val = my_rx
                # Lower baseline confidence without redundancy
                base_tx_conf = 0.6
                base_rx_conf = 0.6
            else:
                # Interface down cannot send/receive
                hardened_tx_val = 0.0
                hardened_rx_val = 0.0
                base_tx_conf = 0.8  # Strong invariant: down -> zero traffic
                base_rx_conf = 0.8
=======
        else:
            # If either endpoint reports down on this link, traffic should be zero on both sides.
            if peer_data and (not my_up or not peer_up):
                hardened_tx_val = 0.0
                hardened_rx_val = 0.0
                base_tx_conf = 0.85  # Strong invariant: link down -> zero
                base_rx_conf = 0.85
            elif my_up:
                # Peer missing: rely on local but lower confidence due to lack of redundancy
                hardened_tx_val = my_tx
                hardened_rx_val = my_rx
                base_tx_conf = 0.6
                base_rx_conf = 0.6
            else:
                # Local interface down cannot send/receive
                hardened_tx_val = 0.0
                hardened_rx_val = 0.0
                base_tx_conf = 0.85
                base_rx_conf = 0.85
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Finalize: enforce zero rates on down interfaces, and prepare output
=======
    # Final symmetry touch-up (R3) using confidence-weighted averaging
    processed_pairs = set()
    for a in telemetry:
        b = peer_of.get(a)
        if not b or b not in telemetry or (b, a) in processed_pairs or a == b:
            continue
        processed_pairs.add((a, b))

        # If either side is down, force both sides' rates on the link to zero with high confidence
        if status.get(a) == 'down' or status.get(b) == 'down':
            hardened_tx[a] = 0.0
            hardened_rx[a] = 0.0
            hardened_tx[b] = 0.0
            hardened_rx[b] = 0.0
            conf_tx[a] = max(conf_tx.get(a, 0.5), 0.85)
            conf_rx[a] = max(conf_rx.get(a, 0.5), 0.85)
            conf_tx[b] = max(conf_tx.get(b, 0.5), 0.85)
            conf_rx[b] = max(conf_rx.get(b, 0.5), 0.85)
            continue

        w_tx_a = max(1e-6, conf_tx.get(a, 0.5))
        w_rx_b = max(1e-6, conf_rx.get(b, 0.5))
        w_rx_a = max(1e-6, conf_rx.get(a, 0.5))
        w_tx_b = max(1e-6, conf_tx.get(b, 0.5))

        v1_old_a = hardened_tx.get(a, 0.0)
        v1_old_b = hardened_rx.get(b, 0.0)
        v2_old_a = hardened_rx.get(a, 0.0)
        v2_old_b = hardened_tx.get(b, 0.0)

        v1 = (w_tx_a * v1_old_a + w_rx_b * v1_old_b) / (w_tx_a + w_rx_b)
        v2 = (w_rx_a * v2_old_a + w_tx_b * v2_old_b) / (w_rx_a + w_tx_b)

        def rel_change(new, old):
            return abs(new - old) / max(1.0, abs(old), abs(new))

        r1a = rel_change(v1, v1_old_a)
        r1b = rel_change(v1, v1_old_b)
        r2a = rel_change(v2, v2_old_a)
        r2b = rel_change(v2, v2_old_b)

        hardened_tx[a] = v1
        hardened_rx[b] = v1
        hardened_rx[a] = v2
        hardened_tx[b] = v2

        conf_tx[a] = clamp01(conf_tx.get(a, 0.5) * (1.0 - 0.5 * r1a))
        conf_rx[b] = clamp01(conf_rx.get(b, 0.5) * (1.0 - 0.5 * r1b))
        conf_rx[a] = clamp01(conf_rx.get(a, 0.5) * (1.0 - 0.5 * r2a))
        conf_tx[b] = clamp01(conf_tx.get(b, 0.5) * (1.0 - 0.5 * r2b))

    # Finalize: enforce zero rates on down interfaces, and prepare output
>>>>>>> REPLACE
</DIFF>