<NAME>
adaptive_tau_softzero_scaleconf
</NAME>

<DESCRIPTION>
I propose three targeted improvements to increase counter accuracy and confidence calibration, inspired by the Hodor principles and the provided recommendations:

1) Adaptive link tolerance (TAU_H): Replace the fixed 2% symmetry tolerance with an adaptive threshold per direction: 1.5% for high-rate links (both sides â‰¥100 Mbps), 2% baseline, and 3% for near-zero traffic (either side <1 Mbps). This reduces over-correction on small flows and tightens matching on high-throughput links.

2) Soft-zero stabilization for quiescent links: If both endpoints are up and all four directional rates on a link are below 2*ZERO_THRESH (with ZERO_THRESH=1 Mbps), snap them to zero with high confidence. This suppresses noise and improves accuracy for idle links.

3) Confidence calibration with scale-factor term: Blend an explicit penalty term derived from the magnitude of router scaling into the final confidence (10% weight). This better aligns confidence with the extent of applied adjustments, improving calibration.

Additionally, the final re-sync (R3) now uses the adaptive tolerance instead of a fixed threshold. These changes are localized and preserve the existing router-level flow conservation logic, weights, and damping.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    ZERO_EPS = 1e-3

    def clamp01(x: float) -> float:
        return max(0.0, min(1.0, x))

    def rel_diff(a: float, b: float) -> float:
        return abs(a - b) / max(1.0, abs(a), abs(b))
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    ZERO_EPS = 1e-3
    # Soft-zero threshold for Mbps-scale counters
    ZERO_THRESH = 1.0

    def clamp01(x: float) -> float:
        return max(0.0, min(1.0, x))

    def rel_diff(a: float, b: float) -> float:
        return abs(a - b) / max(1.0, abs(a), abs(b))

    def compute_tau_h(v1: float, v2: float) -> float:
        """
        Adaptive symmetry tolerance:
        - 0.015 for high-rate pairs (>=100 Mbps both sides)
        - 0.03 for near-zero/low-rate (either side < 1 Mbps)
        - 0.02 baseline otherwise
        """
        if v1 >= 100.0 and v2 >= 100.0:
            return 0.015
        if v1 < ZERO_THRESH or v2 < ZERO_THRESH:
            return 0.03
        return HARDENING_THRESHOLD
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # If either side is down: enforce zero on both link directions with high confidence
        if not a_up or not b_up:
            hardened_rx[a] = 0.0
            hardened_tx[a] = 0.0
            hardened_rx[b] = 0.0
            hardened_tx[b] = 0.0
            conf_rx[a] = max(conf_rx[a], 0.85)
            conf_tx[a] = max(conf_tx[a], 0.85)
            conf_rx[b] = max(conf_rx[b], 0.85)
            conf_tx[b] = max(conf_tx[b], 0.85)
            continue

        # Direction 1: a.tx should match b.rx
        d1 = rel_diff(a_tx, b_rx)
        if d1 <= HARDENING_THRESHOLD:
            v1 = 0.5 * (a_tx + b_rx)
            hardened_tx[a] = max(0.0, v1)
            hardened_rx[b] = max(0.0, v1)
            c1 = clamp01(0.9 + 0.1 * (1.0 - d1 / max(HARDENING_THRESHOLD, 1e-12)))
            conf_tx[a] = max(conf_tx[a], c1)
            conf_rx[b] = max(conf_rx[b], c1)
        else:
            # Snap to peer's measurement for strong symmetry
            hardened_tx[a] = max(0.0, b_rx)
            hardened_rx[b] = max(0.0, b_rx)
            c1 = clamp01(1.0 - d1)
            conf_tx[a] = max(conf_tx[a], c1)
            conf_rx[b] = max(conf_rx[b], c1)

        # Direction 2: a.rx should match b.tx
        d2 = rel_diff(a_rx, b_tx)
        if d2 <= HARDENING_THRESHOLD:
            v2 = 0.5 * (a_rx + b_tx)
            hardened_rx[a] = max(0.0, v2)
            hardened_tx[b] = max(0.0, v2)
            c2 = clamp01(0.9 + 0.1 * (1.0 - d2 / max(HARDENING_THRESHOLD, 1e-12)))
            conf_rx[a] = max(conf_rx[a], c2)
            conf_tx[b] = max(conf_tx[b], c2)
        else:
            hardened_rx[a] = max(0.0, b_tx)
            hardened_tx[b] = max(0.0, b_tx)
            c2 = clamp01(1.0 - d2)
            conf_rx[a] = max(conf_rx[a], c2)
            conf_tx[b] = max(conf_tx[b], c2)
=======
        # If either side is down: enforce zero on both link directions with high confidence
        if not a_up or not b_up:
            hardened_rx[a] = 0.0
            hardened_tx[a] = 0.0
            hardened_rx[b] = 0.0
            hardened_tx[b] = 0.0
            conf_rx[a] = max(conf_rx[a], 0.85)
            conf_tx[a] = max(conf_tx[a], 0.85)
            conf_rx[b] = max(conf_rx[b], 0.85)
            conf_tx[b] = max(conf_tx[b], 0.85)
            continue

        # Soft-zero stabilization: both ends up and all four directions near zero
        if max(a_rx, a_tx, b_rx, b_tx) < 2.0 * ZERO_THRESH:
            hardened_rx[a] = 0.0
            hardened_tx[a] = 0.0
            hardened_rx[b] = 0.0
            hardened_tx[b] = 0.0
            conf_rx[a] = max(conf_rx[a], 0.95)
            conf_tx[a] = max(conf_tx[a], 0.95)
            conf_rx[b] = max(conf_rx[b], 0.95)
            conf_tx[b] = max(conf_tx[b], 0.95)
            continue

        # Direction 1: a.tx should match b.rx (adaptive tolerance)
        d1 = rel_diff(a_tx, b_rx)
        tau1 = compute_tau_h(a_tx, b_rx)
        if d1 <= tau1:
            v1 = 0.5 * (a_tx + b_rx)
            hardened_tx[a] = max(0.0, v1)
            hardened_rx[b] = max(0.0, v1)
            c1 = clamp01(0.9 + 0.1 * (1.0 - d1 / max(tau1, 1e-12)))
            conf_tx[a] = max(conf_tx[a], c1)
            conf_rx[b] = max(conf_rx[b], c1)
        else:
            # Snap to peer's measurement for strong symmetry
            hardened_tx[a] = max(0.0, b_rx)
            hardened_rx[b] = max(0.0, b_rx)
            c1 = clamp01(1.0 - d1)
            conf_tx[a] = max(conf_tx[a], c1)
            conf_rx[b] = max(conf_rx[b], c1)

        # Direction 2: a.rx should match b.tx (adaptive tolerance)
        d2 = rel_diff(a_rx, b_tx)
        tau2 = compute_tau_h(a_rx, b_tx)
        if d2 <= tau2:
            v2 = 0.5 * (a_rx + b_tx)
            hardened_rx[a] = max(0.0, v2)
            hardened_tx[b] = max(0.0, v2)
            c2 = clamp01(0.9 + 0.1 * (1.0 - d2 / max(tau2, 1e-12)))
            conf_rx[a] = max(conf_rx[a], c2)
            conf_tx[b] = max(conf_tx[b], c2)
        else:
            hardened_rx[a] = max(0.0, b_tx)
            hardened_tx[b] = max(0.0, b_tx)
            c2 = clamp01(1.0 - d2)
            conf_rx[a] = max(conf_rx[a], c2)
            conf_tx[b] = max(conf_tx[b], c2)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            if d1 > HARDENING_THRESHOLD:
                conf_a_tx = conf_tx.get(a, 0.6)
                conf_b_rx = conf_rx.get(b, 0.6)
                if conf_a_tx >= conf_b_rx:
                    # Nudge lower-confidence side (b.rx) unless it had strong router scaling
                    if abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_a_tx - conf_b_rx))
                        if f > 0.0:
                            old = b_rx
                            new = nudge_one_side(old, a_tx, f)
                            hardened_rx[b] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_rx[b] = clamp01(conf_rx.get(b, 0.6) * (1.0 - 0.3 * relc))
                else:
                    # Nudge lower-confidence side (a.tx) unless it had strong router scaling
                    if abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_b_rx - conf_a_tx))
                        if f > 0.0:
                            old = a_tx
                            new = nudge_one_side(old, b_rx, f)
                            hardened_tx[a] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_tx[a] = clamp01(conf_tx.get(a, 0.6) * (1.0 - 0.3 * relc))
=======
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = compute_tau_h(a_tx, b_rx)
            if d1 > tau1:
                conf_a_tx = conf_tx.get(a, 0.6)
                conf_b_rx = conf_rx.get(b, 0.6)
                if conf_a_tx >= conf_b_rx:
                    # Nudge lower-confidence side (b.rx) unless it had strong router scaling
                    if abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_a_tx - conf_b_rx))
                        if f > 0.0:
                            old = b_rx
                            new = nudge_one_side(old, a_tx, f)
                            hardened_rx[b] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_rx[b] = clamp01(conf_rx.get(b, 0.6) * (1.0 - 0.3 * relc))
                else:
                    # Nudge lower-confidence side (a.tx) unless it had strong router scaling
                    if abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_b_rx - conf_a_tx))
                        if f > 0.0:
                            old = a_tx
                            new = nudge_one_side(old, b_rx, f)
                            hardened_tx[a] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_tx[a] = clamp01(conf_tx.get(a, 0.6) * (1.0 - 0.3 * relc))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            if d2 > HARDENING_THRESHOLD:
                conf_a_rx = conf_rx.get(a, 0.6)
                conf_b_tx = conf_tx.get(b, 0.6)
                if conf_a_rx >= conf_b_tx:
                    # Nudge lower-confidence side (b.tx) unless it had strong router scaling
                    if abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_a_rx - conf_b_tx))
                        if f > 0.0:
                            old = b_tx
                            new = nudge_one_side(old, a_rx, f)
                            hardened_tx[b] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_tx[b] = clamp01(conf_tx.get(b, 0.6) * (1.0 - 0.3 * relc))
                else:
                    # Nudge lower-confidence side (a.rx) unless it had strong router scaling
                    if abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_b_tx - conf_a_rx))
                        if f > 0.0:
                            old = a_rx
                            new = nudge_one_side(old, b_tx, f)
                            hardened_rx[a] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_rx[a] = clamp01(conf_rx.get(a, 0.6) * (1.0 - 0.3 * relc))
=======
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = compute_tau_h(a_rx, b_tx)
            if d2 > tau2:
                conf_a_rx = conf_rx.get(a, 0.6)
                conf_b_tx = conf_tx.get(b, 0.6)
                if conf_a_rx >= conf_b_tx:
                    # Nudge lower-confidence side (b.tx) unless it had strong router scaling
                    if abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_a_rx - conf_b_tx))
                        if f > 0.0:
                            old = b_tx
                            new = nudge_one_side(old, a_rx, f)
                            hardened_tx[b] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_tx[b] = clamp01(conf_tx.get(b, 0.6) * (1.0 - 0.3 * relc))
                else:
                    # Nudge lower-confidence side (a.rx) unless it had strong router scaling
                    if abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= 0.08:
                        f = min(0.4, max(0.0, conf_b_tx - conf_a_rx))
                        if f > 0.0:
                            old = a_rx
                            new = nudge_one_side(old, b_tx, f)
                            hardened_rx[a] = max(0.0, new)
                            relc = abs(new - old) / max(1.0, abs(old), abs(new))
                            conf_rx[a] = clamp01(conf_rx.get(a, 0.6) * (1.0 - 0.3 * relc))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        rx_c = clamp01(conf_rx.get(i, 0.6))
        tx_c = clamp01(conf_tx.get(i, 0.6))
=======
        rx_c_base = clamp01(conf_rx.get(i, 0.6))
        tx_c_base = clamp01(conf_tx.get(i, 0.6))
        # Include a small (10%) confidence component tied to the magnitude of router scaling
        alpha_rx = abs(scaled_rx_factor.get(i, 1.0) - 1.0)
        alpha_tx = abs(scaled_tx_factor.get(i, 1.0) - 1.0)
        scale_term_rx = clamp01(1.0 - min(0.5, alpha_rx))
        scale_term_tx = clamp01(1.0 - min(0.5, alpha_tx))
        rx_c = clamp01(0.9 * rx_c_base + 0.1 * scale_term_rx)
        tx_c = clamp01(0.9 * tx_c_base + 0.1 * scale_term_tx)
>>>>>>> REPLACE
</DIFF>