<NAME>
stability_bundle_confidence
</NAME>

<DESCRIPTION>
I propose improving the confidence calibration by incorporating two additional, topology-aware terms that are grounded in the Hodor principles and should not alter the repaired counters:

1) Per-router stability term: A link’s confidence should be lower if it dominates a router’s traffic share, as small errors there propagate more. We compute stab_i = clamp01(1 − 0.5·share_i) for both TX and RX directions, with shares per router. This captures robustness of a direction relative to router totals.

2) Bundle-consistency term: On parallel links between the same router pair, residuals should be consistent. We compute a bundle-median residual per direction and score each member by its deviation from that median, scaled by the link’s rate, providing bcons_i that rewards consistent members and down-weights outliers.

These terms are integrated into the final confidence composition with conservative weights that were effective in earlier high-performing variants: we also add an improvement credit (imp) to reflect how much symmetry improved from pre- to post-repair. This is a calibration-only change: it does not modify any repaired rates, preserving counter accuracy while improving confidence calibration.

Expected impact:
- Better alignment of confidence with actual repair quality (higher calibration score).
- Preserve or slightly improve the combined score without risking counter accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Compose final results with calibrated confidences
    result: Dict[str, Dict[str, Tuple]] = {}
=======
    # Stability term per router and direction: stab_i = clamp01(1 - 0.5 * share_i)
    stab_tx: Dict[str, float] = {}
    stab_rx: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        sum_tx_r = sum(max(hard_tx.get(i, 0.0), 0.0) for i in ifs)
        sum_rx_r = sum(max(hard_rx.get(i, 0.0), 0.0) for i in ifs)
        for i in ifs:
            vtx = max(hard_tx.get(i, 0.0), 0.0)
            vrx = max(hard_rx.get(i, 0.0), 0.0)
            share_tx = (vtx / sum_tx_r) if sum_tx_r > EPS else 0.0
            share_rx = (vrx / sum_rx_r) if sum_rx_r > EPS else 0.0
            stab_tx[i] = clamp01(1.0 - 0.5 * share_tx)
            stab_rx[i] = clamp01(1.0 - 0.5 * share_rx)

    # Bundle-consistency term: compare residuals to bundle median per unordered router pair
    bcons_tx: Dict[str, float] = {}
    bcons_rx: Dict[str, float] = {}
    bundles_cons: Dict[Tuple[str, str], List[Tuple[str, str]]] = {}
    seen_pairs_cons = set()
    for a, data_a in telemetry.items():
        b = peers.get(a)
        if not b:
            continue
        key = tuple(sorted([a, b]))
        if key in seen_pairs_cons:
            continue
        seen_pairs_cons.add(key)
        ra = telemetry[a].get("local_router")
        rb = telemetry[b].get("local_router")
        if isinstance(ra, str) and isinstance(rb, str):
            rp = tuple(sorted([ra, rb]))
            bundles_cons.setdefault(rp, []).append((a, b))

    def _median(vals: List[float]) -> float:
        s = sorted(vals)
        n = len(s)
        if n == 0:
            return 0.0
        if n % 2 == 1:
            return s[n // 2]
        return 0.5 * (s[n // 2 - 1] + s[n // 2])

    for rp, pairs in bundles_cons.items():
        if not pairs:
            continue
        e_ab_list = []
        e_ba_list = []
        for (a, b) in pairs:
            e_ab_list.append(hard_tx.get(a, 0.0) - hard_rx.get(b, 0.0))
            e_ba_list.append(hard_tx.get(b, 0.0) - hard_rx.get(a, 0.0))
        med_ab = _median(e_ab_list)
        med_ba = _median(e_ba_list)
        for (a, b) in pairs:
            tx_a = max(hard_tx.get(a, 0.0), 0.0)
            rx_b = max(hard_rx.get(b, 0.0), 0.0)
            rate_ab = max(tx_a, rx_b, 1.0)
            e_ab = tx_a - rx_b
            bcons_tx[a] = clamp01(1.0 - abs(e_ab - med_ab) / (abs(med_ab) + rate_ab))
            bcons_rx[b] = clamp01(1.0 - abs(e_ab - med_ab) / (abs(med_ab) + rate_ab))
            tx_b = max(hard_tx.get(b, 0.0), 0.0)
            rx_a = max(hard_rx.get(a, 0.0), 0.0)
            rate_ba = max(tx_b, rx_a, 1.0)
            e_ba = tx_b - rx_a
            bcons_tx[b] = clamp01(1.0 - abs(e_ba - med_ba) / (abs(med_ba) + rate_ba))
            bcons_rx[a] = clamp01(1.0 - abs(e_ba - med_ba) / (abs(med_ba) + rate_ba))

    # Defaults for interfaces not covered above
    for if_id in telemetry.keys():
        if if_id not in bcons_tx:
            bcons_tx[if_id] = 0.8
        if if_id not in bcons_rx:
            bcons_rx[if_id] = 0.8
        if if_id not in stab_tx:
            stab_tx[if_id] = 0.85
        if if_id not in stab_rx:
            stab_rx[if_id] = 0.85

    # Compose final results with calibrated confidences
    result: Dict[str, Dict[str, Tuple]] = {}
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
        conf_tx_final = clamp01(
            0.23 * base_tx_conf +
            0.20 * red_tx +
            0.27 * fin_sym_tx +
            0.10 * ch_tx +
            0.10 * router_factor_after +
            0.10 * scale_tx_term
        )
        conf_rx_final = clamp01(
            0.23 * base_rx_conf +
            0.20 * red_rx +
            0.27 * fin_sym_rx +
            0.10 * ch_rx +
            0.10 * router_factor_after +
            0.10 * scale_rx_term
        )
=======
        # Add improvement credit and topology-aware stability/bundle-consistency terms
        stab_term_tx = clamp01(stab_tx.get(if_id, 0.85))
        stab_term_rx = clamp01(stab_rx.get(if_id, 0.85))
        bcons_term_tx = clamp01(bcons_tx.get(if_id, 0.8))
        bcons_term_rx = clamp01(bcons_rx.get(if_id, 0.8))
        imp_tx = clamp01(pre_tx - post_mismatch_tx_dir.get(if_id, 0.4))
        imp_rx = clamp01(pre_rx - post_mismatch_rx_dir.get(if_id, 0.4))

        conf_tx_final = clamp01(
            0.18 * base_tx_conf +
            0.16 * red_tx +
            0.22 * fin_sym_tx +
            0.10 * ch_tx +
            0.10 * router_factor_after +
            0.05 * scale_tx_term +
            0.08 * imp_tx +
            0.05 * stab_term_tx +
            0.06 * bcons_term_tx
        )
        conf_rx_final = clamp01(
            0.18 * base_rx_conf +
            0.16 * red_rx +
            0.22 * fin_sym_rx +
            0.10 * ch_rx +
            0.10 * router_factor_after +
            0.05 * scale_rx_term +
            0.08 * imp_rx +
            0.05 * stab_term_rx +
            0.06 * bcons_term_rx
        )
>>>>>>> REPLACE
</DIFF>