<NAME>
router_imbalance_resync_conf_refine
</NAME>

<DESCRIPTION>
I propose four targeted improvements aligned with Hodor’s principles and the provided recommendations to increase counter repair accuracy and tighten confidence calibration without overhauling the algorithm:

1) Add dominance cap and clip-hit tracking in router correction:
   - Cap any single interface’s share of the correction to ≤50% in the targeted router adjustments (both non-majority and no-dominant-bundle paths).
   - Track clip hits per direction when relative per-interface scaling reaches the cap or exceeds ±10%. This prevents over-reliance on one interface and feeds into later confidence penalties.

2) Post-router soft-zero stabilization with router-imbalance guard:
   - After router corrections, if a link is near-zero and both adjacent routers are within the adaptive router tolerance, snap both directions to zero with high confidence.
   - This reduces jitter and aligns with the soft-zero rule when the network appears balanced.

3) Re-sync attenuation by router imbalance:
   - In the one-sided confidence-gap re-sync, attenuate the nudge by the local routers’ residual imbalance: f *= clamp01(1 − max(residual_ra, residual_rb)). This avoids double-adjustment on links when routers remain imbalanced.

4) Confidence calibration refinements:
   - Apply a mild clip-hit penalty (×0.95) when a direction’s scaling was clipped or |scale_factor − 1| ≥ 0.10.
   - Add a small untouched boost (+0.02 up to 0.98) when a direction changed <1% and final symmetry is within adaptive tolerance.
   - Keep the existing peer smoothing.

These changes are minimal yet impactful: they better allocate corrections, stabilize near-zero behavior, avoid over-adjusting in unsettled routers, and calibrate confidence to actual repair quality.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Hyperparameters
    TAU_H_BASE = 0.02        # ~2% hardening threshold
    ZERO_EPS = 1e-6
    ZERO_THRESH = 1.0        # Mbps near-zero threshold
    DAMP_ROUTER = 0.60       # router damping factor
    PER_LINK_CLIP = 0.10     # per-interface relative change cap (±10%)
    BUNDLE_CLIP = 0.15       # bundle shared factor cap (±15%)
    STRONG_SCALE_GUARD = 0.08  # guard for re-sync when strong router scaling applied
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
    WEIGHT_FOCUS = 0.70      # focus router correction on lowest-confidence 70% weight
=======
    # Hyperparameters
    TAU_H_BASE = 0.02        # ~2% hardening threshold
    ZERO_EPS = 1e-6
    ZERO_THRESH = 1.0        # Mbps near-zero threshold
    DAMP_ROUTER = 0.60       # router damping factor
    PER_LINK_CLIP = 0.10     # per-interface relative change cap (±10%)
    BUNDLE_CLIP = 0.15       # bundle shared factor cap (±15%)
    STRONG_SCALE_GUARD = 0.08  # guard for re-sync when strong router scaling applied
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
    WEIGHT_FOCUS = 0.70      # focus router correction on lowest-confidence 70% weight
    DOMINANCE_CAP = 0.50     # cap any single interface's weight share to ≤50% in a pass
    INTRA_BUNDLE_CLIP = 0.05 # ±5% intra-bundle smoothing cap (used in soft-zero stage if needed)
    CLIP_HIT_PENALTY = 0.95  # confidence penalty multiplier when clipping/strong scaling hit
    UNTOUCHED_BOOST = 0.02   # confidence boost for untouched, well-synced counters
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Track cumulative router scaling factors for re-sync guard and confidence
    scaled_rx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    scaled_tx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
=======
    # Track cumulative router scaling factors for re-sync guard and confidence
    scaled_rx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    scaled_tx_factor: Dict[str, float] = {i: 1.0 for i in telemetry}
    # Track if a direction hit clipping (±10% per-pass cap or strong scaling)
    clip_hit_rx: Dict[str, bool] = {i: False for i in telemetry}
    clip_hit_tx: Dict[str, bool] = {i: False for i in telemetry}
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                adj_nm = total_adjust * (nm_total_w / focus_total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = weights[i] / nm_total_w
                    adj_i = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i, -cap), cap)
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        prev = hardened_rx[i]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[i] *= (v_new / prev)
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[i]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[i] *= (v_new / prev)
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
=======
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                # Apply dominance cap on per-interface weight shares within this pass
                cap_per = DOMINANCE_CAP * nm_total_w
                eff_weights = {i: min(weights[i], cap_per) for i in non_majority}
                eff_total_w = max(1e-9, sum(eff_weights.values()))
                adj_nm = total_adjust * (nm_total_w / focus_total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = eff_weights[i] / eff_total_w
                    adj_i_raw = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i_raw, -cap), cap)
                    # Mark clip-hit when cap engaged
                    if abs(adj_i) >= cap - 1e-12:
                        if adjust_side == 'rx':
                            clip_hit_rx[i] = True
                        else:
                            clip_hit_tx[i] = True
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        prev = hardened_rx[i]
                        if prev > ZERO_EPS:
                            scl = (v_new / prev)
                            scaled_rx_factor[i] *= scl
                            if abs(scl - 1.0) >= 0.10:
                                clip_hit_rx[i] = True
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[i]
                        if prev > ZERO_EPS:
                            scl = (v_new / prev)
                            scaled_tx_factor[i] *= scl
                            if abs(scl - 1.0) >= 0.10:
                                clip_hit_tx[i] = True
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        else:
            # No dominant bundle: targeted per-interface corrections only over focus_set
            for i in focus_set:
                v_old = side_vals[i]
                w_i = weights[i] / focus_total_w
                adj_i = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i, -cap), cap)
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    prev = hardened_rx[i]
                    if prev > ZERO_EPS:
                        scaled_rx_factor[i] *= (v_new / prev)
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    prev = hardened_tx[i]
                    if prev > ZERO_EPS:
                        scaled_tx_factor[i] *= (v_new / prev)
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
=======
        else:
            # No dominant bundle: targeted per-interface corrections only over focus_set
            # Apply dominance cap on per-interface weight shares within this pass
            cap_per = DOMINANCE_CAP * focus_total_w
            eff_weights = {i: min(weights[i], cap_per) for i in focus_set}
            eff_total_w = max(1e-9, sum(eff_weights.values()))
            for i in focus_set:
                v_old = side_vals[i]
                w_i = eff_weights[i] / eff_total_w
                adj_i_raw = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i_raw, -cap), cap)
                # Mark clip-hit when cap engaged
                if abs(adj_i) >= cap - 1e-12:
                    if adjust_side == 'rx':
                        clip_hit_rx[i] = True
                    else:
                        clip_hit_tx[i] = True
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    prev = hardened_rx[i]
                    if prev > ZERO_EPS:
                        scl = (v_new / prev)
                        scaled_rx_factor[i] *= scl
                        if abs(scl - 1.0) >= 0.10:
                            clip_hit_rx[i] = True
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    prev = hardened_tx[i]
                    if prev > ZERO_EPS:
                        scl = (v_new / prev)
                        scaled_tx_factor[i] *= scl
                        if abs(scl - 1.0) >= 0.10:
                            clip_hit_tx[i] = True
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Stage 3: Confidence-gap-proportional re-sync with scaling guard
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = hardened_tx[a], hardened_rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.6), conf_rx.get(b, 0.6)
                # Skip if strong router scaling already applied on the target direction
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb))
                    if f > 0.0:
                        old = b_rx
                        new = max(0.0, nudge_toward_mean(old, a_tx, f))
                        hardened_rx[b] = new
                        relc = rel_diff(new, old)
                        conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca))
                    if f > 0.0:
                        old = a_tx
                        new = max(0.0, nudge_toward_mean(old, b_rx, f))
                        hardened_tx[a] = new
                        relc = rel_diff(new, old)
                        conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * relc))

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = hardened_rx[a], hardened_tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.6), conf_tx.get(b, 0.6)
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb))
                    if f > 0.0:
                        old = b_tx
                        new = max(0.0, nudge_toward_mean(old, a_rx, f))
                        hardened_tx[b] = new
                        relc = rel_diff(new, old)
                        conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca))
                    if f > 0.0:
                        old = a_rx
                        new = max(0.0, nudge_toward_mean(old, b_tx, f))
                        hardened_rx[a] = new
                        relc = rel_diff(new, old)
                        conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * relc))
=======
    # Stage 2.5: Post-router soft-zero stabilization and residual computation for re-sync attenuation
    # Compute per-router residuals after Stage 2 for attenuation and soft-zero decisions
    router_residual_mid: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        ups = [i for i in ifs if status.get(i) == 'up']
        if not ups:
            router_residual_mid[r] = 0.0
            continue
        srx = sum(hardened_rx[i] for i in ups)
        stx = sum(hardened_tx[i] for i in ups)
        denomr = max(1.0, srx, stx)
        router_residual_mid[r] = abs(srx - stx) / denomr

    # Soft-zero stabilization: if link tiny and adjacent routers close to balanced, snap to zero
    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue
        if max(hardened_rx[a], hardened_tx[a], hardened_rx[b], hardened_tx[b]) < 2.0 * ZERO_THRESH:
            ra = local_router_of.get(a)
            rb = local_router_of.get(b)
            n_active_a = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
            n_active_b = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
            tau_ra = min(0.07, max(0.03, 0.05 * (2.0 / max(2, n_active_a)) ** 0.5))
            tau_rb = min(0.07, max(0.03, 0.05 * (2.0 / max(2, n_active_b)) ** 0.5))
            if router_residual_mid.get(ra, 0.0) <= tau_ra and router_residual_mid.get(rb, 0.0) <= tau_rb:
                hardened_rx[a] = hardened_tx[a] = hardened_rx[b] = hardened_tx[b] = 0.0
                conf_rx[a] = max(conf_rx[a], 0.95)
                conf_tx[a] = max(conf_tx[a], 0.95)
                conf_rx[b] = max(conf_rx[b], 0.95)
                conf_tx[b] = max(conf_tx[b], 0.95)

    # Stage 3: Confidence-gap-proportional re-sync with scaling guard and router-imbalance attenuation
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Attenuation from local router imbalances
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = clamp01(1.0 - max(router_residual_mid.get(ra, 0.0), router_residual_mid.get(rb, 0.0)))

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = hardened_tx[a], hardened_rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.6), conf_rx.get(b, 0.6)
                # Skip if strong router scaling already applied on the target direction
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_rx
                        new = max(0.0, nudge_toward_mean(old, a_tx, f))
                        hardened_rx[b] = new
                        relc = rel_diff(new, old)
                        conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_tx
                        new = max(0.0, nudge_toward_mean(old, b_rx, f))
                        hardened_tx[a] = new
                        relc = rel_diff(new, old)
                        conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * relc))

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = hardened_rx[a], hardened_tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.6), conf_tx.get(b, 0.6)
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_tx
                        new = max(0.0, nudge_toward_mean(old, a_rx, f))
                        hardened_tx[b] = new
                        relc = rel_diff(new, old)
                        conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_rx
                        new = max(0.0, nudge_toward_mean(old, b_tx, f))
                        hardened_rx[a] = new
                        relc = rel_diff(new, old)
                        conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * relc))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Compute confidences
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
=======
    # Compute confidences
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
        # Clip-hit penalty when strong scaling occurred (>=10%) or cap hit
        if abs(scaled_rx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_rx.get(i, False):
            conf_rx[i] = clamp01(conf_rx[i] * CLIP_HIT_PENALTY)
        if abs(scaled_tx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_tx.get(i, False):
            conf_tx[i] = clamp01(conf_tx[i] * CLIP_HIT_PENALTY)
        # Untouched boost when minimal change (<1%) and good final symmetry on link
        p = peer_of.get(i)
        if p and p in telemetry and status.get(i) == 'up' and status.get(p) == 'up':
            # RX direction: small change and good symmetry vs peer TX
            if rel_diff(hardened_rx[i], orig_rx[i]) < 0.01:
                if rel_diff(hardened_rx[i], hardened_tx[p]) <= adaptive_tau(hardened_rx[i], hardened_tx[p]):
                    conf_rx[i] = min(0.98, conf_rx[i] + UNTOUCHED_BOOST)
            # TX direction: small change and good symmetry vs peer RX
            if rel_diff(hardened_tx[i], orig_tx[i]) < 0.01:
                if rel_diff(hardened_tx[i], hardened_rx[p]) <= adaptive_tau(hardened_tx[i], hardened_rx[p]):
                    conf_tx[i] = min(0.98, conf_tx[i] + UNTOUCHED_BOOST)
>>>>>>> REPLACE

</DIFF>