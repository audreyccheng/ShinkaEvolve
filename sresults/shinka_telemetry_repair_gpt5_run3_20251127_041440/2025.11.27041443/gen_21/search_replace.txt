<NAME>
adaptive_tau_and_residual_router_nudge
</NAME>

<DESCRIPTION>
I propose three synergistic improvements to raise counter accuracy while keeping confidence well-calibrated:

1) Adaptive link tolerance during initial fusion: The Stage 1 fuse_direction used a fixed 2% tolerance. I switch it to an adaptive hardening threshold (tight at high rates, loose when rates are tiny), reducing unnecessary changes on healthy links and improving stability in low-rate noise. This mirrors the adaptive re-sync already used post-projection for consistency.

2) Residual router balancing pass: After the targeted router scaling, a small residual imbalance may remain due to per-interface clipping and damping. I add a second, very small, uniform nudge (Â±3% capped, 60% damped, lighter confidence penalty) toward flow conservation on the lower-confidence side. This preserves the targeted nature of Stage 2 while ensuring routers converge closer to flow conservation.

3) Severity-weighted link re-sync: The Stage 2.5 one-sided re-sync already uses confidence gaps and guards against double-scaling. I now scale the nudge fraction by mismatch severity relative to the adaptive tolerance, so larger symmetry violations receive proportionally stronger nudges, and near-threshold mismatches get gentler adjustments. This further improves counter repairs without overcorrecting and keeps confidence penalties proportional to actual adjustment.

These changes build on the existing targeted algorithm, aiming to improve flow-conservation adherence and link symmetry repairs, thus improving counter accuracy and confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Within tolerance, keep local reading
        if mismatch <= TAU_H_BASE:
            return v_local, 0.95
=======
        # Within tolerance (adaptive), keep local reading
        th_local = adapt_tau_h(v_local, v_peer, 0.8, 0.8)
        if mismatch <= th_local:
            return v_local, 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Stage 2.5: Post-projection gentle link re-sync (confidence-gap-proportional, with scaling guard)
=======
    # Residual router balancing pass: small uniform nudge if still imbalanced beyond tolerance
    for router, if_list in router_ifaces.items():
        if len(if_list) <= 1:
            continue
        sum_tx = sum(hard_tx.get(i, 0.0) for i in if_list)
        sum_rx = sum(hard_rx.get(i, 0.0) for i in if_list)
        if max(sum_tx, sum_rx) < EPS:
            continue
        n_active_tx = sum(1 for i in if_list if hard_tx.get(i, 0.0) >= ZERO_THRESH)
        n_active_rx = sum(1 for i in if_list if hard_rx.get(i, 0.0) >= ZERO_THRESH)
        tau_router_res = adaptive_router_tol(max(n_active_tx, n_active_rx))
        if rel_diff(sum_tx, sum_rx) > tau_router_res:
            # Adjust the lower-confidence side with a very small uniform scaling
            c_tx_total = sum(conf_tx_link.get(i, 0.6) for i in if_list)
            c_rx_total = sum(conf_rx_link.get(i, 0.6) for i in if_list)
            side = "tx" if c_tx_total < c_rx_total else "rx"
            if side == "tx" and sum_tx > 0:
                alpha2 = clamp(sum_rx / max(sum_tx, EPS), 0.97, 1.03)
                alpha2_eff = 1.0 + 0.6 * (alpha2 - 1.0)
                for i in if_list:
                    hard_tx[i] *= alpha2_eff
                    scaled_tx_factor[i] *= alpha2_eff
                    penalty2 = abs(alpha2_eff - 1.0)
                    conf_tx_link[i] *= clamp01(1.0 - 0.2 * clamp01(penalty2))
            elif side == "rx" and sum_rx > 0:
                alpha2 = clamp(sum_tx / max(sum_rx, EPS), 0.97, 1.03)
                alpha2_eff = 1.0 + 0.6 * (alpha2 - 1.0)
                for i in if_list:
                    hard_rx[i] *= alpha2_eff
                    scaled_rx_factor[i] *= alpha2_eff
                    penalty2 = abs(alpha2_eff - 1.0)
                    conf_rx_link[i] *= clamp01(1.0 - 0.2 * clamp01(penalty2))

    # Stage 2.5: Post-projection gentle link re-sync (confidence-gap-proportional, with scaling guard)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ab = rel_diff(tx_a, rx_b)
        strong_scaled_a = abs(scaled_tx_factor.get(a, 1.0) - 1.0) > 0.08
=======
        diff_ab = rel_diff(tx_a, rx_b)
        s_ab = clamp01((diff_ab - tau_h_ab) / max(tau_h_ab, 1e-6))
        strong_scaled_a = abs(scaled_tx_factor.get(a, 1.0) - 1.0) > 0.08
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if ca < cb and not strong_scaled_a:
                f = min(0.4, max(0.0, cb - ca))
                hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                conf_tx_link[a] *= 0.95
=======
            if ca < cb and not strong_scaled_a:
                f = min(0.4, max(0.0, cb - ca)) * s_ab
                hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                conf_tx_link[a] *= 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            elif cb < ca and not strong_scaled_b:
                f = min(0.4, max(0.0, ca - cb))
                hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                conf_rx_link[b] *= 0.95
=======
            elif cb < ca and not strong_scaled_b:
                f = min(0.4, max(0.0, ca - cb)) * s_ab
                hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                conf_rx_link[b] *= 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if min(ca, cb) < 0.7:
                    f = 0.15
                    if not strong_scaled_a:
                        hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                        conf_tx_link[a] *= 0.95
                    if not strong_scaled_b:
                        hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                        conf_rx_link[b] *= 0.95
=======
                if min(ca, cb) < 0.7:
                    f = 0.15 * s_ab
                    if not strong_scaled_a:
                        hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                        conf_tx_link[a] *= 0.95
                    if not strong_scaled_b:
                        hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                        conf_rx_link[b] *= 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ba = rel_diff(tx_b, rx_a)
        strong_scaled_btx = abs(scaled_tx_factor.get(b, 1.0) - 1.0) > 0.08
=======
        diff_ba = rel_diff(tx_b, rx_a)
        s_ba = clamp01((diff_ba - tau_h_ba) / max(tau_h_ba, 1e-6))
        strong_scaled_btx = abs(scaled_tx_factor.get(b, 1.0) - 1.0) > 0.08
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if cb_tx < ca_rx and not strong_scaled_btx:
                f = min(0.4, max(0.0, ca_rx - cb_tx))
                hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                conf_tx_link[b] *= 0.95
=======
            if cb_tx < ca_rx and not strong_scaled_btx:
                f = min(0.4, max(0.0, ca_rx - cb_tx)) * s_ba
                hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                conf_tx_link[b] *= 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            elif ca_rx < cb_tx and not strong_scaled_arx:
                f = min(0.4, max(0.0, cb_tx - ca_rx))
                hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                conf_rx_link[a] *= 0.95
=======
            elif ca_rx < cb_tx and not strong_scaled_arx:
                f = min(0.4, max(0.0, cb_tx - ca_rx)) * s_ba
                hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                conf_rx_link[a] *= 0.95
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if min(cb_tx, ca_rx) < 0.7:
                    f = 0.15
                    if not strong_scaled_btx:
                        hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                        conf_tx_link[b] *= 0.95
                    if not strong_scaled_arx:
                        hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                        conf_rx_link[a] *= 0.95
=======
                if min(cb_tx, ca_rx) < 0.7:
                    f = 0.15 * s_ba
                    if not strong_scaled_btx:
                        hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                        conf_tx_link[b] *= 0.95
                    if not strong_scaled_arx:
                        hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                        conf_rx_link[a] *= 0.95
>>>>>>> REPLACE
</DIFF>