<NAME>
micro_finishing_and_ordered_peer_smoothing
</NAME>

<DESCRIPTION>
I propose three targeted improvements to boost counter repair accuracy and tighten confidence calibration without destabilizing the pipeline:

1) Add a micro high-confidence finishing tier (Stage 2.3) after the WLS router projection and bundle smoothing but before link re-sync. This tiny ±3% pass is only triggered when a router’s residual remains >60% of the adaptive tolerance. It allocates a small correction to the side (rx or tx) with higher high-confidence capacity (conf ≥ 0.85), damped by 0.25 and clipped to ±3% per-link. This closes stubborn residuals while preserving stability and respecting invariants.

2) Refine scale/clip confidence penalties with a two-tier guard: apply a mild 0.97 penalty for changes >8% and a stronger CLIP_HIT_PENALTY for >12% or clip hits. This improves calibration by aligning penalties more closely with adjustment magnitude.

3) Make peer smoothing order-independent via a staged update to avoid cascade bias across pairs, improving confidence calibration consistency.

These changes add two new hyperparameters (MICRO_CLIP, MICRO_DAMP), keep the existing function signature, and minimally touch the code where necessary.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Hyperparameters
    TAU_H_BASE = 0.02           # ~2% hardening threshold
    TAU_H_HIGH = 0.015          # tighter tolerance for high-rate pairs
    TAU_H_LOW = 0.03            # looser tolerance for low/near-zero pairs
    ZERO_THRESH = 1.0           # Mbps soft-zero threshold
    ZERO_EPS = 1e-6
    DAMP_ROUTER = 0.60          # router projection damping on lambda
    DOMINANCE_CAP = 0.50        # ≤ 50% share cap for any single interface correction
    PEER_SMOOTH = 0.10          # confidence peer smoothing fraction
    STRONG_SCALE_GUARD = 0.08   # guard threshold for re-sync skipping
    RESYNC_MAX_F = 0.40         # max fraction for one-sided nudge toward mean
    BUNDLE_DOM_FRAC = 0.60      # bundle dominance threshold on a side’s traffic
    INTRA_BUNDLE_CLIP = 0.05    # ±5% intra-bundle smoothing cap
    UNTOUCHED_BOOST = 0.02      # confidence boost for untouched well-synced counters
    CLIP_HIT_PENALTY = 0.95     # multiplicative penalty when strong scaling/clipping hit

    # Targeted router correction focus and clipping
    WEIGHT_FOCUS = 0.70         # focus on lowest-confidence 70% capacity
    MID_TIER_BOOST = 1.5        # weight boost for 0.70–0.85 confidence (moves less)
    OUTSIDE_FOCUS_BOOST = 2.0   # weight boost for ≥0.85 confidence (moves least)
    PER_VAR_REL_CLIP = 0.10     # ±10% relative change cap per variable in router stage
=======
    # Hyperparameters
    TAU_H_BASE = 0.02           # ~2% hardening threshold
    TAU_H_HIGH = 0.015          # tighter tolerance for high-rate pairs
    TAU_H_LOW = 0.03            # looser tolerance for low/near-zero pairs
    ZERO_THRESH = 1.0           # Mbps soft-zero threshold
    ZERO_EPS = 1e-6
    DAMP_ROUTER = 0.60          # router projection damping on lambda
    DOMINANCE_CAP = 0.50        # ≤ 50% share cap for any single interface correction
    PEER_SMOOTH = 0.10          # confidence peer smoothing fraction
    STRONG_SCALE_GUARD = 0.08   # guard threshold for re-sync skipping
    RESYNC_MAX_F = 0.40         # max fraction for one-sided nudge toward mean
    BUNDLE_DOM_FRAC = 0.60      # bundle dominance threshold on a side’s traffic
    INTRA_BUNDLE_CLIP = 0.05    # ±5% intra-bundle smoothing cap
    UNTOUCHED_BOOST = 0.02      # confidence boost for untouched well-synced counters
    CLIP_HIT_PENALTY = 0.95     # multiplicative penalty when strong scaling/clipping hit
    MICRO_CLIP = 0.03           # ±3% micro finishing cap per interface
    MICRO_DAMP = 0.25           # micro finishing damping factor

    # Targeted router correction focus and clipping
    WEIGHT_FOCUS = 0.70         # focus on lowest-confidence 70% capacity
    MID_TIER_BOOST = 1.5        # weight boost for 0.70–0.85 confidence (moves less)
    OUTSIDE_FOCUS_BOOST = 2.0   # weight boost for ≥0.85 confidence (moves least)
    PER_VAR_REL_CLIP = 0.10     # ±10% relative change cap per variable in router stage
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Stage 2.2: Soft-zero stabilization on hardened links if routers balanced
    router_residual_post = compute_router_residuals(rx, tx)
    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue
        # If link tiny and adjacent routers close to balanced, snap to zero
        if is_near_zero_link([rx[a], tx[a], rx[b], tx[b]]):
            ra = local_router_of.get(a)
            rb = local_router_of.get(b)
            imba = router_residual_post.get(ra, 0.0)
            imbb = router_residual_post.get(rb, 0.0)
            # Adaptive router tolerance based on active links
            n_active_a = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
            n_active_b = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
            tau_ra = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_a))))
            tau_rb = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_b))))
            if imba <= tau_ra and imbb <= tau_rb:
                rx[a] = tx[a] = rx[b] = tx[b] = 0.0
                conf_rx[a] = max(conf_rx[a], 0.95)
                conf_tx[a] = max(conf_tx[a], 0.95)
                conf_rx[b] = max(conf_rx[b], 0.95)
                conf_tx[b] = max(conf_tx[b], 0.95)

    # Stage 3: Confidence-gap re-sync with scaling guard and router attenuation
=======
    # Stage 2.2: Soft-zero stabilization on hardened links if routers balanced
    router_residual_post = compute_router_residuals(rx, tx)
    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue
        # If link tiny and adjacent routers close to balanced, snap to zero
        if is_near_zero_link([rx[a], tx[a], rx[b], tx[b]]):
            ra = local_router_of.get(a)
            rb = local_router_of.get(b)
            imba = router_residual_post.get(ra, 0.0)
            imbb = router_residual_post.get(rb, 0.0)
            # Adaptive router tolerance based on active links
            n_active_a = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
            n_active_b = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
            tau_ra = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_a))))
            tau_rb = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_b))))
            if imba <= tau_ra and imbb <= tau_rb:
                rx[a] = tx[a] = rx[b] = tx[b] = 0.0
                conf_rx[a] = max(conf_rx[a], 0.95)
                conf_tx[a] = max(conf_tx[a], 0.95)
                conf_rx[b] = max(conf_rx[b], 0.95)
                conf_tx[b] = max(conf_tx[b], 0.95)

    # Stage 2.3: Micro high-confidence finishing tier (tiny ±3% pass)
    for r, ifs in router_ifaces.items():
        up_ifs = [i for i in ifs if status.get(i) == 'up']
        if len(up_ifs) < 2:
            continue
        sum_rx_r = sum(rx[i] for i in up_ifs)
        sum_tx_r = sum(tx[i] for i in up_ifs)
        denom_r = max(1.0, sum_rx_r, sum_tx_r)
        imbalance = sum_rx_r - sum_tx_r
        n_active = len(up_ifs)
        tau_router = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active))))
        if abs(imbalance) / denom_r <= 0.6 * tau_router:
            continue

        # Eligible high-confidence sets
        elig_rx = [i for i in up_ifs if conf_rx.get(i, 0.7) >= 0.85 and rx[i] > ZERO_EPS]
        elig_tx = [i for i in up_ifs if conf_tx.get(i, 0.7) >= 0.85 and tx[i] > ZERO_EPS]
        if not elig_rx and not elig_tx:
            continue

        cap_rx = sum(MICRO_CLIP * rx[i] for i in elig_rx)
        cap_tx = sum(MICRO_CLIP * tx[i] for i in elig_tx)

        side = None
        if imbalance > 0.0:
            # Prefer decreasing rx or increasing tx based on capacity
            if cap_rx >= cap_tx and cap_rx > ZERO_EPS:
                side = 'rx'
            elif cap_tx > ZERO_EPS:
                side = 'tx'
        else:
            # Prefer decreasing tx or increasing rx based on capacity
            if cap_tx >= cap_rx and cap_tx > ZERO_EPS:
                side = 'tx'
            elif cap_rx > ZERO_EPS:
                side = 'rx'
        if side is None:
            continue

        if side == 'rx' and elig_rx:
            target = -imbalance * MICRO_DAMP
            adj_total = max(-cap_rx, min(cap_rx, target))
            if abs(adj_total) > ZERO_EPS:
                total_w = sum(max(rx[i], ZERO_THRESH) for i in elig_rx)
                for i in elig_rx:
                    w = max(rx[i], ZERO_THRESH) / max(total_w, 1e-12)
                    dv = w * adj_total
                    prev = rx[i]
                    new_v = max(0.0, prev + dv)
                    if prev > ZERO_EPS:
                        scl = new_v / prev
                        scaled_rx_factor[i] *= scl
                    rx[i] = new_v
        elif side == 'tx' and elig_tx:
            target = imbalance * MICRO_DAMP
            adj_total = max(-cap_tx, min(cap_tx, target))
            if abs(adj_total) > ZERO_EPS:
                total_w = sum(max(tx[i], ZERO_THRESH) for i in elig_tx)
                for i in elig_tx:
                    w = max(tx[i], ZERO_THRESH) / max(total_w, 1e-12)
                    dv = w * adj_total
                    prev = tx[i]
                    new_v = max(0.0, prev + dv)
                    if prev > ZERO_EPS:
                        scl = new_v / prev
                        scaled_tx_factor[i] *= scl
                    tx[i] = new_v

    # Stage 3: Confidence-gap re-sync with scaling guard and router attenuation
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Clip-hit penalty and untouched boost
        if clip_hit.get(i, False) or alpha_rx >= 0.10:
            c_rx *= CLIP_HIT_PENALTY
        if clip_hit.get(i, False) or alpha_tx >= 0.10:
            c_tx *= CLIP_HIT_PENALTY
=======
        # Scale/clip penalties (two-tier) and untouched boost
        if clip_hit.get(i, False) or alpha_rx > 0.12:
            c_rx *= CLIP_HIT_PENALTY
        elif alpha_rx > 0.08:
            c_rx *= 0.97
        if clip_hit.get(i, False) or alpha_tx > 0.12:
            c_tx *= CLIP_HIT_PENALTY
        elif alpha_tx > 0.08:
            c_tx *= 0.97
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Peer smoothing
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            # a.tx with b.rx and a.rx with b.tx
            conf_final_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[a] + PEER_SMOOTH * conf_final_rx[b])
            conf_final_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[a] + PEER_SMOOTH * conf_final_tx[b])
            conf_final_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[b] + PEER_SMOOTH * conf_final_rx[a])
            conf_final_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[b] + PEER_SMOOTH * conf_final_tx[a])
=======
    # Peer smoothing (order-independent via staged update)
    new_conf_rx = dict(conf_final_rx)
    new_conf_tx = dict(conf_final_tx)
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            new_conf_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[a] + PEER_SMOOTH * conf_final_rx[b])
            new_conf_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[b] + PEER_SMOOTH * conf_final_tx[a])
            new_conf_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[a] + PEER_SMOOTH * conf_final_tx[b])
            new_conf_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[b] + PEER_SMOOTH * conf_final_rx[a])
    conf_final_rx = new_conf_rx
    conf_final_tx = new_conf_tx
>>>>>>> REPLACE

</DIFF>