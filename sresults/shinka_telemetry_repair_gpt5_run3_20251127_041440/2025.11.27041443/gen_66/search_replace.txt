<NAME>
pair_adaptive_near_zero_in_fusion
</NAME>

<DESCRIPTION>
We introduce a pair-adaptive near-zero threshold during Stage 1 link fusion to better discriminate tiny-noise readings from plausible traffic. The idea is to precompute per-router activity-based thresholds from original (unhardened) rates and then use the max threshold of the two routers forming a link pair when deciding if one side is "near-zero." This sharpens the large-mismatch decision rule: when one side is tiny relative to its routers’ activity, we prefer the non-tiny peer reading, reducing spurious corrections and improving counter repair accuracy. Importantly, to avoid aggressive zeroing of legitimate low-rate links, we still use the conservative fixed ZERO_THRESH for the “both near-zero” case; the pair-adaptive threshold only influences the single-sided near-zero plausibility checks.

Concretely:
- Precompute router_thr_pre[r] = max(ZERO_THRESH, 0.002*(sum_orig_tx_r + sum_orig_rx_r)) before Stage 1.
- Extend fuse_direction to accept a zero_thr argument and use it only for the single-sided near-zero checks.
- For each peer pair during Stage 1, compute zero_thr_pair = max(router_thr_pre[ra], router_thr_pre[rb]) and pass it into fuse_direction.

This change leaves all later stages intact (router-level projection, bundle finishing, and confidence calibration) while improving the initial hardening decisions and thus overall accuracy without harming calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Stage 1: Link hardening with adaptive fusion
=======
    # Precompute router activity-based near-zero thresholds (orig-rate based)
    router_thr_pre: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        sum_tx_o = sum(orig_tx.get(i, 0.0) for i in ifs)
        sum_rx_o = sum(orig_rx.get(i, 0.0) for i in ifs)
        router_thr_pre[r] = max(ZERO_THRESH, 0.002 * (sum_tx_o + sum_rx_o))

    # Stage 1: Link hardening with adaptive fusion
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)
        th = tau_h_dir(v_local, v_peer)

        # Both near-zero => zero with high confidence
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within adaptive hardening tolerance, keep local reading (minimal change)
        if mismatch <= th:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero and the other is not, take the non-zero
        if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
=======
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str, zero_thr: float) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)
        th = tau_h_dir(v_local, v_peer)

        # Both near-zero => zero with high confidence (use conservative fixed threshold to avoid over-zeroing)
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within adaptive hardening tolerance, keep local reading (minimal change)
        if mismatch <= th:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero relative to router activity and the other is not, take the non-zero
        nz_thr = max(ZERO_THRESH, zero_thr)
        if v_local < nz_thr and v_peer >= nz_thr:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < nz_thr and v_local >= nz_thr:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        fused_ab, c_ab = fuse_direction(a_tx, b_rx, sa, sb)
        fused_ba, c_ba = fuse_direction(b_tx, a_rx, sb, sa)
=======
        # Pair-adaptive near-zero threshold for fusion using precomputed router activity
        ra_pair = router_of.get(a, None)
        rb_pair = router_of.get(b, None)
        zero_thr_pair = max(router_thr_pre.get(ra_pair, ZERO_THRESH), router_thr_pre.get(rb_pair, ZERO_THRESH))
        fused_ab, c_ab = fuse_direction(a_tx, b_rx, sa, sb, zero_thr_pair)
        fused_ba, c_ba = fuse_direction(b_tx, a_rx, sb, sa, zero_thr_pair)
>>>>>>> REPLACE
</DIFF>