<NAME>
directional_peer_copy_above_tolerance
</NAME>

<DESCRIPTION>
I’m adjusting the pair-wise hardening step to be more decisive when link symmetry is clearly violated. Currently, when both endpoints are up, the algorithm always averages the two redundant counters for each direction (my_tx with peer_rx, and my_rx with peer_tx), regardless of how large the disagreement is. For large divergences, averaging can bias the repaired value away from the likely ground truth.

Inspired by Hodor’s use of redundancy and a 2% tolerance, I propose:
- If the relative difference is within the 2% hardening threshold, continue averaging, keeping high confidence (slight bump as before).
- If the difference exceeds the threshold, trust the peer’s counter for that direction (my_tx takes peer_rx; my_rx takes peer_tx) instead of averaging. This enforces link symmetry more strongly and should improve counter repair accuracy, especially in cases where one side is clearly wrong (e.g., one endpoint reports zero while the other shows substantial traffic).

Confidence is still based on the magnitude of the symmetry deviation, with a slight bump when within tolerance to reflect agreement.

This is a targeted change: it only alters the per-direction hardening under the “both up” branch. All router-level flow conservation and the final symmetry touch-up remain unchanged, maintaining good confidence calibration and status accuracy.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        if my_up and peer_up and peer_data:
            # Average redundant signals to reduce measurement noise
            hardened_tx_val = 0.5 * (my_tx + peer_rx)
            hardened_rx_val = 0.5 * (my_rx + peer_tx)
            # Confidence primarily from agreement; boost when within tolerance
            base_tx_conf = clamp01(1.0 - tx_to_peer_rx_diff)
            base_rx_conf = clamp01(1.0 - rx_from_peer_tx_diff)
            # Slight bump when within tolerance to reflect redundancy agreement
            if tx_to_peer_rx_diff <= HARDENING_THRESHOLD:
                base_tx_conf = clamp01(0.9 + 0.1 * (1.0 - tx_to_peer_rx_diff / max(HARDENING_THRESHOLD, 1e-9)))
            if rx_from_peer_tx_diff <= HARDENING_THRESHOLD:
                base_rx_conf = clamp01(0.9 + 0.1 * (1.0 - rx_from_peer_tx_diff / max(HARDENING_THRESHOLD, 1e-9)))
=======
        if my_up and peer_up and peer_data:
            # Directional hardening with tolerance:
            # - If within tolerance, average to reduce noise.
            # - If beyond tolerance, trust the peer's redundant counter for that direction.
            if tx_to_peer_rx_diff <= HARDENING_THRESHOLD:
                hardened_tx_val = 0.5 * (my_tx + peer_rx)
            else:
                hardened_tx_val = peer_rx
            if rx_from_peer_tx_diff <= HARDENING_THRESHOLD:
                hardened_rx_val = 0.5 * (my_rx + peer_tx)
            else:
                hardened_rx_val = peer_tx

            # Confidence primarily from agreement; boost when within tolerance
            base_tx_conf = clamp01(1.0 - tx_to_peer_rx_diff)
            base_rx_conf = clamp01(1.0 - rx_from_peer_tx_diff)
            # Slight bump when within tolerance to reflect redundancy agreement
            if tx_to_peer_rx_diff <= HARDENING_THRESHOLD:
                base_tx_conf = clamp01(0.92 + 0.08 * (1.0 - tx_to_peer_rx_diff / max(HARDENING_THRESHOLD, 1e-9)))
            if rx_from_peer_tx_diff <= HARDENING_THRESHOLD:
                base_rx_conf = clamp01(0.92 + 0.08 * (1.0 - rx_from_peer_tx_diff / max(HARDENING_THRESHOLD, 1e-9)))
>>>>>>> REPLACE

</DIFF>