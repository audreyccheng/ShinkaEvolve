<NAME>
post_symmetry_router_after_confidence
</NAME>

<DESCRIPTION>
I propose to improve confidence calibration without changing the core repair logic. The current solution computes final confidence mainly from pre-fusion mismatch, change magnitude, and router imbalance before projection. This can lead to over/underconfidence because it doesnâ€™t account for how well the repaired values satisfy invariants after all adjustments.

The edit adds:
- Post-projection router imbalance (router_imbalance_after) and uses it for confidence instead of using the pre-projection value.
- Final per-direction link symmetry residuals (post_mismatch) computed after all repairs, and incorporates these directly into the confidence. This should better align confidence with actual repair quality.
- Updated confidence blending weights to include the final symmetry residuals, while keeping other factors (base, redundancy, change, router context) in the mix.

This change should increase confidence calibration while preserving or slightly improving counter repair accuracy, thereby increasing the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Compose final results with calibrated confidences
    result: Dict[str, Dict[str, Tuple]] = {}
    for if_id, data in telemetry.items():
        rep_tx = hard_tx.get(if_id, orig_tx[if_id])
        rep_rx = hard_rx.get(if_id, orig_rx[if_id])

        # Compute change magnitude
        # Note: rel_diff uses max(1.0, ...) in denominator, stabilizing near-zero cases
        change_tx = rel_diff(orig_tx[if_id], rep_tx)
        change_rx = rel_diff(orig_rx[if_id], rep_rx)

        # Pre-fusion mismatch
        pre_tx = pre_mismatch_tx.get(if_id, 0.4)
        pre_rx = pre_mismatch_rx.get(if_id, 0.4)

        # Router context penalty
        r = router_of.get(if_id, None)
        router_penalty = router_imbalance_before.get(r, 0.0) if r is not None else 0.0
        router_factor = clamp01(1.0 - min(0.5, router_penalty))

        base_tx_conf = conf_tx_link.get(if_id, 0.6)
        base_rx_conf = conf_rx_link.get(if_id, 0.6)

        red_tx = clamp01(1.0 - pre_tx)
        red_rx = clamp01(1.0 - pre_rx)

        ch_tx = clamp01(1.0 - change_tx)
        ch_rx = clamp01(1.0 - change_rx)

        conf_tx_final = clamp01(0.35 * base_tx_conf + 0.35 * red_tx + 0.20 * ch_tx + 0.10 * router_factor)
        conf_rx_final = clamp01(0.35 * base_rx_conf + 0.35 * red_rx + 0.20 * ch_rx + 0.10 * router_factor)

        # Status enforcement: down implies zero counters
        rep_status = repaired_status.get(if_id, status.get(if_id, "unknown"))
        conf_status = status_conf.get(if_id, 0.9)
        if rep_status == "down":
            rep_tx = 0.0
            rep_rx = 0.0
            if orig_tx[if_id] >= ZERO_THRESH or orig_rx[if_id] >= ZERO_THRESH:
                conf_tx_final = min(conf_tx_final, 0.7)
                conf_rx_final = min(conf_rx_final, 0.7)
            else:
                conf_tx_final = max(conf_tx_final, 0.9)
                conf_rx_final = max(conf_rx_final, 0.9)

        # Assemble output record
        out = {}
        out["rx_rate"] = (orig_rx[if_id], rep_rx, conf_rx_final)
        out["tx_rate"] = (orig_tx[if_id], rep_tx, conf_tx_final)
        out["interface_status"] = (status[if_id], rep_status, conf_status)

        # Copy metadata unchanged
        out["connected_to"] = data.get("connected_to")
        out["local_router"] = data.get("local_router")
        out["remote_router"] = data.get("remote_router")

        result[if_id] = out

    return result
=======
    # Calibrate confidence using post-projection invariants
    # 1) Router imbalance AFTER projection
    router_imbalance_after: Dict[str, float] = {}
    for router, if_list in router_ifaces.items():
        if not if_list:
            router_imbalance_after[router] = 0.0
            continue
        sum_tx_after = sum(hard_tx.get(i, 0.0) for i in if_list)
        sum_rx_after = sum(hard_rx.get(i, 0.0) for i in if_list)
        router_imbalance_after[router] = rel_diff(sum_tx_after, sum_rx_after)

    # 2) Final per-direction symmetry residuals AFTER all adjustments
    post_mismatch_tx_dir: Dict[str, float] = {}
    post_mismatch_rx_dir: Dict[str, float] = {}
    for if_id in telemetry.keys():
        peer = peers.get(if_id)
        if peer:
            post_mismatch_tx_dir[if_id] = rel_diff(hard_tx.get(if_id, 0.0), hard_rx.get(peer, 0.0))
            post_mismatch_rx_dir[if_id] = rel_diff(hard_rx.get(if_id, 0.0), hard_tx.get(peer, 0.0))
        else:
            # No redundant signal available: use moderate default uncertainty
            post_mismatch_tx_dir[if_id] = 0.4
            post_mismatch_rx_dir[if_id] = 0.4

    # Compose final results with calibrated confidences
    result: Dict[str, Dict[str, Tuple]] = {}
    for if_id, data in telemetry.items():
        rep_tx = hard_tx.get(if_id, orig_tx[if_id])
        rep_rx = hard_rx.get(if_id, orig_rx[if_id])

        # Compute change magnitude
        # Note: rel_diff uses max(1.0, ...) in denominator, stabilizing near-zero cases
        change_tx = rel_diff(orig_tx[if_id], rep_tx)
        change_rx = rel_diff(orig_rx[if_id], rep_rx)

        # Pre-fusion mismatch (redundancy before hardening)
        pre_tx = pre_mismatch_tx.get(if_id, 0.4)
        pre_rx = pre_mismatch_rx.get(if_id, 0.4)

        # Post-fusion symmetry agreement (redundancy after final hardening)
        fin_sym_tx = clamp01(1.0 - post_mismatch_tx_dir.get(if_id, 0.4))
        fin_sym_rx = clamp01(1.0 - post_mismatch_rx_dir.get(if_id, 0.4))

        # Router context penalty AFTER projection
        r = router_of.get(if_id, None)
        router_penalty_after = router_imbalance_after.get(r, 0.0) if r is not None else 0.0
        router_factor_after = clamp01(1.0 - min(0.5, router_penalty_after))

        base_tx_conf = conf_tx_link.get(if_id, 0.6)
        base_rx_conf = conf_rx_link.get(if_id, 0.6)

        red_tx = clamp01(1.0 - pre_tx)
        red_rx = clamp01(1.0 - pre_rx)

        ch_tx = clamp01(1.0 - change_tx)
        ch_rx = clamp01(1.0 - change_rx)

        # Blend confidence components with emphasis on final invariant satisfaction
        conf_tx_final = clamp01(
            0.25 * base_tx_conf +
            0.20 * red_tx +
            0.30 * fin_sym_tx +
            0.15 * ch_tx +
            0.10 * router_factor_after
        )
        conf_rx_final = clamp01(
            0.25 * base_rx_conf +
            0.20 * red_rx +
            0.30 * fin_sym_rx +
            0.15 * ch_rx +
            0.10 * router_factor_after
        )

        # Status enforcement: down implies zero counters
        rep_status = repaired_status.get(if_id, status.get(if_id, "unknown"))
        conf_status = status_conf.get(if_id, 0.9)
        if rep_status == "down":
            rep_tx = 0.0
            rep_rx = 0.0
            if orig_tx[if_id] >= ZERO_THRESH or orig_rx[if_id] >= ZERO_THRESH:
                conf_tx_final = min(conf_tx_final, 0.7)
                conf_rx_final = min(conf_rx_final, 0.7)
            else:
                conf_tx_final = max(conf_tx_final, 0.9)
                conf_rx_final = max(conf_rx_final, 0.9)

        # Assemble output record
        out = {}
        out["rx_rate"] = (orig_rx[if_id], rep_rx, conf_rx_final)
        out["tx_rate"] = (orig_tx[if_id], rep_tx, conf_tx_final)
        out["interface_status"] = (status[if_id], rep_status, conf_status)

        # Copy metadata unchanged
        out["connected_to"] = data.get("connected_to")
        out["local_router"] = data.get("local_router")
        out["remote_router"] = data.get("remote_router")

        result[if_id] = out

    return result
>>>>>>> REPLACE

</DIFF>