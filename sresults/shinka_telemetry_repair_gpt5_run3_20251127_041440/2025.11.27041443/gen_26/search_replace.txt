<NAME>
severity_weighted_resync_and_residual_confidence
</NAME>

<DESCRIPTION>
I propose two targeted changes to improve both counter repair accuracy and confidence calibration:

1) Severity-weighted link re-sync: In Stage 2.5, the current one-sided nudge uses only the confidence gap to determine the adjustment fraction. I multiply this fraction by a severity term derived from how much the directional mismatch exceeds the adaptive tolerance, f *= severity = clamp01((mis - tau_h) / tau_h). This makes corrections stronger when mismatches are significant and gentler when they are marginal, improving accuracy without overcorrecting, and aligning well with Hodor’s dynamic checking.

2) Residual-informed confidence smoothing: The final confidence smoothing now includes a residual agreement term. Instead of only blending 10% of the peer’s opposite-direction confidence, we also blend in 10% of (1 - final mismatch) between my TX and peer RX (and vice versa). This ties the final confidence more closely to the achieved symmetry invariant, improving calibration while retaining stability.

These edits are small and consistent with the existing design: thresholds remain adaptive, strong router-scaled directions are still guarded against double adjustment, and the final confidence composition continues to include scale penalties and router balance context.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        if rel_diff(tx_a, rx_b) > th_ab and max(tx_a, rx_b) >= ZERO_THRESH:
            if not (strong_scaled_tx.get(a, False) or strong_scaled_rx.get(b, False)):
                mean_ab = 0.5 * (tx_a + rx_b)
                high, low = (ca, 'a'), (cb, 'b')
                if cb > ca:
                    high, low = (cb, 'b'), (ca, 'a')
                f = min(0.4, max(0.0, high[0] - low[0]))
                if f > 0.0:
                    if low[1] == 'a':
                        hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                        conf_tx_link[a] *= 0.97
                    else:
                        hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                        conf_rx_link[b] *= 0.97
=======
        if rel_diff(tx_a, rx_b) > th_ab and max(tx_a, rx_b) >= ZERO_THRESH:
            if not (strong_scaled_tx.get(a, False) or strong_scaled_rx.get(b, False)):
                mean_ab = 0.5 * (tx_a + rx_b)
                high, low = (ca, 'a'), (cb, 'b')
                if cb > ca:
                    high, low = (cb, 'b'), (ca, 'a')
                # Weight nudge by both confidence gap and mismatch severity beyond tolerance
                mis_ab = rel_diff(tx_a, rx_b)
                sev_ab = clamp01((mis_ab - th_ab) / max(th_ab, 1e-6))
                f = min(0.4, max(0.0, high[0] - low[0])) * sev_ab
                if f > 0.0:
                    if low[1] == 'a':
                        hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                        conf_tx_link[a] *= 0.97
                    else:
                        hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                        conf_rx_link[b] *= 0.97
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        if rel_diff(tx_b, rx_a) > th_ba and max(tx_b, rx_a) >= ZERO_THRESH:
            if not (strong_scaled_tx.get(b, False) or strong_scaled_rx.get(a, False)):
                mean_ba = 0.5 * (tx_b + rx_a)
                high, low = (cb_tx, 'b'), (ca_rx, 'a')
                if ca_rx > cb_tx:
                    high, low = (ca_rx, 'a'), (cb_tx, 'b')
                f = min(0.4, max(0.0, high[0] - low[0]))
                if f > 0.0:
                    if low[1] == 'b':
                        hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                        conf_tx_link[b] *= 0.97
                    else:
                        hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                        conf_rx_link[a] *= 0.97
=======
        if rel_diff(tx_b, rx_a) > th_ba and max(tx_b, rx_a) >= ZERO_THRESH:
            if not (strong_scaled_tx.get(b, False) or strong_scaled_rx.get(a, False)):
                mean_ba = 0.5 * (tx_b + rx_a)
                high, low = (cb_tx, 'b'), (ca_rx, 'a')
                if ca_rx > cb_tx:
                    high, low = (ca_rx, 'a'), (cb_tx, 'b')
                # Weight nudge by both confidence gap and mismatch severity beyond tolerance
                mis_ba = rel_diff(tx_b, rx_a)
                sev_ba = clamp01((mis_ba - th_ba) / max(th_ba, 1e-6))
                f = min(0.4, max(0.0, high[0] - low[0])) * sev_ba
                if f > 0.0:
                    if low[1] == 'b':
                        hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                        conf_tx_link[b] *= 0.97
                    else:
                        hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                        conf_rx_link[a] *= 0.97
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Peer confidence smoothing (10%) when both ends are up
    for i, data in telemetry.items():
        p = data.get("connected_to")
        if not isinstance(p, str) or p not in telemetry:
            continue
        if i not in result or p not in result:
            continue
        if result[i]["interface_status"][1] != "up" or result[p]["interface_status"][1] != "up":
            continue
        # Blend my confidence with peer opposite by 10%
        my_tx_c = clamp01(result[i]["tx_rate"][2])
        my_rx_c = clamp01(result[i]["rx_rate"][2])
        peer_rx_c = clamp01(result[p]["rx_rate"][2])
        peer_tx_c = clamp01(result[p]["tx_rate"][2])
        result[i]["tx_rate"] = (result[i]["tx_rate"][0], result[i]["tx_rate"][1],
                                clamp01(0.90 * my_tx_c + 0.10 * peer_rx_c))
        result[i]["rx_rate"] = (result[i]["rx_rate"][0], result[i]["rx_rate"][1],
                                clamp01(0.90 * my_rx_c + 0.10 * peer_tx_c))
=======
    # Peer confidence smoothing with residual-informed touch (when both ends are up)
    for i, data in telemetry.items():
        p = data.get("connected_to")
        if not isinstance(p, str) or p not in telemetry:
            continue
        if i not in result or p not in result:
            continue
        if result[i]["interface_status"][1] != "up" or result[p]["interface_status"][1] != "up":
            continue
        # Compute final symmetry residuals
        tx_i = safe_rate(result[i]["tx_rate"][1])
        rx_p = safe_rate(result[p]["rx_rate"][1])
        rx_i = safe_rate(result[i]["rx_rate"][1])
        tx_p = safe_rate(result[p]["tx_rate"][1])
        mis_tx = rel_diff(tx_i, rx_p)
        mis_rx = rel_diff(rx_i, tx_p)
        # Blend my confidence with 10% peer opposite and 10% residual agreement
        my_tx_c = clamp01(result[i]["tx_rate"][2])
        my_rx_c = clamp01(result[i]["rx_rate"][2])
        peer_rx_c = clamp01(result[p]["rx_rate"][2])
        peer_tx_c = clamp01(result[p]["tx_rate"][2])
        result[i]["tx_rate"] = (
            result[i]["tx_rate"][0],
            result[i]["tx_rate"][1],
            clamp01(0.80 * my_tx_c + 0.10 * peer_rx_c + 0.10 * clamp01(1.0 - mis_tx))
        )
        result[i]["rx_rate"] = (
            result[i]["rx_rate"][0],
            result[i]["rx_rate"][1],
            clamp01(0.80 * my_rx_c + 0.10 * peer_tx_c + 0.10 * clamp01(1.0 - mis_rx))
        )
>>>>>>> REPLACE
</DIFF>