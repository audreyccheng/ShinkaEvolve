<NAME>
exact_bounded_projection_and_adaptive_resync_confcredit
</NAME>

<DESCRIPTION>
Two targeted improvements:

1) Exact bounded WLS router projection:
   - Replace the damped Lagrange update plus global scaling with a KKT-style iterative clipping loop that enforces per-variable ±10% bounds while exactly satisfying the router flow-conservation constraint (Σin=Σout). This reduces residual imbalance and improves counter accuracy without overcorrecting any single interface.

2) Adaptive re-sync gain with improvement-based confidence credit:
   - Use a saturating sigmoid gain as a function of normalized mismatch beyond tolerance, keep scaling guards and router attenuation, and add a tiny bilateral nudge when both directions are low-confidence and both adjacent routers are within tolerance (±2% cap).
   - Add improvement credit to confidence based on pre- vs post-re-sync link mismatch reduction and router-aware smoothing for lightly scaled directions. This yields more calibrated confidences aligned with actual repair quality.

The function signature and overall structure remain unchanged, and the topology is used throughout for router invariants and link pairing.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Compute lambda for weighted projection
        # a^T x0 = sum(signs[i] * vals[i])
        ax0 = 0.0
        denom = 0.0  # a^T W^{-1} a = sum( (sign^2)/w_i ) = sum(1/w_i)
        inv_weights = [1.0 / max(1e-12, w) for w in weights]
        for sgn, v, invw in zip(signs, vals, inv_weights):
            ax0 += sgn * v
            denom += invw  # since sgn^2 = 1

        if denom <= 1e-12:
            continue

        # Damped Lagrange multiplier
        lam = 2.0 * ax0 / denom
        lam *= DAMP_ROUTER

        # Initial deltas
        deltas = [-(invw) * sgn * lam * 0.5 for sgn, invw in zip(signs, inv_weights)]
        # Note: derived from x* = x0 - 0.5 W^{-1} λ a, with λ as above (post damping)

        # Dominance cap iteration: avoid one interface taking >50% of correction
        def apply_dominance_cap(deltas_in: List[float], invw_in: List[float]) -> List[float]:
            # Compute shares by absolute delta proportional to invw (since all deltas share same lam)
            for _ in range(3):
                absd = [abs(d) for d in deltas_in]
                total = sum(absd) + 1e-12
                shares = [d / total for d in absd]
                max_share = max(shares)
                if max_share <= DOMINANCE_CAP + 1e-6:
                    break
                k = shares.index(max_share)
                # Increase weight (decrease inv weight) for offender
                invw_in[k] *= (max_share / DOMINANCE_CAP)  # reduce its share
                # Recompute deltas with modified inverse weights
                denom_new = sum(invw_in)
                if denom_new <= 1e-12:
                    break
                lam_new = 2.0 * ax0 / denom_new
                lam_new *= DAMP_ROUTER
                deltas_in = [-(invw) * sgn * lam_new * 0.5 for sgn, invw in zip(signs, invw_in)]
            return deltas_in

        deltas = apply_dominance_cap(deltas, inv_weights[:])

        # Per-variable relative change clipping (±10%); scale all deltas if needed
        gamma = 1.0
        for dv, v_old in zip(deltas, vals):
            if abs(dv) <= 0.0:
                continue
            cap_abs = PER_VAR_REL_CLIP * max(v_old, ZERO_THRESH)
            if abs(dv) > cap_abs:
                gamma = min(gamma, cap_abs / max(abs(dv), 1e-12))
        if gamma < 1.0:
            deltas = [dv * gamma for dv in deltas]

        # Apply deltas
        for (i, side), dv, v_old in zip(idx_map, deltas, vals):
            # Mark clip hits if we reached the cap
            if abs(dv) >= PER_VAR_REL_CLIP * max(v_old, ZERO_THRESH) - 1e-12:
                clip_hit[i] = True
            v_new = max(0.0, v_old + dv)
            if side == 'rx':
                prev = rx[i]
                rx[i] = v_new
                if prev > ZERO_EPS and v_new >= 0.0:
                    scl = v_new / prev if prev > 0 else 1.0
                    scaled_rx_factor[i] *= scl
                    if abs(scl - 1.0) >= 0.10:
                        clip_hit[i] = True
            else:
                prev = tx[i]
                tx[i] = v_new
                if prev > ZERO_EPS and v_new >= 0.0:
                    scl = v_new / prev if prev > 0 else 1.0
                    scaled_tx_factor[i] *= scl
                    if abs(scl - 1.0) >= 0.10:
                        clip_hit[i] = True
=======
        # Compute exact bounded WLS projection (single-equality with box constraints)
        # a^T x0 = sum(signs[i] * vals[i])
        ax0 = 0.0
        inv_weights = [1.0 / max(1e-12, w) for w in weights]
        for sgn, v in zip(signs, vals):
            ax0 += sgn * v

        n_vars = len(vals)
        caps_abs = [PER_VAR_REL_CLIP * max(v, ZERO_THRESH) for v in vals]
        deltas = [0.0] * n_vars
        free = list(range(n_vars))
        rhs = -ax0  # need sum(signs[i] * deltas[i]) = -ax0

        # Iteratively clip violating variables and recompute lambda over the free set
        for _ in range(2 * max(1, n_vars)):
            if not free:
                break
            denomF = sum(inv_weights[i] for i in free)
            if denomF <= 1e-12:
                break
            lamF = 2.0 * rhs / denomF  # exact to satisfy conservation on free set
            to_fix = []
            for i in free:
                d_un = -0.5 * inv_weights[i] * signs[i] * lamF
                cap = caps_abs[i]
                if abs(d_un) > cap + 1e-12:
                    d_fix = math.copysign(cap, d_un)
                    deltas[i] = d_fix
                    rhs -= signs[i] * d_fix
                    to_fix.append(i)
            if not to_fix:
                for i in free:
                    d_un = -0.5 * inv_weights[i] * signs[i] * lamF
                    deltas[i] = d_un
                break
            free = [i for i in free if i not in to_fix]

        # Apply deltas honoring bounds and update scale factors/confidence penalties
        for (i, side), dv, v_old in zip(idx_map, deltas, vals):
            if abs(dv) >= PER_VAR_REL_CLIP * max(v_old, ZERO_THRESH) - 1e-12:
                clip_hit[i] = True
            v_new = max(0.0, v_old + dv)
            if side == 'rx':
                prev = rx[i]
                rx[i] = v_new
                if prev > ZERO_EPS and v_new >= 0.0:
                    scl = v_new / prev if prev > 0 else 1.0
                    scaled_rx_factor[i] *= scl
                    if abs(scl - 1.0) >= 0.10:
                        clip_hit[i] = True
            else:
                prev = tx[i]
                tx[i] = v_new
                if prev > ZERO_EPS and v_new >= 0.0:
                    scl = v_new / prev if prev > 0 else 1.0
                    scaled_tx_factor[i] *= scl
                    if abs(scl - 1.0) >= 0.10:
                        clip_hit[i] = True
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Stage 3: Confidence-gap re-sync with scaling guard and router attenuation
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    # Recompute router residuals for attenuation
    router_residual_final = compute_router_residuals(rx, tx)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Attenuation from local router imbalances
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = 1.0 - max(router_residual_final.get(ra, 0.0), router_residual_final.get(rb, 0.0))
        att = clamp01(att)

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = tx[a], rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.7), conf_rx.get(b, 0.7)
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_rx
                        new = max(0.0, nudge_toward_mean(old, a_tx, f))
                        rx[b] = new
                        # confidence penalty proportional to relative movement
                        move_rel = rel_diff(new, old)
                        conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * move_rel))
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_tx
                        new = max(0.0, nudge_toward_mean(old, b_rx, f))
                        tx[a] = new
                        move_rel = rel_diff(new, old)
                        conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * move_rel))

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = rx[a], tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.7), conf_tx.get(b, 0.7)
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_tx
                        new = max(0.0, nudge_toward_mean(old, a_rx, f))
                        tx[b] = new
                        move_rel = rel_diff(new, old)
                        conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * move_rel))
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_rx
                        new = max(0.0, nudge_toward_mean(old, b_tx, f))
                        rx[a] = new
                        move_rel = rel_diff(new, old)
                        conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * move_rel))
=======
    # Stage 3: Confidence-gap re-sync with scaling guard and router attenuation
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    # Record pre-re-sync link mismatches for confidence improvement credit
    pre_link_mis_rx: Dict[str, float] = {}
    pre_link_mis_tx: Dict[str, float] = {}
    for i in telemetry:
        p_i = peer_of.get(i)
        if p_i and p_i in telemetry and status.get(i) == 'up' and status.get(p_i) == 'up':
            pre_link_mis_rx[i] = rel_diff(rx[i], tx[p_i])
            pre_link_mis_tx[i] = rel_diff(tx[i], rx[p_i])
        else:
            pre_link_mis_rx[i] = 0.0
            pre_link_mis_tx[i] = 0.0

    # Recompute router residuals for attenuation
    router_residual_final = compute_router_residuals(rx, tx)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Attenuation from local router imbalances
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = clamp01(1.0 - max(router_residual_final.get(ra, 0.0), router_residual_final.get(rb, 0.0)))

        # Helper for router tolerance
        n_active_a = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
        n_active_b = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
        tau_ra = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_a))))
        tau_rb = min(0.07, max(0.03, 0.05 * math.sqrt(2.0 / max(2, n_active_b))))

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = tx[a], rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.7), conf_rx.get(b, 0.7)
                gap_norm = clamp01((d1 - tau1) / max(tau1, 1e-9))
                s = 1.0 / (1.0 + math.exp(-5.0 * (gap_norm - 0.5)))
                f = min(RESYNC_MAX_F, 0.4 * s) * att
                # Skip if strong router scaling already applied on the target direction
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD and f > 0.0:
                    old = b_rx
                    new = max(0.0, nudge_toward_mean(old, a_tx, f))
                    rx[b] = new
                    move_rel = rel_diff(new, old)
                    conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * move_rel))
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD and f > 0.0:
                    old = a_tx
                    new = max(0.0, nudge_toward_mean(old, b_rx, f))
                    tx[a] = new
                    move_rel = rel_diff(new, old)
                    conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * move_rel))

            # Tiny bilateral nudge when both sides low-confidence and routers within tolerance
            ca, cb = conf_tx.get(a, 0.7), conf_rx.get(b, 0.7)
            if ca < 0.70 and cb < 0.70 and router_residual_final.get(ra, 0.0) <= tau_ra and router_residual_final.get(rb, 0.0) <= tau_rb:
                if abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    mean1 = 0.5 * (a_tx + b_rx)
                    # Nudge both toward mean with ±2% cap
                    frac = 0.10
                    # b.rx
                    old = rx[b]
                    tgt = nudge_toward_mean(old, mean1, frac)
                    cap = 0.02 * max(old, ZERO_THRESH)
                    new = max(0.0, min(old + cap, max(old - cap, tgt)))
                    rx[b] = new
                    # a.tx
                    olda = tx[a]
                    tgt_a = nudge_toward_mean(olda, mean1, frac)
                    cap_a = 0.02 * max(olda, ZERO_THRESH)
                    newa = max(0.0, min(olda + cap_a, max(olda - cap_a, tgt_a)))
                    tx[a] = newa

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = rx[a], tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.7), conf_tx.get(b, 0.7)
                gap_norm = clamp01((d2 - tau2) / max(tau2, 1e-9))
                s = 1.0 / (1.0 + math.exp(-5.0 * (gap_norm - 0.5)))
                f = min(RESYNC_MAX_F, 0.4 * s) * att
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD and f > 0.0:
                    old = b_tx
                    new = max(0.0, nudge_toward_mean(old, a_rx, f))
                    tx[b] = new
                    move_rel = rel_diff(new, old)
                    conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * move_rel))
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD and f > 0.0:
                    old = a_rx
                    new = max(0.0, nudge_toward_mean(old, b_tx, f))
                    rx[a] = new
                    move_rel = rel_diff(new, old)
                    conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * move_rel))

            # Tiny bilateral nudge when both sides low-confidence and routers within tolerance
            ca, cb = conf_rx.get(a, 0.7), conf_tx.get(b, 0.7)
            if ca < 0.70 and cb < 0.70 and router_residual_final.get(ra, 0.0) <= tau_ra and router_residual_final.get(rb, 0.0) <= tau_rb:
                if abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    mean2 = 0.5 * (a_rx + b_tx)
                    # Nudge both toward mean with ±2% cap
                    frac = 0.10
                    # a.rx
                    old = rx[a]
                    tgt = nudge_toward_mean(old, mean2, frac)
                    cap = 0.02 * max(old, ZERO_THRESH)
                    new = max(0.0, min(old + cap, max(old - cap, tgt)))
                    rx[a] = new
                    # b.tx
                    oldb = tx[b]
                    tgt_b = nudge_toward_mean(oldb, mean2, frac)
                    cap_b = 0.02 * max(oldb, ZERO_THRESH)
                    newb = max(0.0, min(oldb + cap_b, max(oldb - cap_b, tgt_b)))
                    tx[b] = newb
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Confidence calibration
    # Router residuals after all adjustments
    router_resid_end = compute_router_residuals(rx, tx)

    # Compute raw confidence components and combine
    conf_final_rx: Dict[str, float] = {}
    conf_final_tx: Dict[str, float] = {}
    for i in telemetry:
        # Measurement residuals
        r_meas_rx = rel_diff(rx[i], orig_rx[i])
        r_meas_tx = rel_diff(tx[i], orig_tx[i])

        # Link residuals
        p = peer_of.get(i)
        if p and p in telemetry and status.get(i) == 'up' and status.get(p) == 'up':
            r_link_rx = rel_diff(rx[i], tx[p])
            r_link_tx = rel_diff(tx[i], rx[p])
        else:
            r_link_rx = 0.2
            r_link_tx = 0.2

        # Router residual
        rtr = router_resid_end.get(local_router_of.get(i), 0.0)

        base_rx = clamp01(1.0 - (0.55 * r_meas_rx + 0.35 * r_link_rx + 0.10 * rtr))
        base_tx = clamp01(1.0 - (0.55 * r_meas_tx + 0.35 * r_link_tx + 0.10 * rtr))

        # Scaling penalties
        alpha_rx = abs(scaled_rx_factor.get(i, 1.0) - 1.0)
        alpha_tx = abs(scaled_tx_factor.get(i, 1.0) - 1.0)
        scale_term_rx = clamp01(1.0 - min(0.5, alpha_rx))
        scale_term_tx = clamp01(1.0 - min(0.5, alpha_tx))

        c_rx = clamp01(0.90 * base_rx + 0.10 * scale_term_rx)
        c_tx = clamp01(0.90 * base_tx + 0.10 * scale_term_tx)

        # Clip-hit penalty and untouched boost
        if clip_hit.get(i, False) or alpha_rx >= 0.10:
            c_rx *= CLIP_HIT_PENALTY
        if clip_hit.get(i, False) or alpha_tx >= 0.10:
            c_tx *= CLIP_HIT_PENALTY

        # Untouched small-change and good symmetry boost
        if r_meas_rx < 0.01 and r_link_rx <= adaptive_tau(rx[i], tx.get(p, rx[i]) if p else rx[i]):
            c_rx = min(0.98, c_rx + UNTOUCHED_BOOST)
        if r_meas_tx < 0.01 and r_link_tx <= adaptive_tau(tx[i], rx.get(p, tx[i]) if p else tx[i]):
            c_tx = min(0.98, c_tx + UNTOUCHED_BOOST)

        # Floor for down interfaces
        if status.get(i) != 'up':
            c_rx = max(c_rx, 0.85)
            c_tx = max(c_tx, 0.85)

        conf_final_rx[i] = c_rx
        conf_final_tx[i] = c_tx

    # Peer smoothing
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            # a.tx with b.rx and a.rx with b.tx
            conf_final_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[a] + PEER_SMOOTH * conf_final_rx[b])
            conf_final_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[a] + PEER_SMOOTH * conf_final_tx[b])
            conf_final_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[b] + PEER_SMOOTH * conf_final_rx[a])
            conf_final_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[b] + PEER_SMOOTH * conf_final_tx[a])
=======
    # Confidence calibration
    # Router residuals after all adjustments
    router_resid_end = compute_router_residuals(rx, tx)

    # Compute raw confidence components and combine
    conf_final_rx: Dict[str, float] = {}
    conf_final_tx: Dict[str, float] = {}
    for i in telemetry:
        # Measurement residuals
        r_meas_rx = rel_diff(rx[i], orig_rx[i])
        r_meas_tx = rel_diff(tx[i], orig_tx[i])

        # Link residuals
        p = peer_of.get(i)
        if p and p in telemetry and status.get(i) == 'up' and status.get(p) == 'up':
            r_link_rx = rel_diff(rx[i], tx[p])
            r_link_tx = rel_diff(tx[i], rx[p])
        else:
            r_link_rx = 0.2
            r_link_tx = 0.2

        # Router residual
        rtr = router_resid_end.get(local_router_of.get(i), 0.0)

        base_rx = clamp01(1.0 - (0.55 * r_meas_rx + 0.35 * r_link_rx + 0.10 * rtr))
        base_tx = clamp01(1.0 - (0.55 * r_meas_tx + 0.35 * r_link_tx + 0.10 * rtr))

        # Scaling penalties
        alpha_rx = abs(scaled_rx_factor.get(i, 1.0) - 1.0)
        alpha_tx = abs(scaled_tx_factor.get(i, 1.0) - 1.0)
        scale_term_rx = clamp01(1.0 - min(0.5, alpha_rx))
        scale_term_tx = clamp01(1.0 - min(0.5, alpha_tx))

        c_rx = clamp01(0.90 * base_rx + 0.10 * scale_term_rx)
        c_tx = clamp01(0.90 * base_tx + 0.10 * scale_term_tx)

        # Improvement credit from pre- to post-re-sync link mismatch
        imp_rx = clamp01(pre_link_mis_rx.get(i, 0.0) - r_link_rx)
        imp_tx = clamp01(pre_link_mis_tx.get(i, 0.0) - r_link_tx)
        c_rx = clamp01(c_rx + 0.08 * imp_rx)
        c_tx = clamp01(c_tx + 0.08 * imp_tx)

        # Clip-hit penalty and untouched boost
        if clip_hit.get(i, False) or alpha_rx >= 0.10:
            c_rx *= CLIP_HIT_PENALTY
        if clip_hit.get(i, False) or alpha_tx >= 0.10:
            c_tx *= CLIP_HIT_PENALTY

        # Untouched small-change and good symmetry boost
        if r_meas_rx < 0.01 and r_link_rx <= adaptive_tau(rx[i], tx.get(p, rx[i]) if p else rx[i]):
            c_rx = min(0.98, c_rx + UNTOUCHED_BOOST)
        if r_meas_tx < 0.01 and r_link_tx <= adaptive_tau(tx[i], rx.get(p, tx[i]) if p else tx[i]):
            c_tx = min(0.98, c_tx + UNTOUCHED_BOOST)

        # Floor for down interfaces
        if status.get(i) != 'up':
            c_rx = max(c_rx, 0.85)
            c_tx = max(c_tx, 0.85)

        conf_final_rx[i] = c_rx
        conf_final_tx[i] = c_tx

    # Router-aware smoothing for stable directions
    mean_rx_conf_router: Dict[str, float] = {}
    mean_tx_conf_router: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        ups = [i for i in ifs if i in telemetry]
        if ups:
            mean_rx_conf_router[r] = sum(conf_final_rx[i] for i in ups) / len(ups)
            mean_tx_conf_router[r] = sum(conf_final_tx[i] for i in ups) / len(ups)
    for r, ifs in router_ifaces.items():
        for i in ifs:
            if i in telemetry:
                if abs(scaled_rx_factor.get(i, 1.0) - 1.0) < 0.05:
                    conf_final_rx[i] = clamp01(0.85 * conf_final_rx[i] + 0.15 * mean_rx_conf_router.get(r, conf_final_rx[i]))
                if abs(scaled_tx_factor.get(i, 1.0) - 1.0) < 0.05:
                    conf_final_tx[i] = clamp01(0.85 * conf_final_tx[i] + 0.15 * mean_tx_conf_router.get(r, conf_final_tx[i]))

    # Peer smoothing
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            # a.tx with b.rx and a.rx with b.tx
            conf_final_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[a] + PEER_SMOOTH * conf_final_rx[b])
            conf_final_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[a] + PEER_SMOOTH * conf_final_tx[b])
            conf_final_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_tx[b] + PEER_SMOOTH * conf_final_rx[a])
            conf_final_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_final_rx[b] + PEER_SMOOTH * conf_final_tx[a])
>>>>>>> REPLACE

</DIFF>