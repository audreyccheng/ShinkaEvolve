<NAME>
penalty_aware_side_and_micro_finish
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy and maintain strong confidence calibration:

1) Penalty-aware side selection: In both the main router correction stage and the mid-tier spillover, replace the simple “lower average confidence” rule with an expected-penalty lookahead. We estimate penalty_rx/penalty_tx as Σ(confidence × capacity), where capacity is the interface’s current value. We adjust the side with the lower expected penalty (i.e., lower confidence-weighted cost). This refines which side to scale and better aligns with the principle of minimizing confidence loss, especially when rate magnitudes differ across sides.

2) Micro high-confidence finishing tier: After the moderate router adjustments, we add a tiny finishing pass on high-confidence links (conf ≥ 0.85) with capped ±3% change and 25% damping when residual imbalance remains above 60% of the router tolerance. This closes stubborn gaps without oscillation and preserves calibration thanks to small, bounded changes.

Additionally, I tighten confidence calibration slightly by applying a mild penalty for sub-clip strong scaling (>8% and <10%), improving calibration without harming accuracy.

These changes are minimal, keep the algorithm’s structure, and leverage topology and redundancy more effectively. They should push the combined score upward by improving balance decisions and final residuals while avoiding overconfidence.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    UNTOUCHED_BOOST = 0.02   # confidence boost for untouched, well-synced counters
=======
    UNTOUCHED_BOOST = 0.02   # confidence boost for untouched, well-synced counters
    MICRO_FINISH_CLIP = 0.03  # ±3% micro finishing per-interface cap
    MICRO_FINISH_DAMP = 0.25  # micro finishing damping factor
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Choose side with lower aggregate confidence to adjust
        avg_rx_conf = sum(conf_rx[i] for i in up_ifs) / len(up_ifs)
        avg_tx_conf = sum(conf_tx[i] for i in up_ifs) / len(up_ifs)
        adjust_side = 'rx' if avg_rx_conf < avg_tx_conf else 'tx'
        total_adjust = (-imbalance if adjust_side == 'rx' else imbalance) * DAMP_ROUTER
=======
        # Choose side with lower expected penalty (confidence-weighted lookahead)
        penalty_rx = sum(conf_rx[i] * max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
        penalty_tx = sum(conf_tx[i] * max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
        if penalty_rx == penalty_tx:
            # tie-breaker by lower weighted average confidence
            sum_rx_vals = sum(max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
            sum_tx_vals = sum(max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
            avg_rx_conf_w = penalty_rx / max(sum_rx_vals, 1e-9)
            avg_tx_conf_w = penalty_tx / max(sum_tx_vals, 1e-9)
            adjust_side = 'rx' if avg_rx_conf_w < avg_tx_conf_w else 'tx'
        else:
            adjust_side = 'rx' if penalty_rx < penalty_tx else 'tx'
        total_adjust = (-imbalance if adjust_side == 'rx' else imbalance) * DAMP_ROUTER
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Choose the lower-confidence side for this spillover
        avg_rx_conf = sum(conf_rx[i] for i in up_ifs) / len(up_ifs)
        avg_tx_conf = sum(conf_tx[i] for i in up_ifs) / len(up_ifs)
        adjust_side = 'rx' if avg_rx_conf < avg_tx_conf else 'tx'
        total_adjust2 = (-imbalance if adjust_side == 'rx' else imbalance) * DAMP_ROUTER
=======
        # Choose side with lower expected penalty for this spillover
        penalty_rx = sum(conf_rx[i] * max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
        penalty_tx = sum(conf_tx[i] * max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
        if penalty_rx == penalty_tx:
            sum_rx_vals = sum(max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
            sum_tx_vals = sum(max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
            avg_rx_conf_w = penalty_rx / max(sum_rx_vals, 1e-9)
            avg_tx_conf_w = penalty_tx / max(sum_tx_vals, 1e-9)
            adjust_side = 'rx' if avg_rx_conf_w < avg_tx_conf_w else 'tx'
        else:
            adjust_side = 'rx' if penalty_rx < penalty_tx else 'tx'
        total_adjust2 = (-imbalance if adjust_side == 'rx' else imbalance) * DAMP_ROUTER
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Compute per-router residuals for re-sync attenuation
    router_residual_mid: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        ups = [i for i in ifs if status.get(i) == 'up']
        if not ups:
            router_residual_mid[r] = 0.0
        else:
            srx = sum(hardened_rx[i] for i in ups)
            stx = sum(hardened_tx[i] for i in ups)
            denomr = max(1.0, srx, stx)
            router_residual_mid[r] = abs(srx - stx) / denomr
=======
    # Stage 2c: Micro high-confidence finishing tier to close stubborn residuals
    for r, ifs in router_ifaces.items():
        up_ifs = [i for i in ifs if status.get(i) == 'up']
        if len(up_ifs) < 2:
            continue
        sum_rx = sum(hardened_rx[i] for i in up_ifs)
        sum_tx = sum(hardened_tx[i] for i in up_ifs)
        denom = max(1.0, sum_rx, sum_tx)
        imbalance = (sum_rx - sum_tx)
        rel_gap = abs(imbalance) / denom
        n_active = len(up_ifs)
        tau_router = min(0.07, max(0.03, 0.05 * (2.0 / max(2, n_active)) ** 0.5))
        # Only run micro finishing if remaining gap still notable
        if rel_gap <= 0.60 * tau_router:
            continue

        # Penalty-aware side selection
        penalty_rx = sum(conf_rx[i] * max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
        penalty_tx = sum(conf_tx[i] * max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
        if penalty_rx == penalty_tx:
            sum_rx_vals = sum(max(hardened_rx[i], ZERO_THRESH) for i in up_ifs)
            sum_tx_vals = sum(max(hardened_tx[i], ZERO_THRESH) for i in up_ifs)
            avg_rx_conf_w = penalty_rx / max(sum_rx_vals, 1e-9)
            avg_tx_conf_w = penalty_tx / max(sum_tx_vals, 1e-9)
            adjust_side = 'rx' if avg_rx_conf_w < avg_tx_conf_w else 'tx'
        else:
            adjust_side = 'rx' if penalty_rx < penalty_tx else 'tx'

        total_adjust3 = (-imbalance if adjust_side == 'rx' else imbalance) * MICRO_FINISH_DAMP

        # High-confidence candidate set and weights by magnitude
        side_vals = {i: (hardened_rx[i] if adjust_side == 'rx' else hardened_tx[i]) for i in up_ifs}
        side_confs = {i: (conf_rx[i] if adjust_side == 'rx' else conf_tx[i]) for i in up_ifs}
        hi_set = [i for i in up_ifs if side_confs[i] >= 0.85]
        if not hi_set:
            continue

        weights3 = {i: max(side_vals[i], ZERO_THRESH) for i in hi_set}
        total_w3 = sum(weights3.values())
        if total_w3 <= 0:
            continue

        for i in hi_set:
            v_old = side_vals[i]
            w_i = weights3[i] / max(total_w3, 1e-9)
            adj_i_raw = total_adjust3 * w_i
            cap = MICRO_FINISH_CLIP * v_old
            adj_i = min(max(adj_i_raw, -cap), cap)
            v_new = max(0.0, v_old + adj_i)
            if adjust_side == 'rx':
                prev = hardened_rx[i]
                if prev > ZERO_EPS:
                    scaled_rx_factor[i] *= (v_new / prev)
                hardened_rx[i] = v_new
                relc = abs(adj_i) / max(1.0, abs(v_old))
                conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.3 * relc))
            else:
                prev = hardened_tx[i]
                if prev > ZERO_EPS:
                    scaled_tx_factor[i] *= (v_new / prev)
                hardened_tx[i] = v_new
                relc = abs(adj_i) / max(1.0, abs(v_old))
                conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.3 * relc))

    # Compute per-router residuals for re-sync attenuation
    router_residual_mid: Dict[str, float] = {}
    for r, ifs in router_ifaces.items():
        ups = [i for i in ifs if status.get(i) == 'up']
        if not ups:
            router_residual_mid[r] = 0.0
        else:
            srx = sum(hardened_rx[i] for i in ups)
            stx = sum(hardened_tx[i] for i in ups)
            denomr = max(1.0, srx, stx)
            router_residual_mid[r] = abs(srx - stx) / denomr
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
        # Clip-hit penalty when strong scaling occurred (>=10%) or cap hit
        if abs(scaled_rx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_rx.get(i, False):
            conf_rx[i] = clamp01(conf_rx[i] * CLIP_HIT_PENALTY)
        if abs(scaled_tx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_tx.get(i, False):
            conf_tx[i] = clamp01(conf_tx[i] * CLIP_HIT_PENALTY)

        # Untouched boost when minimal change (<1%) and good final symmetry on link
=======
    for i in telemetry:
        cr, ct = compute_conf(i)
        conf_rx[i], conf_tx[i] = cr, ct
        # Clip-hit penalty when strong scaling occurred (>=10%) or cap hit
        if abs(scaled_rx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_rx.get(i, False):
            conf_rx[i] = clamp01(conf_rx[i] * CLIP_HIT_PENALTY)
        if abs(scaled_tx_factor.get(i, 1.0) - 1.0) >= 0.10 or clip_hit_tx.get(i, False):
            conf_tx[i] = clamp01(conf_tx[i] * CLIP_HIT_PENALTY)

        # Mild penalty for strong but sub-clip scaling (>8% and <10%)
        if 0.08 < abs(scaled_rx_factor.get(i, 1.0) - 1.0) < 0.10:
            conf_rx[i] = clamp01(conf_rx[i] * 0.97)
        if 0.08 < abs(scaled_tx_factor.get(i, 1.0) - 1.0) < 0.10:
            conf_tx[i] = clamp01(conf_tx[i] * 0.97)

        # Untouched boost when minimal change (<1%) and good final symmetry on link
>>>>>>> REPLACE