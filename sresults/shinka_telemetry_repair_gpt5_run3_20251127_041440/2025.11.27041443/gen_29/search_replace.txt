<NAME>
focus_and_staged_smoothing
</NAME>

<DESCRIPTION>
Two targeted improvements:

1) Focused router correction on lowest-confidence interfaces: In Stage 2, after computing weights, we now select a subset of interfaces that together account for 70% of the total adjustment weight (WEIGHT_FOCUS). We apply bundle-aware scaling and per-interface adjustments only within this focus set, leaving high-confidence links largely untouched. This reduces unnecessary changes, improving counter accuracy and confidence calibration.

2) Order-independent peer smoothing: Replace in-place peer confidence smoothing with a staged update to avoid order dependency and ensure symmetric blending, which improves calibration stability.

These changes keep existing invariants and calibration logic intact while reducing overcorrection.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
=======
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
    WEIGHT_FOCUS = 0.70      # focus router corrections on lowest-confidence 70% weight
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Build weights for distribution: w_i = (1 - conf) * max(val, ZERO_THRESH)
        weights = {i: (1.0 - clamp01(side_confs[i])) * max(side_vals[i], ZERO_THRESH) + 1e-9 for i in up_ifs}
        total_w = sum(weights.values())
        if total_w <= 0:
            weights = {i: 1.0 for i in up_ifs}
            total_w = float(len(up_ifs))

        # Apply bundle-aware scaling if there is a majority bundle; else per-interface adjustments
        if majority_bundles:
            # Distribute total_adjust across bundles proportionally to their combined weights
            # Compute per-bundle weight as sum of member weights
            bundle_weights: Dict[Tuple[Any, Any], float] = {}
            for key, members, _ in majority_bundles:
                bundle_weights[key] = sum(weights[m] for m in members)
            # Remaining non-majority as one group (per-interface below)
            major_total_w = sum(bundle_weights.values())

            # First, scale majority bundles with a shared factor per bundle
            for key, members, s_sum in majority_bundles:
                w_g = bundle_weights.get(key, 0.0)
                if major_total_w <= 0 or s_sum <= ZERO_EPS:
                    continue
                adj_g = total_adjust * (w_g / total_w)  # use global total_w to preserve proportionality
                target_sum = max(0.0, s_sum + adj_g)
                scale_g = target_sum / s_sum
                # Clip group scale to [0.85, 1.15]
                scale_g = max(1.0 - BUNDLE_CLIP, min(1.0 + BUNDLE_CLIP, scale_g))
                for m in members:
                    old = side_vals[m]
                    new = max(0.0, scale_g * old)
                    if adjust_side == 'rx':
                        if hardened_rx[m] > ZERO_EPS:
                            scaled_rx_factor[m] *= (new / hardened_rx[m])
                        hardened_rx[m] = new
                        # Confidence penalty proportional to relative change
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_rx[m] = clamp01(conf_rx[m] * (1.0 - 0.6 * relc))
                    else:
                        if hardened_tx[m] > ZERO_EPS:
                            scaled_tx_factor[m] *= (new / hardened_tx[m])
                        hardened_tx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_tx[m] = clamp01(conf_tx[m] * (1.0 - 0.6 * relc))

            # Then, adjust remaining non-majority interfaces individually using leftover weights
            non_majority = [i for i in up_ifs if all(i not in members for _, members, _ in majority_bundles)]
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                # Compute remaining adjustment share for non-majority
                adj_nm = total_adjust * (nm_total_w / total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = weights[i] / nm_total_w
                    adj_i = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i, -cap), cap)
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        if hardened_rx[i] > ZERO_EPS:
                            scaled_rx_factor[i] *= (v_new / hardened_rx[i])
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        if hardened_tx[i] > ZERO_EPS:
                            scaled_tx_factor[i] *= (v_new / hardened_tx[i])
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
        else:
            # No dominant bundle: targeted per-interface corrections only
            for i in up_ifs:
                v_old = side_vals[i]
                w_i = weights[i] / total_w
                adj_i = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i, -cap), cap)
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    if hardened_rx[i] > ZERO_EPS:
                        scaled_rx_factor[i] *= (v_new / hardened_rx[i])
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    if hardened_tx[i] > ZERO_EPS:
                        scaled_tx_factor[i] *= (v_new / hardened_tx[i])
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
=======
        # Build weights for distribution: w_i = (1 - conf) * max(val, ZERO_THRESH)
        weights = {i: (1.0 - clamp01(side_confs[i])) * max(side_vals[i], ZERO_THRESH) + 1e-9 for i in up_ifs}
        total_w = sum(weights.values())
        if total_w <= 0:
            weights = {i: 1.0 for i in up_ifs}
            total_w = float(len(up_ifs))

        # Focus adjustments on the lowest-confidence subset covering WEIGHT_FOCUS of total weight
        sorted_ifs = sorted(up_ifs, key=lambda x: weights[x], reverse=True)
        focus_set: List[str] = []
        acc = 0.0
        for i in sorted_ifs:
            if acc / max(total_w, 1e-12) >= WEIGHT_FOCUS:
                break
            focus_set.append(i)
            acc += weights[i]
        if not focus_set:
            focus_set = list(up_ifs)
            acc = total_w
        focus_total_w = max(acc, 1e-9)

        # Apply bundle-aware scaling if there is a majority bundle; else per-interface adjustments
        if majority_bundles:
            # Compute per-bundle weight and focused members
            bundle_weights: Dict[Tuple[Any, Any], float] = {}
            bundle_members_focused: Dict[Tuple[Any, Any], List[str]] = {}
            for key, members, _ in majority_bundles:
                focused_members = [m for m in members if m in focus_set]
                if not focused_members:
                    continue
                bundle_members_focused[key] = focused_members
                bundle_weights[key] = sum(weights[m] for m in focused_members)

            # First, scale majority bundles with a shared factor per bundle on focused members only
            for key, members, _ in majority_bundles:
                focused_members = bundle_members_focused.get(key, [])
                if not focused_members:
                    continue
                w_g = bundle_weights.get(key, 0.0)
                if w_g <= 0.0:
                    continue
                adj_g = total_adjust * (w_g / focus_total_w)
                s_sum_focus = sum(side_vals[m] for m in focused_members)
                if s_sum_focus <= ZERO_EPS:
                    continue
                target_sum = max(0.0, s_sum_focus + adj_g)
                scale_g = target_sum / s_sum_focus
                # Clip group scale to [0.85, 1.15]
                scale_g = max(1.0 - BUNDLE_CLIP, min(1.0 + BUNDLE_CLIP, scale_g))
                for m in focused_members:
                    old = side_vals[m]
                    new = max(0.0, scale_g * old)
                    if adjust_side == 'rx':
                        prev = hardened_rx[m]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[m] *= (new / prev)
                        hardened_rx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_rx[m] = clamp01(conf_rx[m] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[m]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[m] *= (new / prev)
                        hardened_tx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_tx[m] = clamp01(conf_tx[m] * (1.0 - 0.6 * relc))

            # Then, adjust remaining focused non-majority interfaces individually
            all_major_members = [m for _, members, _ in majority_bundles for m in members]
            non_majority_all = [i for i in up_ifs if i not in all_major_members]
            non_majority = [i for i in non_majority_all if i in focus_set]
            nm_total_w = sum(weights[i] for i in non_majority)
            if nm_total_w > 0:
                adj_nm = total_adjust * (nm_total_w / focus_total_w)
                for i in non_majority:
                    v_old = side_vals[i]
                    w_i = weights[i] / nm_total_w
                    adj_i = adj_nm * w_i
                    # Clip per-interface relative change ±10%
                    cap = PER_LINK_CLIP * v_old
                    adj_i = min(max(adj_i, -cap), cap)
                    v_new = max(0.0, v_old + adj_i)
                    if adjust_side == 'rx':
                        prev = hardened_rx[i]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[i] *= (v_new / prev)
                        hardened_rx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[i]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[i] *= (v_new / prev)
                        hardened_tx[i] = v_new
                        relc = abs(adj_i) / max(1.0, abs(v_old))
                        conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
        else:
            # No dominant bundle: targeted per-interface corrections only over focus_set
            for i in focus_set:
                v_old = side_vals[i]
                w_i = weights[i] / focus_total_w
                adj_i = total_adjust * w_i
                cap = PER_LINK_CLIP * v_old
                adj_i = min(max(adj_i, -cap), cap)
                v_new = max(0.0, v_old + adj_i)
                if adjust_side == 'rx':
                    prev = hardened_rx[i]
                    if prev > ZERO_EPS:
                        scaled_rx_factor[i] *= (v_new / prev)
                    hardened_rx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_rx[i] = clamp01(conf_rx[i] * (1.0 - 0.6 * relc))
                else:
                    prev = hardened_tx[i]
                    if prev > ZERO_EPS:
                        scaled_tx_factor[i] *= (v_new / prev)
                    hardened_tx[i] = v_new
                    relc = abs(adj_i) / max(1.0, abs(v_old))
                    conf_tx[i] = clamp01(conf_tx[i] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Peer smoothing
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            conf_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_tx[a] + PEER_SMOOTH * conf_rx[b])
            conf_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_rx[b] + PEER_SMOOTH * conf_tx[a])
            conf_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_rx[a] + PEER_SMOOTH * conf_tx[b])
            conf_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_tx[b] + PEER_SMOOTH * conf_rx[a])
=======
    # Peer smoothing (order-independent via staged update)
    new_conf_rx = dict(conf_rx)
    new_conf_tx = dict(conf_tx)
    for a, b in link_pairs:
        if status.get(a) == 'up' and status.get(b) == 'up':
            new_conf_tx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_tx[a] + PEER_SMOOTH * conf_rx[b])
            new_conf_rx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_rx[b] + PEER_SMOOTH * conf_tx[a])
            new_conf_rx[a] = clamp01((1.0 - PEER_SMOOTH) * conf_rx[a] + PEER_SMOOTH * conf_tx[b])
            new_conf_tx[b] = clamp01((1.0 - PEER_SMOOTH) * conf_tx[b] + PEER_SMOOTH * conf_rx[a])
    conf_rx, conf_tx = new_conf_rx, new_conf_tx
>>>>>>> REPLACE
</DIFF>