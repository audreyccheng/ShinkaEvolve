<NAME>
adaptive_tolerances_softzero_resync_guard_conf_calib
</NAME>

<DESCRIPTION>
I propose four targeted improvements to boost counter accuracy and confidence calibration without destabilizing status repairs:

1) Adaptive tolerances:
   - Use a dynamic per-direction hardening tolerance inside fuse_direction: stricter (1.5%) when both sides are high-rate and up; looser (3%) for low rates or down/unknown status; baseline 2% otherwise. This reduces over-fixing at high rates and suppresses jitter at low rates.
   - Use an adaptive router imbalance threshold TAU_ROUTER based on the number of active interfaces: TAU_ROUTER = clip(0.03–0.07, 0.05 * sqrt(2 / max(2, n_active))). It avoids unnecessary scaling on sparse routers and reacts better on busy ones.

2) Confidence-gap re-sync guard:
   - Skip the post-projection one-sided nudge on a direction that just experienced strong scaling (|scale_factor − 1| > 0.08). This prevents double-adjustment and improves router conservation and calibration.

3) Soft-zero stabilization:
   - After router projection, if both directions on a link are tiny (< 2*ZERO_THRESH) and both adjacent routers are within their adaptive thresholds, snap both directions to zero with high confidence. This stabilizes near-zero noise and aligns with the no-drop invariant.

4) Confidence calibration refinements:
   - Apply a mild clip-hit penalty (×0.95) when a direction's total scaling magnitude is large (≥10%) or hits the clip bounds (≤0.90 or ≥1.10).
   - Add an untouched boost (+0.02 up to 0.98) when a direction changed <1% and final symmetry is good.
   - Enhance the final residual-based touch-up by adding 10% peer confidence smoothing on top of the 70/30 residual blend.

These changes are minimal, well-bounded, and consistent with the Hodor-inspired principles, focusing on better invariant satisfaction and calibrated confidence without heavy rewrites.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Helper functions
    def safe_rate(x: Any) -> float:
        try:
            v = float(x)
            if not math.isfinite(v) or v < 0:
                return 0.0
            return v
        except Exception:
            return 0.0

    def rel_diff(a: float, b: float) -> float:
        m = max(abs(a), abs(b), 1.0)
        return abs(a - b) / m

    def clamp01(x: float) -> float:
        if x < 0.0: return 0.0
        if x > 1.0: return 1.0
        return x
=======
    # Helper functions
    def safe_rate(x: Any) -> float:
        try:
            v = float(x)
            if not math.isfinite(v) or v < 0:
                return 0.0
            return v
        except Exception:
            return 0.0

    def rel_diff(a: float, b: float) -> float:
        m = max(abs(a), abs(b), 1.0)
        return abs(a - b) / m

    def clamp01(x: float) -> float:
        if x < 0.0: return 0.0
        if x > 1.0: return 1.0
        return x

    def tau_router(n_active: int) -> float:
        # Adaptive router tolerance based on number of active interfaces
        # Clamp within [0.03, 0.07]
        base = 0.05 * math.sqrt(2.0 / max(2, n_active))
        return max(0.03, min(0.07, base))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)

        # Both near-zero => zero with high confidence
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within hardening tolerance, keep local reading (minimal change)
        if mismatch <= TAU_H:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero and the other is not, take the non-zero
        if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
=======
    def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
        mismatch = rel_diff(v_local, v_peer)

        # Adaptive hardening tolerance per-direction
        if (v_local > 100.0 and v_peer > 100.0 and s_local == "up" and s_peer == "up"):
            th = 0.015
        elif (v_local < 1.0 or v_peer < 1.0) or (s_local != "up" or s_peer != "up"):
            th = 0.03
        else:
            th = TAU_H

        # Both near-zero => zero with high confidence
        if max(v_local, v_peer) < ZERO_THRESH:
            return 0.0, 0.95

        # If within hardening tolerance, keep local reading (minimal change)
        if mismatch <= th:
            return v_local, 0.95

        # Moderate mismatch: average
        if mismatch <= 0.10:
            fused = 0.5 * v_local + 0.5 * v_peer
            return fused, clamp01(1.0 - mismatch)

        # Large mismatch: prefer the more plausible side
        # If one is near-zero and the other is not, take the non-zero
        if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
            return v_peer, clamp01(1.0 - mismatch)
        if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
            return v_local, clamp01(1.0 - mismatch)

        # Status-aware bias
        if s_local == "down" and s_peer == "up":
            return v_peer, clamp01(1.0 - mismatch)
        if s_peer == "down" and s_local == "up":
            return v_local, clamp01(1.0 - mismatch)

        # Otherwise, snap mostly to peer to resolve asymmetry decisively
        fused = 0.3 * v_local + 0.7 * v_peer
        return fused, clamp01(1.0 - mismatch)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        sum_tx = sum(hard_tx.get(i, 0.0) for i in if_list)
        sum_rx = sum(hard_rx.get(i, 0.0) for i in if_list)
        mismatch = rel_diff(sum_tx, sum_rx)
        router_imbalance_before[router] = mismatch

        if max(sum_tx, sum_rx) < EPS:
            continue  # nothing to project

        if mismatch > TAU_ROUTER:
=======
        sum_tx = sum(hard_tx.get(i, 0.0) for i in if_list)
        sum_rx = sum(hard_rx.get(i, 0.0) for i in if_list)
        mismatch = rel_diff(sum_tx, sum_rx)
        router_imbalance_before[router] = mismatch

        if max(sum_tx, sum_rx) < EPS:
            continue  # nothing to project

        # Adaptive router tolerance based on active interfaces
        n_active_tx = sum(1 for i in if_list if hard_tx.get(i, 0.0) >= ZERO_THRESH)
        n_active_rx = sum(1 for i in if_list if hard_rx.get(i, 0.0) >= ZERO_THRESH)
        n_active = max(n_active_tx, n_active_rx)
        TAU_ROUTER_LOCAL = tau_router(n_active)

        if mismatch > TAU_ROUTER_LOCAL:
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ab = rel_diff(tx_a, rx_b)
        if diff_ab > TAU_H and max(tx_a, rx_b) >= ZERO_THRESH:
            mean_ab = 0.5 * (tx_a + rx_b)
            ca = conf_tx_link.get(a, 0.6)
            cb = conf_rx_link.get(b, 0.6)
            if ca < cb:
                # Nudge lower-confidence side proportionally to confidence gap
                f = min(0.4, max(0.0, cb - ca))
                hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                conf_tx_link[a] *= 0.95
            elif cb < ca:
                f = min(0.4, max(0.0, ca - cb))
                hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                conf_rx_link[b] *= 0.95
            else:
                # Both similar confidence and low: small cautious nudge toward mean
                if ca < 0.7:
                    f = 0.15
                    hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                    hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                    conf_tx_link[a] *= 0.93
                    conf_rx_link[b] *= 0.93
=======
        diff_ab = rel_diff(tx_a, rx_b)
        recent_strong_scale = (abs(scaled_tx_factor.get(a, 1.0) - 1.0) > 0.08) or (abs(scaled_rx_factor.get(b, 1.0) - 1.0) > 0.08)
        if diff_ab > TAU_H and max(tx_a, rx_b) >= ZERO_THRESH and not recent_strong_scale:
            mean_ab = 0.5 * (tx_a + rx_b)
            ca = conf_tx_link.get(a, 0.6)
            cb = conf_rx_link.get(b, 0.6)
            if ca < cb:
                # Nudge lower-confidence side proportionally to confidence gap
                f = min(0.4, max(0.0, cb - ca))
                hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                conf_tx_link[a] *= 0.95
            elif cb < ca:
                f = min(0.4, max(0.0, ca - cb))
                hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                conf_rx_link[b] *= 0.95
            else:
                # Both similar confidence and low: small cautious nudge toward mean
                if ca < 0.7:
                    f = 0.15
                    hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                    hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                    conf_tx_link[a] *= 0.93
                    conf_rx_link[b] *= 0.93
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        diff_ba = rel_diff(tx_b, rx_a)
        if diff_ba > TAU_H and max(tx_b, rx_a) >= ZERO_THRESH:
            mean_ba = 0.5 * (tx_b + rx_a)
            cb_tx = conf_tx_link.get(b, 0.6)
            ca_rx = conf_rx_link.get(a, 0.6)
            if cb_tx < ca_rx:
                f = min(0.4, max(0.0, ca_rx - cb_tx))
                hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                conf_tx_link[b] *= 0.95
            elif ca_rx < cb_tx:
                f = min(0.4, max(0.0, cb_tx - ca_rx))
                hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                conf_rx_link[a] *= 0.95
            else:
                if cb_tx < 0.7:
                    f = 0.15
                    hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                    hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                    conf_tx_link[b] *= 0.93
                    conf_rx_link[a] *= 0.93
=======
        diff_ba = rel_diff(tx_b, rx_a)
        recent_strong_scale_ba = (abs(scaled_tx_factor.get(b, 1.0) - 1.0) > 0.08) or (abs(scaled_rx_factor.get(a, 1.0) - 1.0) > 0.08)
        if diff_ba > TAU_H and max(tx_b, rx_a) >= ZERO_THRESH and not recent_strong_scale_ba:
            mean_ba = 0.5 * (tx_b + rx_a)
            cb_tx = conf_tx_link.get(b, 0.6)
            ca_rx = conf_rx_link.get(a, 0.6)
            if cb_tx < ca_rx:
                f = min(0.4, max(0.0, ca_rx - cb_tx))
                hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                conf_tx_link[b] *= 0.95
            elif ca_rx < cb_tx:
                f = min(0.4, max(0.0, cb_tx - ca_rx))
                hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                conf_rx_link[a] *= 0.95
            else:
                if cb_tx < 0.7:
                    f = 0.15
                    hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                    hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                    conf_tx_link[b] *= 0.93
                    conf_rx_link[a] *= 0.93
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # 2) Final per-direction symmetry residuals AFTER all adjustments
    post_mismatch_tx_dir: Dict[str, float] = {}
    post_mismatch_rx_dir: Dict[str, float] = {}
=======
    # Soft-zero stabilization for tiny bidirectional links when adjacent routers are balanced
    processed_pairs = set()
    for a, data in telemetry.items():
        b = data.get('connected_to')
        if not isinstance(b, str) or b not in telemetry:
            continue
        key = tuple(sorted([a, b]))
        if key in processed_pairs:
            continue
        processed_pairs.add(key)
        tx_a = hard_tx.get(a, 0.0)
        rx_b = hard_rx.get(b, 0.0)
        tx_b = hard_tx.get(b, 0.0)
        rx_a = hard_rx.get(a, 0.0)
        if max(tx_a, rx_b, tx_b, rx_a) < 2.0 * ZERO_THRESH:
            ra = router_of.get(a)
            rb = router_of.get(b)
            imba = router_imbalance_after.get(ra, 0.0)
            imbb = router_imbalance_after.get(rb, 0.0)

            def router_active_thresh(rid: str) -> float:
                if rid is None or rid not in router_ifaces:
                    return 0.05
                ifs = router_ifaces.get(rid, [])
                n_tx = sum(1 for i in ifs if hard_tx.get(i, 0.0) >= ZERO_THRESH)
                n_rx = sum(1 for i in ifs if hard_rx.get(i, 0.0) >= ZERO_THRESH)
                return tau_router(max(n_tx, n_rx))

            tau_a = router_active_thresh(ra)
            tau_b = router_active_thresh(rb)
            if imba <= tau_a and imbb <= tau_b:
                hard_tx[a] = 0.0
                hard_rx[b] = 0.0
                hard_tx[b] = 0.0
                hard_rx[a] = 0.0
                conf_tx_link[a] = max(conf_tx_link.get(a, 0.6), 0.95)
                conf_rx_link[b] = max(conf_rx_link.get(b, 0.6), 0.95)
                conf_tx_link[b] = max(conf_tx_link.get(b, 0.6), 0.95)
                conf_rx_link[a] = max(conf_rx_link.get(a, 0.6), 0.95)

    # 2) Final per-direction symmetry residuals AFTER all adjustments
    post_mismatch_tx_dir: Dict[str, float] = {}
    post_mismatch_rx_dir: Dict[str, float] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        conf_rx_final = clamp01(
            0.23 * base_rx_conf +
            0.20 * red_rx +
            0.27 * fin_sym_rx +
            0.10 * ch_rx +
            0.10 * router_factor_after +
            0.10 * scale_rx_term
        )

        # Status enforcement: down implies zero counters
        rep_status = repaired_status.get(if_id, status.get(if_id, "unknown"))
=======
        conf_rx_final = clamp01(
            0.23 * base_rx_conf +
            0.20 * red_rx +
            0.27 * fin_sym_rx +
            0.10 * ch_rx +
            0.10 * router_factor_after +
            0.10 * scale_rx_term
        )

        # Confidence refinements: clip-hit penalty and untouched boost
        if abs(scaled_tx_factor.get(if_id, 1.0) - 1.0) >= 0.10 or scaled_tx_factor.get(if_id, 1.0) <= 0.90 or scaled_tx_factor.get(if_id, 1.0) >= 1.10:
            conf_tx_final *= 0.95
        if abs(scaled_rx_factor.get(if_id, 1.0) - 1.0) >= 0.10 or scaled_rx_factor.get(if_id, 1.0) <= 0.90 or scaled_rx_factor.get(if_id, 1.0) >= 1.10:
            conf_rx_final *= 0.95
        if change_tx < 0.01 and fin_sym_tx >= (1.0 - TAU_H):
            conf_tx_final = min(0.98, conf_tx_final + 0.02)
        if change_rx < 0.01 and fin_sym_rx >= (1.0 - TAU_H):
            conf_rx_final = min(0.98, conf_rx_final + 0.02)

        # Status enforcement: down implies zero counters
        rep_status = repaired_status.get(if_id, status.get(if_id, "unknown"))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            clamp01(0.70 * old_tx_c + 0.30 * clamp01(1.0 - mis_tx))
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            clamp01(0.70 * old_rx_c + 0.30 * clamp01(1.0 - mis_rx))
        )
=======
        mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
        mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
        old_tx_c = clamp01(result[i]['tx_rate'][2])
        old_rx_c = clamp01(result[i]['rx_rate'][2])
        base_tx_c = clamp01(0.70 * old_tx_c + 0.30 * clamp01(1.0 - mis_tx))
        base_rx_c = clamp01(0.70 * old_rx_c + 0.30 * clamp01(1.0 - mis_rx))
        peer_rx_c = clamp01(result[peer]['rx_rate'][2])
        peer_tx_c = clamp01(result[peer]['tx_rate'][2])
        final_tx_c = clamp01(0.90 * base_tx_c + 0.10 * peer_rx_c)
        final_rx_c = clamp01(0.90 * base_rx_c + 0.10 * peer_tx_c)
        result[i]['tx_rate'] = (
            result[i]['tx_rate'][0],
            result[i]['tx_rate'][1],
            final_tx_c
        )
        result[i]['rx_rate'] = (
            result[i]['rx_rate'][0],
            result[i]['rx_rate'][1],
            final_rx_c
        )
>>>>>>> REPLACE
</DIFF>