<NAME>
saturating_resync_with_caps_and_bilateral
</NAME>

<DESCRIPTION>
I propose improving Stage 3 (link re-sync) by making the re-sync gain mismatch-proportional and saturating, and adding a per-direction absolute move cap. This makes nudges stronger when the symmetry gap is clearly beyond tolerance and gentler near the threshold, while guarding against large one-shot corrections that may harm calibration. I also add a guarded bilateral micro-step when both sides are low-confidence and both adjacent routers are within tolerance, which helps close stubborn residuals safely.

Concretely:
- Introduce a sigmoid-based gain f = 0.4·sigmoid(5·(gap_norm − 0.5)), attenuated by adjacent router imbalance. gap_norm is the normalized symmetry gap beyond adaptive tolerance.
- Add RESYNC_PER_DIR_CAP = 0.02 to cap each move to ±2% of the max of the two values per direction.
- Keep the strong scaling guard so we don’t move a direction that was strongly adjusted in Stage 2.
- Add bilateral micro-step when both confidences < 0.70 and routers are balanced, moving both sides toward their mean with small, capped steps.

These changes should improve counter repair accuracy by addressing mismatches proportionally and safely, and maintain or improve confidence calibration by avoiding overcorrections, especially on low or recently scaled links.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from typing import Dict, Any, Tuple, List
=======
from typing import Dict, Any, Tuple, List
import math
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    PEER_SMOOTH = 0.10       # 10% peer smoothing
=======
    RESYNC_MAX_F = 0.40      # max one-sided nudge toward mean
    RESYNC_PER_DIR_CAP = 0.02  # per-direction absolute move cap as fraction of max value
    PEER_SMOOTH = 0.10       # 10% peer smoothing
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Attenuation factor based on adjacent routers' imbalance
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = clamp01(1.0 - max(router_residual_mid.get(ra, 0.0), router_residual_mid.get(rb, 0.0)))

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = hardened_tx[a], hardened_rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.6), conf_rx.get(b, 0.6)
                # Skip if strong router scaling already applied on the target direction
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_rx
                        new = max(0.0, nudge_toward_mean(old, a_tx, f))
                        hardened_rx[b] = new
                        relc = rel_diff(new, old)
                        conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_tx
                        new = max(0.0, nudge_toward_mean(old, b_rx, f))
                        hardened_tx[a] = new
                        relc = rel_diff(new, old)
                        conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * relc))

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = hardened_rx[a], hardened_tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.6), conf_tx.get(b, 0.6)
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, ca - cb)) * att
                    if f > 0.0:
                        old = b_tx
                        new = max(0.0, nudge_toward_mean(old, a_rx, f))
                        hardened_tx[b] = new
                        relc = rel_diff(new, old)
                        conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * relc))
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, max(0.0, cb - ca)) * att
                    if f > 0.0:
                        old = a_rx
                        new = max(0.0, nudge_toward_mean(old, b_tx, f))
                        hardened_rx[a] = new
                        relc = rel_diff(new, old)
                        conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * relc))
=======
    def nudge_toward_mean(val_lo: float, val_hi: float, frac: float) -> float:
        target = 0.5 * (val_lo + val_hi)
        return val_lo + frac * (target - val_lo)

    for a, b in link_pairs:
        if status.get(a) != 'up' or status.get(b) != 'up':
            continue

        # Attenuation factor based on adjacent routers' imbalance
        ra = local_router_of.get(a)
        rb = local_router_of.get(b)
        att = clamp01(1.0 - max(router_residual_mid.get(ra, 0.0), router_residual_mid.get(rb, 0.0)))

        # Direction 1: a.tx vs b.rx
        a_tx, b_rx = hardened_tx[a], hardened_rx[b]
        if max(a_tx, b_rx) > ZERO_EPS:
            d1 = rel_diff(a_tx, b_rx)
            tau1 = adaptive_tau(a_tx, b_rx)
            if d1 > tau1:
                ca, cb = conf_tx.get(a, 0.6), conf_rx.get(b, 0.6)
                gap_norm = clamp01((d1 - tau1) / max(tau1, 1e-9))
                # Saturating mismatch-proportional gain attenuated by router imbalance
                f_base = 0.4 * (1.0 / (1.0 + math.exp(-5.0 * (gap_norm - 0.5)))) * att
                moved = False
                # Prefer moving the higher-confidence peer whose target dir hasn't been strongly scaled
                if ca >= cb and abs(scaled_rx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, f_base)
                    if f > 0.0:
                        old = b_rx
                        target = a_tx
                        step = nudge_toward_mean(old, target, f)
                        # cap absolute move per direction
                        cap_abs = RESYNC_PER_DIR_CAP * max(target, old, 1.0)
                        new = max(0.0, min(old + cap_abs, max(old - cap_abs, step)))
                        hardened_rx[b] = new
                        relc = rel_diff(new, old)
                        conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.3 * relc))
                        moved = True
                elif cb > ca and abs(scaled_tx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, f_base)
                    if f > 0.0:
                        old = a_tx
                        target = b_rx
                        step = nudge_toward_mean(old, target, f)
                        cap_abs = RESYNC_PER_DIR_CAP * max(target, old, 1.0)
                        new = max(0.0, min(old + cap_abs, max(old - cap_abs, step)))
                        hardened_tx[a] = new
                        relc = rel_diff(new, old)
                        conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.3 * relc))
                        moved = True
                # bilateral micro-step when both sides low-confidence and routers within tolerance
                if not moved and ca < 0.70 and cb < 0.70:
                    na = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
                    nb = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
                    tau_ra = min(0.07, max(0.03, 0.05 * (2.0 / max(2, na)) ** 0.5))
                    tau_rb = min(0.07, max(0.03, 0.05 * (2.0 / max(2, nb)) ** 0.5))
                    if router_residual_mid.get(ra, 0.0) <= tau_ra and router_residual_mid.get(rb, 0.0) <= tau_rb:
                        f_bi = min(0.10, 0.5 * gap_norm) * att
                        if f_bi > 0.0:
                            old_a = a_tx; old_b = b_rx
                            tgt = 0.5 * (old_a + old_b)
                            cap_a = RESYNC_PER_DIR_CAP * max(old_a, tgt, 1.0)
                            cap_b = RESYNC_PER_DIR_CAP * max(old_b, tgt, 1.0)
                            new_a = old_a + clamp01(f_bi) * (tgt - old_a)
                            new_b = old_b + clamp01(f_bi) * (tgt - old_b)
                            new_a = max(0.0, min(old_a + cap_a, max(old_a - cap_a, new_a)))
                            new_b = max(0.0, min(old_b + cap_b, max(old_b - cap_b, new_b)))
                            hardened_tx[a] = new_a
                            hardened_rx[b] = new_b
                            conf_tx[a] = clamp01(conf_tx[a] * (1.0 - 0.2 * rel_diff(new_a, old_a)))
                            conf_rx[b] = clamp01(conf_rx[b] * (1.0 - 0.2 * rel_diff(new_b, old_b)))

        # Direction 2: a.rx vs b.tx
        a_rx, b_tx = hardened_rx[a], hardened_tx[b]
        if max(a_rx, b_tx) > ZERO_EPS:
            d2 = rel_diff(a_rx, b_tx)
            tau2 = adaptive_tau(a_rx, b_tx)
            if d2 > tau2:
                ca, cb = conf_rx.get(a, 0.6), conf_tx.get(b, 0.6)
                gap_norm = clamp01((d2 - tau2) / max(tau2, 1e-9))
                f_base = 0.4 * (1.0 / (1.0 + math.exp(-5.0 * (gap_norm - 0.5)))) * att
                moved = False
                if ca >= cb and abs(scaled_tx_factor.get(b, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, f_base)
                    if f > 0.0:
                        old = b_tx
                        target = a_rx
                        step = nudge_toward_mean(old, target, f)
                        cap_abs = RESYNC_PER_DIR_CAP * max(target, old, 1.0)
                        new = max(0.0, min(old + cap_abs, max(old - cap_abs, step)))
                        hardened_tx[b] = new
                        relc = rel_diff(new, old)
                        conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.3 * relc))
                        moved = True
                elif cb > ca and abs(scaled_rx_factor.get(a, 1.0) - 1.0) <= STRONG_SCALE_GUARD:
                    f = min(RESYNC_MAX_F, f_base)
                    if f > 0.0:
                        old = a_rx
                        target = b_tx
                        step = nudge_toward_mean(old, target, f)
                        cap_abs = RESYNC_PER_DIR_CAP * max(target, old, 1.0)
                        new = max(0.0, min(old + cap_abs, max(old - cap_abs, step)))
                        hardened_rx[a] = new
                        relc = rel_diff(new, old)
                        conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.3 * relc))
                        moved = True
                if not moved and ca < 0.70 and cb < 0.70:
                    na = len([i for i in router_ifaces.get(ra, []) if status.get(i) == 'up'])
                    nb = len([i for i in router_ifaces.get(rb, []) if status.get(i) == 'up'])
                    tau_ra = min(0.07, max(0.03, 0.05 * (2.0 / max(2, na)) ** 0.5))
                    tau_rb = min(0.07, max(0.03, 0.05 * (2.0 / max(2, nb)) ** 0.5))
                    if router_residual_mid.get(ra, 0.0) <= tau_ra and router_residual_mid.get(rb, 0.0) <= tau_rb:
                        f_bi = min(0.10, 0.5 * gap_norm) * att
                        if f_bi > 0.0:
                            old_a = a_rx; old_b = b_tx
                            tgt = 0.5 * (old_a + old_b)
                            cap_a = RESYNC_PER_DIR_CAP * max(old_a, tgt, 1.0)
                            cap_b = RESYNC_PER_DIR_CAP * max(old_b, tgt, 1.0)
                            new_a = old_a + clamp01(f_bi) * (tgt - old_a)
                            new_b = old_b + clamp01(f_bi) * (tgt - old_b)
                            new_a = max(0.0, min(old_a + cap_a, max(old_a - cap_a, new_a)))
                            new_b = max(0.0, min(old_b + cap_b, max(old_b - cap_b, new_b)))
                            hardened_rx[a] = new_a
                            hardened_tx[b] = new_b
                            conf_rx[a] = clamp01(conf_rx[a] * (1.0 - 0.2 * rel_diff(new_a, old_a)))
                            conf_tx[b] = clamp01(conf_tx[b] * (1.0 - 0.2 * rel_diff(new_b, old_b)))
>>>>>>> REPLACE

</DIFF>