--- a/original.py
+++ b/original.py
@@ -1,603 +1,738 @@
 # EVOLVE-BLOCK-START
 """
 Hybrid Hodor repair: robust link hardening with adaptive fusion + conservative router projection.
 
 This implementation follows and combines:
 1) Signal Collection: use redundant signals from both sides of a link.
 2) Signal Hardening: direction-wise fusion with adaptive regimes:
    - tiny mismatch: keep local
    - moderate mismatch: average
    - large mismatch: snap to peer with status/zero-aware bias
 3) Dynamic Checking / Projection: conservatively enforce router flow conservation with
    damped scaling and clipped factors. After projection, gently re-sync links, adjusting
    only the lower-confidence side if needed.
 
 Outputs repaired telemetry with calibrated confidence scores.
 """
 from typing import Dict, Any, Tuple, List
 import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network telemetry using hybrid per-link fusion and conservative router-level flow projection.
 
     Args:
         telemetry: per-interface telemetry dictionary with fields:
             - interface_status: "up" or "down"
             - rx_rate: float Mbps
             - tx_rate: float Mbps
             - connected_to: peer interface id
             - local_router: router id
             - remote_router: router id on the other side
         topology: router_id -> list of interface_ids
 
     Returns:
         Same structure as telemetry, but rx_rate, tx_rate, interface_status become tuples:
         (original_value, repaired_value, confidence) in [0, 1].
         Non-telemetry fields are copied unchanged.
     """
     # Tolerances/thresholds inspired by Hodor
     TAU_H = 0.02          # symmetry tolerance 2%
     TAU_ROUTER = 0.05     # router imbalance tolerance 5% (more conservative)
     EPS = 1e-9
     ZERO_THRESH = 0.1     # Mbps considered near-zero
 
     # Helper functions
     def safe_rate(x: Any) -> float:
         try:
             v = float(x)
             if not math.isfinite(v) or v < 0:
                 return 0.0
             return v
         except Exception:
             return 0.0
 
     def rel_diff(a: float, b: float) -> float:
         m = max(abs(a), abs(b), 1.0)
         return abs(a - b) / m
 
     def clamp01(x: float) -> float:
         if x < 0.0: return 0.0
         if x > 1.0: return 1.0
         return x
+
+    def tau_router(n_active: int) -> float:
+        """
+        Adaptive router imbalance tolerance based on number of active interfaces.
+        0.05 * sqrt(2 / max(2, n_active)) clamped to [0.03, 0.07].
+        """
+        base = 0.05 * math.sqrt(2.0 / max(2, n_active))
+        return max(0.03, min(0.07, base))
+
+    def router_imbalance(router_id: str) -> float:
+        """
+        Compute current router imbalance using hardened rates (post-hardening, pre/post projection).
+        Note: relies on hard_tx/hard_rx/router_ifaces defined later in the function.
+        """
+        try:
+            if not router_id or router_id not in router_ifaces:
+                return 0.0
+            ifs = router_ifaces[router_id]
+            stx = sum(hard_tx.get(i, 0.0) for i in ifs)
+            srx = sum(hard_rx.get(i, 0.0) for i in ifs)
+            return rel_diff(stx, srx)
+        except Exception:
+            return 0.0
 
     # Build peer mapping
     peers: Dict[str, str] = {}
     for if_id, data in telemetry.items():
         peer = data.get("connected_to")
         if isinstance(peer, str) and peer in telemetry:
             peers[if_id] = peer
 
     # Build router->interfaces from topology with fallback to local_router
     router_ifaces: Dict[str, List[str]] = {}
     for r, if_list in topology.items():
         router_ifaces.setdefault(r, [])
         for i in if_list:
             if i in telemetry:
                 router_ifaces[r].append(i)
     for if_id, data in telemetry.items():
         r = data.get("local_router")
         if r is None:
             r = f"unknown_router::{if_id}"
         router_ifaces.setdefault(r, [])
         if if_id not in router_ifaces[r]:
             router_ifaces[r].append(if_id)
 
     # Prepare originals and status
     orig_tx: Dict[str, float] = {}
     orig_rx: Dict[str, float] = {}
     status: Dict[str, str] = {}
     router_of: Dict[str, str] = {}
     for r, ifs in router_ifaces.items():
         for i in ifs:
             router_of[i] = r
 
     for if_id, data in telemetry.items():
         orig_tx[if_id] = safe_rate(data.get("tx_rate", 0.0))
         orig_rx[if_id] = safe_rate(data.get("rx_rate", 0.0))
         s = data.get("interface_status", "unknown")
         status[if_id] = s if s in ("up", "down") else "unknown"
 
     # Stage 1: Link hardening with adaptive fusion
     hard_tx: Dict[str, float] = {}
     hard_rx: Dict[str, float] = {}
     conf_tx_link: Dict[str, float] = {}
     conf_rx_link: Dict[str, float] = {}
     pre_mismatch_tx: Dict[str, float] = {}
     pre_mismatch_rx: Dict[str, float] = {}
 
     visited = set()
 
     def fuse_direction(v_local: float, v_peer: float, s_local: str, s_peer: str) -> Tuple[float, float]:
         mismatch = rel_diff(v_local, v_peer)
 
         # Both near-zero => zero with high confidence
         if max(v_local, v_peer) < ZERO_THRESH:
             return 0.0, 0.95
 
         # If within hardening tolerance, keep local reading (minimal change)
         if mismatch <= TAU_H:
             return v_local, 0.95
 
         # Moderate mismatch: average
         if mismatch <= 0.10:
             fused = 0.5 * v_local + 0.5 * v_peer
             return fused, clamp01(1.0 - mismatch)
 
         # Large mismatch: prefer the more plausible side
         # If one is near-zero and the other is not, take the non-zero
         if v_local < ZERO_THRESH and v_peer >= ZERO_THRESH:
             return v_peer, clamp01(1.0 - mismatch)
         if v_peer < ZERO_THRESH and v_local >= ZERO_THRESH:
             return v_local, clamp01(1.0 - mismatch)
 
         # Status-aware bias
         if s_local == "down" and s_peer == "up":
             return v_peer, clamp01(1.0 - mismatch)
         if s_peer == "down" and s_local == "up":
             return v_local, clamp01(1.0 - mismatch)
 
-        # Otherwise, snap mostly to peer to resolve asymmetry decisively
-        fused = 0.3 * v_local + 0.7 * v_peer
+        # Otherwise, use adaptive peer-biased fusion for decisive reconciliation
+        # beta increases with mismatch severity and leans to peer when local is down/near-zero; slightly away if peer is down
+        # beta in [0.7, 0.9]
+        mm = max(0.0, min(1.0, (mismatch - 0.10) / 0.20))  # normalized beyond 10% up to 30%
+        bias_up_local_down = 1.0 if (s_local == "down" or (v_local < ZERO_THRESH and v_peer >= ZERO_THRESH)) else 0.0
+        bias_peer_down = 1.0 if (s_peer == "down") else 0.0
+        beta = 0.7 + 0.2 * mm + 0.1 * bias_up_local_down - 0.1 * bias_peer_down
+        beta = max(0.7, min(0.9, beta))
+        fused = (1.0 - beta) * v_local + beta * v_peer
         return fused, clamp01(1.0 - mismatch)
 
     for if_id, data in telemetry.items():
         if if_id in visited:
             continue
         peer = peers.get(if_id)
         if not peer:
             # Isolated interface: keep as-is with conservative confidence
             hard_tx[if_id] = orig_tx[if_id]
             hard_rx[if_id] = orig_rx[if_id]
             conf_tx_link[if_id] = 0.6
             conf_rx_link[if_id] = 0.6
             pre_mismatch_tx[if_id] = 0.4
             pre_mismatch_rx[if_id] = 0.4
             visited.add(if_id)
             continue
 
         visited.add(if_id)
         visited.add(peer)
 
         a, b = if_id, peer
         a_tx, a_rx = orig_tx[a], orig_rx[a]
         b_tx, b_rx = orig_tx[b], orig_rx[b]
         sa, sb = status[a], status[b]
 
         # If both ends down: force zeros
         if sa == "down" and sb == "down":
             hard_tx[a] = 0.0
             hard_rx[a] = 0.0
             hard_tx[b] = 0.0
             hard_rx[b] = 0.0
             conf_tx_link[a] = 0.98
             conf_rx_link[a] = 0.98
             conf_tx_link[b] = 0.98
             conf_rx_link[b] = 0.98
             pre_mismatch_tx[a] = rel_diff(a_tx, b_rx)
             pre_mismatch_rx[a] = rel_diff(a_rx, b_tx)
             pre_mismatch_tx[b] = rel_diff(b_tx, a_rx)
             pre_mismatch_rx[b] = rel_diff(b_rx, a_tx)
             continue
 
         # Directional mismatches
         diff_ab = rel_diff(a_tx, b_rx)
         diff_ba = rel_diff(b_tx, a_rx)
         pre_mismatch_tx[a] = diff_ab
         pre_mismatch_rx[b] = diff_ab
         pre_mismatch_tx[b] = diff_ba
         pre_mismatch_rx[a] = diff_ba
 
         fused_ab, c_ab = fuse_direction(a_tx, b_rx, sa, sb)
         fused_ba, c_ba = fuse_direction(b_tx, a_rx, sb, sa)
 
         # Assign hardened values per direction maintaining symmetry mapping
         hard_tx[a] = fused_ab
         hard_rx[b] = fused_ab
         hard_tx[b] = fused_ba
         hard_rx[a] = fused_ba
 
         conf_tx_link[a] = c_ab
         conf_rx_link[b] = c_ab
         conf_tx_link[b] = c_ba
         conf_rx_link[a] = c_ba
 
     # Ensure all interfaces have hardened values
     for if_id in telemetry.keys():
         if if_id not in hard_tx:
             hard_tx[if_id] = orig_tx[if_id]
             conf_tx_link[if_id] = 0.6
         if if_id not in hard_rx:
             hard_rx[if_id] = orig_rx[if_id]
             conf_rx_link[if_id] = 0.6
         if if_id not in pre_mismatch_tx:
             pre_mismatch_tx[if_id] = 0.4
         if if_id not in pre_mismatch_rx:
             pre_mismatch_rx[if_id] = 0.4
 
-    # Stage 2: Conservative router-level flow projection
+    # Stage 2: Conservative router-level flow projection with adaptive tolerance and dominance cap
     router_imbalance_before: Dict[str, float] = {}
     scaled_tx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
     scaled_rx_factor: Dict[str, float] = {if_id: 1.0 for if_id in telemetry}
+    # Track directions that received strong scaling to guard against double-adjustment in re-sync
+    strong_scaled_tx: Dict[str, bool] = {if_id: False for if_id in telemetry}
+    strong_scaled_rx: Dict[str, bool] = {if_id: False for if_id in telemetry}
 
     for router, if_list in router_ifaces.items():
         # Ignore trivial routers
         if len(if_list) <= 1:
             router_imbalance_before[router] = 0.0
             continue
 
         sum_tx = sum(hard_tx.get(i, 0.0) for i in if_list)
         sum_rx = sum(hard_rx.get(i, 0.0) for i in if_list)
         mismatch = rel_diff(sum_tx, sum_rx)
         router_imbalance_before[router] = mismatch
 
         if max(sum_tx, sum_rx) < EPS:
             continue  # nothing to project
 
-        if mismatch > TAU_ROUTER:
+        # Adaptive router tolerance based on number of active interfaces
+        n_active_tx = sum(1 for i in if_list if hard_tx.get(i, 0.0) >= ZERO_THRESH)
+        n_active_rx = sum(1 for i in if_list if hard_rx.get(i, 0.0) >= ZERO_THRESH)
+        TAU_ROUTER_LOCAL = tau_router(max(n_active_tx, n_active_rx))
+
+        if mismatch > TAU_ROUTER_LOCAL:
             # Choose side with lower aggregate link confidence to adjust
             c_tx_total = sum(conf_tx_link.get(i, 0.5) for i in if_list)
             c_rx_total = sum(conf_rx_link.get(i, 0.5) for i in if_list)
             adjust_side = "tx" if c_tx_total < c_rx_total else "rx"
 
             if adjust_side == "tx" and sum_tx > 0:
-                # Targeted scaling on low-confidence, active interfaces
-                vals = [hard_tx.get(i, 0.0) for i in if_list]
-                confs = [conf_tx_link.get(i, 0.6) for i in if_list]
-                weights = []
-                for v, c in zip(vals, confs):
-                    # Lower confidence and larger rate => more adjustable
-                    w = max(0.0, (1.0 - clamp01(c)) * (v if v >= ZERO_THRESH else 0.0))
-                    weights.append(w)
-                denom = sum(v * w for v, w in zip(vals, weights))
                 target = sum_rx
                 current = sum_tx
                 delta = target - current
+
+                # Targeted scaling on low-confidence, active interfaces with dominance cap
+                vals = {i: hard_tx.get(i, 0.0) for i in if_list}
+                confs = {i: conf_tx_link.get(i, 0.6) for i in if_list}
+                weights = {i: max(0.0, (1.0 - clamp01(confs[i])) * (vals[i] if vals[i] >= ZERO_THRESH else 0.0)) for i in if_list}
+                denom = sum(vals[i] * weights[i] for i in if_list)
                 if denom < EPS:
                     # Fallback to uniform damped scaling
                     alpha = target / max(current, EPS)
                     alpha = max(0.85, min(1.15, alpha))
                     alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                     for i in if_list:
-                        hard_tx[i] *= alpha_eff
+                        v = hard_tx.get(i, 0.0)
+                        hard_tx[i] = v * alpha_eff
                         scaled_tx_factor[i] *= alpha_eff
                         penalty = clamp01(abs(alpha_eff - 1.0))
                         conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
+                        if penalty > 0.08:
+                            strong_scaled_tx[i] = True
                 else:
                     k = delta / denom
-                    for idx, i in enumerate(if_list):
-                        v = vals[idx]
-                        w = weights[idx]
+                    cap_abs = 0.5 * abs(delta) if len(if_list) >= 2 else None
+                    for i in if_list:
+                        v = vals[i]
+                        w = weights[i]
                         if v < EPS or w <= 0.0:
                             continue
                         # Damped, clipped per-interface scaling
                         scale_i = 1.0 + 0.6 * (k * w)
                         scale_i = max(0.90, min(1.10, scale_i))
+                        change_i = v * (scale_i - 1.0)
+                        # Dominance cap: a single interface cannot contribute >50% of total correction
+                        if cap_abs is not None and abs(change_i) > cap_abs:
+                            scale_i = 1.0 + math.copysign(cap_abs, change_i) / max(v, EPS)
+                            change_i = v * (scale_i - 1.0)
                         hard_tx[i] = v * scale_i
                         scaled_tx_factor[i] *= scale_i
                         penalty = clamp01(abs(scale_i - 1.0))
                         conf_tx_link[i] *= clamp01(1.0 - 0.4 * penalty)
+                        if penalty > 0.08:
+                            strong_scaled_tx[i] = True
+
+                    # Final small uniform damped scaling if imbalance persists
+                    sum_tx2 = sum(hard_tx.get(i, 0.0) for i in if_list)
+                    sum_rx2 = sum(hard_rx.get(i, 0.0) for i in if_list)
+                    if rel_diff(sum_tx2, sum_rx2) > TAU_ROUTER_LOCAL and sum_tx2 > 0:
+                        alpha = sum_rx2 / max(sum_tx2, EPS)
+                        alpha = max(0.95, min(1.05, alpha))
+                        alpha_eff = 1.0 + 0.4 * (alpha - 1.0)
+                        for i in if_list:
+                            v = hard_tx.get(i, 0.0)
+                            if v < ZERO_THRESH:
+                                continue
+                            hard_tx[i] = v * alpha_eff
+                            scaled_tx_factor[i] *= alpha_eff
+                            penalty = clamp01(abs(alpha_eff - 1.0))
+                            conf_tx_link[i] *= clamp01(1.0 - 0.3 * penalty)
+                            if penalty > 0.08:
+                                strong_scaled_tx[i] = True
+
             elif adjust_side == "rx" and sum_rx > 0:
-                vals = [hard_rx.get(i, 0.0) for i in if_list]
-                confs = [conf_rx_link.get(i, 0.6) for i in if_list]
-                weights = []
-                for v, c in zip(vals, confs):
-                    w = max(0.0, (1.0 - clamp01(c)) * (v if v >= ZERO_THRESH else 0.0))
-                    weights.append(w)
-                denom = sum(v * w for v, w in zip(vals, weights))
                 target = sum_tx
                 current = sum_rx
                 delta = target - current
+
+                vals = {i: hard_rx.get(i, 0.0) for i in if_list}
+                confs = {i: conf_rx_link.get(i, 0.6) for i in if_list}
+                weights = {i: max(0.0, (1.0 - clamp01(confs[i])) * (vals[i] if vals[i] >= ZERO_THRESH else 0.0)) for i in if_list}
+                denom = sum(vals[i] * weights[i] for i in if_list)
                 if denom < EPS:
                     alpha = target / max(current, EPS)
                     alpha = max(0.85, min(1.15, alpha))
                     alpha_eff = 1.0 + 0.6 * (alpha - 1.0)
                     for i in if_list:
-                        hard_rx[i] *= alpha_eff
+                        v = hard_rx.get(i, 0.0)
+                        hard_rx[i] = v * alpha_eff
                         scaled_rx_factor[i] *= alpha_eff
                         penalty = clamp01(abs(alpha_eff - 1.0))
                         conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
+                        if penalty > 0.08:
+                            strong_scaled_rx[i] = True
                 else:
                     k = delta / denom
-                    for idx, i in enumerate(if_list):
-                        v = vals[idx]
-                        w = weights[idx]
+                    cap_abs = 0.5 * abs(delta) if len(if_list) >= 2 else None
+                    for i in if_list:
+                        v = vals[i]
+                        w = weights[i]
                         if v < EPS or w <= 0.0:
                             continue
                         scale_i = 1.0 + 0.6 * (k * w)
                         scale_i = max(0.90, min(1.10, scale_i))
+                        change_i = v * (scale_i - 1.0)
+                        if cap_abs is not None and abs(change_i) > cap_abs:
+                            scale_i = 1.0 + math.copysign(cap_abs, change_i) / max(v, EPS)
+                            change_i = v * (scale_i - 1.0)
                         hard_rx[i] = v * scale_i
                         scaled_rx_factor[i] *= scale_i
                         penalty = clamp01(abs(scale_i - 1.0))
                         conf_rx_link[i] *= clamp01(1.0 - 0.4 * penalty)
+                        if penalty > 0.08:
+                            strong_scaled_rx[i] = True
+
+                    sum_tx2 = sum(hard_tx.get(i, 0.0) for i in if_list)
+                    sum_rx2 = sum(hard_rx.get(i, 0.0) for i in if_list)
+                    if rel_diff(sum_tx2, sum_rx2) > TAU_ROUTER_LOCAL and sum_rx2 > 0:
+                        alpha = sum_tx2 / max(sum_rx2, EPS)
+                        alpha = max(0.95, min(1.05, alpha))
+                        alpha_eff = 1.0 + 0.4 * (alpha - 1.0)
+                        for i in if_list:
+                            v = hard_rx.get(i, 0.0)
+                            if v < ZERO_THRESH:
+                                continue
+                            hard_rx[i] = v * alpha_eff
+                            scaled_rx_factor[i] *= alpha_eff
+                            penalty = clamp01(abs(alpha_eff - 1.0))
+                            conf_rx_link[i] *= clamp01(1.0 - 0.3 * penalty)
+                            if penalty > 0.08:
+                                strong_scaled_rx[i] = True
 
     # Stage 2.5: Post-projection gentle link re-sync (only adjust lower-confidence side)
     for a, data in telemetry.items():
         b = peers.get(a)
         if not b or a > b:
             # Process each pair once; ensure deterministic order by a > b check
             continue
-        # Compare my_tx[a] vs their_rx[b], and my_rx[a] vs their_tx[b]
         # a->b direction
         tx_a = hard_tx.get(a, 0.0)
         rx_b = hard_rx.get(b, 0.0)
         diff_ab = rel_diff(tx_a, rx_b)
         if diff_ab > TAU_H and max(tx_a, rx_b) >= ZERO_THRESH:
             mean_ab = 0.5 * (tx_a + rx_b)
-            ca = conf_tx_link.get(a, 0.6)
-            cb = conf_rx_link.get(b, 0.6)
-            if ca < cb:
-                # Nudge lower-confidence side proportionally to confidence gap
-                f = min(0.4, max(0.0, cb - ca))
+            ca = clamp01(conf_tx_link.get(a, 0.6))
+            cb = clamp01(conf_rx_link.get(b, 0.6))
+            # Attenuate by local router imbalance to avoid double-adjustment
+            att_a = clamp01(1.0 - router_imbalance(router_of.get(a, "")))
+            att_b = clamp01(1.0 - router_imbalance(router_of.get(b, "")))
+            if ca < cb and not strong_scaled_tx.get(a, False):
+                f = min(0.4, max(0.0, cb - ca)) * att_a
                 hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
                 conf_tx_link[a] *= 0.95
-            elif cb < ca:
-                f = min(0.4, max(0.0, ca - cb))
+            elif cb < ca and not strong_scaled_rx.get(b, False):
+                f = min(0.4, max(0.0, ca - cb)) * att_b
                 hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
                 conf_rx_link[b] *= 0.95
             else:
                 # Both similar confidence and low: small cautious nudge toward mean
-                if ca < 0.7:
-                    f = 0.15
-                    hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
-                    hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
-                    conf_tx_link[a] *= 0.93
-                    conf_rx_link[b] *= 0.93
+                if min(ca, cb) < 0.7:
+                    f = 0.15 * min(att_a, att_b)
+                    if not strong_scaled_tx.get(a, False):
+                        hard_tx[a] = (1.0 - f) * tx_a + f * mean_ab
+                        conf_tx_link[a] *= 0.93
+                    if not strong_scaled_rx.get(b, False):
+                        hard_rx[b] = (1.0 - f) * rx_b + f * mean_ab
+                        conf_rx_link[b] *= 0.93
         # b->a direction
         tx_b = hard_tx.get(b, 0.0)
         rx_a = hard_rx.get(a, 0.0)
         diff_ba = rel_diff(tx_b, rx_a)
         if diff_ba > TAU_H and max(tx_b, rx_a) >= ZERO_THRESH:
             mean_ba = 0.5 * (tx_b + rx_a)
-            cb_tx = conf_tx_link.get(b, 0.6)
-            ca_rx = conf_rx_link.get(a, 0.6)
-            if cb_tx < ca_rx:
-                f = min(0.4, max(0.0, ca_rx - cb_tx))
+            cb_tx = clamp01(conf_tx_link.get(b, 0.6))
+            ca_rx = clamp01(conf_rx_link.get(a, 0.6))
+            att_b = clamp01(1.0 - router_imbalance(router_of.get(b, "")))
+            att_a = clamp01(1.0 - router_imbalance(router_of.get(a, "")))
+            if cb_tx < ca_rx and not strong_scaled_tx.get(b, False):
+                f = min(0.4, max(0.0, ca_rx - cb_tx)) * att_b
                 hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
                 conf_tx_link[b] *= 0.95
-            elif ca_rx < cb_tx:
-                f = min(0.4, max(0.0, cb_tx - ca_rx))
+            elif ca_rx < cb_tx and not strong_scaled_rx.get(a, False):
+                f = min(0.4, max(0.0, cb_tx - ca_rx)) * att_a
                 hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
                 conf_rx_link[a] *= 0.95
             else:
-                if cb_tx < 0.7:
-                    f = 0.15
-                    hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
-                    hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
-                    conf_tx_link[b] *= 0.93
-                    conf_rx_link[a] *= 0.93
+                if min(cb_tx, ca_rx) < 0.7:
+                    f = 0.15 * min(att_a, att_b)
+                    if not strong_scaled_tx.get(b, False):
+                        hard_tx[b] = (1.0 - f) * tx_b + f * mean_ba
+                        conf_tx_link[b] *= 0.93
+                    if not strong_scaled_rx.get(a, False):
+                        hard_rx[a] = (1.0 - f) * rx_a + f * mean_ba
+                        conf_rx_link[a] *= 0.93
 
     # Status repair (conservative and symmetry-aware)
     repaired_status: Dict[str, str] = {}
     status_conf: Dict[str, float] = {}
     processed = set()
     for if_id in telemetry.keys():
         if if_id in processed:
             continue
         peer = peers.get(if_id)
         s_local = status.get(if_id, "unknown")
         if not peer:
             repaired_status[if_id] = s_local
             status_conf[if_id] = 0.95
             processed.add(if_id)
             continue
 
         s_peer = status.get(peer, "unknown")
         rep_local = s_local
         rep_peer = s_peer
         c_local = 0.95
         c_peer = 0.95
 
         # Both report down
         if s_local == "down" and s_peer == "down":
             rep_local = "down"
             rep_peer = "down"
             c_local = 0.98
             c_peer = 0.98
         elif s_local != s_peer:
             # If any traffic on link, set both up
             link_has_traffic = (hard_tx[if_id] >= ZERO_THRESH or hard_rx[if_id] >= ZERO_THRESH or
                                 hard_tx.get(peer, 0.0) >= ZERO_THRESH or hard_rx.get(peer, 0.0) >= ZERO_THRESH)
             if link_has_traffic:
                 rep_local = "up"
                 rep_peer = "up"
                 c_local = 0.7
                 c_peer = 0.7
             else:
                 # Ambiguous mismatch; keep as-is but lower confidence
                 c_local = 0.6
                 c_peer = 0.6
         else:
             rep_local = s_local
             rep_peer = s_peer
             c_local = 0.95
             c_peer = 0.95
 
         repaired_status[if_id] = rep_local
         repaired_status[peer] = rep_peer
         status_conf[if_id] = c_local
         status_conf[peer] = c_peer
         processed.add(if_id)
         processed.add(peer)
 
     # Calibrate confidence using post-projection invariants
     # 1) Router imbalance AFTER projection
     router_imbalance_after: Dict[str, float] = {}
     for router, if_list in router_ifaces.items():
         if not if_list:
             router_imbalance_after[router] = 0.0
             continue
         sum_tx_after = sum(hard_tx.get(i, 0.0) for i in if_list)
         sum_rx_after = sum(hard_rx.get(i, 0.0) for i in if_list)
         router_imbalance_after[router] = rel_diff(sum_tx_after, sum_rx_after)
 
     # 2) Final per-direction symmetry residuals AFTER all adjustments
     post_mismatch_tx_dir: Dict[str, float] = {}
     post_mismatch_rx_dir: Dict[str, float] = {}
     for if_id in telemetry.keys():
         peer = peers.get(if_id)
         if peer:
             post_mismatch_tx_dir[if_id] = rel_diff(hard_tx.get(if_id, 0.0), hard_rx.get(peer, 0.0))
             post_mismatch_rx_dir[if_id] = rel_diff(hard_rx.get(if_id, 0.0), hard_tx.get(peer, 0.0))
         else:
             # No redundant signal available: use moderate default uncertainty
             post_mismatch_tx_dir[if_id] = 0.4
             post_mismatch_rx_dir[if_id] = 0.4
 
     # Compose final results with calibrated confidences
     result: Dict[str, Dict[str, Tuple]] = {}
     for if_id, data in telemetry.items():
         rep_tx = hard_tx.get(if_id, orig_tx[if_id])
         rep_rx = hard_rx.get(if_id, orig_rx[if_id])
 
         # Compute change magnitude
         # Note: rel_diff uses max(1.0, ...) in denominator, stabilizing near-zero cases
         change_tx = rel_diff(orig_tx[if_id], rep_tx)
         change_rx = rel_diff(orig_rx[if_id], rep_rx)
 
         # Pre-fusion mismatch (redundancy before hardening)
         pre_tx = pre_mismatch_tx.get(if_id, 0.4)
         pre_rx = pre_mismatch_rx.get(if_id, 0.4)
 
         # Post-fusion symmetry agreement (redundancy after final hardening)
         fin_sym_tx = clamp01(1.0 - post_mismatch_tx_dir.get(if_id, 0.4))
         fin_sym_rx = clamp01(1.0 - post_mismatch_rx_dir.get(if_id, 0.4))
 
         # Router context penalty AFTER projection
         r = router_of.get(if_id, None)
         router_penalty_after = router_imbalance_after.get(r, 0.0) if r is not None else 0.0
         router_factor_after = clamp01(1.0 - min(0.5, router_penalty_after))
 
         base_tx_conf = conf_tx_link.get(if_id, 0.6)
         base_rx_conf = conf_rx_link.get(if_id, 0.6)
 
         red_tx = clamp01(1.0 - pre_tx)
         red_rx = clamp01(1.0 - pre_rx)
 
         ch_tx = clamp01(1.0 - change_tx)
         ch_rx = clamp01(1.0 - change_rx)
 
         # Blend confidence components with emphasis on final invariant satisfaction and scale penalty
         scale_tx_term = clamp01(1.0 - min(0.5, abs(scaled_tx_factor.get(if_id, 1.0) - 1.0)))
         scale_rx_term = clamp01(1.0 - min(0.5, abs(scaled_rx_factor.get(if_id, 1.0) - 1.0)))
         conf_tx_final = clamp01(
             0.23 * base_tx_conf +
             0.20 * red_tx +
             0.27 * fin_sym_tx +
             0.10 * ch_tx +
             0.10 * router_factor_after +
             0.10 * scale_tx_term
         )
         conf_rx_final = clamp01(
             0.23 * base_rx_conf +
             0.20 * red_rx +
             0.27 * fin_sym_rx +
             0.10 * ch_rx +
             0.10 * router_factor_after +
             0.10 * scale_rx_term
         )
 
+        # Confidence refinements: strong-scale penalty and untouched boost
+        if abs(scaled_tx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
+            conf_tx_final *= 0.95
+        if abs(scaled_rx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
+            conf_rx_final *= 0.95
+        if 'strong_scaled_tx' in locals() and strong_scaled_tx.get(if_id, False):
+            conf_tx_final *= 0.97
+        if 'strong_scaled_rx' in locals() and strong_scaled_rx.get(if_id, False):
+            conf_rx_final *= 0.97
+        if change_tx < 0.01 and fin_sym_tx >= (1.0 - TAU_H):
+            conf_tx_final = min(0.98, conf_tx_final + 0.02)
+        if change_rx < 0.01 and fin_sym_rx >= (1.0 - TAU_H):
+            conf_rx_final = min(0.98, conf_rx_final + 0.02)
+
         # Status enforcement: down implies zero counters
         rep_status = repaired_status.get(if_id, status.get(if_id, "unknown"))
         conf_status = status_conf.get(if_id, 0.9)
         if rep_status == "down":
             rep_tx = 0.0
             rep_rx = 0.0
             if orig_tx[if_id] >= ZERO_THRESH or orig_rx[if_id] >= ZERO_THRESH:
                 conf_tx_final = min(conf_tx_final, 0.7)
                 conf_rx_final = min(conf_rx_final, 0.7)
             else:
                 conf_tx_final = max(conf_tx_final, 0.9)
                 conf_rx_final = max(conf_rx_final, 0.9)
 
         # Assemble output record
         out = {}
         out["rx_rate"] = (orig_rx[if_id], rep_rx, conf_rx_final)
         out["tx_rate"] = (orig_tx[if_id], rep_tx, conf_tx_final)
         out["interface_status"] = (status[if_id], rep_status, conf_status)
 
         # Copy metadata unchanged
         out["connected_to"] = data.get("connected_to")
         out["local_router"] = data.get("local_router")
         out["remote_router"] = data.get("remote_router")
 
         result[if_id] = out
 
     # Final confidence touch-up: incorporate final symmetry residuals.
     # Only adjust when both ends are up to avoid inflating confidence for downed links.
     for i, data in telemetry.items():
         peer = data.get('connected_to')
         if not isinstance(peer, str) or peer not in telemetry or i not in result or peer not in result:
             continue
         if result[i]['interface_status'][1] != 'up' or result[peer]['interface_status'][1] != 'up':
             continue
         mis_tx = rel_diff(safe_rate(result[i]['tx_rate'][1]), safe_rate(result[peer]['rx_rate'][1]))
         mis_rx = rel_diff(safe_rate(result[i]['rx_rate'][1]), safe_rate(result[peer]['tx_rate'][1]))
         old_tx_c = clamp01(result[i]['tx_rate'][2])
         old_rx_c = clamp01(result[i]['rx_rate'][2])
         result[i]['tx_rate'] = (
             result[i]['tx_rate'][0],
             result[i]['tx_rate'][1],
             clamp01(0.70 * old_tx_c + 0.30 * clamp01(1.0 - mis_tx))
         )
         result[i]['rx_rate'] = (
             result[i]['rx_rate'][0],
             result[i]['rx_rate'][1],
             clamp01(0.70 * old_rx_c + 0.30 * clamp01(1.0 - mis_rx))
+        )
+
+    # Peer confidence smoothing (10%) when both ends are up
+    for i, data in telemetry.items():
+        p = data.get('connected_to')
+        if not isinstance(p, str) or p not in telemetry:
+            continue
+        if i not in result or p not in result:
+            continue
+        if result[i]['interface_status'][1] != 'up' or result[p]['interface_status'][1] != 'up':
+            continue
+        my_tx_c = clamp01(result[i]['tx_rate'][2])
+        my_rx_c = clamp01(result[i]['rx_rate'][2])
+        peer_rx_c = clamp01(result[p]['rx_rate'][2])
+        peer_tx_c = clamp01(result[p]['tx_rate'][2])
+        result[i]['tx_rate'] = (
+            result[i]['tx_rate'][0],
+            result[i]['tx_rate'][1],
+            clamp01(0.90 * my_tx_c + 0.10 * peer_rx_c)
+        )
+        result[i]['rx_rate'] = (
+            result[i]['rx_rate'][0],
+            result[i]['rx_rate'][1],
+            clamp01(0.90 * my_rx_c + 0.10 * peer_tx_c)
         )
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")