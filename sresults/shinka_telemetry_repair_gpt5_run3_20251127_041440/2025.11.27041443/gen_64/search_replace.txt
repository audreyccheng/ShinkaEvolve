<NAME>
median_bundle_and_strongscale_conf
</NAME>

<DESCRIPTION>
I propose two targeted improvements to boost counter repair accuracy and tighten confidence calibration:

1) Robust bundle residual centering via median: In the conservation-preserving bundle finishing pass (Stage 2.6), replace the mean residual center with the median residual. Parallel link bundles often have one outlier link with a skewed residual. Using the median e_med instead of the mean for the base delta computation reduces the influence of outliers, improving link symmetry alignment without disturbing router conservation (we keep the zero-sum re-centering step). This should improve counter accuracy and stability on bundles.

2) Strong-scale guard for confidence calibration: Add an explicit small penalty to confidence when a direction underwent strong router-level scaling (>8%). We already track strong_scaled_tx/rx and clip hits; this additional guard makes confidences more honest when significant scaling was applied, improving calibration without unduly harming overall confidence.

Both changes are minimal, self-contained, and consistent with the existing algorithmâ€™s flow and thresholds.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        if len(es) <= 1:
            return
        mean_e = sum(es) / len(es)
        # Build base deltas with adaptive gamma per link
        base = []
        for k, e in enumerate(es):
            if ab_dir:
                tx = hard_tx.get(idxs[k][0], 0.0)
                rx = hard_rx.get(idxs[k][1], 0.0)
            else:
                tx = hard_tx.get(idxs[k][1], 0.0)
                rx = hard_rx.get(idxs[k][0], 0.0)
            mismatch = rel_diff(tx, rx)
            gamma = min(0.25, 0.5 * TAU_H / max(mismatch, 1e-9))
            base.append(-gamma * (e - mean_e))
=======
        if len(es) <= 1:
            return
        # Robust center using median residual to reduce outlier influence
        es_sorted = sorted(es)
        mid = len(es_sorted) // 2
        if len(es_sorted) % 2 == 1:
            e_center = es_sorted[mid]
        else:
            e_center = 0.5 * (es_sorted[mid - 1] + es_sorted[mid])
        # Build base deltas with adaptive gamma per link
        base = []
        for k, e in enumerate(es):
            if ab_dir:
                tx = hard_tx.get(idxs[k][0], 0.0)
                rx = hard_rx.get(idxs[k][1], 0.0)
            else:
                tx = hard_tx.get(idxs[k][1], 0.0)
                rx = hard_rx.get(idxs[k][0], 0.0)
            mismatch = rel_diff(tx, rx)
            gamma = min(0.25, 0.5 * TAU_H / max(mismatch, 1e-9))
            base.append(-gamma * (e - e_center))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Confidence refinements: clip-hit penalty and untouched boost
        if abs(scaled_tx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_tx_final *= 0.95
        if abs(scaled_rx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_rx_final *= 0.95
        # Additional penalty when scaling was clipped
        if 'clip_hit_tx' in locals() and clip_hit_tx.get(if_id, False):
            conf_tx_final *= 0.95
        if 'clip_hit_rx' in locals() and clip_hit_rx.get(if_id, False):
            conf_rx_final *= 0.95
        if change_tx < 0.01 and fin_sym_tx >= (1.0 - TAU_H):
            conf_tx_final = min(0.98, conf_tx_final + 0.02)
        if change_rx < 0.01 and fin_sym_rx >= (1.0 - TAU_H):
            conf_rx_final = min(0.98, conf_rx_final + 0.02)
=======
        # Confidence refinements: clip-hit penalty and untouched boost
        if abs(scaled_tx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_tx_final *= 0.95
        if abs(scaled_rx_factor.get(if_id, 1.0) - 1.0) >= 0.10:
            conf_rx_final *= 0.95
        # Additional penalty when scaling was clipped
        if 'clip_hit_tx' in locals() and clip_hit_tx.get(if_id, False):
            conf_tx_final *= 0.95
        if 'clip_hit_rx' in locals() and clip_hit_rx.get(if_id, False):
            conf_rx_final *= 0.95
        # Strong-scale guard: small additional penalty when any strong scaling (>8%) occurred
        if 'strong_scaled_tx' in locals() and strong_scaled_tx.get(if_id, False):
            conf_tx_final *= 0.97
        if 'strong_scaled_rx' in locals() and strong_scaled_rx.get(if_id, False):
            conf_rx_final *= 0.97
        if change_tx < 0.01 and fin_sym_tx >= (1.0 - TAU_H):
            conf_tx_final = min(0.98, conf_tx_final + 0.02)
        if change_rx < 0.01 and fin_sym_rx >= (1.0 - TAU_H):
            conf_rx_final = min(0.98, conf_rx_final + 0.02)
>>>>>>> REPLACE
</DIFF>