<NAME>
final_micro_projection
</NAME>

<DESCRIPTION>
I propose adding a conservative final micro-projection step after bundle finishing and soft-zero passes but before status and confidence calibration. This step re-enforces per-router flow conservation with a very small, damped, and clipped uniform scaling (≤2%, with 0.3 damping) on the side (TX or RX) that has lower aggregate confidence. It excludes near-zero interfaces using a router activity threshold to avoid jitter and updates scaling factors and confidences accordingly.

Rationale:
- Router finishing and bundle alignment can slightly disturb per-router conservation; re-enforcing it with a guarded micro-step should reduce residual imbalances and improve counter repair accuracy without harming symmetry.
- Using low damping and narrow clips minimizes risk of overcorrection.
- Shielding near-zero links preserves stability.
- Confidence adjustments are minor and aligned with the small correction magnitude, improving calibration.

This change is targeted and consistent with the existing tiered scaling, dominance awareness, and router-aware smoothing framework. It is expected to lift counter_repair_accuracy and keep or slightly improve confidence calibration, thus increasing the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Status repair (conservative and symmetry-aware)
    repaired_status: Dict[str, str] = {}
    status_conf: Dict[str, float] = {}
    processed = set()
=======
    # Stage 2.8: Final micro-projection to restore router flow conservation (≤2% move, damped)
    for router, if_list in router_ifaces.items():
        if len(if_list) <= 1:
            continue
        sum_tx = sum(hard_tx.get(i, 0.0) for i in if_list)
        sum_rx = sum(hard_rx.get(i, 0.0) for i in if_list)
        if max(sum_tx, sum_rx) < EPS:
            continue
        n_active_tx = sum(1 for i in if_list if hard_tx.get(i, 0.0) >= ZERO_THRESH)
        n_active_rx = sum(1 for i in if_list if hard_rx.get(i, 0.0) >= ZERO_THRESH)
        TAU_ROUTER_LOCAL = tau_router(max(n_active_tx, n_active_rx))
        mismatch = rel_diff(sum_tx, sum_rx)
        if mismatch > TAU_ROUTER_LOCAL:
            # Choose side with lower aggregate confidence for a tiny correction
            c_tx_total = sum(clamp01(conf_tx_link.get(i, 0.6)) for i in if_list)
            c_rx_total = sum(clamp01(conf_rx_link.get(i, 0.6)) for i in if_list)
            side = "tx" if c_tx_total < c_rx_total else "rx"
            current = sum_tx if side == "tx" else sum_rx
            target = sum_rx if side == "tx" else sum_tx
            # Tiny, damped, clipped scaling
            alpha = clamp(target / max(current, EPS), 0.98, 1.02)
            alpha_eff = 1.0 + 0.3 * (alpha - 1.0)
            # Shield near-zero interfaces based on router activity
            thr_router = max(ZERO_THRESH, 0.002 * (sum_tx + sum_rx))
            if side == "tx":
                for i in if_list:
                    v = hard_tx.get(i, 0.0)
                    if v < max(ZERO_THRESH, thr_router):
                        continue
                    hard_tx[i] = v * alpha_eff
                    scaled_tx_factor[i] *= alpha_eff
                    pen = clamp01(abs(alpha_eff - 1.0))
                    conf_tx_link[i] *= clamp01(1.0 - 0.2 * pen)
                    if alpha_eff <= 0.98 or alpha_eff >= 1.02:
                        clip_hit_tx[i] = True
            else:
                for i in if_list:
                    v = hard_rx.get(i, 0.0)
                    if v < max(ZERO_THRESH, thr_router):
                        continue
                    hard_rx[i] = v * alpha_eff
                    scaled_rx_factor[i] *= alpha_eff
                    pen = clamp01(abs(alpha_eff - 1.0))
                    conf_rx_link[i] *= clamp01(1.0 - 0.2 * pen)
                    if alpha_eff <= 0.98 or alpha_eff >= 1.02:
                        clip_hit_rx[i] = True

    # Status repair (conservative and symmetry-aware)
    repaired_status: Dict[str, str] = {}
    status_conf: Dict[str, float] = {}
    processed = set()
>>>>>>> REPLACE

</DIFF>