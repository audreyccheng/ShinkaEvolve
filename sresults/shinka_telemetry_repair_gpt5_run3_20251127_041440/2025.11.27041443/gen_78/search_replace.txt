<NAME>
fix_focus_bundle_scaling
</NAME>

<DESCRIPTION>
I found and fixed a consistency bug in Stage 2’s bundle-aware scaling. When a majority bundle exists, the algorithm distributes the router’s required adjustment over a focused subset of interfaces (the lowest-confidence share). However, the group scale factor was computed using the total bundle sum (s_sum) while applying the scaling only to the focused members. This causes over/under-scaling of the focused subset and can distort both router balance and link symmetry, harming counter accuracy and confidence calibration.

The fix computes the shared scale using only the focused members’ sum (s_sum_focus), ensuring the target adjustment is correctly realized by exactly those interfaces that are actually being scaled. This change aligns intent with effect, reduces unnecessary distortions, and should improve counter repair accuracy while keeping confidence better calibrated.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            for key, members, s_sum in majority_bundles:
                focused_members = bundle_members_focused.get(key, [])
                if not focused_members or s_sum <= ZERO_EPS:
                    continue
                w_g = bundle_weights.get(key, 0.0)
                if w_g <= 0.0:
                    continue
                adj_g = total_adjust * (w_g / focus_total_w)
                target_sum = max(0.0, s_sum + adj_g)
                scale_g = target_sum / max(s_sum, 1e-12)
                # Clip group scale to [0.85, 1.15]
                scale_g = max(1.0 - BUNDLE_CLIP, min(1.0 + BUNDLE_CLIP, scale_g))
                for m in focused_members:
                    old = side_vals[m]
                    new = max(0.0, scale_g * old)
                    if adjust_side == 'rx':
                        prev = hardened_rx[m]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[m] *= (new / prev)
                        hardened_rx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_rx[m] = clamp01(conf_rx[m] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[m]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[m] *= (new / prev)
                        hardened_tx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_tx[m] = clamp01(conf_tx[m] * (1.0 - 0.6 * relc))
=======
            for key, members, s_sum in majority_bundles:
                focused_members = bundle_members_focused.get(key, [])
                if not focused_members:
                    continue
                w_g = bundle_weights.get(key, 0.0)
                if w_g <= 0.0:
                    continue
                adj_g = total_adjust * (w_g / focus_total_w)
                # Compute scale against focused members only to avoid over/under-scaling
                s_sum_focus = sum(side_vals[m] for m in focused_members)
                if s_sum_focus <= ZERO_EPS:
                    continue
                target_sum = max(0.0, s_sum_focus + adj_g)
                scale_g = target_sum / max(s_sum_focus, 1e-12)
                # Clip group scale to [0.85, 1.15]
                scale_g = max(1.0 - BUNDLE_CLIP, min(1.0 + BUNDLE_CLIP, scale_g))
                for m in focused_members:
                    old = side_vals[m]
                    new = max(0.0, scale_g * old)
                    if adjust_side == 'rx':
                        prev = hardened_rx[m]
                        if prev > ZERO_EPS:
                            scaled_rx_factor[m] *= (new / prev)
                        hardened_rx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_rx[m] = clamp01(conf_rx[m] * (1.0 - 0.6 * relc))
                    else:
                        prev = hardened_tx[m]
                        if prev > ZERO_EPS:
                            scaled_tx_factor[m] *= (new / prev)
                        hardened_tx[m] = new
                        relc = abs(new - old) / max(1.0, abs(old))
                        conf_tx[m] = clamp01(conf_tx[m] * (1.0 - 0.6 * relc))
>>>>>>> REPLACE

</DIFF>