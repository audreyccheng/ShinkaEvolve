<prefix_dom_child_prune_and_greedy_promotion>
Introduce shared prefix-dominance cache and child-level pruning with greedy promotion. This edit adds a global prefix_dom cache keyed by (remaining set, suffix) and uses it in both greedy rollouts and beam expansion. It promotes top children by running a greedy completion on K children (K=2 early, K=1 late), prunes children whose adjusted lookahead is not better than the incumbent, and prunes children dominated by prefix_dom. It also updates the depth-adaptive suffix from (3,2,2) to (3 early, 4 late) to carry more context toward the end, improving pruning power and reducing wasted exploration. Together, these changes tighten bounds earlier, reduce search breadth on bad branches, and drive the beam to higher-quality schedules.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Global prefix-dominance map shared across restarts/phases
    best_state_global = {}
=======
    # Global prefix-dominance map shared across restarts/phases
    best_state_global = {}
    # Shared prefix-dominance cache for pruning across beam/greedy
    prefix_dom = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        while rem and time_left():
            if incumbent is not None:
                if lb_singleton(cur_cost, rem) >= incumbent:
                    break
            last = seq_out[-1] if seq_out else None
            rem_list = list(rem)
            cand_pool = []
=======
        while rem and time_left():
            if incumbent is not None:
                if lb_singleton(cur_cost, rem) >= incumbent:
                    break
            # Shared prefix-dominance update and optional prune
            k_upd = 3 if len(seq_out) < int(0.7 * N) else 4
            sig_g = make_signature(rem, seq_out, k_upd)
            prev_g = prefix_dom.get(sig_g)
            if prev_g is not None and cur_cost >= prev_g - 1e-9:
                break
            if prev_g is None or cur_cost < prev_g:
                prefix_dom[sig_g] = cur_cost
            last = seq_out[-1] if seq_out else None
            rem_list = list(rem)
            cand_pool = []
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Depth-adaptive suffix length for dominance
            if depth < int(0.35 * N):
                k_cur = max(3, k_suffix)
            elif depth < int(0.7 * N):
                k_cur = max(2, k_suffix - 1)
            else:
                k_cur = max(2, k_suffix - 2)
=======
            # Depth-adaptive suffix length for dominance (more context later)
            if depth < int(0.7 * N):
                k_cur = max(3, k_suffix)
            else:
                k_cur = max(4, k_suffix)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                top = scored[:min(branch_factor, len(scored))]
                # Probe a few best children by greedily completing them to tighten incumbent
                probe_k = min(params.get('next_k', 4), len(top))
                idx_child = 0
                for _delta, la_score, ec, cand in top:
                    new_seq = seq + [cand]
                    new_rem = rem.copy()
                    new_rem.remove(cand)
                    # Child LB pruning
                    if lb_singleton(ec, new_rem) >= best_full_cost:
                        continue
                    # Greedy probe for first few children to update incumbent and refine ranking
                    if idx_child < probe_k and time_left():
                        g_cost, g_seq = greedy_finish(new_seq, new_rem, branch_k=max(6, N // 12), incumbent=best_full_cost)
                        if len(g_seq) == N and g_cost < best_full_cost:
                            best_full_cost, best_full_seq = g_cost, g_seq
                        la_score = min(la_score, g_cost)
                    idx_child += 1
                    new_beam.append((ec, new_seq, new_rem, la_score))
=======
                top = scored[:min(branch_factor, len(scored))]
                # Promote top children via greedy completion and prune by incumbent/prefix-dom
                probe_k = min(len(top), 2 if depth < int(0.7 * N) else 1)
                idx_child = 0
                for _delta, la_score, ec, cand in top:
                    new_seq = seq + [cand]
                    new_rem = rem.copy()
                    new_rem.remove(cand)
                    # Child LB pruning
                    if lb_singleton(ec, new_rem) >= best_full_cost:
                        continue
                    # Prefix-dominance prune on child state
                    sig_child = make_signature(new_rem, new_seq, k_cur)
                    prev_pd = prefix_dom.get(sig_child)
                    if prev_pd is not None and ec >= prev_pd - 1e-9:
                        continue
                    # Greedy probe for first few children to update incumbent and refine ranking
                    if idx_child < probe_k and time_left():
                        g_cost, g_seq = greedy_finish(new_seq, new_rem, branch_k=max(6, N // 12), incumbent=best_full_cost)
                        if len(g_seq) == N and g_cost < best_full_cost:
                            best_full_cost, best_full_seq = g_cost, g_seq
                        la_score = min(la_score, g_cost)
                    idx_child += 1
                    # Prune child if lookahead is not better than incumbent
                    if la_score >= best_full_cost:
                        continue
                    # Update shared prefix-dominance with best known prefix cost
                    if prev_pd is None or ec < prev_pd:
                        prefix_dom[sig_child] = ec
                    new_beam.append((ec, new_seq, new_rem, la_score))
>>>>>>> REPLACE
</DIFF>