<NAME>
conflict_targeted_2p5opt
</NAME>

<DESCRIPTION>
I introduce a conflict-targeted 2-opt/2.5-opt (bridge) improvement step that focuses search on the heaviest read/write conflicts indicated by pairwise penalties. Instead of uniform random non-adjacent swaps and insertions, the new step:

- Identifies the top κ worst violated adjacencies using M[a][b] − M[b][a].
- For each hot adjacency (a, b), samples candidate positions far from it and attempts targeted 2-opt swaps with both endpoints (a and b) as well as adjacent partner indices.
- Applies a 2.5-opt “bridge” move: extracts a short block around b and reinserts it just before a (and its reverse), which often resolves cascading conflicts effectively.

This concentrates local search effort on the most harmful boundaries, reduces wasted evaluations, and typically yields better makespan improvements. I keep a small fallback of random swaps/insertions to maintain diversification if the targeted step finds no improvement. The rest of the algorithm remains unchanged.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 1b) Limited non-adjacent 2-opt swaps (sampled)
        swap_attempts = min(n, 60)
        for _ in range(swap_attempts):
            i, j = rng.sample(range(n), 2)
            if abs(i - j) <= 1:
                continue
            seq[i], seq[j] = seq[j], seq[i]
            c = seq_cost(seq)
            if c < current_cost:
                current_cost = c
            else:
                # revert
                seq[i], seq[j] = seq[j], seq[i]

        # 2) Random insertion improvements with accept-if-better
        attempts = min(150, 3 * n)
        for _ in range(attempts):
            i = rng.randint(0, n - 1)
            j = rng.randint(0, n - 1)
            if i == j:
                continue
            t = seq.pop(i)
            seq.insert(j, t)
            c = seq_cost(seq)
            if c < current_cost:
                current_cost = c
            else:
                # revert
                seq.pop(j)
                seq.insert(i, t)
=======
        # 1b) Conflict-targeted 2-opt / 2.5-opt (bridge) sampling around worst adjacencies
        improved_ct = False
        # Build list of worst adjacencies by pairwise penalty
        pairs = []
        for i in range(len(seq) - 1):
            a, b = seq[i], seq[i + 1]
            pen = M[a][b] - M[b][a]
            if pen > 0:
                pairs.append((pen, i))
        pairs.sort(reverse=True)
        kappa = min(20, max(3, len(seq) // 8))
        hot = [i for _, i in pairs[:kappa]]
        for i in hot:
            if i >= len(seq) - 1:
                continue
            a, b = seq[i], seq[i + 1]
            # candidate partner indices far from i
            js = set()
            limit_j = 8
            while len(js) < limit_j and len(js) < len(seq):
                j = rng.randint(0, len(seq) - 2)  # up to n-2 to safely read j+1
                if abs(j - i) <= 1:
                    continue
                js.add(j)
            # Try 2-opt swap endpoint with seq[j] and seq[j+1]
            for j in js:
                # swap a with seq[j]
                cand = seq[:]
                cand[i], cand[j] = cand[j], cand[i]
                c = seq_cost(cand)
                if c < current_cost:
                    seq = cand
                    current_cost = c
                    improved_ct = True
                    break
                # swap b with seq[j]
                cand = seq[:]
                cand[i + 1], cand[j] = cand[j], cand[i + 1]
                c = seq_cost(cand)
                if c < current_cost:
                    seq = cand
                    current_cost = c
                    improved_ct = True
                    break
                # also try swapping against j+1 neighbor if safe and non-adjacent to i
                if j + 1 < len(seq) and abs((j + 1) - i) > 1 and abs((j + 1) - (i + 1)) > 1:
                    cand = seq[:]
                    cand[i], cand[j + 1] = cand[j + 1], cand[i]
                    c = seq_cost(cand)
                    if c < current_cost:
                        seq = cand
                        current_cost = c
                        improved_ct = True
                        break
            if improved_ct:
                break
            # 2.5-opt: extract block around b and reinsert before a (optionally reversed)
            kb = 3 if n < 50 else 4
            start_b = max(0, min((i + 1) - kb // 2, len(seq) - kb))
            if start_b <= i < start_b + kb:
                # block overlaps 'a', skip
                continue
            block = seq[start_b:start_b + kb]
            base = seq[:start_b] + seq[start_b + kb:]
            # 'a' must be in base
            try:
                apos = base.index(a)
            except ValueError:
                continue
            # evaluate reinsertion just before a; also a couple nearby offsets
            pos_candidates = [max(0, apos), max(0, apos - 1)]
            if apos + 1 <= len(base):
                pos_candidates.append(apos + 1)
            best_cand = None
            best_cand_cost = current_cost
            for pos in pos_candidates:
                cand1 = base[:pos] + block + base[pos:]
                c1 = seq_cost(cand1)
                if c1 < best_cand_cost:
                    best_cand_cost = c1
                    best_cand = cand1
                cand2 = base[:pos] + list(reversed(block)) + base[pos:]
                c2 = seq_cost(cand2)
                if c2 < best_cand_cost:
                    best_cand_cost = c2
                    best_cand = cand2
            if best_cand is not None and best_cand_cost < current_cost:
                seq = best_cand
                current_cost = best_cand_cost
                improved_ct = True
                break
        if not improved_ct:
            # Small random fallback to keep diversification
            fallback_swaps = min(20, n // 2)
            for _ in range(fallback_swaps):
                i, j = rng.sample(range(n), 2)
                if abs(i - j) <= 1:
                    continue
                seq[i], seq[j] = seq[j], seq[i]
                c = seq_cost(seq)
                if c < current_cost:
                    current_cost = c
                    break
                else:
                    # revert
                    seq[i], seq[j] = seq[j], seq[i]
            if not improved_ct:
                fallback_inserts = min(40, n)
                for _ in range(fallback_inserts):
                    i = rng.randint(0, n - 1)
                    j = rng.randint(0, n - 1)
                    if i == j:
                        continue
                    t = seq.pop(i)
                    seq.insert(j, t)
                    c = seq_cost(seq)
                    if c < current_cost:
                        current_cost = c
                        break
                    else:
                        # revert
                        seq.pop(j)
                        seq.insert(i, t)
>>>>>>> REPLACE

</DIFF>