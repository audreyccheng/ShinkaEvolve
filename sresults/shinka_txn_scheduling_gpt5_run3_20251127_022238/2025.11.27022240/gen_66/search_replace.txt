<prefix_dom_and_inc_beam_prune>
Hoist a global prefix-dominance cache and use it in both the greedy constructor and the beam search. Additionally, add incumbent-aware greedy completion for top children during beam expansion to prune weak branches earlier. This reduces redundant exploration of dominated prefixes and tightens the incumbent sooner, leading to lower makespan schedules without significant runtime overhead.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
        if not remaining:
            return []
        recents = prefix[-recent_k:] if recent_k > 0 else []
        scored = []
        for t in remaining:
            sc = 0
            for x in recents:
                sc += W[x][t]
            scored.append((sc, t))
        scored.sort(key=lambda z: (z[0], z[1]))
        return [t for _, t in scored[:k]]
=======
    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
        if not remaining:
            return []
        recents = prefix[-recent_k:] if recent_k > 0 else []
        scored = []
        for t in remaining:
            sc = 0
            for x in recents:
                sc += W[x][t]
            scored.append((sc, t))
        scored.sort(key=lambda z: (z[0], z[1]))
        return [t for _, t in scored[:k]]

    # Global prefix-dominance map shared across constructors and beam
    # Keyed by (frozenset(remaining), suffix<=3 of prefix) -> best observed prefix cost
    prefix_dom = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        step = 0
        while remaining:
            # Incumbent pruning against best seed so far (if available)
            try:
                if seed_best_cost < float('inf'):
                    base_cost = eval_seq(seq)
                    if base_cost >= seed_best_cost:
                        # Complete cheaply by immediate best to terminate early
                        rest = list(remaining)
                        rest.sort(key=lambda t: eval_seq(seq + [t]))
                        seq.extend(rest)
                        remaining.clear()
                        break
            except NameError:
                # seed_best_cost not yet defined in first call
                pass
=======
        step = 0
        while remaining:
            # Current prefix cost
            base_cost = eval_seq(seq)

            # Incumbent pruning against best seed so far (if available)
            try:
                if seed_best_cost < float('inf') and base_cost >= seed_best_cost:
                    # Complete cheaply by immediate best to terminate early
                    rest = list(remaining)
                    rest.sort(key=lambda t: eval_seq(seq + [t]))
                    seq.extend(rest)
                    remaining.clear()
                    break
            except NameError:
                # seed_best_cost not yet defined in first call
                pass

            # Global prefix-dominance pruning on current prefix
            sig_cur = (frozenset(remaining), tuple(seq[-3:]) if len(seq) >= 3 else tuple(seq))
            prev_cur = prefix_dom.get(sig_cur)
            if prev_cur is not None and base_cost >= prev_cur:
                # Abandon this path quickly by cheap completion to possibly set a better incumbent
                rest = list(remaining)
                rest.sort(key=lambda t: eval_seq(seq + [t]))
                seq.extend(rest)
                remaining.clear()
                break
            if prev_cur is None or base_cost < prev_cur:
                prefix_dom[sig_cur] = base_cost
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            seq.append(best_t)
            remaining.remove(best_t)
            if best_t in pool:
                pool.remove(best_t)
            step += 1
=======
            # Update global prefix dominance for the child prefix
            new_cost = eval_seq(seq + [best_t])
            child_rem = set(remaining)
            child_rem.remove(best_t)
            sig_child = (frozenset(child_rem), tuple((seq + [best_t])[-3:]) if len(seq) + 1 >= 3 else tuple(seq + [best_t]))
            prev_child = prefix_dom.get(sig_child)
            if prev_child is None or new_cost < prev_child:
                prefix_dom[sig_child] = new_cost

            seq.append(best_t)
            remaining.remove(best_t)
            if best_t in pool:
                pool.remove(best_t)
            step += 1
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        dom = {}  # prefix-dominance: (remaining_fset, suffix<=3) -> best cost
        seen_init = set()
        for t in starts:
            seq = [t]
            rem = frozenset(set(range(n)) - {t})
            cost = eval_seq(seq)
            key = (tuple(seq), rem)
            if key in seen_init:
                continue
            seen_init.add(key)
            sig = (rem, tuple(seq[-1:]))
            prev = dom.get(sig)
            if prev is None or cost < prev:
                dom[sig] = cost
                beam.append((cost, seq, rem))
=======
        dom = prefix_dom  # shared prefix-dominance: (remaining_fset, suffix<=3) -> best cost
        seen_init = set()
        for t in starts:
            seq = [t]
            rem = frozenset(set(range(n)) - {t})
            cost = eval_seq(seq)
            key = (tuple(seq), rem)
            if key in seen_init:
                continue
            seen_init.add(key)
            sig = (rem, tuple(seq[-1:]))
            prev = dom.get(sig)
            if prev is None or cost < prev:
                dom[sig] = cost
                beam.append((cost, seq, rem))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # Unique by child and keep best-k
                uniq = {}
                for t, m in scored:
                    if (t not in uniq) or (m < uniq[t]):
                        uniq[t] = m
                items = sorted(uniq.items(), key=lambda z: z[1])
                take = min(cand_per_expand, len(items))
                for t, _ in items[:take]:
                    new_seq = seq + [t]
                    new_rem = rem - {t}
                    new_cost = eval_seq(new_seq)
                    if (incumbent_cost < float('inf')) and (new_cost >= incumbent_cost):
                        continue
                    sig = (new_rem, tuple(new_seq[-3:]) if len(new_seq) >= 3 else tuple(new_seq))
                    prev = dom.get(sig)
                    if (prev is not None) and (new_cost >= prev):
                        continue
                    dom[sig] = new_cost
                    key = (tuple(new_seq), new_rem)
                    if key in local_seen:
                        continue
                    local_seen.add(key)
                    next_beam.append((new_cost, new_seq, new_rem))
=======
                # Unique by child and keep best-k; run incumbent-aware completion for top children
                uniq = {}
                for t, m in scored:
                    if (t not in uniq) or (m < uniq[t]):
                        uniq[t] = m
                items = sorted(uniq.items(), key=lambda z: z[1])
                take = min(cand_per_expand, len(items))
                chosen_children = items[:take]

                # For the top-K children, attempt greedy completion and prune if not promising
                k_gc = min(3, len(chosen_children))
                completed_filter = {}
                for idx in range(k_gc):
                    t, _ = chosen_children[idx]
                    tmp_seq = seq + [t]
                    full_seq, fc = greedy_complete(tmp_seq)
                    completed_filter[t] = fc
                    if fc < incumbent_cost:
                        incumbent_cost = fc
                        incumbent_seq = full_seq

                for t, _ in chosen_children:
                    # If we evaluated full completion for this child and it's not better, prune it
                    fc = completed_filter.get(t, None)
                    if fc is not None and (incumbent_cost < float('inf')) and (fc >= incumbent_cost):
                        continue

                    new_seq = seq + [t]
                    new_rem = rem - {t}
                    new_cost = eval_seq(new_seq)
                    if (incumbent_cost < float('inf')) and (new_cost >= incumbent_cost):
                        continue
                    sig = (new_rem, tuple(new_seq[-3:]) if len(new_seq) >= 3 else tuple(new_seq))
                    prev = dom.get(sig)
                    if (prev is not None) and (new_cost >= prev):
                        continue
                    dom[sig] = new_cost
                    key = (tuple(new_seq), new_rem)
                    if key in local_seen:
                        continue
                    local_seen.add(key)
                    next_beam.append((new_cost, new_seq, new_rem))
>>>>>>> REPLACE
</DIFF>