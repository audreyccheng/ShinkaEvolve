<NAME>
fix_beam_prune_and_antibuddy_greedy
</NAME>

<DESCRIPTION>
I propose three targeted improvements:
1) Fix a pruning bug in beam_seed child expansion: the code pruned a child after greedy completion by comparing the childâ€™s completion cost to the updated incumbent, which always led to pruning even for improving children. I switch to comparing against the previous incumbent before updating it, so improving children are not incorrectly dropped.
2) Make the prefix-dominance signature more discriminative late in the search by adapting the suffix length from 3 to 4 after 70% depth. This reduces collisions and improves pruning effectiveness without blowing up memory early.
3) Add an anti-buddy guard in the greedy restarts: if the last placed transaction strongly disfavors a candidate (based on W and the 75th percentile threshold qcut), skip that candidate unless its immediate cost is within 1% of the best immediate. This directly targets bad adjacencies that cause high makespan due to conflicts. Also, slightly increase incumbent tightening frequency by invoking greedy completion every 8 steps instead of 10.

These changes align with the recommendations to promote incumbents at child expansion, strengthen prefix-dominance, and apply anti-buddy filtering in builders. They should yield better schedules with lower makespan.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                    # Incumbent-aware greedy completion on first few children
                    if taken < greedy_probe_k:
                        full, fc = greedy_complete(new_seq, list(new_rem))
                        if fc < incumbent_cost:
                            incumbent_cost = fc
                            incumbent_seq = full
                        # prune child if its full completion is not better than incumbent
                        if fc >= incumbent_cost:
                            continue
=======
                    # Incumbent-aware greedy completion on first few children
                    if taken < greedy_probe_k:
                        prev_inc = incumbent_cost
                        full, fc = greedy_complete(new_seq, list(new_rem))
                        if fc < prev_inc:
                            incumbent_cost = fc
                            incumbent_seq = full
                        # prune child if its full completion is not better than previous incumbent
                        if fc >= prev_inc:
                            continue
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        incumbent_cost = inc if inc is not None else float('inf')
        incumbent_seq = None
        suffix_k = 3

        for d in range(n - 1):
            phaseA = d < depth_limit
            beam_width = beam_width_A if phaseA else beam_width_B
            cand_per_expand = cand_per_expand_A if phaseA else cand_per_expand_B
            lookahead_top = lookahead_top_A if phaseA else lookahead_top_B
            next_k = next_k_A if phaseA else next_k_B
            recent_k = recent_k_for_depth(d)
=======
        incumbent_cost = inc if inc is not None else float('inf')
        incumbent_seq = None

        for d in range(n - 1):
            phaseA = d < depth_limit
            beam_width = beam_width_A if phaseA else beam_width_B
            cand_per_expand = cand_per_expand_A if phaseA else cand_per_expand_B
            lookahead_top = lookahead_top_A if phaseA else lookahead_top_B
            next_k = next_k_A if phaseA else next_k_B
            recent_k = recent_k_for_depth(d)
            suffix_k = 3 if d < int(0.7 * (n - 1)) else 4
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Evaluate immediate costs within pool
            imm = [(t, seq_cost(seq + [t])) for t in cand_pool]
            imm.sort(key=lambda x: x[1])
=======
            # Evaluate immediate costs within pool
            imm = [(t, seq_cost(seq + [t])) for t in cand_pool]
            imm.sort(key=lambda x: x[1])
            # Anti-buddy guard: if last placed strongly disfavors t, skip unless within 1%
            if seq:
                last = seq[-1]
                if imm:
                    best_immediate = imm[0][1]
                    filt = [(t, c) for (t, c) in imm if not (W[last][t] > 0 and W[last][t] >= qcut[last] and c > best_immediate * 1.01)]
                    if filt:
                        imm = filt
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Periodic greedy completion to tighten incumbent
            if step % 10 == 0 and remaining:
                full, fc = greedy_complete(seq, remaining)
                if fc < best_cost:
                    best_cost = fc
                    best_seq = full[:]
=======
            # Periodic greedy completion to tighten incumbent
            if step % 8 == 0 and remaining:
                full, fc = greedy_complete(seq, remaining)
                if fc < best_cost:
                    best_cost = fc
                    best_seq = full[:]
>>>>>>> REPLACE

</DIFF>