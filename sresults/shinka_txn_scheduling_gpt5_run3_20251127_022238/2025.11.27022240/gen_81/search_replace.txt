<NAME>
beam_greedy_antibuddy_fix_and_bubble_cleanup
</NAME>

<DESCRIPTION>
I propose three targeted improvements that reduce makespan by better pruning and improved local refinement:

1) Fix an incumbent-pruning bug in beam child expansion: when probing a child with greedy completion, we previously pruned whenever the completed cost was greater-than-or-equal to the incumbent, which mistakenly threw away the very child that set a new incumbent. Changing the condition to strictly greater preserves the improving child inside the beam while still pruning worse ones.

2) Add anti-buddy gating to the greedy restarts’ lookahead selection, mirroring the beam’s logic. This avoids extending prefixes with strongly disfavored followers unless they are competitive by immediate cost, reducing time spent on poor extensions and improving final makespan.

3) Add a cheap tournament-based bubble pass before the local hill-climb. This quickly corrects common local inversions based on pairwise preferences and provides a better starting point for subsequent local search.

Additionally, I slightly increase the frequency of incumbent promotion in the greedy builder (from every 10 steps to every 8) to tighten the incumbent earlier and drive better pruning. These changes are minimal yet synergistic, leveraging the conflict structure to steer the search and reduce wasteful evaluations, thereby lowering makespan.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
        if not remaining:
            return []
        recents = prefix[-recent_k:] if recent_k > 0 else []
        scored = []
        for t in remaining:
            sc = 0
            for x in recents:
                sc += W[x][t]
            scored.append((sc, t))
        scored.sort(key=lambda z: (z[0], z[1]))
        return [t for _, t in scored[:k]]

    def recent_k_for_depth(d):
        frac = d / max(1, n - 1)
        return 5 if frac < 0.33 else (4 if frac < 0.66 else 3)
=======
    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
        if not remaining:
            return []
        recents = prefix[-recent_k:] if recent_k > 0 else []
        scored = []
        for t in remaining:
            sc = 0
            for x in recents:
                sc += W[x][t]
            scored.append((sc, t))
        scored.sort(key=lambda z: (z[0], z[1]))
        return [t for _, t in scored[:k]]

    def prefer_before(a, b):
        # Cheap indication if a before b is no worse than b before a
        return M[a][b] <= M[b][a]

    def tournament_bubble_pass(seq, passes=2):
        arr = seq[:]
        for _ in range(passes):
            improved = False
            for k in range(len(arr) - 1):
                a, b = arr[k], arr[k + 1]
                if not prefer_before(a, b):
                    arr[k], arr[k + 1] = b, a
                    improved = True
            if not improved:
                break
        return arr

    def recent_k_for_depth(d):
        frac = d / max(1, n - 1)
        return 5 if frac < 0.33 else (4 if frac < 0.66 else 3)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
                    # Incumbent-aware greedy completion on first few children
                    if taken < greedy_probe_k:
                        full, fc = greedy_complete(new_seq, list(new_rem))
                        if fc < incumbent_cost:
                            incumbent_cost = fc
                            incumbent_seq = full
                        # prune child if its full completion is not better than incumbent
                        if fc >= incumbent_cost:
                            continue
=======
                    # Incumbent-aware greedy completion on first few children
                    if taken < greedy_probe_k:
                        full, fc = greedy_complete(new_seq, list(new_rem))
                        if fc < incumbent_cost:
                            incumbent_cost = fc
                            incumbent_seq = full
                        # prune only if strictly worse than incumbent; keep equal/best child
                        if fc > incumbent_cost:
                            continue
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Periodic greedy completion to tighten incumbent
            if step % 10 == 0 and remaining:
                full, fc = greedy_complete(seq, remaining)
                if fc < best_cost:
                    best_cost = fc
                    best_seq = full[:]
=======
            # Periodic greedy completion to tighten incumbent
            if step % 8 == 0 and remaining:
                full, fc = greedy_complete(seq, remaining)
                if fc < best_cost:
                    best_cost = fc
                    best_seq = full[:]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Evaluate immediate costs within pool
            imm = [(t, seq_cost(seq + [t])) for t in cand_pool]
            imm.sort(key=lambda x: x[1])

            # Adaptive lookahead: slightly deeper early
            L = min(4 if step < 10 else 3, len(imm))
            chosen_t = imm[0][0]
            best_metric = imm[0][1]

            for t, immediate_c in imm[:L]:
                rest = [x for x in remaining if x != t]
                if not rest:
                    metric = immediate_c
                else:
                    need = 6 if n > 60 else 7
                    buddy_pref = [u for u in buddies[t] if u in rest]
                    la_pool = buddy_pref[:min(need, len(rest))]
                    if len(la_pool) < min(need, len(rest)):
                        extra = preselect_by_tournament(seq + [t], [u for u in rest if u not in la_pool], min(need - len(la_pool), len(rest) - len(la_pool)), recent_k=3)
                        la_pool.extend(extra)
                    if not la_pool:
                        la_pool = rest[:min(need, len(rest))]
                    metric = min(seq_cost(seq + [t, u]) for u in la_pool)
                if metric < best_metric:
                    best_metric = metric
                    chosen_t = t
=======
            # Evaluate immediate costs within pool
            imm = [(t, seq_cost(seq + [t])) for t in cand_pool]
            imm.sort(key=lambda x: x[1])

            # Adaptive lookahead with anti-buddy gating: slightly deeper early
            L = min(4 if step < 10 else 3, len(imm))
            best_immediate = imm[0][1]
            last = seq[-1] if seq else None
            look_list = imm[:L]
            if last is not None:
                filtered = []
                for t, immediate_c in look_list:
                    if W[last][t] > 0 and W[last][t] >= qcut[last] and immediate_c > best_immediate * 1.01:
                        continue
                    filtered.append((t, immediate_c))
                if filtered:
                    look_list = filtered
            chosen_t = look_list[0][0]
            best_metric = look_list[0][1]

            for t, immediate_c in look_list:
                rest = [x for x in remaining if x != t]
                if not rest:
                    metric = immediate_c
                else:
                    need = 6 if n > 60 else 7
                    buddy_pref = [u for u in buddies[t] if u in rest]
                    la_pool = buddy_pref[:min(need, len(rest))]
                    if len(la_pool) < min(need, len(rest)):
                        extra = preselect_by_tournament(seq + [t], [u for u in rest if u not in la_pool], min(need - len(la_pool), len(rest) - len(la_pool)), recent_k=3)
                        la_pool.extend(extra)
                    if not la_pool:
                        la_pool = rest[:min(need, len(rest))]
                    metric = min(seq_cost(seq + [t, u]) for u in la_pool)
                if metric < best_metric:
                    best_metric = metric
                    chosen_t = t
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Local improvement phase
        current_cost = seq_cost(seq)

        # 1) Adjacent swap hill-climb passes
=======
        # Local improvement phase
        # Cheap tournament-based cleanup before hill-climb
        tb = tournament_bubble_pass(seq, passes=2)
        tb_cost = seq_cost(tb)
        if tb_cost < seq_cost(seq):
            seq = tb
            current_cost = tb_cost
        else:
            current_cost = seq_cost(seq)

        # 1) Adjacent swap hill-climb passes
>>>>>>> REPLACE

</DIFF>