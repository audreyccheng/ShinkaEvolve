# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy sampled transaction scheduler**
- **Implementation**: Implements a greedy cost-sampling scheduler: start at a random transaction, then at each step evaluate up to 10 randomly selected candidates via workload.get_opt_seq_cost and pick the minimum; sample_rate is fixed at 1.0 so only the greedy path runs. Includes robust repo-root path discovery; num_seqs and workload_size are unused, costs are recomputed redundantly, and randomness is unseeded.
- **Performance**: Combined score 2.65 across 3 workloads (300 transactions); correct and passes all validation tests with execution time recorded.
- **Feedback**: Greedy sampling trades optimality for speed; unseeded randomness can cause variability—seeding or multi-start runs could stabilize/improve scores. Removing redundant cost recomputations and honoring num_seqs/sample_rate would reduce overhead and enable broader exploration.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Beam-search transaction scheduler with memoized costs**
- **Implementation**: Uses beam search with dynamic beam/branch sizing, memoized prefix cost evaluation, and multiple random restarts. Initializes the beam from sampled singletons and prunes to top unique prefixes at each depth to control breadth.
- **Performance**: Combined score 3.40; produced valid schedules for all three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Dynamic sizing and memoization reduced search overhead, while random restarts improved robustness; capped beam (≤32) and branch (≤24) factors kept runtime reasonable but can miss global optima due to stochastic pruning. Re-evaluating final schedules confirmed consistency of reported makespans.
**Program Identifier:** Generation 1 - Patch Name beam_search_with_memoized_costs - Correct Program: True

**Program Name: Beam + local search transaction scheduler**
- **Implementation**: Uses a beam search with memoized partial-cost evaluations (Workload.get_opt_seq_cost) and adaptive beam width (from num_seqs) plus sampled candidate expansions, followed by local improvements via adjacent swaps and sampled insertion. Includes robust repository path discovery to import simulator/workloads reliably.
- **Performance**: Achieved a combined score of 3.19 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Memoization and controlled branching reduce simulator calls and help meet the time budget, while local improvements further lower makespan beyond the beam result. Randomized starts and sampling introduce run-to-run variance without a fixed seed.
**Program Identifier:** Generation 2 - Patch Name beam_search_local_improve - Correct Program: True

**Program Name: Multi-start Greedy Scheduler with Lookahead and Local Search**
- **Implementation**: Uses a multi-start greedy constructor with full candidate evaluation, limited two-step lookahead, and a memoized cost cache. Final schedules are refined via adjacent-swap hill climbing and accept-if-better random insertions, with starts seeded from lowest-cost singletons.
- **Performance**: Combined score 3.40 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Memoization and lookahead improve selection quality and reduce redundant cost calls, while local search finds additional improvements after greedy construction. Runtime is mitigated by sampling and bounded local moves, though full candidate evaluation per step remains a potential bottleneck on larger instances.
**Program Identifier:** Generation 3 - Patch Name greedy_full_eval_beam_local - Correct Program: True

**Program Name: Tournament-ILS Transaction Scheduler**
- **Implementation**: Builds a pairwise preference matrix from O(n^2) length-1/2 simulations to score transactions and locally sort via tournament comparisons, then applies memoized true-cost refinement with one adjacent-swap pass, limited ruin-and-recreate (sampled insert positions), and sampled insertion moves; refinement budget scales with num_seqs. A cached evaluator avoids redundant simulator calls across candidates.
- **Performance**: Combined score 2.87 on 3 workloads (300 transactions); all validation tests passed.
- **Feedback**: Pairwise surrogate costs provided strong ordering signals and reduced expensive evaluations, with memoization further decreasing simulator calls. The constrained ILS budget (single true-cost pass and up to two ruin-and-recreate tries) likely caps peak optimality while keeping runtime controlled.
**Program Identifier:** Generation 4 - Patch Name pairwise_tournament_rank_ils - Correct Program: True

**Program Name: MCTS + VND Transaction Scheduler**
- **Implementation**: UCT-based MCTS over partial schedules with progressive widening, greedy-biased expansion, cost caching, and a transposition table; rollouts use limited lookahead with pruning and are followed by VND local search (adjacent swaps, insertions, small block moves). The final schedule is extracted via most-visited children with greedy fallback, and evaluated across three workloads.
- **Performance**: Combined score: 0.0; did not pass validation.
- **Feedback**: Failures likely stem from nondeterminism (no fixed RNG seed), heavy iteration budgets causing timeouts, and brittle repo path discovery; partial-cost reliance may also mismatch the simulator API. Seed the RNG, cap/scale iteration budgets, simplify imports to avoid filesystem probing, and verify partial-cost calls against the provided Workload interface.
**Program Identifier:** Generation 5 - Patch Name uct_mcts_vnd_scheduler - Correct Program: False

**Program Name: Hybrid Beam-GRASP Transaction Scheduler**
- **Implementation**: Alternates a beam search with shallow lookahead and a GRASP constructor, using adaptive beam/branch sizes scaled by N and a shared memoized cost cache under a 0.35s per-workload time budget. A local search phase (adjacent swaps, random swaps, sampled insertions) refines each constructed sequence.
- **Performance**: Achieved combined score 1.56 on 3 workloads (300 transactions) within the time budget, and passed all validation tests.
- **Feedback**: The hybrid construction plus local improvement consistently finds low-makespan schedules under tight time constraints, aided by caching and adaptive sampling. Beam truncation with greedy completion can occur when the budget is tight, but outputs remain valid.
**Program Identifier:** Generation 6 - Patch Name beam_grasp_ils_hybrid - Correct Program: True

**Program Name: Multi-start Greedy VNS Transaction Scheduler**
- **Implementation**: Uses a memoized partial-sequence evaluator with multi-start greedy construction (limited lookahead) and Variable Neighborhood Search combining adjacent swaps, sampled relocations, and light ruin-and-recreate; seeding is diversified via singleton-cost rankings and budgets adapt to problem size. Includes adaptive candidate sampling and restart strategies to control simulator calls and runtime.
- **Performance**: Combined score 3.24 across three workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization significantly cuts simulator evaluations, enabling stronger local search within the given budget, while adaptive sampling and restrained ruin-and-recreate maintain good makespan-quality/runtime trade-offs. Time-based RNG seeding yields non-deterministic results across runs.
**Program Identifier:** Generation 7 - Patch Name greedy_lookahead_rr_vns - Correct Program: True

**Program Name: Marginal-Cost LNS Transaction Scheduler**
- **Implementation**: Employs a marginal-cost-guided LNS: a lazy candidate-pool greedy constructor with limited lookahead builds seeds, a global cost cache accelerates evals, adjacent-swap hill-climb cleans up, and hot windows (chosen via prefix marginals) are reordered using budgeted permutation enumeration/sampling; targeted relocate moves, multi-start seeding, and final random insertions provide additional refinement.
- **Performance**: Achieved a combined score of 3.18 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Evaluation indicates robust correctness and effective heuristic improvements from caching and windowed LNS/relocate moves; the score suggests remaining headroom, potentially addressable via adaptive pool/window sizes or dynamic permutation budgets.
**Program Identifier:** Generation 8 - Patch Name marginal_lns_pool - Correct Program: True

**Program Name: Tournament-Guided Greedy VNS Scheduler**
- **Implementation**: Uses pairwise-tournament-guided greedy construction with limited lookahead and a global memoized cost cache. Precomputes singleton/pairwise costs to form preference margins, applies multi-start seeding, and refines schedules via VNS (tournament bubble cleanup, adjacent swaps, relocations, non-adjacent swaps, and ruin-and-recreate).
- **Performance**: Achieved combined score 3.12 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Precomputing pairwise preferences and caching partial evaluations effectively cut simulator calls and guided the search toward low-conflict orderings. Multi-start plus VNS consistently improved makespan, and size-aware budgeting maintained stable performance across varying workload complexities.
**Program Identifier:** Generation 9 - Patch Name pairwise_guided_greedy_vns - Correct Program: True

**Program Name: Preference-Guided Beam Search Scheduler**
- **Implementation**: Uses a memoized cost oracle and a sampled pairwise preference model to compute soft precedence weights, guiding a time-bounded beam search scored by true cost plus penalty with shallow lookahead and adaptive beam/branch sizes. A multi-pass LocalRefiner fixes high-weight violations, then performs adjacent swaps, random insertions, and long swaps, with a SchedulerEngine allocating time across preference building, construction, and refinement per workload size.
- **Performance**: Achieved a combined score of 2.04 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests within the ~0.75s/workload budget.
- **Feedback**: Preference sampling and cost memoization effectively reduce search overhead, while lookahead and violation-guided refinement yield consistent makespan improvements. Dynamic scaling and ALNS-style moves aid solution quality, though the modest score indicates potential gains from deeper lookahead or broader restart strategies under the same time budget.
**Program Identifier:** Generation 10 - Patch Name pref_beam_alns - Correct Program: True

**Program Name: Beam search scheduler with caching and refinement**
- **Implementation**: Time-bounded beam search using marginal-cost ordering and shallow lookahead, with shared memoization caches (cost/delta), incumbent-based pruning, greedy completion, and a local improvement pass (adjacent swaps plus random insertions). Beam/branch widths scale with workload size and multiple restarts run within the budget.
- **Performance**: Achieved combined score 1.93 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and marginal-cost ordering reduce redundant evaluations and focus exploration, while shallow lookahead and greedy completion tighten pruning against the incumbent. The lightweight local refinement yields incremental gains without exceeding the per-workload time budget.
**Program Identifier:** Generation 11 - Patch Name beam_astar_delta_local - Correct Program: True

**Program Name: A*-beam scheduler with memoized delta costs**
- **Implementation**: Uses an A*-guided beam search with delta-based candidate ordering, greedy two-step lookahead completion, and local polishing (adjacent swaps and sampled insertions). A shared CostOracle memoizes cost and marginal deltas with FIFO-bounded caches, plus multi-profile restarts and adaptive beam/branching from num_seqs.
- **Performance**: Combined score to maximize: 0.0; failed all validation tests.
- **Feedback**: Time-salted RNG seeds and brittle repository path discovery undermine determinism and portability, likely contributing to test failures. The max-singleton lower bound used as f=max(g,h) is not clearly admissible for the remaining cost, risking incorrect pruning and invalid results; additionally, the “partial sampling” branches are no-ops, reducing intended speedups.
**Program Identifier:** Generation 12 - Patch Name astar_beam_lns_scheduler - Correct Program: False

**Program Name: A*-guided Beam + Local Search Scheduler**
- **Implementation**: Uses an A*-guided beam search with cached sequence costs and marginal deltas, a singleton-cost lower bound, diversified seeding, candidate sampling, two-step lookahead, periodic greedy completions, and multi-restart local search (adjacent swaps and relocations) with shared caches and deterministic RNG. Includes repo-root probing to import external simulator/workloads and aggregates makespan across three workloads.
- **Performance**: Combined score 0.0; the program failed validation tests.
- **Feedback**: Likely failure stems from brittle external path discovery/imports and/or oversized beam/branch settings causing timeouts; the singleton-based lower bound may be too weak to prune effectively. Additionally, ‘workload_size’ is unused and restarts share the same RNG stream, reducing diversity and potential solution quality.
**Program Identifier:** Generation 13 - Patch Name beam_astar_delta_vns - Correct Program: False

**Program Name: A*-guided beam scheduler with local refinement**
- **Implementation**: Uses an A*-style marginal-cost beam search with shared cost/delta caches, lightweight lookahead, incumbent pruning, greedy completion, and a bounded local improvement phase (adjacent swaps and limited insertions) under a 0.60s per-workload time budget and deterministic multi-mode restarts. It also includes custom repository path discovery and sys.path injection to import the simulator and workloads.
- **Performance**: Combined score 0.0; the program is marked incorrect and fails validation tests.
- **Feedback**: Fragile import path discovery and strict time budgeting likely caused failures or fallback to low-quality/random schedules, leading to validation failure. The heuristic (max singleton as lower bound) and non-additive g-cost may misguide the beam/A* scoring, further hurting solution quality under tight time limits.
**Program Identifier:** Generation 14 - Patch Name astar_marginal_beam - Correct Program: False

**Program Name: Memoized Beam Search Transaction Scheduler**
- **Implementation**: Implements a time-bounded, dynamic-width beam search that ranks candidates by marginal cost with shallow lookahead, periodically greedily completes prefixes to tighten the incumbent, and deduplicates prefixes. Shared memoized cost caches span restarts, and a local improvement pass (adjacent swaps plus random insertions) refines the final sequence.
- **Performance**: Achieved a combined score of 2.48 across 3 workloads (300 transactions), passing all validation tests within the per-workload 0.55s budget.
- **Feedback**: Cache reuse and greedy completion reduce redundant evaluations and enable effective pruning under the tight time cap, improving schedule quality. Dynamic beam sizing and local refinement balance exploration and exploitation, though the strict 0.55s budget can limit the number of effective restarts on larger instances.
**Program Identifier:** Generation 15 - Patch Name precedence_guided_beam_with_lookahead_and_local_refine - Correct Program: True

**Program Name: Time-bounded memoized beam scheduler with local search**
- **Implementation**: Combines adaptive beam search with memoized marginal-cost evaluation and shallow lookahead under a strict time budget. Prefixes are greedily completed with incumbency pruning, then refined by adjacent swaps and sampled insertions across restarts.
- **Performance**: Achieved combined score 1.83 across 3 workloads (300 transactions); schedules are valid and all validation tests pass.
- **Feedback**: Caching of full sequence costs and prefix-extension pairs reduces simulator calls and enables near real-time search, yielding strong makespan within tight budgets. Randomized candidate sampling and restarts introduce variability but help escape local minima; ext_cost recomputes full costs rather than true deltas, which may cap scalability on larger N.
**Program Identifier:** Generation 16 - Patch Name beam_marginal_memo - Correct Program: True

**Program Name: Beam A*-guided Transaction Scheduler**
- **Implementation**: Implements beam search with A*-style lower bounds, marginal-cost ordering, shallow lookahead, and greedy multi-prefix completion; shared memoized cost/extension caches across restarts and precomputed singleton costs reduce evaluation overhead. A post-beam local-improvement phase (adjacent swaps, sliding-window insertions, bounded random insertions) refines schedules, with dynamic beam/branch sizing and a 0.55s/workload time budget.
- **Performance**: Combined score to maximize: 2.28; produced valid schedules for 3 workloads (300 transactions) within the time budget and passed all validation tests.
- **Feedback**: Lower-bound pruning plus memoization cut redundant evaluations and accelerate convergence, while sliding-window refinement improves makespan beyond greedy completion. Time-bounded restarts and incumbent tightening via greedy finishes yield robust results, with minor variability due to randomized sampling.
**Program Identifier:** Generation 17 - Patch Name a_star_lb_beam_and_window_local - Correct Program: True

**Program Name: Tournament-Guided Beam Search with VNS for Scheduling**
- **Implementation**: Builds a tournament preference matrix from memoized singleton/pairwise costs and runs a beam search with lookahead, tournament-based candidate preselection, diverse starts, and state deduplication. A VNS post-optimizer applies tournament bubble passes, adjacent swaps, sampled 2-opt, relocations, and ruin-and-recreate, leveraging caching to limit simulator calls.
- **Performance**: Achieved a combined score of 3.41 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Memoization and tournament-guided pruning effectively balance exploration and evaluation cost, yielding strong schedules with a modest beam width. Local VNS refinements reliably improve beam outputs; tuning beam and candidate parameters may further boost results on conflict-heavy workloads.
**Program Identifier:** Generation 18 - Patch Name tournament_guided_beam_vns - Correct Program: True

**Program Name: A*-Guided Beam Scheduler with Greedy Refinement**
- **Implementation**: Implements a time-budgeted A*-guided beam search using marginal-cost ordering, singleton lower-bound pruning, shallow lookahead, and shared memoized cost caches across restarts with dynamic beam/branch sizing. Beam prefixes are greedily completed to tighten the incumbent and then locally refined via adjacent swaps, insertions, and sparse long swaps.
- **Performance**: Achieved combined score 2.07 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Shared caches and LB pruning reduce cost evaluations and help maintain quality under the 0.55s/workload budget; dynamic beam/branching and periodic greedy completion quickly establish strong incumbents. Local refinement yields modest extra gains, but results remain somewhat sensitive to randomness and tight time limits.
**Program Identifier:** Generation 19 - Patch Name a_star_lb_prune_and_multi_finish - Correct Program: True

**Program Name: MCTS+LNS Conflict-Aware Txn Scheduler**
- **Implementation**: Combines MCTS with epsilon-greedy, conflict-biased rollouts and a ruin-and-recreate LNS refinement under a strict time budget. Employs memoized cost caches (full, extension, pairwise, singleton) and sampled conflict weights to guide expansion, rollout, removal, reinsertion, and light swap polishing.
- **Performance**: Achieved a combined score of 0.0 and failed validation tests.
- **Feedback**: Repo path discovery via find_repo_root (using __file__ and hardcoded fallbacks) is brittle and likely caused import/runtime failures; nondeterminism (no seeding) and tight time budgets can yield inconsistent or weak schedules, triggering fallbacks. Stabilize imports, add deterministic seeding, and reassess time allocation to improve robustness and pass validations.
**Program Identifier:** Generation 20 - Patch Name mcts_lns_hybrid - Correct Program: False

**Program Name: Tournament-guided beam search with VNS refinement**
- **Implementation**: Uses a memoized partial evaluator with precomputed singleton/pairwise costs to build preference margins, then runs a multi-restart beam search with incumbent pruning, buddy-list lookahead, and tournament-based candidate preselection. A local improvement phase applies violation-focused adjacent swaps, sampled 2-opt, relocate moves, and ruin-and-recreate; RNG is seeded for determinism and repository path resolution is handled via a custom finder.
- **Performance**: Combined score: 0.0; the program failed validation tests.
- **Feedback**: Failures likely stem from brittle repo path detection or reliance on partial-sequence evaluation (get_opt_seq_cost) that may not match the expected API, leading to incorrect results. Aggressive pruning and heavy O(n^2) precomputation may also hurt robustness/performance on some workloads.
**Program Identifier:** Generation 21 - Patch Name beam_multirestart_incumbent_buddies - Correct Program: False

**Program Name: Lookahead Greedy TXN Scheduler with Local Search**
- **Implementation**: Implements a time-bounded, memoized greedy constructor with restricted candidate lists and two-step lookahead, multi-start seeding from best singletons plus random seeds, and a local search phase (adjacent swaps and random insertions). Uses caching of sequence and extension costs and attempts auto-discovery of import paths.
- **Performance**: Combined score to maximize: 0.0; failed validation.
- **Feedback**: Likely failures stem from unseeded randomness and time-based control causing nondeterministic outputs, and brittle path-hacking for imports that may break in the evaluator. Fix imports, seed the RNG, and replace time-based limits with deterministic iteration bounds to satisfy validation.
**Program Identifier:** Generation 22 - Patch Name memoized_lookahead_greedy_ils - Correct Program: False

**Program Name: Greedy-VNS Transaction Scheduler with Adaptive Lookahead**
- **Implementation**: Multi-start greedy construction (10 restarts) with deterministic per-workload RNG, memoized sequence-costs, incumbent pruning, and adaptive lookahead over top candidates; followed by VNS-style local improvement (adjacent/non-adjacent swaps, insertion, targeted high-marginal relocations, and light ruin-and-recreate with greedy reinsertion). Robust repo-root discovery and seeding ensure reproducibility and stable imports.
- **Performance**: Achieved a combined score of 3.40 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Incumbent pruning and caching reduce redundant evaluations, while adaptive lookahead and targeted relocations improve makespan quality; deterministic seeding yields consistent, repeatable outcomes. The balance of randomized restarts with focused local refinements provides strong correctness with dependable performance.
**Program Identifier:** Generation 23 - Patch Name none - Correct Program: True

**Program Name: Beam-guided memoized transaction scheduler**
- **Implementation**: Uses beam search with adaptive beam/branching, one-step lookahead, and early incumbent tightening, supported by memoized prefix/extension costs. Completes prefixes via greedy marginal-cost selection, then applies local refinement (adjacent swaps and random insertions) with multiple restarts under a per-workload time budget (0.65s).
- **Performance**: Combined score to maximize: 2.02 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests within the set time budget.
- **Feedback**: Caching and marginal-cost lookahead improved pruning and reduced expensive evaluations; restarts enhanced exploration. The shallow lookahead and fixed time cap likely cap peak quality for larger N but delivered consistent, timely solutions here.
**Program Identifier:** Generation 24 - Patch Name beam_memo_local_refine - Correct Program: True

**Program Name: Cluster-guided MCTS Transaction Scheduler**
- **Implementation**: Uses MCTS with UCT, memoized cost calls, pairwise cost matrix (M), W-margins, tournament ordering, conflict clustering (|W| 70th percentile), buddy lists, W/cluster-guided rollouts, incumbent pruning via prefix “lower bounds,” multi-restarts, and a final adjacent-swap polish. Path bootstrapping attempts to locate the example repo dynamically before importing workloads/simulator.
- **Performance**: Combined score 0.0; fails validation tests and yields incorrect results.
- **Feedback**: Reliance on get_opt_seq_cost for partial prefixes (used for lb, M, W) likely violates simulator assumptions, making pruning unsafe and schedules invalid. Heavy O(n^2) precomputation of M/W contradicts the intended “few simulator calls” design and may hurt runtime; ensure valid lower bounds or restrict to full-sequence evaluations and harden path discovery to pass tests.
**Program Identifier:** Generation 25 - Patch Name mcts_clustered_ucb - Correct Program: False

**Program Name: Tournament beam search with VNS refinement**
- **Implementation**: Builds singleton/pairwise cost matrices to derive a tournament preference order, then runs a deterministic multi-restart beam search with memoized evaluations, incumbent pruning, buddy-guided lookahead, and periodic greedy completions; the best sequence is refined by a VNS applying tournament cleanups, swaps, relocations, and ruin-and-recreate. It uses a global cost cache, diverse seeded starts, and custom repo-path discovery to load workloads.
- **Performance**: Combined score 0.0; the program fails all validation tests.
- **Feedback**: The algorithm evaluates partial prefixes with get_opt_seq_cost (e.g., [i], [i, j]), which may violate the simulator’s contract and lead to invalid costs/schedules; ensure pruning/metrics use APIs that support prefixes or evaluate only full permutations. The custom path probing is brittle in test environments—stabilize imports and add schedule validity checks before reporting results.
**Program Identifier:** Generation 26 - Patch Name none - Correct Program: False

**Program Name: GRASP Micro-Beam Transaction Scheduler**
- **Implementation**: Hybrid GRASP with randomized greedy RCL and micro-beam intensification, time-bounded multi-starts, and memoized cost/extension caches for true marginal-cost evaluation. Seeds from top singletons/pairs with adaptive candidate pools and RCL by depth, followed by local refinement (adjacent swaps, 2-opt, insertions) and permutation repair.
- **Performance**: Combined score 2.43 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Caching and adaptive sampling cut evaluations and stabilized quality under a tight ~0.36s+N-scaled budget; micro-beam and local search consistently improved greedy builds. Additional time could be leveraged by deeper beams or richer neighborhoods for further gains.
**Program Identifier:** Generation 27 - Patch Name grasp_beam_hybrid_v1 - Correct Program: True

**Program Name: Tournament-guided VNS Transaction Scheduler**
- **Implementation**: Builds schedules via tournament-guided greedy with buddy-list lookahead over memoized simulator costs, using precomputed singleton/pairwise matrices and preference margins. Refines solutions with a VNS combining tournament cleanup, adjacent/non-adjacent swaps, targeted relocations, and light ruin‑and‑recreate across multi-start seeds with deterministic RNG.
- **Performance**: Achieved combined score 3.03 on three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Pairwise-preference seeding plus memoized evaluations effectively reduce simulator calls and focus search, while VNS post-optimization further lowers makespan. Deterministic runs and diversified restarts produce stable, high-quality schedules under modest exploration budgets.
**Program Identifier:** Generation 28 - Patch Name tournament_guided_buddy_lookahead - Correct Program: True

**Program Name: Deterministic Beam Search with VNS for Txn Scheduling**
- **Implementation**: Uses sampled pairwise preference margins to build conflict clusters and buddy lists, then runs a deterministic multi-restart beam search with shared memoization and greedy completions, followed by VNS local refinement guided by a surrogate boundary-margin score. Caches sequence and extension costs, caps pairwise probes, and allocates a fixed per-workload time budget to bound runtime.
- **Performance**: Combined score to maximize: 2.30 on 3 workloads (300 transactions); program is correct and passes all validation tests.
- **Feedback**: Deterministic seeding and caching stabilized quality and reduced evaluations under tight time budgets; clustering and buddy-biased candidate pools effectively narrowed the search to yield good schedules quickly. Note: the num_seqs parameter is unused, and the probe cap/weak LB may trade optimality for speed on larger instances.
**Program Identifier:** Generation 29 - Patch Name clustered_beam_vns - Correct Program: True

**Program Name: Beam-A* Transaction Scheduler with Greedy Refinement**
- **Implementation**: Uses beam search with memoized prefix/extension costs, singleton-based A* lower bounds, shallow lookahead ranking, and greedy completion to tighten incumbents, followed by a lightweight local improvement (adjacent swaps and random insertions). Parameters adapt to problem size (beam/branch factors), unique-prefix deduplication is enforced, and a 0.40s time budget with 1–3 restarts bounds runtime.
- **Performance**: Combined score 2.49 across 3 workloads (300 transactions); produces valid schedules and passes all validation tests.
- **Feedback**: Effective caching and pruning reduce evaluations, while greedy finishing frequently improves incumbents under the tight budget. The strict time cap and shallow local search can cap optimality, and unseeded randomness may introduce run-to-run variance.
**Program Identifier:** Generation 30 - Patch Name beam_greedy_prune_local - Correct Program: True

**Program Name: Tournament beam search with VNS refinement**
- **Implementation**: Uses a tournament-guided, incumbent-pruned beam search with lookahead, backed by memoized cost evaluation and precomputed singleton/pairwise costs to derive preference margins. Refines candidates via a robust VNS local search (bubble-based tournament cleanup, adjacent/non-adjacent swaps, relocations, targeted marginal relocations, and a light ruin-and-recreate), integrated with a Workload simulator after repo-path discovery.
- **Performance**: Achieved a combined score of 3.75 over 3 workloads (261 transactions), producing schedules for each workload.
- **Feedback**: The program is incorrect and fails validation tests; likely risk points include reliance on partial-sequence cost evaluations during search and the possibility of returning/pruning to incomplete or invalid permutations. Add strict permutation completion/validation and align evaluator semantics for partial sequences to improve correctness.
**Program Identifier:** Generation 31 - Patch Name tournament_beam_vns_pruned - Correct Program: False

**Program Name: Buddy-guided beam search with VNS for txn scheduling**
- **Implementation**: Implements a two-phase, time-bounded buddy-guided beam search with prefix-dominance and incumbent/singleton-LB pruning, shallow lookahead, memoized cost evaluations, and greedy completion, followed by lightweight VNS (adjacent swaps and relocations) with deterministic portfolio restarts. Buddy lists are built from singleton-delta scoring to focus branching; safety checks repair permutations if needed.
- **Performance**: Combined score 2.09 across 3 workloads (300 transactions); all validations passed.
- **Feedback**: Buddy guidance and caching concentrate the search and cut evaluations, while greedy finishing and VNS provide incremental gains under the tight ~0.58s/workload budget. Deterministic seeding stabilizes results; note that some parameters (e.g., next_k) are unused and deeper exploration may be constrained by the time cap.
**Program Identifier:** Generation 32 - Patch Name buddy_beam_vns - Correct Program: True

**Program Name: Tournament-guided Greedy + LNS Scheduler**
- **Implementation**: Precomputes singleton/pairwise costs and tournament margins to drive a greedy constructor with buddy lookahead and a refreshable candidate pool, backed by a global cost cache. Improves via multi-start, adjacent swaps, boundary-focused LNS with capped permutations/relocate moves, then 2-opt and random insertions, with incumbent pruning.
- **Performance**: Achieved combined score 3.34 on 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Pairwise tournament guidance and buddy-based lookahead produce strong seeds that LNS refines effectively; caching significantly amortizes evaluation cost. Runtime is driven by cost evaluations and permutation sampling, but pool preselection, small windows (k≤7), and early termination keep it tractable.
**Program Identifier:** Generation 33 - Patch Name tournament_buddies_lns - Correct Program: True

**Program Name: Buddy-Guided Beam Search with VNS Scheduler**
- **Implementation**: Two-phase beam search driven by buddy lists, prefix-dominance pruning (local/global), shallow adaptive lookahead, and incumbent-based pruning, all under a 0.58s time budget. Uses cached cost/extension evaluations, greedy completions, and a lightweight VNS refinement (adjacent swaps, boundary repair via surrogate pair costs, and targeted relocations) with portfolio-based restarts.
- **Performance**: Achieved a combined score of 2.57 on 3 workloads (300 transactions), producing valid schedules under a 0.58s per-workload time budget.
- **Feedback**: Buddy-guided candidate pools and caching reduced evaluation overhead while improving search focus; prefix-dominance and incumbent pruning effectively cut the search space, and VNS yielded incremental post-optimization gains. Performance is sensitive to beam/branch settings and time budget, but the approach is robust and passes all validation tests.
**Program Identifier:** Generation 34 - Patch Name buddy_beam_prefix_dominance_vns_plus - Correct Program: True

**Program Name: Tournament-guided LNS Transaction Scheduler**
- **Implementation**: Uses a tournament-guided greedy constructor with buddy lookahead, backed by a global cost cache, precomputed singleton/pairwise costs (M) and preference margins (W). Multi-start seeding combines a beam search with dominance pruning (by remaining set and suffix) and greedy completion, followed by adjacent swaps, boundary-focused LNS over hot windows (marginal sums and violation boundaries), targeted relocations, 2-opt, and random insert polish; includes early pruning against the incumbent.
- **Performance**: Achieved a combined score of 3.47 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Tournament/buddy guidance and caching significantly reduced evaluation overhead and improved early choices, while LNS on high-impact windows delivered most of the final gains. Beam-seed quality and the num_seqs exploration budget were key levers for the makespan–time trade-off, with dominance checks aiding scalability.
**Program Identifier:** Generation 35 - Patch Name none - Correct Program: True

**Program Name: Tournament-guided beam search with VNS refinement**
- **Implementation**: Two-phase beam search seeded by tournament scores with precomputed singleton/pairwise costs to derive preference margins (W) and buddy lists, plus prefix-dominance pruning, adaptive lookahead, periodic greedy completions, and a VNS post-optimizer (bubble pass, adjacent swaps, sampled 2-opt, relocations, ruin-and-recreate). Memoized partial-sequence costs and deterministic RNG improve speed and stability.
- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Tournament-guided preselection and prefix-dominance pruning reduced simulator calls and tightened the beam, while periodic greedy completions and VNS yielded consistent final improvements. Pairwise precompute is O(n^2) overhead but is amortized by caching; deterministic seeding provided reproducible schedules.
**Program Identifier:** Generation 36 - Patch Name beam2phase_prefix_prune_vns - Correct Program: True

**Program Name: MCTS Transaction Scheduler with RAVE**
- **Implementation**: UCT-based Monte Carlo Tree Search with progressive widening and RAVE adjacency guidance, using transposition keys (remaining bitmask + 3-length suffix). It memoizes full and extension costs, builds buddy lists from sampled pairwise deltas, performs greedy rollouts with incumbent pruning, and applies light 2-opt/relocate refinement under a capped adaptive time budget.
- **Performance**: Achieved a combined score of 2.27 across 3 workloads (300 transactions) with valid schedules within the time budget.
- **Feedback**: Cost memoization, buddy-guided candidate ordering, and progressive widening reduced evaluations and stabilized search; RAVE improved early action scoring. Greedy rollouts plus local refinement consistently improved the incumbent, with modest final gains from the polishing phase.
**Program Identifier:** Generation 37 - Patch Name uct_mcts_scheduler - Correct Program: True

**Program Name: Tournament-guided merge with LNS scheduling**
- **Implementation**: Uses a sparse pairwise tournament (Copeland+margin strength) to rank transactions, then builds schedules via block-wise merge guided by memoized extension costs. Applies multi-start local search (adjacent swaps, limited 2-opt, and margin-guided ruin-and-recreate) under a ~0.62s per-workload time budget with aggressive cost caching.
- **Performance**: Achieved combined score 2.38 across 3 workloads (300 transactions), producing valid schedules within the time budget.
- **Feedback**: Tournament ranking plus cached extension costs yielded strong initial sequences while minimizing expensive evaluations; LNS refinements consistently improved makespan without exceeding the budget. The solution was robust (permutation repair included) and passed all validation tests.
**Program Identifier:** Generation 38 - Patch Name tournament_merge_lns - Correct Program: True

**Program Name: Buddy-Guided Beam Search Scheduler**
- **Implementation**: Dual-phase incumbent-seeded beam search with prefix-dominance pruning, buddy-biased candidate pools, depth-adaptive lookahead, greedy completion, and light VNS polish. Uses memoized cost evaluations, singleton-based lower bounds, multi-restarts with slight parameter perturbations, and a tight time budget scaled by N.
- **Performance**: Achieved combined score 2.03 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching, lower bounds, and dominance pruning reduce evaluations and keep runtime bounded, while buddy-guided candidates and greedy incumbent tightening improve quality within the budget. Multi-restart diversity and VNS yield incremental gains; the approach handled simple cases (e.g., workload 3 near-identity order) without degradation.
**Program Identifier:** Generation 39 - Patch Name dual_beam_incumbent_vns - Correct Program: True

**Program Name: Two-Phase Beam Search with Buddy Lookahead**
- **Implementation**: Uses a time-capped, two-phase beam search with prefix-dominance pruning, buddy lists built from two-step marginal deltas, and cached singleton/extension costs; greedy completion updates incumbents mid-search, followed by light local improvement (adjacent swaps, boundary-focused block reinsertion, random insertions). Includes adaptive beam/branch portfolio restarts and a simple lower bound via max remaining singleton cost.
- **Performance**: Combined score to maximize: 2.10; produced valid schedules for 3 workloads (300 transactions) within per-workload time budgets.
- **Feedback**: Passed all validation tests. Caching, buddy-guided lookahead, and dominance pruning reduced evaluations, while greedy completion and VNS-like refinement tightened incumbents and improved robustness across workloads.
**Program Identifier:** Generation 40 - Patch Name beam2phase_prefixdom_vns - Correct Program: True

**Program Name: Buddy-guided beam search scheduler with local refinement**
- **Implementation**: Uses a time-bounded (0.48s) buddy-guided beam search with memoized prefix/extension costs, A*-style singleton lower bounds, prefix-dominance pruning, shallow lookahead, and greedy completion, followed by local refinement (adjacent swaps, boundary repair via pair deltas, and random insertions) over multiple restarts. Beam/branch sizes scale with N and buddies are built from sampled pairwise marginal deltas cached for reuse.
- **Performance**: Achieved combined score 2.42 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching plus lower bounds and dominance pruning effectively cut search while maintaining solution quality, enabling multiple restarts within the budget. The local refinement stage consistently tightens makespan beyond the beam incumbent, indicating good synergy between global guidance and lightweight local moves.
**Program Identifier:** Generation 41 - Patch Name buddy_beam_lookahead_ils - Correct Program: True

**Program Name: Tournament-guided LNS transaction scheduler**
- **Implementation**: Builds pairwise cost and preference matrices, then combines a tournament/buddy-guided greedy constructor, beam-search seeding with dominance pruning, and a global eval cache. Performs LNS over hot windows (permutations), targeted relocate, block-swap/reinsert, plus adjacent swaps, 2-opt, and random insert cleanups; evaluates three workloads and sums makespans.
- **Performance**: Combined score to maximize: 0.0 (program marked incorrect; fails validation).
- **Feedback**: Fails due to an undefined variable ‘inc’ used before initialization inside get_best_schedule (referenced in build_initial_sequence and passed to beam_seed), causing runtime errors. Non-deterministic RNG seeding and heavy local search neighborhoods may further hinder reproducibility and timing under tests.
**Program Identifier:** Generation 42 - Patch Name two_phase_beam_domlns - Correct Program: False

**Program Name: Tournament-guided beam + VNS scheduler**
- **Implementation**: Uses a two-phase beam search with tournament-based preselection and lookahead, augmented by memoized partial-cost evaluation and greedy completion for pruning and incumbent updates. After beam search, a VNS local improvement applies tournament bubble passes, adjacent swaps, sampled 2-opt, relocations, and ruin-and-recreate; it precomputes singleton/pairwise costs to build preference margins and a tournament order, and prunes via prefix-dominance signatures.
- **Performance**: Combined score reported as 0.0; program did not pass validation tests.
- **Feedback**: The heavy heuristic stack is non-deterministic (RNG seeded by time) and path bootstrapping is brittle, contributing to inconsistent behavior and failures under tests. Aggressive pruning and O(n^2) precomputation increase complexity and may hurt robustness/performance on the evaluator’s workloads.
**Program Identifier:** Generation 43 - Patch Name two_phase_beam_with_incumbent_pruning - Correct Program: False

**Program Name: Buddy-guided beam search with VNS refinement**
- **Implementation**: Time-bounded two-phase beam search uses prefix-dominance pruning (local/global suffix signatures), incumbent-based pruning, shallow adaptive lookahead, and greedy probes; it precomputes singleton costs, builds buddy lists, caches extension costs, and uses a pairwise adjacency surrogate. A lightweight VNS applies adjacent swaps, boundary repair around worst adjacencies, limited block swaps, and targeted relocations, with permutation repair safeguards.
- **Performance**: Achieved combined score 2.81 on three workloads (300 transactions), producing valid schedules within ~0.58s per workload and passing all validation tests.
- **Feedback**: Caching plus buddy-guided lookahead/pruning effectively reduced simulator calls and quickly tightened incumbents, while VNS delivered incremental gains. Results may be sensitive to random sampling and the fixed time budget; the portfolio parameters appear well-tuned for these workloads.
**Program Identifier:** Generation 44 - Patch Name child_probe_and_block_swap - Correct Program: True

**Program Name: Surrogate-Guided Greedy + LNS Scheduler**
- **Implementation**: Memoizes true costs (full and prefix-extension) and uses an on-demand pairwise delta surrogate Δ(a→b) to guide both construction and local moves. Builds buddy lists for conflict-aware greedy seeding, then applies ΔW-gated local refinement (worst-pair reinsertion, adjacent swaps, block reinsert, random insertions) under a 0.60s time budget with multi-restart seeds.
- **Performance**: Achieved a combined score of 2.11 (maximize) across three workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Surrogate gating and caching substantially reduce expensive true-cost calls, enabling consistent improvements within the tight budget. Multi-restart seeding from top singletons and buddy pairs provides robust performance across heterogeneous workloads.
**Program Identifier:** Generation 45 - Patch Name sgl_surr_lns - Correct Program: True

**Program Name: Hybrid tournament-beam LNS scheduler**
- **Implementation**: Combines a two-phase, tournament-guided beam search with buddy-aware greedy seeding, prefix-dominance pruning, and boundary-focused LNS, followed by light 2-opt and random insertion refinements. Uses a memoized evaluator, a pairwise cost matrix with preference margins, and deterministic RNG; includes path discovery to import simulator/workloads.
- **Performance**: Combined score 0.0; fails validation tests, yielding no valid metric.
- **Feedback**: A critical bug in the greedy seed cleanup assigns a function to seq0 instead of a list (uses a “no-op tuple trick”), causing type errors and invalid execution; replace with seq0 = tournament_bubble_pass(seq0, passes=2). The O(n^2) precomputation and frequent evaluate_seq calls are costly; caching helps but runtime risk remains high.
**Program Identifier:** Generation 46 - Patch Name hybrid_beam_lns_buddy - Correct Program: False

**Program Name: MCTS + LNS Transaction Scheduler**
- **Implementation**: UCT-style MCTS with progressive widening, conflict-aware greedy rollouts guided by singleton costs and pairwise-preference “buddies,” plus an elite Order Crossover; followed by a focused LNS (adjacent swaps, relocations, small block reinserts) under a tight time budget. Uses cost/extension caches, a transposition table keyed by (prefix, remaining), and seeded incumbents for faster convergence.
- **Performance**: Combined score 2.92 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Heuristic guidance (singleton costs, pairwise preferences) and caching reduce expensive evaluations and keep runtime modest, while the LNS stage reliably improves MCTS solutions. Progressive widening and occasional elite crossover provide diversity without excessive branching, yielding stable performance within sub-second budgets.
**Program Identifier:** Generation 47 - Patch Name uct_conflict_mcts_lns - Correct Program: True

**Program Name: Greedy-VNS Transaction Scheduler with Pruning**
- **Implementation**: Deterministic multi-start greedy constructor guided by pairwise tournament scores and buddy lists, with adaptive lookahead, prefix-dominance pruning, and memoized cost evaluations. A VNS-style local improvement suite applies adjacent and sampled non-adjacent swaps, insertions, targeted relocations by marginal cost, ruin-and-recreate, and window permutations around worst adjacencies.
- **Performance**: Achieved a combined score to maximize of 3.28 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Precomputing singleton/pairwise costs and caching greatly reduce simulator calls and tighten incumbents via periodic greedy completion, enabling effective pruning and faster convergence; the O(n^2) M/W construction remains the main overhead on larger workloads. Deterministic seeding ensures stable results, while the targeted VNS moves consistently improve makespan over the initial greedy sequences.
**Program Identifier:** Generation 48 - Patch Name tournament_buddy_greedy_dom_lns - Correct Program: True

**Program Name: MCTS-PUCT with ΔW-guided LNS Scheduler**
- **Implementation**: Uses Monte Carlo Tree Search with PUCT, progressive widening, incumbent and prefix-dominance pruning, and a greedy rollout guided by tournament rankings and buddy lists with global memoized evaluations. Post-optimization applies a ΔW-gated Large Neighborhood Search (block swaps, reinserts, and adjacent passes) under tight time guards and deterministic RNG.
- **Performance**: Combined score 0.0; the program is marked incorrect and fails validation tests.
- **Feedback**: The brittle repo-root discovery and sys.path manipulation likely caused import/runtime failures in the evaluation harness, preventing scoring; additionally, heavy O(n^2) precomputation plus time-bounded stochastic search may contribute to timeouts. Make imports resilient to environment differences and ensure deterministic, fast execution aligned with the expected API to pass validations.
**Program Identifier:** Generation 50 - Patch Name mcts_pruned_puct_lns - Correct Program: False

**Program Name: Beam-A* Transaction Scheduler with Greedy/VNS**
- **Implementation**: Implements a portfolio beam search with A*-style lower-bound pruning, greedy completion, shallow lookahead, prefix-dominance pruning, and a fast VNS local improver, using cached sequence/extension costs. Seeds by singleton costs, probes greedily to tighten incumbents, perturbs parameters across restarts, and includes permutation repair plus repository-path discovery for workload imports.
- **Performance**: Combined score to maximize: 0.0; the program is marked incorrect and fails validation tests.
- **Feedback**: Likely failures come from fragile repo-path/dependency imports and nondeterministic randomness (no fixed seed), leading to non-reproducible or invalid outputs under tests. Make imports robust, enforce determinism, and verify interface/return types to align with validation expectations.
**Program Identifier:** Generation 49 - Patch Name beam_lb_greedy_dom_vns - Correct Program: False

**Program Name: Portfolio Beam + LNS Scheduler**
- **Implementation**: Two-phase portfolio beam search guided by pairwise preference matrix (M, W) with tournament preselection, buddy/anti-buddy filtering, global prefix-dominance pruning, and periodic greedy completions; followed by ΔW-inspired LNS (adjacent hill-climb, block swap/reinsert, relocate, 2-opt), using a memoized cost evaluator. It also precomputes singleton/pairwise costs and shares caches across beam variants.
- **Performance**: Combined score: 0.0; program flagged as incorrect and failed validation tests.
- **Feedback**: num_seqs is not actually used to control beam width (doc/behavior mismatch), and the O(n^2) precompute plus large beam/LNS evaluation budgets likely violate runtime constraints, contributing to failure. Path discovery via __file__ and hardcoded fallbacks is brittle and may break in the evaluation environment.
**Program Identifier:** Generation 51 - Patch Name beam_lns_portfolio_v2 - Correct Program: False

**Program Name: Beam-Seeded Greedy VNS Transaction Scheduler**
- **Implementation**: Uses deterministic multi-start construction with a two-phase beam search seeded by tournament/buddy heuristics, memoized cost evaluations, prefix-dominance pruning (by remaining set and 3-length suffix), and adaptive lookahead plus periodic greedy completion. A targeted VNS local improvement follows (adjacent/non-adjacent swaps, insertions, ruin-and-recreate, and boundary window permutations guided by pairwise cost asymmetries).
- **Performance**: Achieved a combined score of 3.41 on 3 workloads (300 total transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Beam seeding and incumbent-based pruning effectively cut search while preserving solution quality, and the VNS phase consistently tightened makespan. Deterministic RNG and caching improved stability and evaluation efficiency; further gains may come from deeper incremental cost reuse.
**Program Identifier:** Generation 52 - Patch Name two_phase_beam_seed_with_incumbent - Correct Program: True

**Program Name: FAS-guided greedy scheduling with SA refinement**
- **Implementation**: Builds a sparse pairwise preference matrix via sampled two-item costs to derive a FAS-inspired global ranking, then uses a memoized true-cost greedy builder (windowed) to construct schedules. Applies local hill-climbing (adjacent swaps, targeted relocations) and simulated annealing under a 0.65s time budget, with portfolio seeding (FAS, reverse, random), caching for sequences/prefix extensions, and permutation repair safeguards.
- **Performance**: Achieved combined score 1.83 on 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: FAS-guided ranking plus memoized true-cost evaluation and bounded local/annealing refinements yield strong schedules quickly; diverse seeding improves robustness across workloads. The strict time budgeting and caches effectively control evaluation overhead, enabling deeper refinement within the runtime limit.
**Program Identifier:** Generation 53 - Patch Name fas_rank_sa - Correct Program: True

**Program Name: Buddy-Guided Beam and GRASP Scheduler**
- **Implementation**: Time-bounded beam search with buddy lists derived from pairwise deltas, prefix-dominance pruning (local/global), and greedy lookahead/probes backed by cost and extension caching. Diversification via conflict-aware GRASP and refinement through lightweight VNS/ILS (adjacent swaps, boundary repair, block swaps, relocations) ensures schedule quality and reproducibility with seeded RNG.
- **Performance**: Combined score: 2.75; processed 3 workloads (300 transactions) producing valid schedules within per-workload time budgets and passing all validation tests.
- **Feedback**: Buddy-based candidate pools and shallow lookahead/probes tightened incumbents early, enabling effective pruning with singleton-based lower bounds and prefix-dominance. Global dominance sharing across restarts and targeted local refinements provided additional makespan reductions with low overhead, yielding stable results.
**Program Identifier:** Generation 54 - Patch Name beam_grasp_vns_crossover - Correct Program: True

**Program Name: Beam-A* Transaction Scheduler with Buddy Heuristics**
- **Implementation**: Uses beam search with memoized prefix/extension costs and singleton-cost lower bounds (A*-style), buddy-guided candidate pools, suffix-aware prefix-dominance pruning, shallow lookahead, and greedy completion, followed by local adjacent-swap and insertion refinement. Runs under a 0.5s time budget with up to 3 restarts and includes a safety repair to ensure valid permutations.
- **Performance**: Achieved combined score 2.26 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and dominance pruning effectively cut expansions, while two-step-delta buddy lists and early greedy probes tightened incumbents and improved ranking. The method is stochastic but robust due to multi-restarts and repair logic, yielding stable schedules in evaluation.
**Program Identifier:** Generation 55 - Patch Name buddy_prefix_dom_beam - Correct Program: True

**Program Name: Tournament-guided beam LNS scheduler**
- **Implementation**: Time-bounded (≈0.62s/workload) scheduler with memoized cost/extension oracles, a sparse pairwise tournament for ranking, and merge-based construction; refined via buddy-guided beam search (dominance + shallow lookahead) and a multi-start local search portfolio (adjacent swaps, limited 2-opt, targeted ruin-and-recreate), with safety permutation repair and repo-root detection.
- **Performance**: Combined score to maximize: 2.18 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Tournament margins and extension-cost caching yield strong seeds, while beam+greedy probes and LNS steps consistently tighten incumbents under tight budgets. Robustness measures (path discovery, schedule repair) help reliability, though RnR/2-opt rely on full cost reevaluations that likely dominate remaining runtime.
**Program Identifier:** Generation 56 - Patch Name buddy_beam_seed_lns - Correct Program: True

**Program Name: Beam+Greedy LNS Transaction Scheduler**
- **Implementation**: Builds a preference matrix from precomputed singleton/pairwise costs and uses a two-phase beam search with tournament-guided candidates, global/local prefix-dominance pruning, and greedy completion with buddy lookahead; then applies a restart portfolio with LNS (window permutations, block swap/reinsert, targeted relocations) and final 2-opt/insert polishing. Caches partial costs (cost_cache), uses a global dominance map, and dynamically probes repository paths to import external workloads.
- **Performance**: Combined score 0.0; failed validation tests.
- **Feedback**: Likely failures stem from brittle external dependency resolution (repo path probing for openevolve_examples) causing import/runtime errors in the evaluator; heavy search/LNS budgets and O(n^2) precomputation may also induce timeouts. Removing path assumptions and tightening compute budgets would improve robustness and test pass rates.
**Program Identifier:** Generation 57 - Patch Name beam_lns_portfolio_v3 - Correct Program: False

**Program Name: Beam-seeded Greedy LNS Transaction Scheduler**
- **Implementation**: Memoized cost evaluation with precomputed singleton/pairwise matrices builds a tournament ordering and buddy lists to guide a two-phase beam search with incumbent pruning and adaptive lookahead, followed by greedy completion. A boundary-focused large neighborhood search refines solutions via hot-window permutations, targeted relocations, adjacent swaps, and light 2-opt/insertion moves, with prefix-dominance and tournament bubbling for cheap pruning/cleanup.
- **Performance**: Combined score 3.61 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Incumbent/prefix-dominance pruning and tournament/buddy-guided candidate pools reduce search while preserving solution quality; boundary-centric LNS drives most late-stage improvements. Deterministic seeding and caching stabilize outcomes over restarts, though the heuristic may trade runtime for better makespan on larger instances.
**Program Identifier:** Generation 58 - Patch Name tournament_beam_lns_hybrid - Correct Program: True

**Program Name: Buddy-Guided Beam Search Scheduler**
- **Implementation**: Hybrid beam search with memoized extension/sequence costs, singleton-based buddy lists for candidate pooling, and incumbent-aware greedy completions under a strict time budget. Final schedules are refined via a lightweight local search (adjacent swaps and limited relocations) with a few time-bounded restarts.
- **Performance**: Achieved combined score 2.70, producing valid schedules for 3 workloads (300 transactions) within tight time budgets and passing all validation tests.
- **Feedback**: Buddy-guided candidate pools and caching substantially cut evaluation overhead and enable effective pruning, while greedy tightening stabilizes results across restarts. The lower bound (max remaining singleton) and minimalist local search limit optimality; stronger bounds or richer neighborhoods could further reduce makespan.
**Program Identifier:** Generation 59 - Patch Name beam_vns_mcts_hybrid - Correct Program: True

**Program Name: Tournament-Guided Buddy LNS Scheduler**
- **Implementation**: Precomputes singleton/pairwise costs to derive tournament preferences and buddy lists, then builds schedules via a tournament-guided greedy with lookahead and a beam-seeded prefix explorer with dominance pruning, all using a global cost cache. Refines solutions with boundary-focused LNS over hot windows plus targeted relocate, adjacent swaps, 2-opt, and random insertion moves.
- **Performance**: Achieved combined score 3.57 across 3 workloads (300 transactions) while passing all validation tests.
- **Feedback**: Pairwise precomputation and caching reduced expensive evaluations, enabling deeper guided search; tournament/buddy heuristics improved early ordering and boundary-focused LNS delivered most final gains. The num_seqs parameter effectively trades exploration depth for runtime, suggesting higher budgets could yield further makespan improvements at additional cost.
**Program Identifier:** Generation 60 - Patch Name beam_seed_prefix_search - Correct Program: True

**Program Name: Tournament-guided Beam+LNS Transaction Scheduler**
- **Implementation**: Uses cached cost evaluations with a precomputed pairwise cost matrix and tournament margins to guide a pool-based greedy constructor with buddy lookahead; seeds via a dominance-pruned beam search and refines with boundary-focused LNS plus local adjacent/2-opt/insertion moves. Early pruning via an incumbent and capped permutation/sampling keep the LNS tractable.
- **Performance**: Achieved combined score 3.55, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: The hybrid seeding (beam + greedy) and boundary-aware LNS effectively reduce makespan while caching and tournament-guided preselection control runtime. Performance depends on the exploration budget (num_seqs) and window sizes, suggesting further gains from parameter tuning.
**Program Identifier:** Generation 61 - Patch Name two_phase_beam_and_block_moves - Correct Program: True

**Program Name: Tournament-guided beam search with VNS**
- **Implementation**: Implements a two-phase, tournament-guided beam search with memoized partial-cost evaluation, precomputed singleton/pairwise cost matrices (c1, M), preference margins (W), buddy heuristics, adaptive lookahead, greedy completions, prefix-dominance pruning, and a VNS-style local improvement (adjacent/non-adjacent swaps, relocations, ruin-and-recreate). Includes deterministic seeding and an aggressive repo-root path resolver that modifies sys.path to import the simulator/workloads.
- **Performance**: Combined score 0.0; the program did not pass validation tests.
- **Feedback**: The path discovery/import logic is brittle and likely caused import failures in the evaluation environment, leading to a hard failure. Even when running, the heavy pairwise precomputation and frequent evaluate_seq calls increase runtime risk; aggressive dominance/pruning and extensive heuristics may also over-prune or waste budget without guaranteed feasibility gains.
**Program Identifier:** Generation 62 - Patch Name beam_child_greedy_prune_and_suffix3 - Correct Program: False

**Program Name: Buddy-Guided Beam Scheduler with Local Search**
- **Implementation**: Hybrid beam search guided by memoized extension costs, singleton-based lower bounds, and per-transaction “buddy” lists from pairwise deltas; includes prefix-dominance pruning via k-suffix signatures, shallow lookahead, greedy probes, and multi-restart execution within a strict time budget. A lightweight local search refines results using adjacent swaps, boundary ruin-and-recreate around worst adjacencies, and random relocations.
- **Performance**: Achieved a combined score of 2.60 across 3 workloads (300 transactions), producing valid schedules within the allotted sub-second per-workload budget.
- **Feedback**: The caching and dominance pruning sharply reduce costly evaluations, while early greedy completions tighten the incumbent and improve pruning efficiency; local moves add consistent post-search improvements. Program passes all validation tests; further gains may come from stronger lower bounds or deeper lookahead if time allows.
**Program Identifier:** Generation 63 - Patch Name none - Correct Program: True

**Program Name: Portfolio beam+greedy LNS txn scheduler**
- **Implementation**: Combines beam search and greedy construction guided by precomputed singleton/pairwise costs (M) and preference margins (W), with tournament ordering, buddy/anti-buddy heuristics, global prefix-dominance, and incumbent-aware pruning. Post-construction, uses LNS with window permutations, ΔW-gated block swaps/reinserts, targeted relocations, adjacent swaps, and final 2-opt/insertion refinements; cost evaluations are memoized and RNG is deterministically seeded.
- **Performance**: Combined score to maximize: 0.0 (failed validation tests).
- **Feedback**: Likely failures stem from fragile repository path resolution/import dependencies and/or mismatch with evaluation expectations (e.g., runtime/portability or output contract), despite deterministic seeding and caching. The heavy search and frequent cost evaluations risk timeouts; simplifying neighborhoods and hardening path/import logic would improve robustness.
**Program Identifier:** Generation 64 - Patch Name txn_beam_greedy_lns_portfolio - Correct Program: False

**Program Name: Tournament-guided LNS Transaction Scheduler**
- **Implementation**: Builds a sampled pairwise tournament matrix W and buddy lists to seed orders, then uses a beam search with shared prefix-dominance caching (keyed by remaining-set and tail suffix), lower bounds, and incumbent-aware greedy completion; final refinement applies ΔW-gated LNS (window permutations, block swaps, reinserts) ranked by a cheap surrogate and capped evaluations, all under a tight time budget with deterministic portfolio restarts and shared memoization.
- **Performance**: Achieved a combined score of 2.05, generating valid schedules for 3 workloads (300 transactions total) and passing all validation tests.
- **Feedback**: Prefix-dominance caching, extension-cost memoization, and ΔW surrogate gating effectively cut true evaluations and kept runtime predictable, while selective LNS and portfolio restarts reliably improved seeds. Further improvements likely depend on richer W sampling/adaptation and tuning evaluation caps to workload size.
**Program Identifier:** Generation 65 - Patch Name uct_tournament_lns - Correct Program: True

**Program Name: Tournament-guided greedy with buddy lookahead LNS**
- **Implementation**: Builds a global cost cache and pairwise cost matrix to derive a tournament preference (W) and buddy lists, then constructs schedules via a tournament-guided greedy pool with lookahead and prefix-dominance pruning, plus a beam-seeded multi-start. Applies boundary-focused LNS (window permutations, relocate, block-swap/reinsert), followed by adjacent swaps, limited 2-opt, and random insertions.
- **Performance**: Combined score 0.0; marked incorrect and failing validation tests.
- **Feedback**: Nondeterministic seeding (time/PID) and environment-dependent path discovery likely cause inconsistent behavior and test failures; extensive eval_seq usage can also trigger timeouts. Make the search deterministic, harden repository discovery/imports, and cap neighborhood/budget sizes to stabilize runtime and improve reliability.
**Program Identifier:** Generation 66 - Patch Name none - Correct Program: False

**Program Name: Beam+LNS Transaction Scheduler with Prefix-Dominance**
- **Implementation**: Uses a deterministic beam search with conflict-aware greedy completion, global prefix-dominance pruning, anti-buddy filtering from sampled pairwise preferences, and depth-adaptive lookahead; cost evaluations are cached (sequence and extension), buddies are built from singleton/extension costs, and LNS refines results via adjacent swaps and block swap/reinsert guided by a ΔW surrogate.
- **Performance**: Combined score to maximize: 2.82; produced valid schedules across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: The mix of prefix-dominance, anti-buddy gating, and caching effectively prunes the search while preserving quality, and the portfolio plus LNS steps provide additional gains within the 0.50–0.58s per-workload time budget. Performance may be sensitive to pairwise sampling density and the fixed time budget as N grows, but deterministic seeding keeps runs stable.
**Program Identifier:** Generation 67 - Patch Name beam_lns_portfolio_prefixdom - Correct Program: True

**Program Name: Beam-seeded multi-start greedy scheduler with VNS**
- **Implementation**: Deterministic multi-start greedy construction is seeded by a beam search incumbent, with memoized seq_cost, pairwise cost/tournament matrices, buddy lists, adaptive lookahead, and prefix-dominance pruning plus periodic greedy completion. A targeted VNS phase applies tournament bubble passes, adjacent/non-adjacent swaps, insert/relocate by marginal cost, ruin-and-recreate, and window permutations.
- **Performance**: Achieved combined score 3.22 over 3 workloads (300 transactions) and passes all validation tests.
- **Feedback**: Beam seeding and prefix-dominance pruning effectively tighten the incumbent and prune unpromising branches, while cost memoization curbs simulator overhead. Further improvements likely hinge on tuning beam width/lookahead and local search budgets to balance quality versus runtime.
**Program Identifier:** Generation 68 - Patch Name beam_seed_and_bubble_cleanup - Correct Program: True

**Program Name: Time-bounded beam+LNS scheduler**
- **Implementation**: Implements a time-bounded portfolio beam search with global prefix-dominance caching and incumbent-aware greedy completion, using anti-buddy filtering from sampled pairwise preferences and buddy-biased candidate pools. Local search refinement applies ΔW-guided LNS (adjacent swaps, block swaps, and reinserts) with memoized cost/extension caches and deterministic restarts.
- **Performance**: Combined score 2.00; produced valid schedules for 3 workloads (300 transactions total) and passed all validation tests.
- **Feedback**: Caching and time-gated probing maintain speed while ΔW-guided LNS and anti-buddy gating improve makespan within the ~0.55–0.62s per-instance budget. Deterministic seeding and permutation-repair enhance robustness; outputs were consistent and sensible across workloads (e.g., trivial ordering recognized on workload 3).
**Program Identifier:** Generation 69 - Patch Name beam_lns_prefixdom_v2 - Correct Program: True

**Program Name: Beam-seeded Greedy VNS Scheduler**
- **Implementation**: Multi-start, beam-seeded greedy constructor with prefix-dominance caching, tournament/buddy scoring from precomputed pairwise costs (M, W), adaptive lookahead, and incumbent-tightening via greedy completion; followed by targeted VNS-style local search (adjacent/non-adjacent swaps, insertions, relocate by marginals, ruin-and-recreate, window permutations, block swaps/reinserts). Deterministic RNG and seq_cost memoization reduce variance and recomputation, with a shared prefix cache across restarts for pruning.
- **Performance**: Achieved combined score 3.37 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Tournament/buddy-guided lookahead plus shared prefix-dominance pruning effectively tightened incumbents early, yielding strong makespan reductions with manageable evaluation cost due to memoization. Robust repo-root discovery ensured portability; minor note that workload_size is defined but unused.
**Program Identifier:** Generation 70 - Patch Name shared_prefix_dom_and_block_moves - Correct Program: True

**Program Name: Dominance-Pruned Beam Search Scheduler**
- **Implementation**: Implements a time-bounded stochastic beam search with memoized cost and extension caches, singleton-cost seeding/LB, and shared prefix-dominance keyed by (remaining-set, k-suffix). Uses a small multi-restart portfolio with deterministic base RNG, greedy completion, and a cheap adjacent-swap pass, with beam/branch sizes scaling with N.
- **Performance**: Achieved a combined score of 1.57, producing valid schedules for 3 workloads (300 transactions total) and passing all validation tests.
- **Feedback**: Cost caching and prefix-dominance substantially reduce recomputation and enable effective pruning under tight time budgets; greedy finalization and a light local swap provide inexpensive last-mile gains. The disabled mid-run greedy probe and constrained branching keep runtime stable but may limit peak optimality on larger instances.
**Program Identifier:** Generation 71 - Patch Name dom_beam_pruned_v2 - Correct Program: True

**Program Name: Incumbent-aware beam and LNS transaction scheduler**
- **Implementation**: Combines beam search with incumbent-aware greedy completion, global prefix-dominance caching, anti-buddy filtering from pairwise preferences, and depth-adaptive lookahead; shared cost/extension caches and deterministic seeding ensure fast, reproducible scoring. A ΔW-gated LNS phase (block swap/reinsert and adjacent swaps) refines top seeds under an evaluation cap.
- **Performance**: Achieved combined score 1.85 across 3 workloads (300 transactions), producing valid schedules within the ~0.5–0.58s per-instance budget and passing all validation tests.
- **Feedback**: Pairwise sampling and anti-buddy gating effectively reduce branching without degrading quality, while LNS reliably improves the beam’s best candidates. Sensitivity may remain to W/D sampling coverage and percentile thresholds, but shared dominance and caching choices balance speed and quality well.
**Program Identifier:** Generation 72 - Patch Name beam_lns_prefixdom_v3 - Correct Program: True

**Program Name: Buddy-Guided Beam Search with VNS Refinement**
- **Implementation**: Two-phase, time-bounded beam search guided by learned buddy/anti-buddy heuristics, global/local prefix-dominance pruning with adaptive k-suffix, shallow lookahead, and incumbent-based pruning, with memoized cost/extension caches. Solutions are greedily completed and locally improved via a lightweight VNS (adjacent swaps, ruin-recreate, block swaps, relocations).
- **Performance**: Achieved combined score 2.82 on three workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Buddy-guided candidate pools and anti-buddy gating effectively reduce branching without degrading quality, while prefix-dominance and LB pruning stabilize runtime. The beam-parameter portfolio plus VNS consistently tightens the incumbent within the ~0.58s/workload budget, contributing materially to the final score.
**Program Identifier:** Generation 73 - Patch Name prefix_dom_antibuddy_lns - Correct Program: True

**Program Name: Beam+LNS Makespan Scheduler**
- **Implementation**: Time-bounded portfolio of beam search plus conflict-aware greedy completion, using depth-adaptive lookahead, global prefix-dominance pruning, and buddy/anti-buddy heuristics derived from sampled pairwise preferences with cached cost evaluations. Post-optimization uses LNS (adjacent swaps, block swap, and block reinsert) guided by a ΔW surrogate to refine top candidates; deterministic RNG ensures reproducibility.
- **Performance**: Achieved a combined score of 2.16 across 3 workloads (300 transactions total), producing valid schedules and passing all validation tests within an ~0.50–0.58s per-workload budget.
- **Feedback**: Prefix-dominance, caching, and anti-buddy filtering effectively reduce redundant evaluations and steer the beam toward promising prefixes, while LNS provides consistent incremental gains on the best candidates. The sampled preference matrix and depth-adaptive parameters balance exploration and speed, though limited pairwise probing and time budgets may cap deeper search on larger N.
**Program Identifier:** Generation 74 - Patch Name greedy_lookahead_prefixdom - Correct Program: True

**Program Name: Portfolio beam-greedy scheduler with LNS**
- **Implementation**: Combines beam search and tournament-guided greedy builders using precomputed pairwise cost matrix (M), preference margins (W), buddy/anti-buddy heuristics, prefix-dominance pruning, and incumbent-aware greedy completions. A ΔW-gated large-neighborhood search performs window permutations, block swaps/reinserts, adjacency-based surrogate ranking, and final 2-opt/insertion polishing under evaluation caps with deterministic RNG.
- **Performance**: Combined score reported as 0.0; the program fails validation tests.
- **Feedback**: Despite a rich heuristic portfolio and pruning, the solution appears brittle in validation (likely due to path/import assumptions or unmet API/edge-case handling), yielding no credit. Stabilizing environment discovery, tightening correctness checks, and adding guardrails for fallback behavior would improve reliability and test pass rates.
**Program Identifier:** Generation 75 - Patch Name incumbent_portfolio_beam_lns - Correct Program: False

**Program Name: Beam-Greedy ΔW-LNS Transaction Scheduler**
- **Implementation**: Time-bounded (~0.58s) beam search with greedy completion uses cached singleton/extension costs, a sampled pairwise preference matrix (W), anti-buddy thresholds (75th percentile), and unified prefix-dominance pruning with depth-adaptive lookahead and incumbent-aware probes. A ΔW-gated LNS performs block swaps/reinserts plus adjacent passes, with deterministic portfolio restarts and final permutation repair for safety.
- **Performance**: Achieved combined score 2.31 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Anti-buddy filtering and prefix-dominance pruning effectively reduced unpromising branches while preserving high-quality extensions; ΔW-guided LNS delivered final refinements after beam+greedy established strong prefixes. Deterministic portfolio restarts improved robustness without breaching the time budget.
**Program Identifier:** Generation 76 - Patch Name beam_lns_prefixdom_v3 - Correct Program: True

**Program Name: Buddy-guided beam search scheduler**
- **Implementation**: Implements a hybrid buddy-guided beam search with memoized extension costs, singleton-based lower bounds, and prefix-dominance pruning; candidate pools leverage buddy lists with anti-buddy thresholds, shallow lookahead, and greedy completions. Multiple restarts plus a lightweight local search (adjacent swaps and relocations) refine results within a tight time budget.
- **Performance**: Achieved a combined score of 2.34 across three workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and pruning reduce evaluations and keep runtime predictable, while restarts and local tweaks effectively tighten the incumbent. Anti-buddy gating and lookahead focus expansions, though solution quality is ultimately bounded by the fixed time budget.
**Program Identifier:** Generation 78 - Patch Name none - Correct Program: True

**Program Name: Buddy-guided Beam+GRASP-ILS Transaction Scheduler**
- **Implementation**: Time-bounded, cache-accelerated beam search with global/local prefix-dominance, buddy/anti-buddy heuristics, shallow lookahead, and greedy completion. Adds GRASP diversification and VNS/ILS refinement (adjacent swaps, boundary repair, block swaps, relocations) with portfolio restarts; uses singleton-based lower bounds and pairwise cost surrogates.
- **Performance**: Achieved combined score 2.82 on 3 workloads (300 txns), producing valid schedules and passing all tests within tight ~0.5s/workload time budgets.
- **Feedback**: Caching and buddy-guided candidate pools pruned the search effectively, while global prefix-dominance across restarts reduced recomputation and stabilized results. Local improvement consistently tightened incumbents, and GRASP/portfolio diversification prevented premature convergence.
**Program Identifier:** Generation 79 - Patch Name antibuddy_gating_and_filters - Correct Program: True

**Program Name: Buddy-guided beam search transaction scheduler**
- **Implementation**: Implements a hybrid buddy-guided beam search with memoized extension costs, greedy incumbent tightening, and lightweight local improvement (adjacent swaps + relocations). Builds buddy lists from pairwise cost deltas, uses singleton-cost lower bounds and a prefix-dominance map to prune, and completes prefixes via greedy lookahead under a tight time budget with multi-restarts.
- **Performance**: Achieved a combined score of 2.29 on 3 workloads (300 transactions) and passed all validation tests within the set time budgets.
- **Feedback**: Cost caching and guided candidate pools significantly reduce evaluations and focus the beam, delivering good solutions quickly. The weak singleton lower bound and compact local search keep runtime low but may limit deeper exploration; modestly increasing beam/branch factors or time could further reduce makespan.
**Program Identifier:** Generation 80 - Patch Name none - Correct Program: True

**Program Name: Tournament-guided LNS Scheduler**
- **Implementation**: Heuristic scheduler combining tournament-based pairwise-preference ordering with buddy lookahead, beam-seeded greedy construction, and boundary-focused Large Neighborhood Search, plus 2-opt and random insertion polishing. It precomputes a pairwise cost matrix, uses anti-buddy gating, prefix-dominance pruning keyed by remaining-set and suffix, and a global cost cache.
- **Performance**: Combined score 0.0; the program fails validation/tests.
- **Feedback**: A missing function call (tournament_bubble_pass) in lns_improve triggers a runtime error; the repository path autodiscovery may also be brittle. Define/remove the missing routine and consider cutting redundant eval_seq calls or making seeding deterministic to improve robustness and runtime.
**Program Identifier:** Generation 77 - Patch Name incumbent_aware_beam_prefix_dom_antibuddy_lns_bubble - Correct Program: False

**Program Name: Beam-guided VNS Transaction Scheduler**
- **Implementation**: Multi-start beam search with incumbent pruning uses tournament-derived pairwise costs (M/W), buddy lists, anti-buddy gating, and prefix-dominance memoization (remaining-set + suffix) to build schedules, then applies VNS-style local search (swaps, relocations, ruin-and-recreate, window/block ops) to refine them. Deterministic RNG and a sequence-cost memo cache reduce variance and redundant evaluations.
- **Performance**: Combined score 0.0; fails validation tests and produces incorrect results.
- **Feedback**: Reliance on get_opt_seq_cost for partial sequences and aggressive prefix-dominance pruning likely breaks API assumptions or yields invalid schedules; path probing for external modules further risks runtime failures. Ensure full-permutation validity, add robust fallbacks/imports, and reduce brittle pruning to improve correctness and scoring.
**Program Identifier:** Generation 81 - Patch Name beam_greedy_antibuddy_fix_and_bubble_cleanup - Correct Program: False

**Program Name: Tournament-Guided Beam+Greedy LNS Scheduler**
- **Implementation**: Precomputes singleton/pairwise costs to build a tournament matrix, then runs beam-seeded and adaptive greedy constructors with shared prefix-dominance pruning, followed by LNS (bubble, anchored permutations, block swaps/reinserts) and small 2-opt/insert finishes. Uses memoized cost caching, buddy/anti-buddy guidance, a global incumbent across portfolio restarts, and custom repo path discovery.
- **Performance**: Combined score 0.0; the program is marked incorrect and fails validation tests.
- **Feedback**: Determinism is undermined by seeding RNGs with Python's randomized hash, the search-budget parameter (num_seqs) is ignored, and brittle filesystem path injection can fail in the evaluator. Extensive O(n^2) precomputation and frequent seq_cost calls may cause timeouts; honoring num_seqs and removing path hacks would likely improve robustness.
**Program Identifier:** Generation 82 - Patch Name fusion_beam_portfolio_v3 - Correct Program: False

**Program Name: Conflict-aware MCTS-LNS Transaction Scheduler**
- **Implementation**: UCT-style MCTS with progressive widening and a transposition table, using conflict-aware greedy rollouts guided by sampled pairwise margins (anti-buddy gating), singleton heuristics, and cached cost/extension evaluations; elite order-crossover injects diversity. A focused LNS phase (adjacent swaps, relocations, small block reinserts, limited 2-opt) refines the incumbent under a tight per-workload time budget (~0.58–0.66s).
- **Performance**: Achieved combined score 2.79 across three workloads (300 transactions) with valid schedules; all validation tests passed.
- **Feedback**: Pairwise-informed candidate ranking and anti-buddy filtering reduced poor extensions and improved rollout quality, while caching kept evaluations efficient within the time cap. The fixed short budget limits exploration depth, but elite crossover plus LNS consistently recovered additional improvements after MCTS.
**Program Identifier:** Generation 83 - Patch Name none - Correct Program: True

**Program Name: Beam-seeded VNS with prefix pruning**
- **Implementation**: Two-phase beam-seeded constructive search uses tournament/buddy heuristics, memoized cost evaluation, prefix-dominance pruning with suffix signatures, adaptive lookahead, and anti-buddy filters. A deterministic multi-restart phase is followed by a VNS-style local improvement suite (adjacent/non-adjacent swaps, targeted relocations, ruin-and-recreate, window permutations, and block swaps/reinserts).
- **Performance**: Achieved combined score 3.47 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Incumbent tightening via periodic greedy completions and shared prefix-dominance significantly pruned the search and improved makespan stability; tournament/W-guided candidate selection reduced harmful adjacencies. The main tradeoff is heavier upfront pairwise cost computation and frequent scoring, though memoization mitigates recomputation.
**Program Identifier:** Generation 84 - Patch Name fix_beam_prune_and_antibuddy_greedy - Correct Program: True

**Program Name: Portfolio Beam+Greedy LNS Scheduler**
- **Implementation**: Combines beam-seeded greedy construction with strengthened local neighborhood search (LNS), sharing a memoized evaluator across stages. Precomputes pairwise cost matrix M and asymmetry W for tournament ranking, uses unified prefix-dominance keyed by (remaining-set, suffix), buddy/anti-buddy gating, and deterministic seeding.
- **Performance**: Combined score to maximize: 0.0; program failed validation.
- **Feedback**: Failures likely stem from brittle repository-root import discovery (RuntimeError when openevolve_examples is not found) and potentially heavy search exceeding time limits. Make imports robust to packaging (avoid absolute-path fallbacks), add graceful fallbacks when workloads are missing, and consider tightening search budgets for validation.
**Program Identifier:** Generation 85 - Patch Name portfolio_beam_greedy_lns - Correct Program: False

**Program Name: Conflict-aware beam search scheduler**
- **Implementation**: Uses a beam search with shared prefix-dominance, singleton-based lower bounds, and cached cost/extension evaluations, guided by buddy lists and shallow lookahead. It promotes incumbents via child-level greedy completion and finishes with a single adjacent-swap local improvement, running under a tight per-workload time budget with a small parameter portfolio.
- **Performance**: Achieved a combined score of 2.35 across 3 workloads (300 transactions total), within the intended runtime and passing all validation tests.
- **Feedback**: Prefix-dominance plus singleton LBs effectively prune the search, while buddy-guided pools and targeted greedy probes improve incumbent quality early. The adjacent-swap pass provides quick local gains, and portfolio restarts add robustness without significant overhead.
**Program Identifier:** Generation 86 - Patch Name beam_prefix_dom_greedy_ox - Correct Program: True

**Program Name: Tournament-Guided Beam+Greedy LNS Scheduler**
- **Implementation**: Builds a pairwise cost matrix and tournament margins to steer a two-phase beam search seeded with good singletons, using greedy completion, buddy-based lookahead, shared prefix-dominance pruning, and multi-start LNS (window permutations, relocate/block moves) with adjacent, 2-opt, and insertion cleanups. Sequence-cost caching is used throughout to minimize repeated evaluations.
- **Performance**: Achieved a combined score of 3.68 on 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Tournament preselection, buddy lookahead, and prefix-dominance effectively prune the search while LNS refines high-impact regions, yielding robust makespans across mixed workloads. Periodic greedy completion to tighten incumbents noticeably improves convergence and final quality.
**Program Identifier:** Generation 87 - Patch Name beam_tourney_lns_plus - Correct Program: True

**Program Name: Buddy-guided beam search with VNS refinement**
- **Implementation**: Uses a two-phase beam search guided by learned buddy/anti-buddy lists, with global/local prefix-dominance pruning via k-suffix signatures, shallow lookahead, and greedy probes, all backed by cached cost/extension evaluations. A lightweight VNS (adjacent swaps, boundary ruin–recreate, block swaps/reinserts, targeted relocations) refines schedules under a ~0.58s/workload time budget with portfolio-based restarts.
- **Performance**: Achieved a combined score of 2.91 across 3 workloads (300 transactions), producing valid schedules under the time budget.
- **Feedback**: Anti-buddy gating, prefix-dominance caching, and early greedy probing reduced branching and improved incumbent quality; VNS yielded modest final improvements. Deterministic seeding ensures reproducibility but may limit diversity across restarts.
**Program Identifier:** Generation 88 - Patch Name none - Correct Program: True

**Program Name: Buddy-Guided Beam Search with VNS Refinement**
- **Implementation**: Two-phase, time-bounded beam search guided by learned buddy lists, prefix-dominance pruning (remaining-set + k-suffix signatures), shallow lookahead, and incumbent pruning, followed by a lightweight VNS local search (adjacent swaps, ruin-and-recreate, block swaps/relocations). Aggressive cost memoization (prefix and extension caches), anti-buddy thresholds, greedy probes, and portfolio-based restarts diversify and tighten the search.
- **Performance**: Achieved a combined score of 2.58, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Caching plus anti-buddy gating reduced expensive evaluations and pruned weak branches early, while greedy probes and VNS rapidly improved incumbents within the 0.58s budget. Portfolio restarts improved robustness across workloads without sacrificing stability.
**Program Identifier:** Generation 90 - Patch Name pair_seeded_beam - Correct Program: True

**Program Name: Beam-guided Greedy VNS Transaction Scheduler**
- **Implementation**: Uses deterministic multi-start beam-seeded greedy construction with memoized cost evaluation, precomputed pairwise/tournament preferences, and prefix-dominance pruning, plus incumbent-aware greedy lookahead. A VNS-style local improvement suite (bubble, adjacent/non-adjacent swaps, insertions, marginal-guided relocates, ruin-and-recreate, window/block permutations and swaps) refines schedules.
- **Performance**: Combined score 3.37 across three workloads (300 transactions).
- **Feedback**: Evaluation confirms correctness and reproducibility (passes all validation tests). Prefix-dominance caching and incumbent-driven pruning efficiently cut the search while maintaining solution quality, and the diverse local moves improved final makespan.
**Program Identifier:** Generation 89 - Patch Name bridge_and_bubble_refinements - Correct Program: True

**Program Name: Buddy-Guided Beam + VNS Scheduler**
- **Implementation**: Two-phase beam search seeded by singleton/pair costs with local/global prefix-dominance pruning, depth-adaptive shallow lookahead, anti-buddy gating, incumbent/LB pruning, and cached cost evaluations; followed by lightweight VNS-style local improvement (adjacent swaps, boundary/block repairs, relocations). A tight time budget (~0.58s/workload) and greedy probes tighten the incumbent to strengthen pruning.
- **Performance**: Achieved combined score 2.70, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Caching, dominance pruning, and early greedy probes effectively reduce evaluations and focus the search, yielding good makespan under the time budget, while VNS refinement recovers additional improvements from the beam output. Anti-buddy thresholds with depth-adaptive tolerances help avoid harmful adjacencies without sacrificing candidate diversity.
**Program Identifier:** Generation 91 - Patch Name pair_seeded_beam_with_depth_adaptive_antibuddy_and_child_dom - Correct Program: True

**Program Name: Buddy-guided Beam + VNS Scheduler**
- **Implementation**: Two-phase beam search seeded by best singletons uses buddy lists, anti-buddy thresholds, adaptive k-suffix prefix-dominance (global/local), shallow lookahead, and greedy probes, then refines via lightweight VNS (adjacent swaps, boundary repair, block swaps, relocations). Memoized cost/extension caches, precomputed singleton/pair costs, and a 0.58s time budget enable fast evaluation and aggressive pruning.
- **Performance**: Achieved combined score 2.47 across 3 workloads (300 transactions), producing valid schedules within the time budget and passing all tests.
- **Feedback**: Prefix-dominance and incumbent-based pruning, together with anti-buddy gating and greedy completions, effectively reduce search while preserving solution quality; the VNS step consistently improves beam outputs. The algorithm is correct, stable across restarts, and passes all validation checks.
**Program Identifier:** Generation 92 - Patch Name none - Correct Program: True

**Program Name: Beam-seeded greedy scheduler with VNS local search**
- **Implementation**: Builds pairwise cost and tournament matrices to guide ordering; runs a two-phase beam-seeded prefix explorer with incumbent-aware greedy completion, prefix-dominance memoization, anti-buddy filtering, and adaptive lookahead, then refines via multi-neighborhood local search (bubble, adjacent swaps, targeted 2-opt/bridge, block reinsertion, ruin-and-recreate). Deterministic RNG and cost memoization reduce recomputation and variance.
- **Performance**: Achieved combined score 3.37 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Incumbent pruning plus greedy probes tightened bounds early, enabling aggressive pruning without losing quality; tournament-guided preselection and buddy lists yielded strong starts, while targeted block/relocate moves delivered consistent marginal improvements. Robust import-path resolution aids portability with negligible runtime impact beyond startup.
**Program Identifier:** Generation 93 - Patch Name conflict_targeted_2p5opt - Correct Program: True

**Program Name: Buddy-Guided Beam+GRASP Scheduler**
- **Implementation**: Implements a time-bounded portfolio: buddy-guided, dominance-pruned beam search with greedy lookahead, anti-buddy gating, and GRASP diversification, followed by VNS/ILS local refinement. Caches sequence/extension costs and prefix signatures with deterministic seeding to reduce recomputation and stabilize search.
- **Performance**: Combined score: 3.16 across 3 workloads (300 transactions), producing valid schedules within the set time budgets.
- **Feedback**: Buddy/anti-buddy heuristics and prefix-dominance pruning effectively shrink the candidate set and preserve strong prefixes, while greedy probes tighten the incumbent early. Local improvements yield incremental gains and portfolio restarts enhance robustness; all validation tests passed.
**Program Identifier:** Generation 94 - Patch Name none - Correct Program: True

**Program Name: Buddy-Guided Beam Search with LNS for Txn Scheduling**
- **Implementation**: Time-bounded beam search uses shared prefix-dominance pruning, cost caching, and buddy/anti-buddy heuristics with shallow lookahead and greedy promotion; results are refined via an LNS suite (adjacent swaps, anchored window reinsertion, block swaps, conflict-targeted 2.5-opt). Deterministic portfolio restarts share caches across runs to improve reuse and stability.
- **Performance**: Achieved combined score 2.60 across three workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and anti-buddy gating effectively reduce evaluations and focus exploration, delivering consistent improvements within the tight ~0.5s per-workload budget. Further gains may come from tuning time budgets/lookahead depth or allocating more LNS iterations when time permits.
**Program Identifier:** Generation 95 - Patch Name beam_prefix_lns_v5 - Correct Program: True

**Program Name: Beam+LNS Transaction Scheduler**
- **Implementation**: Multi-start greedy with two-phase beam search, memoized seq_cost, tournament-derived M/W matrices, buddy lists, prefix-dominance pruning, and greedy lookahead; followed by LNS (window permutations, targeted relocations/bridges) plus adjacent, 2-opt, and insertion refinements. Includes custom repo-root discovery to import simulator/workloads.
- **Performance**: Combined score 0.0; failed validation tests.
- **Feedback**: The environment-specific path probing and dependency on external repo structure make the program fragile and likely to fail tests; extensive seq_cost evaluations may also breach time budgets. Ensure a stable import/interface contract and tighter runtime bounds or pruning to improve correctness and reliability.
**Program Identifier:** Generation 96 - Patch Name beam_greedy_dom_antibuddy_bridge_lns - Correct Program: False

**Program Name: MCTS-LNS Transaction Scheduler**
- **Implementation**: UCT-style MCTS with progressive widening and conflict-aware greedy rollouts guided by pairwise preference sampling (buddy/anti-buddy), with prefix-dominance and singleton-based lower bounds for pruning. An elite set with order crossover and a focused LNS (adjacent/non-adjacent swaps, relocations, small-block reinserts, 2.5-opt), plus cached cost/extension evaluations and fixed seeding, refine incumbents under a tight time budget.
- **Performance**: Achieved combined score 2.92, producing valid schedules for 3 workloads (300 transactions) within the time-bounded search, and passed all validation tests.
- **Feedback**: Pairwise-guided candidate pools and anti-buddy gating reduced poor extensions and improved rollout quality, while dominance/LB pruning kept the tree compact for faster convergence. Most final gains came from the LNS phase and occasional elite crossover, indicating MCTS quickly finds strong regions and local search provides effective polishing.
**Program Identifier:** Generation 97 - Patch Name none - Correct Program: True

**Program Name: [Portfolio beam + greedy-LNS scheduler]**
- **Implementation**: Uses a deterministic portfolio beam search with shared prefix-dominance pruning, tournament-based preselection, anti-buddy filtering from a precomputed pairwise cost matrix (M/W), greedy-completion promotion, and conflict-targeted LNS (anchored window permutations, bridge/2.5-opt) with adjacent/tournament-bubble cleanups; cost evaluations are memoized and c1/M/W are precomputed for speed. Seeds come from beam incumbents and greedy restarts, then refined via budget-scaled LNS with incumbent/dominance-based pruning.
- **Performance**: Combined score reported as 0.0; the program failed validation tests.
- **Feedback**: Failures likely stem from brittle repository path discovery and external imports (txn_simulator, workloads) that can break in the test harness, overshadowing the algorithm’s heuristic strength. Harden environment handling and return/output contracts, add fallbacks for missing modules, and bind search work strictly to num_seqs to improve reliability and predictability.
**Program Identifier:** Generation 98 - Patch Name beam_portfolio_lns_prefixdom - Correct Program: False

**Program Name: Buddy-guided Beam/GRASP ILS Scheduler**
- **Implementation**: Combines time-bounded beam search with prefix-dominance pruning and greedy lookahead, guided by learned buddy/anti-buddy lists from pairwise deltas and cached cost extensions. Diversifies with GRASP and refines via VNS/ILS moves (adjacent swaps, boundary repair, anchored-window permutations, bridge/block swaps, targeted relocations), all under evaluation/time caps with shared caches and seeded RNG.
- **Performance**: Achieved combined score 3.04 with valid schedules across 3 workloads (300 transactions) within ~0.48–0.56s per workload, passing all validation tests.
- **Feedback**: Caching, shared prefix dominance, and anti-buddy gating reduced expansions and enabled early incumbent updates, improving makespan under tight budgets. Local refinement neighborhoods consistently delivered incremental gains after constructive phases; portfolio restarts added robustness without sacrificing determinism.
**Program Identifier:** Generation 99 - Patch Name beam_grasp_lns_prefixdom_v4 - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Boundary-focused LNS layered on a guided beam constructor yields the top scores
  - Current best (Tournament-guided Beam+Greedy LNS Scheduler, 3.68) combines a two-phase beam with greedy completion and a boundary/“hot-window” LNS that permutes k≤6 exhaustively and k=7 by sampling (≤2000), plus targeted relocate/block-swap/reinsert moves and cheap bubble/2-opt/insert cleanups. Similar but lighter variants (Beam-seeded greedy scheduler with VNS local search, Gen93, 3.37; Beam-guided Greedy VNS Transaction Scheduler, Gen89, 3.37) trail without the stronger boundary-targeted permutations.
- Incumbent-aware beam with shared dominance and greedy probes tightens bounds early
  - Gen91 (Buddy-Guided Beam + VNS, 2.70), Gen92 (Buddy-guided Beam + VNS, 2.47), Gen94 (Buddy-Guided Beam+GRASP, 3.16), and Gen99 (Buddy-guided Beam/GRASP ILS, 3.04) all credit incumbent/LB pruning plus periodic greedy completions with reducing expansions and improving makespan under ~0.5–0.58s budgets.
- Tournament/buddy-guided candidate pools with shallow lookahead consistently help
  - The best program precomputes c1/M/W, builds buddy lists, uses tournament-guided preselection and lookahead, and applies a tournament_bubble_pass polish; these elements also appear in the 3.37 scorers (Gen89, Gen93) and correlate with higher-quality expansions.
- Unified memoized evaluation across phases is critical
  - All top performers cache seq_cost across construction/beam/LNS (e.g., Gen87’s 3.68; Gen93’s 3.37), cutting simulator calls and enabling more aggressive pruning/lookahead without breaching time limits.

## Ineffective Approaches
- Fragile repository path/import handling causes total failure regardless of heuristic quality
  - Gen96 (Beam+LNS Transaction Scheduler, 0.0) and Gen98 ([Portfolio beam + greedy-LNS], 0.0) fail validation due to brittle repo-root probing and external imports; evaluation notes this overshadowed algorithmic strength and likely breached interface/budget expectations.
- Overly light local search caps performance
  - “Lightweight” VNS/LNS passes (adjacent-only or limited neighborhoods) in beam variants (Gen91 at 2.70, Gen92 at 2.47, Gen95 at 2.60) underperform compared to boundary-focused LNS with hot-window permutations and targeted non-local moves (current best at 3.68; Gen93 at 3.37).
- Over-aggressive/invalid pruning or API misuse undermines correctness (from prior insights)
  - Earlier failures (e.g., Gen81, 0.0) tied to using get_opt_seq_cost for partials combined with aggressive dominance pruning, leading to invalid schedules; contrasts with correct, validation-passing implementations here that keep dominance keyed to (remaining set, short suffix) and respect API constraints.

## Implementation Insights
- What makes the current best (3.68) effective
  - Integrated guidance: Precomputed c1/M/W enable tournament ordering, buddy lists, and a tournament_bubble_pass cleanup that cheaply fixes local adjacencies before/after heavier moves.
  - Beam + greedy promotion + dominance: Two-phase beam with depth-adaptive candidate pools and lookahead, local prefix-dominance (suffix≤3) inside beam, global dominance shared across greedy restarts, and periodic greedy completions to tighten the incumbent early.
  - Focused LNS where it matters: Hot windows selected by marginal sums and worst violated adjacencies; exhaustive permutations for k≤6 and sampled for k=7, plus targeted relocates, block swaps, and block reinsertions; capped budgets keep runtime in check while unlocking non-local improvements.
  - Unified caching and cheap polish: A single cost_cache shared across phases reduces recomputation; follow-up two-opt and random insertion passes provide deterministic last-mile gains.
- Additional effective coding patterns from other strong programs
  - Anti-buddy gating with depth-adaptive thresholds (Gen91 at 2.70; Gen92 at 2.47) avoids harmful adjacencies during construction and improves diversity, though it trails the boundary-LNS approach in peak scores.
  - Deterministic seeding and portfolio restarts (Gen93 at 3.37; Gen95 at 2.60; Gen99 at 3.04) stabilize outcomes; sharing caches across restarts improves reuse and reduces evaluation cost.

## Performance Analysis
- Clear advantage for boundary-aware LNS on top of guided beam construction
  - Current best at 3.68 outperforms similar beam+VNS designs (Gen89 and Gen93 at 3.37; Gen99 at 3.04) and beam+LNS without strong boundary targeting (Gen95 at 2.60), indicating that hot-window permutations and adjacency-informed neighborhoods are decisive.
- Beam-centric with lightweight local search underperforms
  - Buddy/anti-buddy guided beams with lightweight VNS/GRASP (Gen91: 2.70; Gen92: 2.47; Gen94: 3.16) improve over naive approaches but fall short of the 3.37–3.68 band achieved by stronger LNS.
- MCTS-LNS is competitive but trails the best beam+boundary-LNS
  - MCTS-LNS (Gen97, 2.92) benefits from pairwise-guided rollouts and caching, but most gains come from the LNS phase; it converges fast to good regions yet lags boundary-focused LNS in final makespan.
- Robustness correlates with scoring potential
  - All high scorers pass validation and emphasize caching, tournament/buddy guidance, and dominance/pruning; 0.0 scorers (Gen96, Gen98) failed due to environment/import brittleness and budget/contract issues, not inherently weaker heuristics.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Share prefix-dominance across beam and greedy and add child-level greedy promotion
   - Replace beam’s local dom with the global prefix_dom keyed by (frozenset(remaining), suffix), using suffix_k=3 until 70% depth and suffix_k=4 after. For each expanded parent, run greedy_complete on the top K children by lookahead (K=2 for early/mid depth, K=1 late); prune a child if its greedy-completion cost ≥ incumbent and update incumbent on improvement. Keep the existing “complete top beam items” step; this tightens bounds earlier and reduces expansions, mirroring what worked in top scorers.

2. Upgrade boundary-focused LNS with anchored windows, ΔW gating, bridge move, and a strict eval cap
   - When choosing hot windows, add anchored windows around worst-violated adjacencies: fix a or b and permute the k−1 interior; keep current marginal-sum windows. Before eval_seq, compute a ΔW surrogate for candidates (permutations/relocates/block-swaps/reinserts) and evaluate only the top 35–40% by ΔW plus 10% random; enforce a per-round eval_seq cap of 700 with early exit. Raise k=7 sampling to up to 3000 only if the cap hasn’t been hit, add a “bridge” move that extracts a block around b (size 3–5), optionally reverses it, and reinserts before a, and run tournament_bubble_pass immediately after any accepted move.

3. Depth- and context-adaptive lookahead with anti-buddy filtering in both beam and greedy
   - Set recent_k by stage: early/mid/late = 5/4/3, and (lookahead_top, next_k) = (4,6), (3,5), (2,4) respectively. Add an anti-buddy guard: if the last placed x has W[x][t] in the top 25% of its row, skip t unless its metric is within 1% of the best at that step; for the single best immediate child, probe one extra depth by minimizing over next_k=4 buddies at depth+2. Apply this uniformly in beam expansion and the greedy builder to concentrate on high-yield continuations while avoiding known-bad adjacencies.

4. Deterministic restart portfolio with shared caches and selective LNS
   - Run 3 deterministic restarts with rng = Random(1729 + r) and reuse cost_cache, M, W, buddies, and prefix_dom across restarts. Vary beam parameters per restart, e.g., (beam_width, cand_per_expand, lookahead_top, next_k) ∈ {(16,12,4,6), (12,14,3,5), (10,10,2,4)}, and apply full lns_improve only to the best two seeds by greedy_complete; keep tournament_bubble_pass and adjacent_pass on all seeds. Add a simple per-restart early-stop: if no improvement after 2 LNS iterations, skip remaining LNS for that restart to keep within budget.

5. Replace late random two-opt/insertion with conflict-targeted 2.5-opt sampling
   - Build a candidate set from the top-κ worst violated adjacencies (κ = min(20, n//8)); for each (a,b) at positions i,i+1, sample j far from i and evaluate either swapping non-adjacent endpoints (2-opt) or extracting a short block around b (size 3–4) and reinserting before a (2.5-opt). Rank candidates by ΔW = (W[a][b] + W[seq[j]][seq[j+1]]), evaluate only the top 40% plus 10% random under a small budget (50–80 trials), and accept the first improving move. This targets the heaviest conflicts more efficiently than uniform two-opt/insertion and aligns with the boundary-aware gains seen in the best program.