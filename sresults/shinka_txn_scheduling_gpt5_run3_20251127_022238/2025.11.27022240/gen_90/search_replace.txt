<NAME>
pair_seeded_beam
</NAME>
<DESCRIPTION>
I introduce an enhanced beam initialization that seeds the search with both singleton and high-quality pair prefixes instead of only singletons. The idea is to quickly lock in strong early adjacencies that reduce future conflicts, based on true extension costs and buddy guidance. For each top singleton transaction (by singleton cost), we evaluate a small candidate pool formed from its buddies and a few low-singleton remaining transactions, compute the exact extension cost cost([t, u]), and add these [t, u] prefixes as seeds. We then keep the best prefixes for the beam. This improves the starting frontier quality, reduces early branching into poor regions, and tightens the incumbent sooner, leading to lower makespan without adding significant runtime (we evaluate only a handful of pairs per seed with full memoization).

This change is localized to the seeding part of the beam runner and is consistent with existing caches, buddy lists, and pruning logic. It leverages the already available eval_ext_cost and buddies, so no new dependencies are introduced.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
        # Seed: best singletons by cost
        seeds = sorted(all_txns_local, key=lambda t: singleton_cost.get(t, float('inf')))
        seeds = seeds[:max(beam_width * 2, 8)]
        beam = []
        for t in seeds:
            if not time_left():
                break
            seq = [t]
            rem = set(all_txns_local)
            rem.remove(t)
            c = eval_seq_cost(seq)
            beam.append((c, seq, rem))
        if not beam:
            seq = all_txns_local[:]
            rng.shuffle(seq)
            return eval_seq_cost(seq), seq, incumbent_cost, None

        beam.sort(key=lambda x: x[0])
        beam = beam[:beam_width]
=======
        # Seed beam with enhanced prefixes: best singletons and top-scoring pairs
        seed_tx = sorted(all_txns_local, key=lambda t: singleton_cost.get(t, float('inf')))
        seed_tx = seed_tx[:max(beam_width * 2, 10)]
        seed_entries = []
        for t in seed_tx:
            if not time_left():
                break
            # Singleton seed
            c1 = eval_seq_cost([t])
            rem1 = set(all_txns_local) - {t}
            seed_entries.append((c1, [t], rem1))

            # Pair seeds: buddies of t and a few low-singleton candidates
            cand_pool = []
            for u in buddies.get(t, []):
                if u in rem1 and u != t and u not in cand_pool:
                    cand_pool.append(u)
            rem_list = list(rem1)
            low_s = sorted(rem_list, key=lambda x: singleton_cost.get(x, float('inf')))[:min(4, len(rem_list))]
            for u in low_s:
                if u not in cand_pool:
                    cand_pool.append(u)
            # Limit number of pair candidates per t
            if len(cand_pool) > 6:
                cand_pool = cand_pool[:6]

            for u in cand_pool:
                if not time_left():
                    break
                c2 = eval_ext_cost((t,), u)  # true cost of [t, u]
                rem2 = rem1.copy()
                rem2.remove(u)
                seed_entries.append((c2, [t, u], rem2))

        if not seed_entries:
            seq = all_txns_local[:]
            rng.shuffle(seq)
            return eval_seq_cost(seq), seq, incumbent_cost, None

        # Deduplicate by prefix and keep the top 'beam_width' seeds
        seed_entries.sort(key=lambda x: x[0])
        beam = []
        seen = set()
        for c, s, r in seed_entries:
            key = tuple(s)
            if key in seen:
                continue
            seen.add(key)
            beam.append((c, s, r))
            if len(beam) >= beam_width:
                break
>>>>>>> REPLACE

</DIFF>