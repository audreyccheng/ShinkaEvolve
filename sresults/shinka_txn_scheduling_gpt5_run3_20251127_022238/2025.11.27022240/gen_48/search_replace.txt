<NAME>
tournament_buddy_greedy_dom_lns
</NAME>

<DESCRIPTION>
I introduce three targeted improvements to reduce makespan by aligning the constructor and local search with true conflict structure:

1) Pairwise conflict modeling with tournament and buddies:
   - Precompute pairwise costs M[i][j] and margins W to expose read/write conflicts.
   - Use a tournament-guided preselection and buddy-based lookahead to pick the next transaction that minimally increases partial schedule cost. This focuses evaluation effort on candidates that truly reduce makespan impact and avoids noisy heuristics.

2) Prefix-dominance pruning with greedy incumbent tightening:
   - Maintain a global prefix dominance map keyed by (remaining set, suffix) to prune dominated partial prefixes across restarts.
   - Periodically greedy-complete current prefix to update an incumbent full schedule, enabling early termination of inferior paths.

3) Boundary-focused micro-LNS:
   - After local improvements, target the worst violated adjacencies (by W) and try limited block permutations (k=5â€“6) around these boundaries. This cheaply fixes high-impact inversions that adjacent swaps and relocations miss.

These changes keep the overall structure intact but make the constructor conflict-aware and the local improvement smarter, improving schedule makespan with controlled evaluation counts.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
import time
import random
import sys
import os
=======
import time
import random
import sys
import os
import itertools
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Precompute singleton costs to seed better starting points
    singleton_costs = [(t, seq_cost([t])) for t in range(n)]
    singleton_costs.sort(key=lambda x: x[1])
=======
    # Precompute singleton costs to seed better starting points
    singleton_costs = [(t, seq_cost([t])) for t in range(n)]
    singleton_costs.sort(key=lambda x: x[1])

    # Pairwise costs and tournament/buddy structure to expose conflicts
    M = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            M[i][j] = seq_cost([i]) if i == j else seq_cost([i, j])

    W = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = 0 if i == j else (M[i][j] - M[j][i])

    s = [0] * n
    for i in range(n):
        s[i] = sum(W[i][j] for j in range(n) if j != i)
    tournament_order = list(range(n))
    tournament_order.sort(key=lambda x: (s[x], x))

    # Buddy list per txn by small M[i][j]
    buddy_k = 8 if n >= 90 else 6
    buddies = []
    for t in range(n):
        order = sorted((u for u in range(n) if u != t), key=lambda u: M[t][u])
        buddies.append(order[:buddy_k])

    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
        if not remaining:
            return []
        recents = prefix[-recent_k:] if recent_k > 0 else []
        scored = []
        for t in remaining:
            sc = 0
            for x in recents:
                sc += W[x][t]
            scored.append((sc, t))
        scored.sort(key=lambda z: (z[0], z[1]))
        return [t for _, t in scored[:k]]

    def recent_k_for_depth(d):
        frac = d / max(1, n - 1)
        return 5 if frac < 0.33 else (4 if frac < 0.66 else 3)

    # Cheap greedy completion used to tighten incumbent during construction
    def greedy_complete(seq, remaining):
        base = seq[:]
        rem = list(remaining)
        while rem:
            t = min(rem, key=lambda u: seq_cost(base + [u]))
            base.append(t)
            rem.remove(t)
        return base, seq_cost(base)

    # Prefix-dominance map shared across restarts: (frozenset(remaining), suffix<=3) -> best cost
    prefix_dom = {}
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        if r < min(5, n):
            k = min(10, n)
            t0 = rng.choice([t for t, _ in singleton_costs[:k]])
        else:
            t0 = rng.randint(0, n - 1)
=======
        if r == 0:
            t0 = tournament_order[0]
        elif r < min(5, n):
            # pick among top by singleton and tournament
            k = min(10, n)
            pool = set([t for t, _ in singleton_costs[:k]])
            pool.update(tournament_order[:k])
            t0 = rng.choice(list(pool))
        else:
            t0 = rng.randint(0, n - 1)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Greedy build: evaluate all candidates and use adaptive lookahead to break ties
        step = 0
        while remaining:
            # Incumbent-based pruning: if partial already not better, abort this restart
            base_cost = seq_cost(seq)
            if best_cost < float('inf') and base_cost >= best_cost:
                # Abort current restart early; no completion can beat incumbent
                seq = None
                break

            cand_costs = []
            base = seq
            for t in remaining:
                c = seq_cost(base + [t])
                cand_costs.append((t, c))
            cand_costs.sort(key=lambda x: x[1])

            # Adaptive lookahead: slightly deeper in early steps
            L = min(4 if step < 10 else 3, len(cand_costs))
            top_cands = cand_costs[:L]

            chosen_t = top_cands[0][0]
            best_pair_cost = None
            # Dynamic next-sample size: smaller when many remain
            R = len(remaining)
            if n <= 60:
                base_la = 6
            else:
                base_la = 4
            lookahead_samples = base_la if R <= 60 else max(3, base_la - 1)

            for t, immediate_c in top_cands:
                if R == 1:
                    la_cost = immediate_c
                else:
                    next_pool = [x for x in remaining if x != t]
                    if len(next_pool) <= lookahead_samples:
                        sampled_next = next_pool
                    else:
                        sampled_next = rng.sample(next_pool, lookahead_samples)
                    la_cost = min(seq_cost(base + [t, u]) for u in sampled_next)
                if best_pair_cost is None or la_cost < best_pair_cost:
                    best_pair_cost = la_cost
                    chosen_t = t

            seq.append(chosen_t)
            remaining.remove(chosen_t)
            step += 1
=======
        # Greedy build: tournament-guided pool with buddy lookahead and prefix dominance pruning
        step = 0
        while remaining:
            base_cost = seq_cost(seq)

            # Incumbent-based pruning: if partial already not better, abort this restart
            if best_cost < float('inf') and base_cost >= best_cost:
                seq = None
                break

            # Prefix-dominance pruning on current prefix
            sig_cur = (frozenset(remaining), tuple(seq[-3:]) if len(seq) >= 3 else tuple(seq))
            prev_cur = prefix_dom.get(sig_cur)
            if prev_cur is not None and base_cost >= prev_cur:
                seq = None
                break
            if prev_cur is None or base_cost < prev_cur:
                prefix_dom[sig_cur] = base_cost

            # Periodic greedy completion to tighten incumbent
            if step % 10 == 0 and remaining:
                full, fc = greedy_complete(seq, remaining)
                if fc < best_cost:
                    best_cost = fc
                    best_seq = full[:]

            # Tournament-guided preselection pool
            R = len(remaining)
            pool_size = 16 if n >= 90 else 12
            k_pool = min(pool_size, R) if R > pool_size else R
            cand_pool = preselect_by_tournament(seq, list(remaining), k_pool, recent_k=recent_k_for_depth(len(seq)))
            if not cand_pool:
                cand_pool = list(remaining)

            # Evaluate immediate costs within pool
            imm = [(t, seq_cost(seq + [t])) for t in cand_pool]
            imm.sort(key=lambda x: x[1])

            # Adaptive lookahead: slightly deeper early
            L = min(4 if step < 10 else 3, len(imm))
            chosen_t = imm[0][0]
            best_metric = imm[0][1]

            for t, immediate_c in imm[:L]:
                rest = [x for x in remaining if x != t]
                if not rest:
                    metric = immediate_c
                else:
                    need = 6 if n > 60 else 7
                    buddy_pref = [u for u in buddies[t] if u in rest]
                    la_pool = buddy_pref[:min(need, len(rest))]
                    if len(la_pool) < min(need, len(rest)):
                        extra = preselect_by_tournament(seq + [t], [u for u in rest if u not in la_pool], min(need - len(la_pool), len(rest) - len(la_pool)), recent_k=3)
                        la_pool.extend(extra)
                    if not la_pool:
                        la_pool = rest[:min(need, len(rest))]
                    metric = min(seq_cost(seq + [t, u]) for u in la_pool)
                if metric < best_metric:
                    best_metric = metric
                    chosen_t = t

            # Update prefix-dominance with child
            new_cost = seq_cost(seq + [chosen_t])
            child_rem = set(remaining)
            child_rem.remove(chosen_t)
            sig_child = (frozenset(child_rem), tuple((seq + [chosen_t])[-3:]) if len(seq) + 1 >= 3 else tuple(seq + [chosen_t]))
            prev_child = prefix_dom.get(sig_child)
            if prev_child is None or new_cost < prev_child:
                prefix_dom[sig_child] = new_cost

            seq.append(chosen_t)
            remaining.remove(chosen_t)
            step += 1
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        if current_cost < best_cost:
            best_cost = current_cost
            best_seq = seq[:]
=======
        # 3b) Boundary-focused window permutations (small k) around worst violated adjacencies
        if n > 8:
            k_win = 6 if n >= 40 else 5
            def worst_violation_indices(sq, topm=2):
                pairs = []
                for i in range(len(sq) - 1):
                    a, b = sq[i], sq[i + 1]
                    pen = M[a][b] - M[b][a]
                    if pen > 0:
                        pairs.append((pen, i))
                pairs.sort(reverse=True)
                return [i for _, i in pairs[:topm]]

            viols = worst_violation_indices(seq, topm=2)
            for v in viols:
                start = max(0, min(v - k_win // 2, n - k_win))
                if start < 0 or start + k_win > n:
                    continue
                block = seq[start:start + k_win]
                base = seq[:start] + seq[start + k_win:]
                best_blk_cost = current_cost
                best_blk_seq = None
                # Limited random permutations
                tried = set()
                budget = 240 if k_win == 6 else 120
                attempts = 0
                while attempts < budget:
                    p = tuple(rng.sample(block, len(block)))
                    if p in tried:
                        continue
                    tried.add(p)
                    cand = base[:start] + list(p) + base[start:]
                    c = seq_cost(cand)
                    if c < best_blk_cost:
                        best_blk_cost = c
                        best_blk_seq = cand
                    attempts += 1
                if best_blk_seq is not None and best_blk_cost < current_cost:
                    seq = best_blk_seq
                    current_cost = best_blk_cost
                    break

        if current_cost < best_cost:
            best_cost = current_cost
            best_seq = seq[:]
>>>>>>> REPLACE

</DIFF>