# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy sampled transaction scheduler**
- **Implementation**: Implements a greedy cost-sampling scheduler: start at a random transaction, then at each step evaluate up to 10 randomly selected candidates via workload.get_opt_seq_cost and pick the minimum; sample_rate is fixed at 1.0 so only the greedy path runs. Includes robust repo-root path discovery; num_seqs and workload_size are unused, costs are recomputed redundantly, and randomness is unseeded.
- **Performance**: Combined score 2.65 across 3 workloads (300 transactions); correct and passes all validation tests with execution time recorded.
- **Feedback**: Greedy sampling trades optimality for speed; unseeded randomness can cause variability—seeding or multi-start runs could stabilize/improve scores. Removing redundant cost recomputations and honoring num_seqs/sample_rate would reduce overhead and enable broader exploration.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Beam-search transaction scheduler with memoized costs**
- **Implementation**: Uses beam search with dynamic beam/branch sizing, memoized prefix cost evaluation, and multiple random restarts. Initializes the beam from sampled singletons and prunes to top unique prefixes at each depth to control breadth.
- **Performance**: Combined score 3.40; produced valid schedules for all three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Dynamic sizing and memoization reduced search overhead, while random restarts improved robustness; capped beam (≤32) and branch (≤24) factors kept runtime reasonable but can miss global optima due to stochastic pruning. Re-evaluating final schedules confirmed consistency of reported makespans.
**Program Identifier:** Generation 1 - Patch Name beam_search_with_memoized_costs - Correct Program: True

**Program Name: Beam + local search transaction scheduler**
- **Implementation**: Uses a beam search with memoized partial-cost evaluations (Workload.get_opt_seq_cost) and adaptive beam width (from num_seqs) plus sampled candidate expansions, followed by local improvements via adjacent swaps and sampled insertion. Includes robust repository path discovery to import simulator/workloads reliably.
- **Performance**: Achieved a combined score of 3.19 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Memoization and controlled branching reduce simulator calls and help meet the time budget, while local improvements further lower makespan beyond the beam result. Randomized starts and sampling introduce run-to-run variance without a fixed seed.
**Program Identifier:** Generation 2 - Patch Name beam_search_local_improve - Correct Program: True

**Program Name: Multi-start Greedy Scheduler with Lookahead and Local Search**
- **Implementation**: Uses a multi-start greedy constructor with full candidate evaluation, limited two-step lookahead, and a memoized cost cache. Final schedules are refined via adjacent-swap hill climbing and accept-if-better random insertions, with starts seeded from lowest-cost singletons.
- **Performance**: Combined score 3.40 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Memoization and lookahead improve selection quality and reduce redundant cost calls, while local search finds additional improvements after greedy construction. Runtime is mitigated by sampling and bounded local moves, though full candidate evaluation per step remains a potential bottleneck on larger instances.
**Program Identifier:** Generation 3 - Patch Name greedy_full_eval_beam_local - Correct Program: True

**Program Name: Tournament-ILS Transaction Scheduler**
- **Implementation**: Builds a pairwise preference matrix from O(n^2) length-1/2 simulations to score transactions and locally sort via tournament comparisons, then applies memoized true-cost refinement with one adjacent-swap pass, limited ruin-and-recreate (sampled insert positions), and sampled insertion moves; refinement budget scales with num_seqs. A cached evaluator avoids redundant simulator calls across candidates.
- **Performance**: Combined score 2.87 on 3 workloads (300 transactions); all validation tests passed.
- **Feedback**: Pairwise surrogate costs provided strong ordering signals and reduced expensive evaluations, with memoization further decreasing simulator calls. The constrained ILS budget (single true-cost pass and up to two ruin-and-recreate tries) likely caps peak optimality while keeping runtime controlled.
**Program Identifier:** Generation 4 - Patch Name pairwise_tournament_rank_ils - Correct Program: True

**Program Name: MCTS + VND Transaction Scheduler**
- **Implementation**: UCT-based MCTS over partial schedules with progressive widening, greedy-biased expansion, cost caching, and a transposition table; rollouts use limited lookahead with pruning and are followed by VND local search (adjacent swaps, insertions, small block moves). The final schedule is extracted via most-visited children with greedy fallback, and evaluated across three workloads.
- **Performance**: Combined score: 0.0; did not pass validation.
- **Feedback**: Failures likely stem from nondeterminism (no fixed RNG seed), heavy iteration budgets causing timeouts, and brittle repo path discovery; partial-cost reliance may also mismatch the simulator API. Seed the RNG, cap/scale iteration budgets, simplify imports to avoid filesystem probing, and verify partial-cost calls against the provided Workload interface.
**Program Identifier:** Generation 5 - Patch Name uct_mcts_vnd_scheduler - Correct Program: False

**Program Name: Hybrid Beam-GRASP Transaction Scheduler**
- **Implementation**: Alternates a beam search with shallow lookahead and a GRASP constructor, using adaptive beam/branch sizes scaled by N and a shared memoized cost cache under a 0.35s per-workload time budget. A local search phase (adjacent swaps, random swaps, sampled insertions) refines each constructed sequence.
- **Performance**: Achieved combined score 1.56 on 3 workloads (300 transactions) within the time budget, and passed all validation tests.
- **Feedback**: The hybrid construction plus local improvement consistently finds low-makespan schedules under tight time constraints, aided by caching and adaptive sampling. Beam truncation with greedy completion can occur when the budget is tight, but outputs remain valid.
**Program Identifier:** Generation 6 - Patch Name beam_grasp_ils_hybrid - Correct Program: True

**Program Name: Multi-start Greedy VNS Transaction Scheduler**
- **Implementation**: Uses a memoized partial-sequence evaluator with multi-start greedy construction (limited lookahead) and Variable Neighborhood Search combining adjacent swaps, sampled relocations, and light ruin-and-recreate; seeding is diversified via singleton-cost rankings and budgets adapt to problem size. Includes adaptive candidate sampling and restart strategies to control simulator calls and runtime.
- **Performance**: Combined score 3.24 across three workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization significantly cuts simulator evaluations, enabling stronger local search within the given budget, while adaptive sampling and restrained ruin-and-recreate maintain good makespan-quality/runtime trade-offs. Time-based RNG seeding yields non-deterministic results across runs.
**Program Identifier:** Generation 7 - Patch Name greedy_lookahead_rr_vns - Correct Program: True

**Program Name: Marginal-Cost LNS Transaction Scheduler**
- **Implementation**: Employs a marginal-cost-guided LNS: a lazy candidate-pool greedy constructor with limited lookahead builds seeds, a global cost cache accelerates evals, adjacent-swap hill-climb cleans up, and hot windows (chosen via prefix marginals) are reordered using budgeted permutation enumeration/sampling; targeted relocate moves, multi-start seeding, and final random insertions provide additional refinement.
- **Performance**: Achieved a combined score of 3.18 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Evaluation indicates robust correctness and effective heuristic improvements from caching and windowed LNS/relocate moves; the score suggests remaining headroom, potentially addressable via adaptive pool/window sizes or dynamic permutation budgets.
**Program Identifier:** Generation 8 - Patch Name marginal_lns_pool - Correct Program: True

**Program Name: Tournament-Guided Greedy VNS Scheduler**
- **Implementation**: Uses pairwise-tournament-guided greedy construction with limited lookahead and a global memoized cost cache. Precomputes singleton/pairwise costs to form preference margins, applies multi-start seeding, and refines schedules via VNS (tournament bubble cleanup, adjacent swaps, relocations, non-adjacent swaps, and ruin-and-recreate).
- **Performance**: Achieved combined score 3.12 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Precomputing pairwise preferences and caching partial evaluations effectively cut simulator calls and guided the search toward low-conflict orderings. Multi-start plus VNS consistently improved makespan, and size-aware budgeting maintained stable performance across varying workload complexities.
**Program Identifier:** Generation 9 - Patch Name pairwise_guided_greedy_vns - Correct Program: True

**Program Name: Preference-Guided Beam Search Scheduler**
- **Implementation**: Uses a memoized cost oracle and a sampled pairwise preference model to compute soft precedence weights, guiding a time-bounded beam search scored by true cost plus penalty with shallow lookahead and adaptive beam/branch sizes. A multi-pass LocalRefiner fixes high-weight violations, then performs adjacent swaps, random insertions, and long swaps, with a SchedulerEngine allocating time across preference building, construction, and refinement per workload size.
- **Performance**: Achieved a combined score of 2.04 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests within the ~0.75s/workload budget.
- **Feedback**: Preference sampling and cost memoization effectively reduce search overhead, while lookahead and violation-guided refinement yield consistent makespan improvements. Dynamic scaling and ALNS-style moves aid solution quality, though the modest score indicates potential gains from deeper lookahead or broader restart strategies under the same time budget.
**Program Identifier:** Generation 10 - Patch Name pref_beam_alns - Correct Program: True

**Program Name: Beam search scheduler with caching and refinement**
- **Implementation**: Time-bounded beam search using marginal-cost ordering and shallow lookahead, with shared memoization caches (cost/delta), incumbent-based pruning, greedy completion, and a local improvement pass (adjacent swaps plus random insertions). Beam/branch widths scale with workload size and multiple restarts run within the budget.
- **Performance**: Achieved combined score 1.93 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and marginal-cost ordering reduce redundant evaluations and focus exploration, while shallow lookahead and greedy completion tighten pruning against the incumbent. The lightweight local refinement yields incremental gains without exceeding the per-workload time budget.
**Program Identifier:** Generation 11 - Patch Name beam_astar_delta_local - Correct Program: True

**Program Name: A*-beam scheduler with memoized delta costs**
- **Implementation**: Uses an A*-guided beam search with delta-based candidate ordering, greedy two-step lookahead completion, and local polishing (adjacent swaps and sampled insertions). A shared CostOracle memoizes cost and marginal deltas with FIFO-bounded caches, plus multi-profile restarts and adaptive beam/branching from num_seqs.
- **Performance**: Combined score to maximize: 0.0; failed all validation tests.
- **Feedback**: Time-salted RNG seeds and brittle repository path discovery undermine determinism and portability, likely contributing to test failures. The max-singleton lower bound used as f=max(g,h) is not clearly admissible for the remaining cost, risking incorrect pruning and invalid results; additionally, the “partial sampling” branches are no-ops, reducing intended speedups.
**Program Identifier:** Generation 12 - Patch Name astar_beam_lns_scheduler - Correct Program: False

**Program Name: A*-guided Beam + Local Search Scheduler**
- **Implementation**: Uses an A*-guided beam search with cached sequence costs and marginal deltas, a singleton-cost lower bound, diversified seeding, candidate sampling, two-step lookahead, periodic greedy completions, and multi-restart local search (adjacent swaps and relocations) with shared caches and deterministic RNG. Includes repo-root probing to import external simulator/workloads and aggregates makespan across three workloads.
- **Performance**: Combined score 0.0; the program failed validation tests.
- **Feedback**: Likely failure stems from brittle external path discovery/imports and/or oversized beam/branch settings causing timeouts; the singleton-based lower bound may be too weak to prune effectively. Additionally, ‘workload_size’ is unused and restarts share the same RNG stream, reducing diversity and potential solution quality.
**Program Identifier:** Generation 13 - Patch Name beam_astar_delta_vns - Correct Program: False

**Program Name: A*-guided beam scheduler with local refinement**
- **Implementation**: Uses an A*-style marginal-cost beam search with shared cost/delta caches, lightweight lookahead, incumbent pruning, greedy completion, and a bounded local improvement phase (adjacent swaps and limited insertions) under a 0.60s per-workload time budget and deterministic multi-mode restarts. It also includes custom repository path discovery and sys.path injection to import the simulator and workloads.
- **Performance**: Combined score 0.0; the program is marked incorrect and fails validation tests.
- **Feedback**: Fragile import path discovery and strict time budgeting likely caused failures or fallback to low-quality/random schedules, leading to validation failure. The heuristic (max singleton as lower bound) and non-additive g-cost may misguide the beam/A* scoring, further hurting solution quality under tight time limits.
**Program Identifier:** Generation 14 - Patch Name astar_marginal_beam - Correct Program: False

**Program Name: Memoized Beam Search Transaction Scheduler**
- **Implementation**: Implements a time-bounded, dynamic-width beam search that ranks candidates by marginal cost with shallow lookahead, periodically greedily completes prefixes to tighten the incumbent, and deduplicates prefixes. Shared memoized cost caches span restarts, and a local improvement pass (adjacent swaps plus random insertions) refines the final sequence.
- **Performance**: Achieved a combined score of 2.48 across 3 workloads (300 transactions), passing all validation tests within the per-workload 0.55s budget.
- **Feedback**: Cache reuse and greedy completion reduce redundant evaluations and enable effective pruning under the tight time cap, improving schedule quality. Dynamic beam sizing and local refinement balance exploration and exploitation, though the strict 0.55s budget can limit the number of effective restarts on larger instances.
**Program Identifier:** Generation 15 - Patch Name precedence_guided_beam_with_lookahead_and_local_refine - Correct Program: True

**Program Name: Time-bounded memoized beam scheduler with local search**
- **Implementation**: Combines adaptive beam search with memoized marginal-cost evaluation and shallow lookahead under a strict time budget. Prefixes are greedily completed with incumbency pruning, then refined by adjacent swaps and sampled insertions across restarts.
- **Performance**: Achieved combined score 1.83 across 3 workloads (300 transactions); schedules are valid and all validation tests pass.
- **Feedback**: Caching of full sequence costs and prefix-extension pairs reduces simulator calls and enables near real-time search, yielding strong makespan within tight budgets. Randomized candidate sampling and restarts introduce variability but help escape local minima; ext_cost recomputes full costs rather than true deltas, which may cap scalability on larger N.
**Program Identifier:** Generation 16 - Patch Name beam_marginal_memo - Correct Program: True

**Program Name: Beam A*-guided Transaction Scheduler**
- **Implementation**: Implements beam search with A*-style lower bounds, marginal-cost ordering, shallow lookahead, and greedy multi-prefix completion; shared memoized cost/extension caches across restarts and precomputed singleton costs reduce evaluation overhead. A post-beam local-improvement phase (adjacent swaps, sliding-window insertions, bounded random insertions) refines schedules, with dynamic beam/branch sizing and a 0.55s/workload time budget.
- **Performance**: Combined score to maximize: 2.28; produced valid schedules for 3 workloads (300 transactions) within the time budget and passed all validation tests.
- **Feedback**: Lower-bound pruning plus memoization cut redundant evaluations and accelerate convergence, while sliding-window refinement improves makespan beyond greedy completion. Time-bounded restarts and incumbent tightening via greedy finishes yield robust results, with minor variability due to randomized sampling.
**Program Identifier:** Generation 17 - Patch Name a_star_lb_beam_and_window_local - Correct Program: True

**Program Name: Tournament-Guided Beam Search with VNS for Scheduling**
- **Implementation**: Builds a tournament preference matrix from memoized singleton/pairwise costs and runs a beam search with lookahead, tournament-based candidate preselection, diverse starts, and state deduplication. A VNS post-optimizer applies tournament bubble passes, adjacent swaps, sampled 2-opt, relocations, and ruin-and-recreate, leveraging caching to limit simulator calls.
- **Performance**: Achieved a combined score of 3.41 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Memoization and tournament-guided pruning effectively balance exploration and evaluation cost, yielding strong schedules with a modest beam width. Local VNS refinements reliably improve beam outputs; tuning beam and candidate parameters may further boost results on conflict-heavy workloads.
**Program Identifier:** Generation 18 - Patch Name tournament_guided_beam_vns - Correct Program: True

**Program Name: A*-Guided Beam Scheduler with Greedy Refinement**
- **Implementation**: Implements a time-budgeted A*-guided beam search using marginal-cost ordering, singleton lower-bound pruning, shallow lookahead, and shared memoized cost caches across restarts with dynamic beam/branch sizing. Beam prefixes are greedily completed to tighten the incumbent and then locally refined via adjacent swaps, insertions, and sparse long swaps.
- **Performance**: Achieved combined score 2.07 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Shared caches and LB pruning reduce cost evaluations and help maintain quality under the 0.55s/workload budget; dynamic beam/branching and periodic greedy completion quickly establish strong incumbents. Local refinement yields modest extra gains, but results remain somewhat sensitive to randomness and tight time limits.
**Program Identifier:** Generation 19 - Patch Name a_star_lb_prune_and_multi_finish - Correct Program: True

**Program Name: MCTS+LNS Conflict-Aware Txn Scheduler**
- **Implementation**: Combines MCTS with epsilon-greedy, conflict-biased rollouts and a ruin-and-recreate LNS refinement under a strict time budget. Employs memoized cost caches (full, extension, pairwise, singleton) and sampled conflict weights to guide expansion, rollout, removal, reinsertion, and light swap polishing.
- **Performance**: Achieved a combined score of 0.0 and failed validation tests.
- **Feedback**: Repo path discovery via find_repo_root (using __file__ and hardcoded fallbacks) is brittle and likely caused import/runtime failures; nondeterminism (no seeding) and tight time budgets can yield inconsistent or weak schedules, triggering fallbacks. Stabilize imports, add deterministic seeding, and reassess time allocation to improve robustness and pass validations.
**Program Identifier:** Generation 20 - Patch Name mcts_lns_hybrid - Correct Program: False

**Program Name: Tournament-guided beam search with VNS refinement**
- **Implementation**: Uses a memoized partial evaluator with precomputed singleton/pairwise costs to build preference margins, then runs a multi-restart beam search with incumbent pruning, buddy-list lookahead, and tournament-based candidate preselection. A local improvement phase applies violation-focused adjacent swaps, sampled 2-opt, relocate moves, and ruin-and-recreate; RNG is seeded for determinism and repository path resolution is handled via a custom finder.
- **Performance**: Combined score: 0.0; the program failed validation tests.
- **Feedback**: Failures likely stem from brittle repo path detection or reliance on partial-sequence evaluation (get_opt_seq_cost) that may not match the expected API, leading to incorrect results. Aggressive pruning and heavy O(n^2) precomputation may also hurt robustness/performance on some workloads.
**Program Identifier:** Generation 21 - Patch Name beam_multirestart_incumbent_buddies - Correct Program: False

**Program Name: Lookahead Greedy TXN Scheduler with Local Search**
- **Implementation**: Implements a time-bounded, memoized greedy constructor with restricted candidate lists and two-step lookahead, multi-start seeding from best singletons plus random seeds, and a local search phase (adjacent swaps and random insertions). Uses caching of sequence and extension costs and attempts auto-discovery of import paths.
- **Performance**: Combined score to maximize: 0.0; failed validation.
- **Feedback**: Likely failures stem from unseeded randomness and time-based control causing nondeterministic outputs, and brittle path-hacking for imports that may break in the evaluator. Fix imports, seed the RNG, and replace time-based limits with deterministic iteration bounds to satisfy validation.
**Program Identifier:** Generation 22 - Patch Name memoized_lookahead_greedy_ils - Correct Program: False

**Program Name: Greedy-VNS Transaction Scheduler with Adaptive Lookahead**
- **Implementation**: Multi-start greedy construction (10 restarts) with deterministic per-workload RNG, memoized sequence-costs, incumbent pruning, and adaptive lookahead over top candidates; followed by VNS-style local improvement (adjacent/non-adjacent swaps, insertion, targeted high-marginal relocations, and light ruin-and-recreate with greedy reinsertion). Robust repo-root discovery and seeding ensure reproducibility and stable imports.
- **Performance**: Achieved a combined score of 3.40 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Incumbent pruning and caching reduce redundant evaluations, while adaptive lookahead and targeted relocations improve makespan quality; deterministic seeding yields consistent, repeatable outcomes. The balance of randomized restarts with focused local refinements provides strong correctness with dependable performance.
**Program Identifier:** Generation 23 - Patch Name none - Correct Program: True

**Program Name: Beam-guided memoized transaction scheduler**
- **Implementation**: Uses beam search with adaptive beam/branching, one-step lookahead, and early incumbent tightening, supported by memoized prefix/extension costs. Completes prefixes via greedy marginal-cost selection, then applies local refinement (adjacent swaps and random insertions) with multiple restarts under a per-workload time budget (0.65s).
- **Performance**: Combined score to maximize: 2.02 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests within the set time budget.
- **Feedback**: Caching and marginal-cost lookahead improved pruning and reduced expensive evaluations; restarts enhanced exploration. The shallow lookahead and fixed time cap likely cap peak quality for larger N but delivered consistent, timely solutions here.
**Program Identifier:** Generation 24 - Patch Name beam_memo_local_refine - Correct Program: True

**Program Name: Cluster-guided MCTS Transaction Scheduler**
- **Implementation**: Uses MCTS with UCT, memoized cost calls, pairwise cost matrix (M), W-margins, tournament ordering, conflict clustering (|W| 70th percentile), buddy lists, W/cluster-guided rollouts, incumbent pruning via prefix “lower bounds,” multi-restarts, and a final adjacent-swap polish. Path bootstrapping attempts to locate the example repo dynamically before importing workloads/simulator.
- **Performance**: Combined score 0.0; fails validation tests and yields incorrect results.
- **Feedback**: Reliance on get_opt_seq_cost for partial prefixes (used for lb, M, W) likely violates simulator assumptions, making pruning unsafe and schedules invalid. Heavy O(n^2) precomputation of M/W contradicts the intended “few simulator calls” design and may hurt runtime; ensure valid lower bounds or restrict to full-sequence evaluations and harden path discovery to pass tests.
**Program Identifier:** Generation 25 - Patch Name mcts_clustered_ucb - Correct Program: False

**Program Name: Tournament beam search with VNS refinement**
- **Implementation**: Builds singleton/pairwise cost matrices to derive a tournament preference order, then runs a deterministic multi-restart beam search with memoized evaluations, incumbent pruning, buddy-guided lookahead, and periodic greedy completions; the best sequence is refined by a VNS applying tournament cleanups, swaps, relocations, and ruin-and-recreate. It uses a global cost cache, diverse seeded starts, and custom repo-path discovery to load workloads.
- **Performance**: Combined score 0.0; the program fails all validation tests.
- **Feedback**: The algorithm evaluates partial prefixes with get_opt_seq_cost (e.g., [i], [i, j]), which may violate the simulator’s contract and lead to invalid costs/schedules; ensure pruning/metrics use APIs that support prefixes or evaluate only full permutations. The custom path probing is brittle in test environments—stabilize imports and add schedule validity checks before reporting results.
**Program Identifier:** Generation 26 - Patch Name none - Correct Program: False

**Program Name: GRASP Micro-Beam Transaction Scheduler**
- **Implementation**: Hybrid GRASP with randomized greedy RCL and micro-beam intensification, time-bounded multi-starts, and memoized cost/extension caches for true marginal-cost evaluation. Seeds from top singletons/pairs with adaptive candidate pools and RCL by depth, followed by local refinement (adjacent swaps, 2-opt, insertions) and permutation repair.
- **Performance**: Combined score 2.43 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Caching and adaptive sampling cut evaluations and stabilized quality under a tight ~0.36s+N-scaled budget; micro-beam and local search consistently improved greedy builds. Additional time could be leveraged by deeper beams or richer neighborhoods for further gains.
**Program Identifier:** Generation 27 - Patch Name grasp_beam_hybrid_v1 - Correct Program: True

**Program Name: Tournament-guided VNS Transaction Scheduler**
- **Implementation**: Builds schedules via tournament-guided greedy with buddy-list lookahead over memoized simulator costs, using precomputed singleton/pairwise matrices and preference margins. Refines solutions with a VNS combining tournament cleanup, adjacent/non-adjacent swaps, targeted relocations, and light ruin‑and‑recreate across multi-start seeds with deterministic RNG.
- **Performance**: Achieved combined score 3.03 on three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Pairwise-preference seeding plus memoized evaluations effectively reduce simulator calls and focus search, while VNS post-optimization further lowers makespan. Deterministic runs and diversified restarts produce stable, high-quality schedules under modest exploration budgets.
**Program Identifier:** Generation 28 - Patch Name tournament_guided_buddy_lookahead - Correct Program: True

**Program Name: Deterministic Beam Search with VNS for Txn Scheduling**
- **Implementation**: Uses sampled pairwise preference margins to build conflict clusters and buddy lists, then runs a deterministic multi-restart beam search with shared memoization and greedy completions, followed by VNS local refinement guided by a surrogate boundary-margin score. Caches sequence and extension costs, caps pairwise probes, and allocates a fixed per-workload time budget to bound runtime.
- **Performance**: Combined score to maximize: 2.30 on 3 workloads (300 transactions); program is correct and passes all validation tests.
- **Feedback**: Deterministic seeding and caching stabilized quality and reduced evaluations under tight time budgets; clustering and buddy-biased candidate pools effectively narrowed the search to yield good schedules quickly. Note: the num_seqs parameter is unused, and the probe cap/weak LB may trade optimality for speed on larger instances.
**Program Identifier:** Generation 29 - Patch Name clustered_beam_vns - Correct Program: True

**Program Name: Beam-A* Transaction Scheduler with Greedy Refinement**
- **Implementation**: Uses beam search with memoized prefix/extension costs, singleton-based A* lower bounds, shallow lookahead ranking, and greedy completion to tighten incumbents, followed by a lightweight local improvement (adjacent swaps and random insertions). Parameters adapt to problem size (beam/branch factors), unique-prefix deduplication is enforced, and a 0.40s time budget with 1–3 restarts bounds runtime.
- **Performance**: Combined score 2.49 across 3 workloads (300 transactions); produces valid schedules and passes all validation tests.
- **Feedback**: Effective caching and pruning reduce evaluations, while greedy finishing frequently improves incumbents under the tight budget. The strict time cap and shallow local search can cap optimality, and unseeded randomness may introduce run-to-run variance.
**Program Identifier:** Generation 30 - Patch Name beam_greedy_prune_local - Correct Program: True

**Program Name: Tournament beam search with VNS refinement**
- **Implementation**: Uses a tournament-guided, incumbent-pruned beam search with lookahead, backed by memoized cost evaluation and precomputed singleton/pairwise costs to derive preference margins. Refines candidates via a robust VNS local search (bubble-based tournament cleanup, adjacent/non-adjacent swaps, relocations, targeted marginal relocations, and a light ruin-and-recreate), integrated with a Workload simulator after repo-path discovery.
- **Performance**: Achieved a combined score of 3.75 over 3 workloads (261 transactions), producing schedules for each workload.
- **Feedback**: The program is incorrect and fails validation tests; likely risk points include reliance on partial-sequence cost evaluations during search and the possibility of returning/pruning to incomplete or invalid permutations. Add strict permutation completion/validation and align evaluator semantics for partial sequences to improve correctness.
**Program Identifier:** Generation 31 - Patch Name tournament_beam_vns_pruned - Correct Program: False

**Program Name: Buddy-guided beam search with VNS for txn scheduling**
- **Implementation**: Implements a two-phase, time-bounded buddy-guided beam search with prefix-dominance and incumbent/singleton-LB pruning, shallow lookahead, memoized cost evaluations, and greedy completion, followed by lightweight VNS (adjacent swaps and relocations) with deterministic portfolio restarts. Buddy lists are built from singleton-delta scoring to focus branching; safety checks repair permutations if needed.
- **Performance**: Combined score 2.09 across 3 workloads (300 transactions); all validations passed.
- **Feedback**: Buddy guidance and caching concentrate the search and cut evaluations, while greedy finishing and VNS provide incremental gains under the tight ~0.58s/workload budget. Deterministic seeding stabilizes results; note that some parameters (e.g., next_k) are unused and deeper exploration may be constrained by the time cap.
**Program Identifier:** Generation 32 - Patch Name buddy_beam_vns - Correct Program: True

**Program Name: Tournament-guided Greedy + LNS Scheduler**
- **Implementation**: Precomputes singleton/pairwise costs and tournament margins to drive a greedy constructor with buddy lookahead and a refreshable candidate pool, backed by a global cost cache. Improves via multi-start, adjacent swaps, boundary-focused LNS with capped permutations/relocate moves, then 2-opt and random insertions, with incumbent pruning.
- **Performance**: Achieved combined score 3.34 on 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Pairwise tournament guidance and buddy-based lookahead produce strong seeds that LNS refines effectively; caching significantly amortizes evaluation cost. Runtime is driven by cost evaluations and permutation sampling, but pool preselection, small windows (k≤7), and early termination keep it tractable.
**Program Identifier:** Generation 33 - Patch Name tournament_buddies_lns - Correct Program: True

**Program Name: Buddy-Guided Beam Search with VNS Scheduler**
- **Implementation**: Two-phase beam search driven by buddy lists, prefix-dominance pruning (local/global), shallow adaptive lookahead, and incumbent-based pruning, all under a 0.58s time budget. Uses cached cost/extension evaluations, greedy completions, and a lightweight VNS refinement (adjacent swaps, boundary repair via surrogate pair costs, and targeted relocations) with portfolio-based restarts.
- **Performance**: Achieved a combined score of 2.57 on 3 workloads (300 transactions), producing valid schedules under a 0.58s per-workload time budget.
- **Feedback**: Buddy-guided candidate pools and caching reduced evaluation overhead while improving search focus; prefix-dominance and incumbent pruning effectively cut the search space, and VNS yielded incremental post-optimization gains. Performance is sensitive to beam/branch settings and time budget, but the approach is robust and passes all validation tests.
**Program Identifier:** Generation 34 - Patch Name buddy_beam_prefix_dominance_vns_plus - Correct Program: True

**Program Name: Tournament-guided LNS Transaction Scheduler**
- **Implementation**: Uses a tournament-guided greedy constructor with buddy lookahead, backed by a global cost cache, precomputed singleton/pairwise costs (M) and preference margins (W). Multi-start seeding combines a beam search with dominance pruning (by remaining set and suffix) and greedy completion, followed by adjacent swaps, boundary-focused LNS over hot windows (marginal sums and violation boundaries), targeted relocations, 2-opt, and random insert polish; includes early pruning against the incumbent.
- **Performance**: Achieved a combined score of 3.47 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Tournament/buddy guidance and caching significantly reduced evaluation overhead and improved early choices, while LNS on high-impact windows delivered most of the final gains. Beam-seed quality and the num_seqs exploration budget were key levers for the makespan–time trade-off, with dominance checks aiding scalability.
**Program Identifier:** Generation 35 - Patch Name none - Correct Program: True

**Program Name: Tournament-guided beam search with VNS refinement**
- **Implementation**: Two-phase beam search seeded by tournament scores with precomputed singleton/pairwise costs to derive preference margins (W) and buddy lists, plus prefix-dominance pruning, adaptive lookahead, periodic greedy completions, and a VNS post-optimizer (bubble pass, adjacent swaps, sampled 2-opt, relocations, ruin-and-recreate). Memoized partial-sequence costs and deterministic RNG improve speed and stability.
- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Tournament-guided preselection and prefix-dominance pruning reduced simulator calls and tightened the beam, while periodic greedy completions and VNS yielded consistent final improvements. Pairwise precompute is O(n^2) overhead but is amortized by caching; deterministic seeding provided reproducible schedules.
**Program Identifier:** Generation 36 - Patch Name beam2phase_prefix_prune_vns - Correct Program: True

**Program Name: MCTS Transaction Scheduler with RAVE**
- **Implementation**: UCT-based Monte Carlo Tree Search with progressive widening and RAVE adjacency guidance, using transposition keys (remaining bitmask + 3-length suffix). It memoizes full and extension costs, builds buddy lists from sampled pairwise deltas, performs greedy rollouts with incumbent pruning, and applies light 2-opt/relocate refinement under a capped adaptive time budget.
- **Performance**: Achieved a combined score of 2.27 across 3 workloads (300 transactions) with valid schedules within the time budget.
- **Feedback**: Cost memoization, buddy-guided candidate ordering, and progressive widening reduced evaluations and stabilized search; RAVE improved early action scoring. Greedy rollouts plus local refinement consistently improved the incumbent, with modest final gains from the polishing phase.
**Program Identifier:** Generation 37 - Patch Name uct_mcts_scheduler - Correct Program: True

**Program Name: Tournament-guided merge with LNS scheduling**
- **Implementation**: Uses a sparse pairwise tournament (Copeland+margin strength) to rank transactions, then builds schedules via block-wise merge guided by memoized extension costs. Applies multi-start local search (adjacent swaps, limited 2-opt, and margin-guided ruin-and-recreate) under a ~0.62s per-workload time budget with aggressive cost caching.
- **Performance**: Achieved combined score 2.38 across 3 workloads (300 transactions), producing valid schedules within the time budget.
- **Feedback**: Tournament ranking plus cached extension costs yielded strong initial sequences while minimizing expensive evaluations; LNS refinements consistently improved makespan without exceeding the budget. The solution was robust (permutation repair included) and passed all validation tests.
**Program Identifier:** Generation 38 - Patch Name tournament_merge_lns - Correct Program: True

**Program Name: Buddy-Guided Beam Search Scheduler**
- **Implementation**: Dual-phase incumbent-seeded beam search with prefix-dominance pruning, buddy-biased candidate pools, depth-adaptive lookahead, greedy completion, and light VNS polish. Uses memoized cost evaluations, singleton-based lower bounds, multi-restarts with slight parameter perturbations, and a tight time budget scaled by N.
- **Performance**: Achieved combined score 2.03 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching, lower bounds, and dominance pruning reduce evaluations and keep runtime bounded, while buddy-guided candidates and greedy incumbent tightening improve quality within the budget. Multi-restart diversity and VNS yield incremental gains; the approach handled simple cases (e.g., workload 3 near-identity order) without degradation.
**Program Identifier:** Generation 39 - Patch Name dual_beam_incumbent_vns - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Tournament-guided construction with pairwise margins and buddies, backed by a unified cache, consistently yields top scores.
  - Current best: Tournament-guided LNS Transaction Scheduler (3.47). It precomputes singleton/pairwise costs M and margins W, builds buddy lists, and uses tournament-guided preselection against recent prefix items. This matches earlier high performers that also precomputed M/W: Tournament-guided beam search with VNS refinement (3.33) and Tournament-guided Greedy + LNS Scheduler (3.34).
- Beam-seeded multi-start with prefix-dominance and greedy completion improves seeds before LNS/VNS.
  - The best program adds a beam seed with dominance pruning keyed by (remaining set, short suffix) and greedily completes/promotes incumbents. Feedback explicitly cites “beam-seed quality and the num_seqs exploration budget” as key levers (3.47), edging out the similar Tournament-guided Greedy + LNS Scheduler (3.34) which relies more on greedy seeding.
- Boundary-focused LNS on hot windows delivers most of the final gains when paired with tournament/buddy guidance.
  - The best program targets windows selected by marginal sums and worst violated adjacencies (using M[a][b] - M[b][a]), exhaustively/sampled-permuted for k≤7 with capped budgets, then applies targeted relocations and light 2-opt/insert polish. This mirrors the effective LNS in Tournament-guided Greedy + LNS Scheduler (3.34) and improves over VNS-only variants.
- Disciplined memoization across all phases is a common denominator for strong results.
  - The current best uses a single cost_cache for eval_seq across precompute, greedy/beam, lookahead, and all local-search moves. Similar cache-centric designs underpin other correct high scorers: beam2phase_prefix_prune_vns (3.33) and tournament_buddies_lns (3.34).

## Ineffective Approaches
- Unsafe use of partial-sequence cost evaluations for pruning/selection leads to incorrect results despite high apparent scores.
  - Tournament beam search with VNS refinement (3.75, incorrect) likely pruned or returned invalid permutations based on partial-cost semantics. Earlier failures in prior rounds showed the same pattern (0.0 scores when prefix costs were misused as bounds).
- Overaggressive time caps with shallow local search limit optimality.
  - Beam-A* Transaction Scheduler with Greedy Refinement (2.49) runs under a strict ~0.40s budget, where shallow local search and brief greedy finishing cap improvements; similar constraints appear in Buddy-Guided Beam Search with VNS Scheduler (2.57) and Buddy-guided beam search with VNS for txn scheduling (2.09).
- Heavy beam-centric exploration without richer neighborhoods underperforms relative to tournament-guided LNS/VNS hybrids.
  - Buddy-Guided Beam Search Scheduler (2.03) and other beam-heavy variants trail the 3.33–3.47 band, indicating that bounded beam alone, even with memoization and light VNS, leaves value on the table.
- Nondeterministic control can introduce variance and fragility when combined with tight budgets.
  - Feedback for Beam-A* flags unseeded randomness as a variance source; although the current best is correct, its time-based seeding (time_ns XOR pid) is nondeterministic and can affect reproducibility under budget pressure.

## Implementation Insights
- What makes the current best effective:
  - Unified memoized evaluator: A single cost_cache backs all eval_seq calls, amortizing simulator calls across precompute (c1, M, W), greedy/beam selection, lookahead, and all LNS/VNS moves.
  - Tournament + buddy guidance localized to recent context: preselect_by_tournament scores candidates against the last recent_k=4 (3 in lookahead) prefix items using W margins; buddy_k adapts to n (6–8). This keeps candidate pools small and relevant.
  - Beam-seed with dominance/duplication control: dom keyed by (remaining frozenset, suffix up to 3) prunes dominated prefixes; local_seen prevents duplicate expansions; periodic greedy_complete upgrades incumbents, aligning with feedback that beam-seed quality drives gains (3.47).
  - Boundary-focused LNS with tight caps: Windows chosen by marginal sums and worst violations, full permutation for k≤6 and sampled up to 2000 tries for k=7; then targeted relocations from top-blame marginals and light 2-opt/random insert passes (≤60 tries each). This concentrates expensive evaluations where they matter.
- Concrete coding patterns reflected across high scorers:
  - Precompute M[i][j] and W margins once and reuse broadly in candidate ranking and boundary scoring (3.47, 3.34, 3.33).
  - Shallow lookahead over a preselected pool: lookahead_top≈3–4 with buddy/tournament pools (next_k≈5–8) tightens ranking while keeping evaluation counts low (3.47, 3.33).
  - State deduplication by prefix signature: using (tuple(prefix), remaining_set/suffix) keys to reduce redundant expansions in beam search (3.47, 3.33, 2.57).

## Performance Analysis
- Clear hierarchy of approaches:
  - Top tier: Tournament-guided LNS/beam hybrids at 3.47 (Tournament-guided LNS Transaction Scheduler) and 3.34–3.33 (Tournament-guided Greedy + LNS Scheduler; Tournament-guided beam search with VNS refinement). The additional beam-seed with dominance and incumbent pruning, plus boundary-focused LNS, lifts 3.34 to 3.47.
  - Mid tier: Beam-centric with memoization and light VNS/LNS at ~2.03–2.57 (Buddy-Guided Beam Search Scheduler 2.03; Buddy-guided beam search with VNS for txn scheduling 2.09; Buddy-Guided Beam Search with VNS Scheduler 2.57; Beam-A* 2.49). Tight budgets and lighter neighborhoods correlate with lower scores.
  - Alternatives: MCTS Transaction Scheduler with RAVE (2.27) and Tournament-guided merge with LNS (2.38) are competitive but below tournament+beam+LNS/VNS hybrids.
- Correctness discipline matters more than nominal search power:
  - The incorrect Tournament beam search with VNS refinement “scored” 3.75 but failed validation due to unsafe partial-cost reliance; correct tournament-beam+VNS variants still achieved 3.33–3.47 when evaluator semantics were aligned and permutation completion/validation enforced.
- Consistent correlations:
  - Pairwise tournament guidance + bounded lookahead + unified caching correlates with the 3.33–3.47 band.
  - Stricter time caps and shallower local search correlate with the 2.0–2.6 band, even when memoization and pruning are present.
  - Robust seed generation (beam-seed + greedy seeds) improves LNS starting points, reflected in the best program’s “beam-seed quality” feedback and its 3.47 edge over the similar 3.34/3.33 implementations.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Add a safe, incumbent-pruned two-phase beam inside beam_seed
   - Phase A (broad): beam=16, cand_per_expand=12, lookahead_top=4, next_k=6 up to depth ~0.4n, greedily complete the top 2 prefixes each depth to update incumbent as you already do. Phase B (focused): beam=10, cand_per_expand=8, lookahead_top=3, next_k=5; for each expanded child t, run a fast greedy_complete(seq+[t]) for the top 4 children and prune any whose full cost ≥ incumbent_cost; guarantee progress by always keeping the best child even if pruned. This extends the current beam’s strength with safe pruning (full-sequence bounds only), mirroring the beam-seed quality gains seen in top programs.

2. Promote prefix-dominance to a global map and apply it in the greedy constructor
   - Maintain a shared dom[(frozenset(remaining), tuple(prefix[-3:]))] = best_cost across both beam_seed and build_initial_sequence, and skip expansions that do not improve this key. In build_initial_sequence, before evaluating a candidate t, compute sig for seq+[t]; if cost ≥ dom[sig], skip; every 10 steps, greedily complete the current prefix to possibly raise a global incumbent and early-terminate if eval_seq(seq) ≥ incumbent. This directly leverages the dominance/duplication patterns that boosted beam quality in the best program and reduces redundant expansions in the greedy phase.

3. Strengthen LNS with ΔW-gated block neighborhoods (block-swap and block-reinsert)
   - At each LNS iteration, in addition to current window permutations and relocations, try: (a) block-swap two blocks of size 3–6 centered on the top-2 worst violated adjacencies (by M[a][b]-M[b][a]); (b) remove a hot block (size 4–6) and reinsert it at the top-3 positions predicted by local ΔW improvement. For each neighborhood, rank candidates by a cheap ΔW surrogate computed from W around edited indices, fully evaluate only the top 35–40% plus ~10% random; cap total move evals per LNS round to ~500–800. This adds non-local improvements that align with boundary-focused gains while keeping evaluation counts controlled.

4. Depth- and context-adaptive lookahead with anti-buddy filtering
   - In both the greedy builder and beam expansion, shrink recent_k with depth (early: 5, mid: 4, late: 3) and set lookahead_top/next_k to (early: 4/6, mid: 3/5, late: 2/4). Add an anti-buddy filter: when the last placed x strongly “dislikes” t (W[x][t] > 0 and in the top quartile), deprioritize t unless its immediate eval beats the best candidate by ≥1% to allow escapes. For the single best immediate child at each step, probe a third step using buddies and tournament preselection (k=4) to refine ranking; this keeps pools small and accurate per the successful tournament+buddy pattern.

5. Deterministic restart portfolio with shared memo and LNS on the top two
   - Run 3 restarts with rng seeds rng = Random(1729 + n*31 + r) to remove variance, sharing the same cost_cache/M/W. Use parameter perturbations per restart: (beam,cand,lookahead_top,next_k,recent_k) ∈ {(16,12,4,6,5), (12,14,3,5,4), (10,10,3,4,3)}; perform full LNS only on the best two completed schedules. This exploits the cache-centric design to broaden exploration cheaply and mirrors the robustness gains observed when beam-seed quality and exploration budget were emphasized.