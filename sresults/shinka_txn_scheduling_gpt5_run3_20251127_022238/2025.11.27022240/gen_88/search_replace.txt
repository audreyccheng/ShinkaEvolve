<edit_name>
incumbent_prune_rng_anchor
</edit_name>
<edit_description>
I introduce four focused improvements to lower makespan without increasing runtime, making the search more deterministic and productive:

1) Deterministic RNG: Add a fixed-seed RNG and replace non-deterministic random.* calls with rng.* within the evolved block. This stabilizes outcomes, improves reproducibility, and reduces variance across restarts.

2) Stronger greedy completion: Enrich greedy candidate pools with low-singleton transactions in addition to buddies and random fill. This reduces poor choices when a buddy is unavailable and yields better completions and incumbents earlier.

3) Tighter beam pruning: After greedy probing a child, prune the child if its adjusted lookahead cost is already â‰¥ incumbent. This reduces wasted expansions, allowing deeper focus on promising prefixes, and improves schedule quality within the same time budget.

4) Additional anchored block reinsertion in local search: After the block-swap pass, add a targeted anchored block reinsert move around the worst boundary, inserting the entire block at top-ranked positions near the hotspot (plus a few random spots). This addresses hard boundary conflicts more effectively than element-by-element reinsertion and improves final makespan.

Together, these changes align with conflict-aware scheduling principles: stabilize randomness, improve candidate selection, prune aggressively using incumbents, and use a stronger locality move to fix worst adjacencies. The code remains within the time budget and compiles cleanly.
</edit_description>
<diff>
<<<<<<< SEARCH
    N = workload.num_txns
    start_time = time.time()
    # Budget chosen to balance quality and runtime for combined score
    base_budget = 0.58
    time_budget_sec = base_budget
=======
    N = workload.num_txns
    start_time = time.time()
    # Budget chosen to balance quality and runtime for combined score
    base_budget = 0.58
    time_budget_sec = base_budget
    rng = random.Random(1729 + 31 * N)
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                cand_pool.extend(random.sample([x for x in all_txns if x != t], min(extra, max(10, N // 5))))
=======
                cand_pool.extend(rng.sample([x for x in all_txns if x != t], min(extra, max(10, N // 5))))
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
            # Prefer buddies of last
            if last is not None and last in buddies:
                for u in buddies[last]:
                    if u in rem:
                        cand_pool.append(u)

            # Fill with random sample for diversity
            need = max(0, branch_k - len(cand_pool))
            if need > 0:
                others = [x for x in rem_list if x not in cand_pool]
                if len(others) > need:
                    cand_pool.extend(random.sample(others, need))
                else:
                    cand_pool.extend(others)

            if not cand_pool:
                cand_pool = rem_list if len(rem_list) <= branch_k else random.sample(rem_list, branch_k)
=======
            # Prefer buddies of last
            if last is not None and last in buddies:
                for u in buddies[last]:
                    if u in rem:
                        cand_pool.append(u)

            # Also include a few low-singleton txns
            low_single = sorted(rem_list, key=lambda t: singleton_cost.get(t, float('inf')))[:min(5, len(rem_list))]
            for u in low_single:
                if u not in cand_pool:
                    cand_pool.append(u)

            # Fill with random sample for diversity
            need = max(0, branch_k - len(cand_pool))
            if need > 0:
                others = [x for x in rem_list if x not in cand_pool]
                if len(others) > need:
                    cand_pool.extend(rng.sample(others, need))
                else:
                    cand_pool.extend(others)

            if not cand_pool:
                cand_pool = rem_list if len(rem_list) <= branch_k else rng.sample(rem_list, branch_k)
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
        if not beam:
            seq = all_txns_local[:]
            random.shuffle(seq)
            return eval_seq_cost(seq), seq, incumbent_cost, None
=======
        if not beam:
            seq = all_txns_local[:]
            rng.shuffle(seq)
            return eval_seq_cost(seq), seq, incumbent_cost, None
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                if need > 0:
                    others = [x for x in rem_list if x not in cand_pool]
                    add = min(len(others), need)
                    if add > 0:
                        cand_pool.extend(random.sample(others, add))
=======
                if need > 0:
                    others = [x for x in rem_list if x not in cand_pool]
                    add = min(len(others), need)
                    if add > 0:
                        cand_pool.extend(rng.sample(others, add))
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                if not cand_pool:
                    cand_pool = rem_list if len(rem_list) <= branch_factor * 2 else random.sample(rem_list, branch_factor * 2)
=======
                if not cand_pool:
                    cand_pool = rem_list if len(rem_list) <= branch_factor * 2 else rng.sample(rem_list, branch_factor * 2)
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                        if len(la_pool) > lookahead_top:
                            la_pool = random.sample(la_pool, lookahead_top)
=======
                        if len(la_pool) > lookahead_top:
                            la_pool = rng.sample(la_pool, lookahead_top)
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                for _delta, la_score, ec, cand in top:
                    new_seq = seq + [cand]
                    new_rem = rem.copy()
                    new_rem.remove(cand)
                    # Child LB pruning
                    if lb_singleton(ec, new_rem) >= best_full_cost:
                        continue
                    # Greedy probe for first few children to update incumbent and refine ranking
                    if idx_child < probe_k and time_left():
                        g_cost, g_seq = greedy_finish(new_seq, new_rem, branch_k=max(6, N // 12), incumbent=best_full_cost)
                        if len(g_seq) == N and g_cost < best_full_cost:
                            best_full_cost, best_full_seq = g_cost, g_seq
                        la_score = min(la_score, g_cost)
                    idx_child += 1
                    new_beam.append((ec, new_seq, new_rem, la_score))
=======
                for _delta, la_score, ec, cand in top:
                    new_seq = seq + [cand]
                    new_rem = rem.copy()
                    new_rem.remove(cand)
                    # Child LB pruning
                    if lb_singleton(ec, new_rem) >= best_full_cost:
                        continue
                    # Greedy probe for first few children to update incumbent and refine ranking
                    if idx_child < probe_k and time_left():
                        g_cost, g_seq = greedy_finish(new_seq, new_rem, branch_k=max(6, N // 12), incumbent=best_full_cost)
                        if len(g_seq) == N and g_cost < best_full_cost:
                            best_full_cost, best_full_seq = g_cost, g_seq
                        la_score = min(la_score, g_cost)
                    idx_child += 1
                    # Prune child if its adjusted lookahead is not better than the incumbent
                    if la_score >= best_full_cost:
                        continue
                    new_beam.append((ec, new_seq, new_rem, la_score))
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
        if best_full_seq is None:
            seq = all_txns_local[:]
            random.shuffle(seq)
            best_full_seq = seq
            best_full_cost = eval_seq_cost(seq)
=======
        if best_full_seq is None:
            seq = all_txns_local[:]
            rng.shuffle(seq)
            best_full_seq = seq
            best_full_cost = eval_seq_cost(seq)
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
                    extra.add(random.randrange(len(seq_build) + 1))
=======
                    extra.add(rng.randrange(len(seq_build) + 1))
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
        # Block-swap neighborhood around top-2 worst adjacencies (limited tries)
        if time_left():
            n = len(best_seq)
            if n >= 8:
                worst = []
                for i in range(n - 1):
                    if not time_left():
                        break
                    worst.append((pair_pref(best_seq[i], best_seq[i + 1]), i))
                worst.sort(key=lambda x: x[0], reverse=True)
                tries = 0
                for a in range(min(2, len(worst))):
                    if not time_left():
                        break
                    for b in range(a + 1, min(4, len(worst))):
                        if not time_left():
                            break
                        i = worst[a][1]
                        j = worst[b][1]
                        block = min(6, max(3, n // 40))
                        si = max(0, min(i - block // 2, n - block))
                        sj = max(0, min(j - block // 2, n - block))
                        # ensure non-overlap
                        if abs(si - sj) < block:
                            continue
                        cand = best_seq[:]
                        # ensure si < sj
                        if si > sj:
                            si, sj = sj, si
                        block_i = cand[si:si + block]
                        block_j = cand[sj:sj + block]
                        mid = cand[si + block:sj]
                        cand2 = cand[:si] + block_j + mid + block_i + cand[sj + block:]
                        c = eval_seq_cost(cand2)
                        tries += 1
                        if c < best_cost:
                            best_cost = c
                            best_seq = cand2
                    if tries >= 4:
                        break

        # Targeted relocations with small window (reduced trials, keep diversity)
        trials = 45
=======
        # Block-swap neighborhood around top-2 worst adjacencies (limited tries)
        if time_left():
            n = len(best_seq)
            if n >= 8:
                worst = []
                for i in range(n - 1):
                    if not time_left():
                        break
                    worst.append((pair_pref(best_seq[i], best_seq[i + 1]), i))
                worst.sort(key=lambda x: x[0], reverse=True)
                tries = 0
                for a in range(min(2, len(worst))):
                    if not time_left():
                        break
                    for b in range(a + 1, min(4, len(worst))):
                        if not time_left():
                            break
                        i = worst[a][1]
                        j = worst[b][1]
                        block = min(6, max(3, n // 40))
                        si = max(0, min(i - block // 2, n - block))
                        sj = max(0, min(j - block // 2, n - block))
                        # ensure non-overlap
                        if abs(si - sj) < block:
                            continue
                        cand = best_seq[:]
                        # ensure si < sj
                        if si > sj:
                            si, sj = sj, si
                        block_i = cand[si:si + block]
                        block_j = cand[sj:sj + block]
                        mid = cand[si + block:sj]
                        cand2 = cand[:si] + block_j + mid + block_i + cand[sj + block:]
                        c = eval_seq_cost(cand2)
                        tries += 1
                        if c < best_cost:
                            best_cost = c
                            best_seq = cand2
                    if tries >= 4:
                        break

        # Anchored block reinsert around worst boundary (move entire block to best positions)
        if time_left():
            n = len(best_seq)
            if n >= 7:
                # identify worst boundary again
                worst_idx = -1
                worst_val = -float('inf')
                for i in range(n - 1):
                    if not time_left():
                        break
                    v = pair_pref(best_seq[i], best_seq[i + 1])
                    if v > worst_val:
                        worst_val = v
                        worst_idx = i
                if worst_idx >= 0:
                    block_size = min(6, max(4, n // 28))
                    start = max(0, min(worst_idx + 1 - block_size // 2, n - block_size))
                    block = best_seq[start:start + block_size]
                    remain = best_seq[:start] + best_seq[start + block_size:]
                    # candidate positions near the boundary and a few random
                    positions = list(range(max(0, worst_idx - 3), min(len(remain) + 1, worst_idx + 4)))
                    extra = set()
                    limit = min(6, len(remain) + 1)
                    while len(extra) < limit and time_left():
                        extra.add(rng.randrange(len(remain) + 1))
                    for p in extra:
                        if p not in positions:
                            positions.append(p)
                    best_local = best_cost
                    best_candidate = None
                    for p in positions:
                        cand = remain[:]
                        for off, x in enumerate(block):
                            cand.insert(p + off, x)
                        c = eval_seq_cost(cand)
                        if c < best_local:
                            best_local = c
                            best_candidate = cand
                    if best_candidate is not None and best_local < best_cost:
                        best_cost, best_seq = best_local, best_candidate

        # Targeted relocations with small window (reduced trials, keep diversity)
        trials = 45
>>>>>>> REPLACE

</diff>
<diff>
<<<<<<< SEARCH
            i = random.randrange(n)
            j = random.randrange(n)
=======
            i = rng.randrange(n)
            j = rng.randrange(n)
>>>>>>> REPLACE

</diff>