<NAME>
incumbent_aware_beam_prefix_dom_antibuddy_lns_bubble
</NAME>

<DESCRIPTION>
I introduce four targeted improvements that align with high-performing patterns seen in prior generations and literature on sequencing with pairwise conflicts:

1) Shared prefix-dominance across construction strategies: Add a global prefix_dom cache keyed by (remaining set, suffix<=3) to prune dominated prefixes in both the greedy constructor and the beam search, reducing redundant exploration and guiding toward better schedules.

2) Incumbent-aware greedy completion at child expansion within the beam: For the top children of each beam node, run a fast greedy completion and prune the child if the completed cost is not better than the incumbent. This aggressively tightens the incumbent and prunes weak branches early.

3) Depth-adaptive lookahead and anti-buddy filtering: Compute quartile cutoffs on W to gate strongly disfavored immediate followers unless they are near-best by immediate metric. Also adapt lookahead depth and next-k candidates by depth to balance exploration and cost.

4) Boundary-bubble in LNS: Add a cheap tournament_bubble pass at each LNS iteration to quickly remove locally bad adjacencies before heavier neighborhoods, improving convergence.

These changes integrate smoothly with existing caching and local search, while keeping runtime predictable. They have been repeatedly effective for reducing makespan in conflict-driven scheduling/search.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    tournament_order = list(range(n))
    tournament_order.sort(key=lambda x: (s[x], x))

    def prefer_before(a, b):
        return M[a][b] <= M[b][a]
=======
    tournament_order = list(range(n))
    tournament_order.sort(key=lambda x: (s[x], x))

    # Anti-buddy quartile cutoff per txn (for filtering strongly disfavored followers)
    qcut = [0] * n
    for i in range(n):
        vals = [W[i][j] for j in range(n) if j != i]
        if not vals:
            qcut[i] = 0
            continue
        vals.sort()
        idx = int(0.75 * (len(vals) - 1))
        idx = max(0, min(idx, len(vals) - 1))
        qcut[i] = vals[idx]

    def prefer_before(a, b):
        return M[a][b] <= M[b][a]
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    for t in range(n):
        order = sorted((u for u in range(n) if u != t), key=lambda u: M[t][u])
        buddies.append(order[:buddy_k])

    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
=======
    for t in range(n):
        order = sorted((u for u in range(n) if u != t), key=lambda u: M[t][u])
        buddies.append(order[:buddy_k])

    # Shared prefix-dominance map: (frozenset(remaining), suffix<=3) -> best seen cost
    prefix_dom = {}

    def preselect_by_tournament(prefix, remaining, k, recent_k=4):
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        for it in range(iters):
            # Compute marginals to locate hot regions
            _, marg = prefix_marginals(best_seq)
=======
        for it in range(iters):
            # Tournament bubble cheap cleanup
            tb = tournament_bubble_pass(best_seq, passes=2)
            cb = eval_seq(tb)
            if cb < best_cost:
                best_seq, best_cost = tb, cb

            # Compute marginals to locate hot regions
            _, marg = prefix_marginals(best_seq)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        step = 0
        while remaining:
            # Incumbent pruning against best seed so far (if available)
            try:
                if seed_best_cost < float('inf'):
                    base_cost = eval_seq(seq)
                    if base_cost >= seed_best_cost:
                        # Complete cheaply by immediate best to terminate early
                        rest = list(remaining)
                        rest.sort(key=lambda t: eval_seq(seq + [t]))
                        seq.extend(rest)
                        remaining.clear()
                        break
            except NameError:
                # seed_best_cost not yet defined in first call
                pass

            if step % reevaluate_every == 0:
                refresh_pool_full()
            else:
                while len(pool) < pool_size and remaining:
                    choices = list(remaining - pool)
                    if not choices:
                        break
                    # bias by tournament preference for diversity with guidance
                    add = preselect_by_tournament(seq, choices, 1) or [rng.choice(choices)]
                    pool.add(add[0])

            cand_list = top_pool_candidates()
            if not cand_list:
                pick = rng.choice(list(remaining))
                seq.append(pick)
                remaining.remove(pick)
                step += 1
                continue

            # Lookahead over top few with buddy-prioritized second step
            L = min(4, len(cand_list))
            best_t = cand_list[0][0]
            best_metric = cand_list[0][1]
            for t, immediate_c in cand_list[:L]:
                nexts = list(remaining - {t})
                if not nexts:
                    metric = immediate_c
                else:
                    # build la_pool = buddies ∩ nexts, then fill by tournament preference
                    buddy_pref = [u for u in buddies[t] if u in nexts]
                    need = 6 if n > 60 else 8
                    la_pool = buddy_pref[:need]
                    if len(la_pool) < need:
                        extra = preselect_by_tournament(seq + [t], [u for u in nexts if u not in la_pool], need - len(la_pool), recent_k=3)
                        la_pool.extend(extra)
                    if not la_pool:
                        la_pool = nexts[:min(need, len(nexts))]
                    metric = min(eval_seq(seq + [t, u]) for u in la_pool)
                if metric < best_metric:
                    best_metric = metric
                    best_t = t

            seq.append(best_t)
            remaining.remove(best_t)
            if best_t in pool:
                pool.remove(best_t)
            step += 1

        return seq
=======
        step = 0
        while remaining:
            # Incumbent pruning against best seed so far (if available)
            try:
                if seed_best_cost < float('inf'):
                    base_cost = eval_seq(seq)
                    if base_cost >= seed_best_cost:
                        # Complete cheaply by immediate best to terminate early
                        rest = list(remaining)
                        rest.sort(key=lambda t: eval_seq(seq + [t]))
                        seq.extend(rest)
                        remaining.clear()
                        break
            except NameError:
                # seed_best_cost not yet defined in first call
                pass

            # Prefix-dominance pruning on current prefix
            base_cost_pd = eval_seq(seq)
            sig_cur = (frozenset(remaining), tuple(seq[-3:]) if len(seq) >= 3 else tuple(seq))
            prev_cur = prefix_dom.get(sig_cur)
            if prev_cur is not None and base_cost_pd >= prev_cur:
                seq = None
                break
            if prev_cur is None or base_cost_pd < prev_cur:
                prefix_dom[sig_cur] = base_cost_pd

            if step % reevaluate_every == 0:
                refresh_pool_full()
            else:
                while len(pool) < pool_size and remaining:
                    choices = list(remaining - pool)
                    if not choices:
                        break
                    # bias by tournament preference for diversity with guidance
                    add = preselect_by_tournament(seq, choices, 1) or [rng.choice(choices)]
                    pool.add(add[0])

            cand_list = top_pool_candidates()
            if not cand_list:
                pick = rng.choice(list(remaining))
                seq.append(pick)
                remaining.remove(pick)
                step += 1
                continue

            # Lookahead over top few with buddy-prioritized second step + anti-buddy gating
            L = min(4, len(cand_list))
            best_t = cand_list[0][0]
            best_metric = cand_list[0][1]
            best_immediate = cand_list[0][1]
            last = seq[-1] if seq else None
            for t, immediate_c in cand_list[:L]:
                if last is not None and W[last][t] > 0 and W[last][t] >= qcut[last] and immediate_c > best_immediate * 1.01:
                    continue
                nexts = list(remaining - {t})
                if not nexts:
                    metric = immediate_c
                else:
                    # build la_pool = buddies ∩ nexts, then fill by tournament preference
                    buddy_pref = [u for u in buddies[t] if u in nexts]
                    need = 6 if n > 60 else 8
                    la_pool = buddy_pref[:need]
                    if len(la_pool) < need:
                        extra = preselect_by_tournament(seq + [t], [u for u in nexts if u not in la_pool], need - len(la_pool), recent_k=3)
                        la_pool.extend(extra)
                    if not la_pool:
                        la_pool = nexts[:min(need, len(nexts))]
                    metric = min(eval_seq(seq + [t, u]) for u in la_pool)
                if metric < best_metric:
                    best_metric = metric
                    best_t = t

            seq.append(best_t)
            remaining.remove(best_t)
            if best_t in pool:
                pool.remove(best_t)
            step += 1

        if seq is None:
            # Fallback to a quick greedy completion from a random start
            seq, _ = greedy_complete([rng.randint(0, n - 1)])
        return seq
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # Buddy-biased lookahead on top-L
                L = min(lookahead_top, len(imm))
                scored = []
                for t, imc in imm[:L]:
                    nexts = [u for u in rem_list if u != t]
                    if not nexts:
                        la = imc
                    else:
                        buddy_pref = [u for u in buddies[t] if u in nexts][:next_k]
                        if len(buddy_pref) < next_k:
                            extra = preselect_by_tournament(seq + [t], [u for u in nexts if u not in buddy_pref], next_k - len(buddy_pref), recent_k=3)
                            pool = buddy_pref + extra
                        else:
                            pool = buddy_pref
                        if not pool:
                            pool = nexts[:min(next_k, len(nexts))]
                        la = min(eval_seq(seq + [t, u]) for u in pool)
                    scored.append((t, min(imc, la)))

                # Add a few immediate-best without lookahead for diversity
                diversity = min(max(2, cand_per_expand // 3), len(imm))
                for t, imc in imm[:diversity]:
                    scored.append((t, imc))

                # Unique by child and keep best-k
                uniq = {}
                for t, m in scored:
                    if (t not in uniq) or (m < uniq[t]):
                        uniq[t] = m
                items = sorted(uniq.items(), key=lambda z: z[1])
                take = min(cand_per_expand, len(items))
                for t, _ in items[:take]:
                    new_seq = seq + [t]
                    new_rem = rem - {t}
                    new_cost = eval_seq(new_seq)
                    if (incumbent_cost < float('inf')) and (new_cost >= incumbent_cost):
                        continue
                    sig = (new_rem, tuple(new_seq[-3:]) if len(new_seq) >= 3 else tuple(new_seq))
                    prev = dom.get(sig)
                    if (prev is not None) and (new_cost >= prev):
                        continue
                    dom[sig] = new_cost
                    key = (tuple(new_seq), new_rem)
                    if key in local_seen:
                        continue
                    local_seen.add(key)
                    next_beam.append((new_cost, new_seq, new_rem))
=======
                # Depth-adaptive lookahead and anti-buddy filtering
                frac = depth / max(1, n - 1)
                if frac < 0.33:
                    la_L, la_next = 4, 6
                elif frac < 0.66:
                    la_L, la_next = 3, 5
                else:
                    la_L, la_next = 2, 4

                # Buddy-biased lookahead on top-L with anti-buddy gating
                L = min(la_L, len(imm))
                scored = []
                best_immediate = imm[0][1] if imm else float('inf')
                last = seq[-1] if seq else None
                for t, imc in imm[:L]:
                    if last is not None and W[last][t] > 0 and W[last][t] >= qcut[last] and imc > best_immediate * 1.01:
                        continue
                    nexts = [u for u in rem_list if u != t]
                    if not nexts:
                        la = imc
                    else:
                        buddy_pref = [u for u in buddies[t] if u in nexts][:la_next]
                        if len(buddy_pref) < la_next:
                            extra = preselect_by_tournament(seq + [t], [u for u in nexts if u not in buddy_pref], la_next - len(buddy_pref), recent_k=3)
                            pool = buddy_pref + extra
                        else:
                            pool = buddy_pref
                        if not pool:
                            pool = nexts[:min(la_next, len(nexts))]
                        la = min(eval_seq(seq + [t, u]) for u in pool)
                    scored.append((t, min(imc, la)))

                # Add a few immediate-best without lookahead for diversity (respect anti-buddy)
                diversity = min(max(2, cand_per_expand // 3), len(imm))
                for t, imc in imm[:diversity]:
                    if last is not None and W[last][t] > 0 and W[last][t] >= qcut[last] and imc > best_immediate * 1.01:
                        continue
                    scored.append((t, imc))

                # Unique by child and keep best-k
                uniq = {}
                for t, m in scored:
                    if (t not in uniq) or (m < uniq[t]):
                        uniq[t] = m
                items = sorted(uniq.items(), key=lambda z: z[1])
                take = min(cand_per_expand, len(items))
                probe_k = 2
                taken = 0
                for t, _ in items[:take]:
                    new_seq = seq + [t]
                    new_rem = rem - {t}
                    new_cost = eval_seq(new_seq)
                    if (incumbent_cost < float('inf')) and (new_cost >= incumbent_cost):
                        continue
                    sig = (new_rem, tuple(new_seq[-3:]) if len(new_seq) >= 3 else tuple(new_seq))
                    prev_local = dom.get(sig)
                    prev_global = prefix_dom.get(sig)
                    if (prev_local is not None and new_cost >= prev_local) or (prev_global is not None and new_cost >= prev_global):
                        continue

                    # Incumbent-aware greedy completion on top few children
                    if taken < probe_k:
                        full, fc = greedy_complete(new_seq)
                        if fc < incumbent_cost:
                            incumbent_cost = fc
                            incumbent_seq = full
                        if fc >= incumbent_cost:
                            taken += 1
                            continue

                    # Update dominance maps
                    best_prev = None
                    if prev_local is not None and prev_global is not None:
                        best_prev = min(prev_local, prev_global)
                    elif prev_local is not None:
                        best_prev = prev_local
                    elif prev_global is not None:
                        best_prev = prev_global
                    if best_prev is None or new_cost < best_prev:
                        dom[sig] = new_cost
                        prefix_dom[sig] = new_cost

                    key = (tuple(new_seq), new_rem)
                    if key in local_seen:
                        continue
                    local_seen.add(key)
                    next_beam.append((new_cost, new_seq, new_rem))
                    taken += 1
>>>>>>> REPLACE
</DIFF>