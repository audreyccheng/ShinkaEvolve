<NAME>
bridge_and_bubble_refinements
</NAME>

<DESCRIPTION>
I add a lightweight tournament bubble cleanup and a targeted “bridge” move to improve schedules with minimal overhead while keeping the current framework intact.

Key changes:
- Add prefer_before and tournament_bubble_pass to cheaply clean local pairwise inversions.
- Apply a quick bubble cleanup to the beam seed and at the start of local improvement, and after accepted LNS window/reinsert moves to lock in gains.
- Introduce a targeted bridge move that fixes the worst violated adjacency by moving a block around the follower just before the leader, optionally reversed, which often breaks long delay-conflict chains.
- Dynamically increase greedy completion probing for beam children during early expansion (greedy_probe_k = 3 early, 1 late) to tighten the incumbent faster while keeping cost in check.

These improvements provide stronger guidance with bounded extra simulator calls and should reduce makespan by resolving high-impact adjacencies and improving local ordering stability.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    tournament_order = list(range(n))
    tournament_order.sort(key=lambda x: (s[x], x))
=======
    tournament_order = list(range(n))
    tournament_order.sort(key=lambda x: (s[x], x))

    # Cheap pairwise preference: a before b if not worse than b before a
    def prefer_before(a, b):
        return M[a][b] <= M[b][a]

    # Simple tournament-based bubble pass to clean local inversions quickly
    def tournament_bubble_pass(seq, passes=2):
        arr = seq[:]
        for _ in range(passes):
            improved = False
            for k in range(len(arr) - 1):
                a, b = arr[k], arr[k + 1]
                if not prefer_before(a, b):
                    arr[k], arr[k + 1] = b, a
                    improved = True
            if not improved:
                break
        return arr
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
                take = min(cand_per_expand, len(items))
                greedy_probe_k = 2
                taken = 0
                for t, _ in items[:take]:
=======
                take = min(cand_per_expand, len(items))
                # Probe greedy completion on a few top children to tighten incumbent and prune
                greedy_probe_k = 3 if phaseA else 1
                taken = 0
                for t, _ in items[:take]:
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    try:
        bseq, bcost = beam_seed(best_cost)
        if bcost < best_cost:
            best_cost, best_seq = bcost, bseq[:]
    except Exception:
        pass
=======
    try:
        bseq, bcost = beam_seed(best_cost)
        # quick tournament bubble cleanup on the beam seed
        tb = tournament_bubble_pass(bseq, passes=2)
        tbc = seq_cost(tb)
        if tbc < bcost:
            bseq, bcost = tb, tbc
        if bcost < best_cost:
            best_cost, best_seq = bcost, bseq[:]
    except Exception:
        pass
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Local improvement phase
        current_cost = seq_cost(seq)

        # 1) Adjacent swap hill-climb passes
=======
        # Local improvement phase
        current_cost = seq_cost(seq)

        # 0) Quick tournament bubble cleanup
        tb = tournament_bubble_pass(seq, passes=2)
        tbc = seq_cost(tb)
        if tbc < current_cost:
            seq = tb
            current_cost = tbc

        # 1) Adjacent swap hill-climb passes
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
                if best_blk_seq is not None and best_blk_cost < current_cost:
                    seq = best_blk_seq
                    current_cost = best_blk_cost
                    break
=======
                if best_blk_seq is not None and best_blk_cost < current_cost:
                    seq = best_blk_seq
                    current_cost = best_blk_cost
                    # small bubble to lock local improvements
                    tb2 = tournament_bubble_pass(seq, passes=1)
                    tb2c = seq_cost(tb2)
                    if tb2c < current_cost:
                        seq = tb2
                        current_cost = tb2c
                    break
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # 3d) Block reinsert (rank positions by ΔW surrogate; evaluate top)
        if n >= 10:
=======
        # 3e) Targeted bridge move: move a block around the follower b just before a
        if n >= 10:
            # Identify worst adjacency (a,b)
            worst_idx = None
            worst_pen = 0
            for i in range(len(seq) - 1):
                a, b = seq[i], seq[i + 1]
                pen = M[a][b] - M[b][a]
                if pen > worst_pen:
                    worst_pen = pen
                    worst_idx = i
            if worst_idx is not None and worst_pen > 0:
                a = seq[worst_idx]
                bpos = worst_idx + 1
                # choose block size around b
                kb = 3 if n < 40 else 4
                start_b = max(bpos - kb // 2, 0)
                if start_b + kb > n:
                    start_b = n - kb
                # ensure 'a' not inside block and block contains b
                if not (start_b <= worst_idx < start_b + kb) and (start_b <= bpos < start_b + kb):
                    block = seq[start_b:start_b + kb]
                    base = seq[:start_b] + seq[start_b + kb:]
                    # target insertion just before 'a' current position in base
                    if a in base:
                        apos = base.index(a)
                        cand1 = base[:apos] + block + base[apos:]
                        cand2 = base[:apos] + list(reversed(block)) + base[apos:]
                        c1 = seq_cost(cand1)
                        c2 = seq_cost(cand2)
                        if c1 < current_cost or c2 < current_cost:
                            if c1 <= c2:
                                seq = cand1
                                current_cost = c1
                            else:
                                seq = cand2
                                current_cost = c2
                            tb_bridge = tournament_bubble_pass(seq, passes=1)
                            tb_bridge_c = seq_cost(tb_bridge)
                            if tb_bridge_c < current_cost:
                                seq = tb_bridge
                                current_cost = tb_bridge_c

        # 3d) Block reinsert (rank positions by ΔW surrogate; evaluate top)
        if n >= 10:
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if best_ins is not None and best_ins_cost < current_cost:
                seq = best_ins
                current_cost = best_ins_cost
=======
            if best_ins is not None and best_ins_cost < current_cost:
                seq = best_ins
                current_cost = best_ins_cost
                tb3 = tournament_bubble_pass(seq, passes=1)
                tb3c = seq_cost(tb3)
                if tb3c < current_cost:
                    seq = tb3
                    current_cost = tb3c
>>>>>>> REPLACE

</DIFF>