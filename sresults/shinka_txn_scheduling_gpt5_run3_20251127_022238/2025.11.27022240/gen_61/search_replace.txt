<NAME>
two_phase_beam_and_block_moves
</NAME>

<DESCRIPTION>
I integrate a two-phase, incumbent-pruned beam seed to produce a stronger initial schedule informed by pairwise conflict costs and tournament margins. The beam uses tournament-guided preselection, buddy-based lookahead, and prefix-dominance pruning keyed by remaining set and last-3 suffix, and greedily completes top prefixes to update an incumbent early. This seed is then locally cleaned and used to prune subsequent greedy builds.

I also strengthen the LNS by adding two non-local neighborhoods that better reduce conflict-induced delays: (1) block-swap of two short windows centered near the worst violated adjacencies by M[a][b]-M[b][a], and (2) block reinsert of a hot block (chosen by marginal sum) at sampled positions. Both moves evaluate a small, capped set of candidates and accept the first improving move, which complements the existing window-permutation and relocate steps.

These changes exploit actual makespan costs rather than proxies, directly minimizing conflict overlaps through guided search and more expressive neighborhoods, improving schedule quality without excessive overhead.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # LNS: pick hot windows by marginal sum and boundary violations; reorder via perms
    def lns_improve(seq, base_cost, budget_factor):
        best_seq = seq[:]
        best_cost = base_cost
        n_local = len(best_seq)

        # Iterations scale mildly with budget_factor and n
        iters = max(4, min(10, 2 + int(budget_factor) + n_local // 40))
        max_k = 7 if n_local >= 40 else 6

        for it in range(iters):
            # Compute marginals to locate hot regions
            _, marg = prefix_marginals(best_seq)

            # Choose window size
            k = max_k if it < 2 else rng.randint(4, max_k)
            if n_local <= k:
                break

            # Find top windows by marginal sum (sliding window)
            sums = []
            window_sum = sum(marg[0:k])
            sums.append((0, window_sum))
            for s in range(1, n_local - k + 1):
                window_sum += marg[s + k - 1] - marg[s - 1]
                sums.append((s, window_sum))
            sums.sort(key=lambda x: -x[1])

            # Also consider windows around worst violated adjacencies
            viol_starts = worst_violation_boundaries(best_seq, topm=3)
            candidate_starts = []
            for v in viol_starts:
                start = max(0, min(v - (k // 2), n_local - k))
                candidate_starts.append(start)
            candidate_starts.extend([start for start, _ in sums[:2]])
            # Deduplicate while preserving order
            seen_starts = set()
            ordered_starts = []
            for st in candidate_starts:
                if st not in seen_starts:
                    seen_starts.add(st)
                    ordered_starts.append(st)

            tried_any = False
            for start in ordered_starts:
                block = best_seq[start : start + k]
                base = best_seq[:start] + best_seq[start + k :]

                # Determine permutation budget
                factorial = 1
                for i in range(2, k + 1):
                    factorial *= i
                # Cap permutations to keep time in check
                if k <= 6:
                    perm_budget = min(720, factorial)
                else:
                    perm_budget = 2000  # sample for k=7

                perm_best_seq = None
                perm_best_cost = best_cost

                if factorial <= perm_budget:
                    for p in itertools.permutations(block):
                        cand_seq = base[:start] + list(p) + base[start:]
                        c = eval_seq(cand_seq)
                        if c < perm_best_cost:
                            perm_best_cost = c
                            perm_best_seq = cand_seq
                else:
                    seenp = set()
                    attempts = 0
                    while attempts < perm_budget:
                        p = tuple(rng.sample(block, k))
                        if p in seenp:
                            continue
                        seenp.add(p)
                        cand_seq = base[:start] + list(p) + base[start:]
                        c = eval_seq(cand_seq)
                        if c < perm_best_cost:
                            perm_best_cost = c
                            perm_best_seq = cand_seq
                        attempts += 1

                if perm_best_seq is not None and perm_best_cost < best_cost:
                    best_seq = perm_best_seq
                    best_cost = perm_best_cost
                    tried_any = True
                    break  # accept first improving window

            # Targeted relocate moves for top-blame transactions
            _, marg = prefix_marginals(best_seq)
            positions = sorted(range(n_local), key=lambda i: marg[i], reverse=True)[:3]
            for pos in positions:
                if pos >= len(best_seq):
                    continue
                t = best_seq[pos]
                base = best_seq[:pos] + best_seq[pos + 1 :]
                best_pos_cost = best_cost
                best_pos_idx = None
                positions_try = set([0, len(base)])
                for _ in range(8):
                    positions_try.add(rng.randint(0, len(base)))
                for j in positions_try:
                    cand = base[:j] + [t] + base[j:]
                    c = eval_seq(cand)
                    if c < best_pos_cost:
                        best_pos_cost = c
                        best_pos_idx = j
                if best_pos_idx is not None and best_pos_cost < best_cost:
                    best_seq = base[:best_pos_idx] + [t] + base[best_pos_idx:]
                    best_cost = best_pos_cost

            if not tried_any:
                continue

        return best_seq, best_cost
=======
    # LNS: pick hot windows by marginal sum and boundary violations; reorder via perms
    def lns_improve(seq, base_cost, budget_factor):
        best_seq = seq[:]
        best_cost = base_cost
        n_local = len(best_seq)

        # Iterations scale mildly with budget_factor and n
        iters = max(4, min(10, 2 + int(budget_factor) + n_local // 40))
        max_k = 7 if n_local >= 40 else 6

        for it in range(iters):
            # Compute marginals to locate hot regions
            _, marg = prefix_marginals(best_seq)

            # Choose window size
            k = max_k if it < 2 else rng.randint(4, max_k)
            if n_local <= k:
                break

            # Find top windows by marginal sum (sliding window)
            sums = []
            window_sum = sum(marg[0:k])
            sums.append((0, window_sum))
            for s in range(1, n_local - k + 1):
                window_sum += marg[s + k - 1] - marg[s - 1]
                sums.append((s, window_sum))
            sums.sort(key=lambda x: -x[1])

            # Also consider windows around worst violated adjacencies
            viol_starts = worst_violation_boundaries(best_seq, topm=3)
            candidate_starts = []
            for v in viol_starts:
                start = max(0, min(v - (k // 2), n_local - k))
                candidate_starts.append(start)
            candidate_starts.extend([start for start, _ in sums[:2]])
            # Deduplicate while preserving order
            seen_starts = set()
            ordered_starts = []
            for st in candidate_starts:
                if st not in seen_starts:
                    seen_starts.add(st)
                    ordered_starts.append(st)

            tried_any = False
            for start in ordered_starts:
                block = best_seq[start : start + k]
                base = best_seq[:start] + best_seq[start + k :]

                # Determine permutation budget
                factorial = 1
                for i in range(2, k + 1):
                    factorial *= i
                # Cap permutations to keep time in check
                if k <= 6:
                    perm_budget = min(720, factorial)
                else:
                    perm_budget = 2000  # sample for k=7

                perm_best_seq = None
                perm_best_cost = best_cost

                if factorial <= perm_budget:
                    for p in itertools.permutations(block):
                        cand_seq = base[:start] + list(p) + base[start:]
                        c = eval_seq(cand_seq)
                        if c < perm_best_cost:
                            perm_best_cost = c
                            perm_best_seq = cand_seq
                else:
                    seenp = set()
                    attempts = 0
                    while attempts < perm_budget:
                        p = tuple(rng.sample(block, k))
                        if p in seenp:
                            continue
                        seenp.add(p)
                        cand_seq = base[:start] + list(p) + base[start:]
                        c = eval_seq(cand_seq)
                        if c < perm_best_cost:
                            perm_best_cost = c
                            perm_best_seq = cand_seq
                        attempts += 1

                if perm_best_seq is not None and perm_best_cost < best_cost:
                    best_seq = perm_best_seq
                    best_cost = perm_best_cost
                    tried_any = True
                    break  # accept first improving window

            # Targeted relocate moves for top-blame transactions
            _, marg = prefix_marginals(best_seq)
            positions = sorted(range(n_local), key=lambda i: marg[i], reverse=True)[:3]
            for pos in positions:
                if pos >= len(best_seq):
                    continue
                t = best_seq[pos]
                base = best_seq[:pos] + best_seq[pos + 1 :]
                best_pos_cost = best_cost
                best_pos_idx = None
                positions_try = set([0, len(base)])
                for _ in range(8):
                    positions_try.add(rng.randint(0, len(base)))
                for j in positions_try:
                    cand = base[:j] + [t] + base[j:]
                    c = eval_seq(cand)
                    if c < best_pos_cost:
                        best_pos_cost = c
                        best_pos_idx = j
                if best_pos_idx is not None and best_pos_cost < best_cost:
                    best_seq = base[:best_pos_idx] + [t] + base[best_pos_idx:]
                    best_cost = best_pos_cost

            # Additional non-local neighborhoods

            # Block-swap two short windows around worst violated adjacencies
            if n_local >= 12:
                viols = worst_violation_boundaries(best_seq, topm=2)
                if viols:
                    k1 = 3 if n_local < 40 else 4
                    k2 = k1
                    s1 = max(0, min(viols[0] - k1 // 2, n_local - k1))
                    # Candidate second starts: one guided near the other violation and a few random
                    s2_candidates = [max(0, min((viols[-1] if len(viols) > 1 else viols[0]) + k1, n_local - k2))]
                    for _ in range(2):
                        s2_candidates.append(rng.randint(0, n_local - k2))
                    improved_swap = False
                    for s2 in s2_candidates:
                        if abs(s2 - s1) < k1:  # avoid overlap
                            continue
                        block1 = best_seq[s1:s1 + k1]
                        block2 = best_seq[s2:s2 + k2]
                        if s1 < s2:
                            cand = best_seq[:s1] + block2 + best_seq[s1 + k1:s2] + block1 + best_seq[s2 + k2:]
                        else:
                            cand = best_seq[:s2] + block1 + best_seq[s2 + k2:s1] + block2 + best_seq[s1 + k1:]
                        c = eval_seq(cand)
                        if c < best_cost:
                            best_cost = c
                            best_seq = cand
                            improved_swap = True
                            break
                    if improved_swap:
                        continue

            # Block reinsert: remove a hot block (by marginal sum) and reinsert at sampled positions
            if n_local >= 10:
                kbr = 4 if n_local < 50 else 5
                sums = []
                window_sum = sum(marg[0:kbr])
                sums.append((0, window_sum))
                for s in range(1, n_local - kbr + 1):
                    window_sum += marg[s + kbr - 1] - marg[s - 1]
                    sums.append((s, window_sum))
                sums.sort(key=lambda x: -x[1])
                start = sums[0][0]
                block = best_seq[start:start + kbr]
                base = best_seq[:start] + best_seq[start + kbr:]
                positions_try = {0, len(base)}
                while len(positions_try) < 6:
                    positions_try.add(rng.randint(0, len(base)))
                best_ins = None
                best_ins_cost = best_cost
                for pos in positions_try:
                    cand = base[:pos] + block + base[pos:]
                    c = eval_seq(cand)
                    if c < best_ins_cost:
                        best_ins_cost = c
                        best_ins = cand
                if best_ins is not None and best_ins_cost < best_cost:
                    best_seq = best_ins
                    best_cost = best_ins_cost
                    continue

            if not tried_any:
                continue

        return best_seq, best_cost
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Multi-start: build a few diverse initial sequences and pick the best as LNS seed
    starts = max(2, min(5, int(num_seqs // 3) + 2))
    seed_best_cost = float('inf')
    seed_best_seq = None
    for _ in range(starts):
        seq0 = build_initial_sequence()
        cost0 = eval_seq(seq0)
        # quick local cleanup
        seq0, cost0 = adjacent_pass(seq0, cost0)
        if cost0 < seed_best_cost:
            seed_best_cost = cost0
            seed_best_seq = seq0

    # LNS improvement on best seed
    final_seq, final_cost = lns_improve(seed_best_seq, seed_best_cost, budget_factor=max(1, int(num_seqs)))
=======
    # Greedy completion utility and beam-seeded prefix explorer
    def greedy_complete(prefix):
        rem = [t for t in range(n) if t not in prefix]
        cur = prefix[:]
        while rem:
            t = min(rem, key=lambda u: eval_seq(cur + [u]))
            cur.append(t)
            rem.remove(t)
        return cur, eval_seq(cur)

    def beam_seed(inc=None):
        beam_width = max(6, min(16, int(num_seqs)))
        cand_per_expand = max(6, min(12, n // 7 + 6))
        lookahead_top = 3
        next_k = 5
        depth_limit = max(3, int(0.4 * n))

        # Starts: tournament-best, a good singleton, then randoms
        starts = []
        starts.append(tournament_order[0])
        topk = min(10, n)
        singles_sorted = sorted(range(n), key=lambda t: c1[t])[:topk]
        starts.append(rng.choice(singles_sorted))
        remcands = [t for t in range(n) if t not in starts]
        rng.shuffle(remcands)
        starts.extend(remcands[:max(0, beam_width - len(starts))])

        beam = []
        dom = {}  # prefix-dominance: (remaining_fset, suffix<=3) -> best cost
        seen_init = set()
        for t in starts:
            seq = [t]
            rem = frozenset(set(range(n)) - {t})
            cost = eval_seq(seq)
            key = (tuple(seq), rem)
            if key in seen_init:
                continue
            seen_init.add(key)
            sig = (rem, tuple(seq[-1:]))
            prev = dom.get(sig)
            if prev is None or cost < prev:
                dom[sig] = cost
                beam.append((cost, seq, rem))

        incumbent_cost = inc if inc is not None else float('inf')
        incumbent_seq = None

        depth = 1
        while depth < min(depth_limit, n) and beam:
            next_beam = []
            local_seen = set()
            for cost, seq, rem in beam:
                if incumbent_cost < float('inf') and cost >= incumbent_cost:
                    continue
                rem_list = list(rem)
                if not rem_list:
                    next_beam.append((cost, seq, rem))
                    continue

                # Tournament-guided preselection
                pre = preselect_by_tournament(seq, rem_list, cand_per_expand * 2) if len(rem_list) > cand_per_expand * 2 else rem_list

                # Immediate costs
                imm = [(t, eval_seq(seq + [t])) for t in pre]
                imm.sort(key=lambda z: z[1])

                # Buddy-biased lookahead on top-L
                L = min(lookahead_top, len(imm))
                scored = []
                for t, imc in imm[:L]:
                    nexts = [u for u in rem_list if u != t]
                    if not nexts:
                        la = imc
                    else:
                        buddy_pref = [u for u in buddies[t] if u in nexts][:next_k]
                        if len(buddy_pref) < next_k:
                            extra = preselect_by_tournament(seq + [t], [u for u in nexts if u not in buddy_pref], next_k - len(buddy_pref), recent_k=3)
                            pool = buddy_pref + extra
                        else:
                            pool = buddy_pref
                        if not pool:
                            pool = nexts[:min(next_k, len(nexts))]
                        la = min(eval_seq(seq + [t, u]) for u in pool)
                    scored.append((t, min(imc, la)))

                # Add a few immediate-best without lookahead for diversity
                diversity = min(max(2, cand_per_expand // 3), len(imm))
                for t, imc in imm[:diversity]:
                    scored.append((t, imc))

                # Unique by child and keep best-k
                uniq = {}
                for t, m in scored:
                    if (t not in uniq) or (m < uniq[t]):
                        uniq[t] = m
                items = sorted(uniq.items(), key=lambda z: z[1])
                take = min(cand_per_expand, len(items))
                for t, _ in items[:take]:
                    new_seq = seq + [t]
                    new_rem = rem - {t}
                    new_cost = eval_seq(new_seq)
                    if (incumbent_cost < float('inf')) and (new_cost >= incumbent_cost):
                        continue
                    sig = (new_rem, tuple(new_seq[-3:]) if len(new_seq) >= 3 else tuple(new_seq))
                    prev = dom.get(sig)
                    if (prev is not None) and (new_cost >= prev):
                        continue
                    dom[sig] = new_cost
                    key = (tuple(new_seq), new_rem)
                    if key in local_seen:
                        continue
                    local_seen.add(key)
                    next_beam.append((new_cost, new_seq, new_rem))

            if not next_beam:
                break

            # Update incumbent by greedily completing top prefixes
            next_beam.sort(key=lambda x: x[0])
            for bc, bseq, brem in next_beam[:2]:
                if incumbent_cost < float('inf') and bc >= incumbent_cost:
                    continue
                full, fc = greedy_complete(bseq)
                if fc < incumbent_cost:
                    incumbent_cost = fc
                    incumbent_seq = full

            # Keep the beam
            beam = next_beam[:beam_width]
            depth += 1

        # Choose best prefix and complete greedily
        if not beam:
            # fallback
            full, fc = greedy_complete([rng.randint(0, n - 1)])
            return full, fc
        beam.sort(key=lambda x: x[0])
        _, bseq, _ = beam[0]
        full, fc = greedy_complete(bseq)
        if incumbent_seq is not None and incumbent_cost < fc:
            return incumbent_seq, incumbent_cost
        return full, fc

    # Multi-start: beam-seeded plus greedy seeds; pick best as LNS seed
    starts = max(2, min(5, int(num_seqs // 3) + 2))
    seed_best_cost = float('inf')
    seed_best_seq = None

    # 0) Beam seed once
    bseq, bcost = beam_seed()
    bseq, bcost = adjacent_pass(bseq, bcost)
    seed_best_seq, seed_best_cost = bseq, bcost

    # 1) Greedy seeds
    for _ in range(starts):
        seq0 = build_initial_sequence()
        cost0 = eval_seq(seq0)
        # quick local cleanup
        seq0, cost0 = adjacent_pass(seq0, cost0)
        if cost0 < seed_best_cost:
            seed_best_cost = cost0
            seed_best_seq = seq0

    # LNS improvement on best seed
    final_seq, final_cost = lns_improve(seed_best_seq, seed_best_cost, budget_factor=max(1, int(num_seqs)))
>>>>>>> REPLACE

</DIFF>