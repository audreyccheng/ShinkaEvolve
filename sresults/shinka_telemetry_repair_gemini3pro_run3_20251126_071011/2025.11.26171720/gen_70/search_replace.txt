<NAME>
improved_solver_with_adaptive_priors
</NAME>

<DESCRIPTION>
This edit completely revamps Step 2 (Iterative Solver) and Step 3 (Confidence & Status) of the algorithm to align with the recommendation for "Status-Aware Bayesian Priors" and "Calibrated Confidence".

1.  **Step 2 (Solver)**:
    *   Introduces `calc_sigma` (adaptive noise model) and `get_router_state` helpers locally to the function scope for better access.
    *   Iterates through both **Internal Suspect Flows** and **External Flows**.
    *   **Internal Flows**: Expands hypotheses to include `0.0` (Phantom check) and the `Mean` (if values are close).
    *   **External Flows**: Generates an `implied` candidate based on router flow conservation to validate/repair external measurements.
    *   **Priors**: explicitly checks `interface_status`. If `down`, `0.0` hypothesis gets high prior (0.95). If `up` and measurement is high, `0.0` gets low prior (0.01).
    *   **Solver Confidence**: Calculates the probability mass around the winning hypothesis (Margin of Victory).

2.  **Step 3 (Confidence)**:
    *   Calculates `router_fits` (Goodness of Fit) for all routers based on final flow balance.
    *   Combines `solver_confidence` (relative probability) with `router_fit` (absolute quality) to produce a calibrated confidence score.
    *   Handles Anchors (from Step 1) separately to preserve their high confidence.
    *   Enforces consistency: if inferred status is 'down', rates are zeroed with high confidence.

This approach effectively targets the "phantom traffic" problem, validates external links (previously trusted blindly), and ensures confidence scores are not overconfident when the underlying repair quality (router balance) is poor.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 2: Iterative Bayesian Refinement ---

    # Helper to calculate router imbalance given current estimates
    def get_router_imbalance(rid):
        if_list = topology.get(rid, [])
        total_in = 0.0
        total_out = 0.0
        for iid in if_list:
            total_in += current_estimates.get(iid, {}).get('rx', 0.0)
            total_out += current_estimates.get(iid, {}).get('tx', 0.0)
        return total_in - total_out, max(total_in, total_out, 1.0)

    # Iteration loop
    for _ in range(ITERATIONS):
        updates = {} # Store updates to apply after full pass

        for flow_prob in suspect_flows:
            link_key = flow_prob['key']
            direction = flow_prob['dir']
            candidates = flow_prob['candidates']

            # Identify interfaces and routers involved
            info = links[link_key]
            if direction == '1_to_2':
                src_if, dst_if = info['if1'], info['if2']
                val_src, val_dst = candidates[0], candidates[1] # src measured tx, dst measured rx
            else:
                src_if, dst_if = info['if2'], info['if1']
                val_src, val_dst = candidates[0], candidates[1]

            router_src = if_to_router.get(src_if)
            router_dst = if_to_router.get(dst_if)

            # Evaluate Hypothesis 1: Value is val_src (Local TX measurement)
            # Evaluate Hypothesis 2: Value is val_dst (Peer RX measurement)
            # We also consider their average as a fallback hypothesis 3? No, keep it binary for strong signals.

            hyps = [val_src, val_dst]
            scores = []

            for h_val in hyps:
                # Probability score based on Gaussian likelihood of imbalance

                # Check Source Router Imbalance if we use h_val for this TX interface
                # Temporarily replace value in calculation
                old_tx = current_estimates[src_if]['tx']
                current_estimates[src_if]['tx'] = h_val
                imb_src, flow_src = get_router_imbalance(router_src)
                # Restore
                current_estimates[src_if]['tx'] = old_tx

                # Check Dest Router Imbalance if we use h_val for this RX interface
                old_rx = current_estimates[dst_if]['rx']
                current_estimates[dst_if]['rx'] = h_val
                imb_dst, flow_dst = get_router_imbalance(router_dst)
                current_estimates[dst_if]['rx'] = old_rx

                # Likelihood function: P ~ exp(- |imbalance| / sigma)
                # sigma is tolerance proportional to flow
                sigma_src = max(flow_src * CONSERVATION_TOLERANCE_PCT, 1.0)
                sigma_dst = max(flow_dst * CONSERVATION_TOLERANCE_PCT, 1.0)

                score_src = math.exp(-abs(imb_src) / sigma_src)
                score_dst = math.exp(-abs(imb_dst) / sigma_dst)

                # Combined score (Bayesian update assuming independent router evidence)
                # We add a small epsilon prior favoring "no change" if both bad,
                # but here we just multiply.
                scores.append(score_src * score_dst)

            # Select Winner
            s1, s2 = scores[0], scores[1]
            total_s = s1 + s2 + 1e-9

            p1 = s1 / total_s
            p2 = s2 / total_s

            if p1 > p2:
                winner_val = val_src
                conf = p1
            else:
                winner_val = val_dst
                conf = p2

            # Store update
            updates[(src_if, 'tx')] = (winner_val, conf)
            updates[(dst_if, 'rx')] = (winner_val, conf)

        # Apply updates
        for (if_id, metric), (val, conf) in updates.items():
            current_estimates[if_id][metric] = val
            estimate_confidence[if_id][metric] = conf

    # --- Step 3: Final Assembly & Status Repair ---

    result = {}

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        # Repaired Rates
        est_rx = current_estimates[if_id]['rx']
        conf_rx = estimate_confidence[if_id]['rx']

        est_tx = current_estimates[if_id]['tx']
        conf_tx = estimate_confidence[if_id]['tx']

        # Status Inference
        # Determine peer status
        peer_id = data.get('connected_to')
        peer_status = 'unknown'
        if peer_id and peer_id in telemetry:
            peer_status = telemetry[peer_id].get('interface_status', 'unknown')

        # 1. Existence of significant traffic implies UP
        has_rx = est_rx > MIN_SIGNIFICANT_FLOW
        has_tx = est_tx > MIN_SIGNIFICANT_FLOW

        rep_status = orig_status
        conf_status = 1.0 # Baseline

        if has_rx or has_tx:
            rep_status = 'up'
            if orig_status != 'up':
                # We are overturning status based on traffic.
                # Confidence depends on traffic confidence.
                flow_conf = max(conf_rx if has_rx else 0, conf_tx if has_tx else 0)
                conf_status = flow_conf

        elif peer_status == 'down':
            # Peer is down and we have no traffic -> We should be down (usually)
            rep_status = 'down'
            if orig_status != 'down':
                conf_status = 0.9

        elif orig_status == 'up' and not has_rx and not has_tx:
            # We say UP, but no traffic.
            # Could be idle.
            # If peer is UP, likely idle -> Keep UP.
            # If peer is DOWN (caught above), then DOWN.
            # If peer unknown, keep UP.
            rep_status = 'up'

        # Post-process: If status is DOWN, force rates to 0
        if rep_status == 'down':
            est_rx = 0.0
            est_tx = 0.0
            # High confidence in 0 if we are confident it's down
            conf_rx = max(conf_rx, conf_status)
            conf_tx = max(conf_tx, conf_status)

        # Result Construction
        entry = {}
        entry['rx_rate'] = (orig_rx, est_rx, conf_rx)
        entry['tx_rate'] = (orig_tx, est_tx, conf_tx)
        entry['interface_status'] = (orig_status, rep_status, conf_status)

        # Metadata
        for k in ['connected_to', 'local_router', 'remote_router']:
            if k in data:
                entry[k] = data[k]

        result[if_id] = entry

    return result
=======
    # --- Step 2: Iterative Bayesian Refinement ---

    def get_router_state(rid):
        if rid not in topology: return 0.0, 1.0
        tin, tout = 0.0, 0.0
        max_f = 0.0
        for iid in topology[rid]:
            if iid in current_estimates:
                r = current_estimates[iid].get('rx', 0.0)
                t = current_estimates[iid].get('tx', 0.0)
                tin += r
                tout += t
                max_f = max(max_f, r, t)
        return (tin - tout), max(max_f, 1.0)

    def calc_sigma(flow_val):
        return max(math.sqrt(flow_val), flow_val * CONSERVATION_TOLERANCE_PCT, 1.0)

    solver_confidences = {}
    MOMENTUM = 0.5

    for _ in range(ITERATIONS):
        updates = []

        # 1. Internal Suspect Flows
        for flow_prob in suspect_flows:
            link_key = flow_prob['key']
            direction = flow_prob['dir']
            candidates = flow_prob['candidates']

            info = links[link_key]
            if direction == '1_to_2':
                src_if, dst_if = info['if1'], info['if2']
            else:
                src_if, dst_if = info['if2'], info['if1']

            r_src = if_to_router.get(src_if)
            r_dst = if_to_router.get(dst_if)

            # Hypotheses: [Meas1, Meas2, 0.0] + Mean
            hyps = sorted(list(set([c for c in candidates if c >= 0] + [0.0])))
            if len(candidates) == 2:
                v1, v2 = candidates
                if abs(v1-v2) < max(v1,v2)*0.2 + 5.0:
                    hyps.append((v1+v2)/2.0)
            hyps = sorted(list(set(hyps)))

            curr_tx = current_estimates[src_if]['tx']
            curr_rx = current_estimates[dst_if]['rx']

            s_src = telemetry[src_if].get('interface_status', 'unknown')
            s_dst = telemetry[dst_if].get('interface_status', 'unknown')

            scores = []
            for h in hyps:
                current_estimates[src_if]['tx'] = h
                current_estimates[dst_if]['rx'] = h

                imb_s, flow_s = get_router_state(r_src)
                score_s = math.exp(-abs(imb_s)/calc_sigma(flow_s)) if r_src else 1.0

                imb_d, flow_d = get_router_state(r_dst)
                score_d = math.exp(-abs(imb_d)/calc_sigma(flow_d)) if r_dst else 1.0

                # Prior
                prior = 1.0
                if h == 0.0:
                    if s_src == 'down' or s_dst == 'down': prior = 0.95
                    else:
                        m_val = max(candidates)
                        if m_val > 10.0: prior = 0.01
                        elif m_val > 1.0: prior = 0.2
                else:
                    dist = min([abs(h-c) for c in candidates])
                    prior = math.exp(-dist / max(h*0.05, 1.0))

                scores.append(score_s * score_d * prior)

            current_estimates[src_if]['tx'] = curr_tx
            current_estimates[dst_if]['rx'] = curr_rx

            best_idx = scores.index(max(scores))
            win_val = hyps[best_idx]

            # Calibration: Probability mass near winner
            total = sum(scores) + 1e-20
            probs = [s/total for s in scores]
            win_prob = sum(p for i, p in enumerate(probs)
                           if abs(hyps[i] - win_val) < max(win_val*0.05, 1.0))

            updates.append((src_if, 'tx', win_val, win_prob))
            updates.append((dst_if, 'rx', win_val, win_prob))

        # 2. External Flows
        for key, info in links.items():
            if info['type'] != 'external': continue
            if_id = info['if1']
            r_id = if_to_router.get(if_id)
            if not r_id: continue

            metrics = []
            if 'tx' in current_estimates.get(if_id, {}): metrics.append('tx')
            if 'rx' in current_estimates.get(if_id, {}): metrics.append('rx')

            stat = telemetry[if_id].get('interface_status', 'unknown')

            for metric in metrics:
                curr_val = current_estimates[if_id][metric]
                meas = telemetry[if_id].get(f'{metric}_rate', 0.0)

                imb, r_flow = get_router_state(r_id)
                if metric == 'tx': implied = max(0.0, curr_val + imb)
                else: implied = max(0.0, curr_val - imb)

                hyps = sorted(list(set([meas, implied, 0.0])))
                scores = []
                for h in hyps:
                    current_estimates[if_id][metric] = h
                    imb, rf = get_router_state(r_id)
                    lik = math.exp(-abs(imb)/calc_sigma(rf))

                    prior = 1.0
                    if h == 0.0:
                        if stat == 'down': prior = 0.95
                        elif meas > 10.0: prior = 0.01
                    elif abs(h - meas) < 1e-6:
                        prior = 0.6
                    elif abs(h - implied) < 1e-6:
                        prior = 0.4

                    if h > 0:
                        prior *= math.exp(-abs(h-meas)/max(meas*0.05, 1.0))

                    scores.append(lik * prior)

                current_estimates[if_id][metric] = curr_val

                best_idx = scores.index(max(scores))
                win_val = hyps[best_idx]
                total = sum(scores) + 1e-20
                probs = [s/total for s in scores]
                win_prob = sum(p for i, p in enumerate(probs)
                           if abs(hyps[i] - win_val) < max(win_val*0.05, 1.0))

                updates.append((if_id, metric, win_val, win_prob))

        # Apply
        for if_id, metric, val, prob in updates:
            old = current_estimates[if_id][metric]
            current_estimates[if_id][metric] = (old * (1 - MOMENTUM)) + (val * MOMENTUM)
            solver_confidences[(if_id, metric)] = prob

    # --- Step 3: Final Assembly & Status Repair ---

    result = {}

    # Calculate final router conservation fits
    router_fits = {}
    for rid in topology:
        imb, flow = get_router_state(rid)
        fit = math.exp(-abs(imb) / calc_sigma(flow))
        router_fits[rid] = fit

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        rep_rx = current_estimates[if_id]['rx']
        rep_tx = current_estimates[if_id]['tx']

        rid = if_to_router.get(if_id)
        r_fit = router_fits.get(rid, 0.8)

        def get_final_conf(metric, val, orig_val):
            # Check if this was a Step 1 Anchor (high confidence in estimate_confidence)
            step1_conf = estimate_confidence.get(if_id, {}).get(metric, 0.0)
            if step1_conf > 0.9:
                return 0.95

            # Otherwise use Solver Confidence
            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Combine: Probability * Fit Quality
            base = sol_prob * (0.3 + 0.7 * r_fit)

            # If value didn't change much from measurement, boost confidence slightly
            if abs(val - orig_val) < max(orig_val * 0.1, 1.0):
                base = max(base, 0.8 * r_fit + 0.1)

            return max(0.01, min(0.99, base))

        conf_rx = get_final_conf('rx', rep_rx, orig_rx)
        conf_tx = get_final_conf('tx', rep_tx, orig_tx)

        # Status Inference
        peer_id = data.get('connected_to')
        peer_status = 'unknown'
        if peer_id and peer_id in telemetry:
            peer_status = telemetry[peer_id].get('interface_status', 'unknown')

        has_traffic = (rep_rx > MIN_SIGNIFICANT_FLOW) or (rep_tx > MIN_SIGNIFICANT_FLOW)

        rep_status = orig_status
        conf_status = 1.0

        if has_traffic:
            rep_status = 'up'
            if orig_status != 'up':
                conf_status = (conf_rx + conf_tx) / 2.0
        elif peer_status == 'down':
            rep_status = 'down'
            if orig_status != 'down':
                conf_status = 0.9
        else:
            rep_status = orig_status

        if rep_status == 'down':
            rep_rx, rep_tx = 0.0, 0.0
            conf_rx = max(conf_rx, 0.95)
            conf_tx = max(conf_tx, 0.95)

        entry = {}
        entry['rx_rate'] = (orig_rx, rep_rx, conf_rx)
        entry['tx_rate'] = (orig_tx, rep_tx, conf_tx)
        entry['interface_status'] = (orig_status, rep_status, conf_status)
        for k in ['connected_to', 'local_router', 'remote_router']:
            if k in data: entry[k] = data[k]
        result[if_id] = entry

    return result
>>>>>>> REPLACE
</DIFF>