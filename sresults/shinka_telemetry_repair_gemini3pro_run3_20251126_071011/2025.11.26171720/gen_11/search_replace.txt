<NAME>
calibrate_confidence_with_residual_imbalance
</NAME>

<DESCRIPTION>
Introduces a global confidence calibration step after the iterative repair process.
While the Bayesian update selects the best local hypothesis, it can remain overconfident if all hypotheses result in a physically invalid state (high flow imbalance).
The new step calculates the residual flow imbalance for each router. If a router violates flow conservation significantly (beyond the tolerance), the confidence scores of all its connected interfaces are heavily penalized.
This ensures that the confidence score accurately reflects the "goodness" of the network state, improving the confidence calibration metric.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 2: Iterative Bayesian Refinement ---

    # Helper to calculate router imbalance given current estimates
    def get_router_imbalance(rid):
        if_list = topology.get(rid, [])
        total_in = 0.0
        total_out = 0.0
        for iid in if_list:
            total_in += current_estimates.get(iid, {}).get('rx', 0.0)
            total_out += current_estimates.get(iid, {}).get('tx', 0.0)
        return total_in - total_out, max(total_in, total_out, 1.0)

    # Iteration loop
    for _ in range(ITERATIONS):
        updates = {} # Store updates to apply after full pass

        for flow_prob in suspect_flows:
            link_key = flow_prob['key']
            direction = flow_prob['dir']
            candidates = flow_prob['candidates']

            # Identify interfaces and routers involved
            info = links[link_key]
            if direction == '1_to_2':
                src_if, dst_if = info['if1'], info['if2']
                val_src, val_dst = candidates[0], candidates[1] # src measured tx, dst measured rx
            else:
                src_if, dst_if = info['if2'], info['if1']
                val_src, val_dst = candidates[0], candidates[1]

            router_src = if_to_router.get(src_if)
            router_dst = if_to_router.get(dst_if)

            # Evaluate Hypothesis 1: Value is val_src (Local TX measurement)
            # Evaluate Hypothesis 2: Value is val_dst (Peer RX measurement)
            # We also consider their average as a fallback hypothesis 3? No, keep it binary for strong signals.

            hyps = [val_src, val_dst]
            scores = []

            for h_val in hyps:
                # Probability score based on Gaussian likelihood of imbalance

                # Check Source Router Imbalance if we use h_val for this TX interface
                # Temporarily replace value in calculation
                old_tx = current_estimates[src_if]['tx']
                current_estimates[src_if]['tx'] = h_val
                imb_src, flow_src = get_router_imbalance(router_src)
                # Restore
                current_estimates[src_if]['tx'] = old_tx

                # Check Dest Router Imbalance if we use h_val for this RX interface
                old_rx = current_estimates[dst_if]['rx']
                current_estimates[dst_if]['rx'] = h_val
                imb_dst, flow_dst = get_router_imbalance(router_dst)
                current_estimates[dst_if]['rx'] = old_rx

                # Likelihood function: P ~ exp(- |imbalance| / sigma)
                # sigma is tolerance proportional to flow
                sigma_src = max(flow_src * CONSERVATION_TOLERANCE_PCT, 1.0)
                sigma_dst = max(flow_dst * CONSERVATION_TOLERANCE_PCT, 1.0)

                score_src = math.exp(-abs(imb_src) / sigma_src)
                score_dst = math.exp(-abs(imb_dst) / sigma_dst)

                # Combined score (Bayesian update assuming independent router evidence)
                # We add a small epsilon prior favoring "no change" if both bad,
                # but here we just multiply.
                scores.append(score_src * score_dst)

            # Select Winner
            s1, s2 = scores[0], scores[1]
            total_s = s1 + s2 + 1e-9

            p1 = s1 / total_s
            p2 = s2 / total_s

            if p1 > p2:
                winner_val = val_src
                conf = p1
            else:
                winner_val = val_dst
                conf = p2

            # Store update
            updates[(src_if, 'tx')] = (winner_val, conf)
            updates[(dst_if, 'rx')] = (winner_val, conf)

        # Apply updates
        for (if_id, metric), (val, conf) in updates.items():
            current_estimates[if_id][metric] = val
            estimate_confidence[if_id][metric] = conf
=======
    # --- Step 2: Iterative Bayesian Refinement ---

    # Helper to calculate router imbalance given current estimates
    def get_router_imbalance(rid):
        if_list = topology.get(rid, [])
        total_in = 0.0
        total_out = 0.0
        for iid in if_list:
            total_in += current_estimates.get(iid, {}).get('rx', 0.0)
            total_out += current_estimates.get(iid, {}).get('tx', 0.0)
        return total_in - total_out, max(total_in, total_out, 1.0)

    # Iteration loop
    for _ in range(ITERATIONS):
        updates = {} # Store updates to apply after full pass

        for flow_prob in suspect_flows:
            link_key = flow_prob['key']
            direction = flow_prob['dir']
            candidates = flow_prob['candidates']

            # Identify interfaces and routers involved
            info = links[link_key]
            if direction == '1_to_2':
                src_if, dst_if = info['if1'], info['if2']
                val_src, val_dst = candidates[0], candidates[1] # src measured tx, dst measured rx
            else:
                src_if, dst_if = info['if2'], info['if1']
                val_src, val_dst = candidates[0], candidates[1]

            router_src = if_to_router.get(src_if)
            router_dst = if_to_router.get(dst_if)

            # Evaluate Hypothesis 1: Value is val_src (Local TX measurement)
            # Evaluate Hypothesis 2: Value is val_dst (Peer RX measurement)
            hyps = [val_src, val_dst]
            scores = []

            for h_val in hyps:
                # Probability score based on Gaussian likelihood of imbalance

                # Check Source Router Imbalance if we use h_val for this TX interface
                old_tx = current_estimates[src_if]['tx']
                current_estimates[src_if]['tx'] = h_val
                imb_src, flow_src = get_router_imbalance(router_src)
                current_estimates[src_if]['tx'] = old_tx

                # Check Dest Router Imbalance if we use h_val for this RX interface
                old_rx = current_estimates[dst_if]['rx']
                current_estimates[dst_if]['rx'] = h_val
                imb_dst, flow_dst = get_router_imbalance(router_dst)
                current_estimates[dst_if]['rx'] = old_rx

                # Likelihood function: P ~ exp(- |imbalance| / sigma)
                # sigma is tolerance proportional to flow
                sigma_src = max(flow_src * CONSERVATION_TOLERANCE_PCT, 1.0)
                sigma_dst = max(flow_dst * CONSERVATION_TOLERANCE_PCT, 1.0)

                score_src = math.exp(-abs(imb_src) / sigma_src)
                score_dst = math.exp(-abs(imb_dst) / sigma_dst)

                scores.append(score_src * score_dst)

            # Select Winner
            s1, s2 = scores[0], scores[1]
            total_s = s1 + s2 + 1e-9

            p1 = s1 / total_s
            p2 = s2 / total_s

            if p1 > p2:
                winner_val = val_src
                conf = p1
            else:
                winner_val = val_dst
                conf = p2

            # Store update
            updates[(src_if, 'tx')] = (winner_val, conf)
            updates[(dst_if, 'rx')] = (winner_val, conf)

        # Apply updates
        for (if_id, metric), (val, conf) in updates.items():
            current_estimates[if_id][metric] = val
            estimate_confidence[if_id][metric] = conf

    # --- Step 2.5: Global Confidence Calibration ---
    # Down-weight confidence for interfaces connected to routers that remain imbalanced.
    # This captures the "all hypotheses bad" or "external link invalid" cases.

    for rid, if_list in topology.items():
        imb, flow = get_router_imbalance(rid)
        imb_ratio = abs(imb) / flow

        # If imbalance > tolerance, penalize confidence
        # Penalty starts at tolerance (0.03) and reaches max (0 conf) at 13% imbalance
        if imb_ratio > CONSERVATION_TOLERANCE_PCT:
            penalty_factor = max(0.0, 1.0 - (imb_ratio - CONSERVATION_TOLERANCE_PCT) * 10.0)

            for iid in if_list:
                if iid in estimate_confidence:
                    if 'rx' in estimate_confidence[iid]:
                        estimate_confidence[iid]['rx'] *= penalty_factor
                    if 'tx' in estimate_confidence[iid]:
                        estimate_confidence[iid]['tx'] *= penalty_factor
>>>>>>> REPLACE
</DIFF>