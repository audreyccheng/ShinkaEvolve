<NAME>conservation_augmented_consensus</NAME>
<DESCRIPTION>
Introduces "Conservation-Augmented Hypothesis Generation" for internal flows.
Currently, the solver only tests measured values (and their mean) against conservation constraints. If both measurements on a link are corrupted (e.g. under-counting), the solver cannot find the true value even if the router's other links strongly imply it.
This change adds "Implied" candidates to the hypothesis set for internal flows. These candidates are derived from the router's current imbalance (i.e., "what value would perfectly balance this router?"). To prevent noise propagation, these candidates are only generated if the router has a sufficient reliability score (>0.25).
The prior probability logic is updated to trust these implied candidates proportional to the router's reliability, effectively allowing strong topological evidence to override corrupt measurements.
Also refines the phantom-flow (0.0 hypothesis) penalty to be magnitude-aware for external links as well, preventing large flows from being zeroed out.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
                # Candidates
                cands = [c for c in flow['cands'] if c >= 0]
                if len(cands) == 2:
                    v1, v2 = cands
                    if abs(v1 - v2) < max(v1, v2) * 0.2 + 5.0:
                        cands.append((v1 + v2) / 2.0)

                hyps = sorted(list(set(cands + [0.0])))
                curr_tx = estimates[src]['tx']
                curr_rx = estimates[dst]['rx']

                scores = []
                for h in hyps:
                    estimates[src]['tx'] = h
                    estimates[dst]['rx'] = h

                    imb_s, flow_s = get_router_state(r_src)
                    score_s = math.exp(-abs(imb_s)/calc_sigma(flow_s, rel_src)) if r_src else 1.0

                    imb_d, flow_d = get_router_state(r_dst)
                    score_d = math.exp(-abs(imb_d)/calc_sigma(flow_d, rel_dst)) if r_dst else 1.0

                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src')
                        s_dst = flow.get('status_dst')
                        if s_src == 'down' or s_dst == 'down': prior = 0.98
                        else:
                            max_meas = max(flow['cands'])
                            if max_meas > 10.0: prior = 0.01
                            elif max_meas > 1.0: prior = 0.2
                    else:
                        min_dist = min([abs(h - c) for c in flow['cands']])
                        prior = math.exp(-min_dist / max(h*0.05, 1.0))

                    scores.append(score_s * score_d * prior)
=======
                # Candidates
                cands = [c for c in flow['cands'] if c >= 0]

                # Conservation-Augmented Candidates
                implied_cands = []

                # Implied from Src
                if r_src:
                    curr_t = estimates[src]['tx']
                    imb_s, _ = get_router_state(r_src)
                    # target = curr + imb (since TX contributes -val to imbalance In-Out)
                    imp_s = max(0.0, curr_t + imb_s)
                    if rel_src > 0.25: # Threshold to trust conservation suggestion
                        implied_cands.append(('src', imp_s, rel_src))

                # Implied from Dst
                if r_dst:
                    curr_r = estimates[dst]['rx']
                    imb_d, _ = get_router_state(r_dst)
                    # target = curr - imb (since RX contributes +val to imbalance)
                    imp_d = max(0.0, curr_r - imb_d)
                    if rel_dst > 0.25:
                        implied_cands.append(('dst', imp_d, rel_dst))

                # Standard candidates
                if len(cands) == 2:
                    v1, v2 = cands
                    if abs(v1 - v2) < max(v1, v2) * 0.2 + 5.0:
                        cands.append((v1 + v2) / 2.0)

                hyps = set(cands + [0.0])
                for _, val, _ in implied_cands:
                    hyps.add(val)
                hyps = sorted(list(hyps))

                curr_tx = estimates[src]['tx']
                curr_rx = estimates[dst]['rx']

                scores = []
                for h in hyps:
                    estimates[src]['tx'] = h
                    estimates[dst]['rx'] = h

                    imb_s, flow_s = get_router_state(r_src)
                    score_s = math.exp(-abs(imb_s)/calc_sigma(flow_s, rel_src)) if r_src else 1.0

                    imb_d, flow_d = get_router_state(r_dst)
                    score_d = math.exp(-abs(imb_d)/calc_sigma(flow_d, rel_dst)) if r_dst else 1.0

                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src')
                        s_dst = flow.get('status_dst')
                        if s_src == 'down' or s_dst == 'down': prior = 0.98
                        else:
                            max_meas = max(flow['cands'])
                            if max_meas > 100.0: prior = 0.001
                            elif max_meas > 10.0: prior = 0.01
                            elif max_meas > 1.0: prior = 0.2
                    else:
                        # Measurement support
                        dist_meas = min([abs(h - c) for c in flow['cands']])
                        p_meas = math.exp(-dist_meas / max(h*0.05, 1.0))

                        # Conservation support
                        p_cons = 0.0
                        for _, val, rel in implied_cands:
                             if abs(h - val) < max(val * 0.05, 1.0):
                                 p_cons = max(p_cons, 0.9 * rel)

                        prior = max(p_meas, p_cons) + 1e-6

                    scores.append(score_s * score_d * prior)
>>>>>>> REPLACE
<<<<<<< SEARCH
                    if h == 0.0:
                        if stat == 'down': prior = 0.98
                        elif meas > 10.0: prior = 0.01
                        else: prior = 0.5
=======
                    if h == 0.0:
                        if stat == 'down': prior = 0.98
                        elif meas > 100.0: prior = 0.001
                        elif meas > 10.0: prior = 0.01
                        else: prior = 0.5
>>>>>>> REPLACE
</DIFF>