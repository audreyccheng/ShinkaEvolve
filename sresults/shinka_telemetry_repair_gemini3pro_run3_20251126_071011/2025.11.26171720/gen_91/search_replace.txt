<NAME>
continuous_prior_and_neighbor_consensus
</NAME>

<DESCRIPTION>
1.  **Continuous Zero-Flow Prior**: Replaces hard thresholds for the "phantom traffic" (zero flow) hypothesis with a continuous exponential decay function. This prevents classification cliffs where a flow of 10.1 is treated vastly differently from 9.9.
2.  **Neighbor-Consensus Calibration**: Updates the confidence calculation for internal links to consider the goodness-of-fit of the *remote* router as well as the local router (using geometric mean). This ensures that we are not overconfident in repairs that satisfy local constraints but push imbalance to neighbors.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src')
                        s_dst = flow.get('status_dst')
                        if s_src == 'down' or s_dst == 'down': prior = 0.98
                        else:
                             m_val = max(flow['cands'])
                             if m_val > 5.0: prior = 0.01
                             elif m_val > 1.0: prior = 0.2
=======
                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src')
                        s_dst = flow.get('status_dst')
                        if s_src == 'down' or s_dst == 'down':
                            prior = 0.98
                        else:
                             # Continuous decay for zero-flow hypothesis on UP links
                             # Uses max candidate to scale probability (larger measurement -> less likely to be zero/phantom)
                             m_val = max(flow['cands'])
                             prior = 0.4 * math.exp(-m_val / 4.0)
>>>>>>> REPLACE
<<<<<<< SEARCH
                    prior = 1.0
                    if h == 0.0:
                        if stat == 'down': prior = 0.98
                        elif meas > 10.0: prior = 0.01
                        else: prior = 0.5
=======
                    prior = 1.0
                    if h == 0.0:
                        if stat == 'down':
                            prior = 0.98
                        else:
                            # Continuous decay
                            prior = 0.5 * math.exp(-meas / 4.0)
>>>>>>> REPLACE
<<<<<<< SEARCH
        def calc_conf(metric, rep_val, orig_val):
            if (if_id, metric) in anchors: return 0.98

            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Harmonic Mean of Solver Probability and Router Fit
            # If solver is unsure (split vote) -> Low Conf
            # If router is imbalanced (bad fit) -> Low Conf
            h_mean = 2 * (sol_prob * r_fit) / (sol_prob + r_fit + 1e-9)

            # Bonus for validating measurement (Small Repair)
            if abs(rep_val - orig_val) < max(orig_val * 0.05, 1.0):
                return max(h_mean, 0.85 * r_fit + 0.1)
            else:
                return h_mean
=======
        def calc_conf(metric, rep_val, orig_val):
            if (if_id, metric) in anchors: return 0.98

            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Incorporate neighbor fit for internal links (Geometric Mean)
            # A good repair must satisfy conservation at both ends of the link
            effective_fit = r_fit
            if 'remote_router' in data and data['remote_router'] in router_fits:
                remote_fit = router_fits[data['remote_router']]
                effective_fit = math.sqrt(r_fit * remote_fit)

            # Harmonic Mean of Solver Probability and Effective Router Fit
            h_mean = 2 * (sol_prob * effective_fit) / (sol_prob + effective_fit + 1e-9)

            # Bonus for validating measurement (Small Repair)
            if abs(rep_val - orig_val) < max(orig_val * 0.05, 1.0):
                # If we trust the measurement, confidence is mainly limited by the router fit
                return max(h_mean, 0.85 * effective_fit + 0.1)
            else:
                return h_mean
>>>>>>> REPLACE
</DIFF>