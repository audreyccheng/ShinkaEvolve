<NAME>
calibrate_confidence
</NAME>

<DESCRIPTION>
Improves confidence calibration by:
1. Increasing iterations for better convergence.
2. Reducing "Agreement" confidence from 1.0 to 0.95 to account for potential common-mode failures or measurement noise (avoiding overconfidence penalties).
3. Reducing "External Link" confidence from 1.0 to 0.90 since they lack redundant peer validation.
4. Correcting the Bayesian confidence mapping in the repair loop to use the actual posterior probability `p` instead of the aggressive `(p-0.5)*2` scaling, which was causing significant underconfidence/calibration error.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Configuration ---
    SYMMETRY_TOLERANCE = 0.02
    CONSERVATION_TOLERANCE_PCT = 0.03
    MIN_SIGNIFICANT_FLOW = 0.5
    ITERATIONS = 3
=======
    # --- Configuration ---
    SYMMETRY_TOLERANCE = 0.02
    CONSERVATION_TOLERANCE_PCT = 0.03
    MIN_SIGNIFICANT_FLOW = 0.5
    ITERATIONS = 5
>>>>>>> REPLACE
<<<<<<< SEARCH
            if diff / denom < SYMMETRY_TOLERANCE:
                # Consistent
                consensus = (val1_tx + val2_rx) / 2.0
                current_estimates[if1] = current_estimates.get(if1, {})
                current_estimates[if1]['tx'] = consensus
                current_estimates[if2] = current_estimates.get(if2, {})
                current_estimates[if2]['rx'] = consensus

                estimate_confidence[if1] = estimate_confidence.get(if1, {})
                estimate_confidence[if1]['tx'] = 1.0
                estimate_confidence[if2] = estimate_confidence.get(if2, {})
                estimate_confidence[if2]['rx'] = 1.0
            else:
=======
            if diff / denom < SYMMETRY_TOLERANCE:
                # Consistent
                consensus = (val1_tx + val2_rx) / 2.0
                current_estimates[if1] = current_estimates.get(if1, {})
                current_estimates[if1]['tx'] = consensus
                current_estimates[if2] = current_estimates.get(if2, {})
                current_estimates[if2]['rx'] = consensus

                estimate_confidence[if1] = estimate_confidence.get(if1, {})
                estimate_confidence[if1]['tx'] = 0.95
                estimate_confidence[if2] = estimate_confidence.get(if2, {})
                estimate_confidence[if2]['rx'] = 0.95
            else:
>>>>>>> REPLACE
<<<<<<< SEARCH
        else:
            # External Link: Trust local blindly for now (no peer to contradict)
            current_estimates[if1] = current_estimates.get(if1, {})
            current_estimates[if1]['tx'] = val1_tx
            estimate_confidence[if1] = estimate_confidence.get(if1, {})
            estimate_confidence[if1]['tx'] = 1.0 # Tentative

        # Analyze Flow IF2 -> IF1 (IF2 TX, IF1 RX)
        if if2:
            val2_tx = d2.get('tx_rate', 0.0)
            val1_rx = d1.get('rx_rate', 0.0)

            denom = max(val2_tx, val1_rx, 1.0)
            diff = abs(val2_tx - val1_rx)

            if diff / denom < SYMMETRY_TOLERANCE:
                consensus = (val2_tx + val1_rx) / 2.0
                current_estimates[if2]['tx'] = consensus
                current_estimates[if1]['rx'] = consensus
                estimate_confidence[if2]['tx'] = 1.0
                estimate_confidence[if1]['rx'] = 1.0
            else:
=======
        else:
            # External Link: Trust local blindly for now (no peer to contradict)
            current_estimates[if1] = current_estimates.get(if1, {})
            current_estimates[if1]['tx'] = val1_tx
            estimate_confidence[if1] = estimate_confidence.get(if1, {})
            estimate_confidence[if1]['tx'] = 0.90 # Less confident than hardened links

        # Analyze Flow IF2 -> IF1 (IF2 TX, IF1 RX)
        if if2:
            val2_tx = d2.get('tx_rate', 0.0)
            val1_rx = d1.get('rx_rate', 0.0)

            denom = max(val2_tx, val1_rx, 1.0)
            diff = abs(val2_tx - val1_rx)

            if diff / denom < SYMMETRY_TOLERANCE:
                consensus = (val2_tx + val1_rx) / 2.0
                current_estimates[if2]['tx'] = consensus
                current_estimates[if1]['rx'] = consensus
                estimate_confidence[if2]['tx'] = 0.95
                estimate_confidence[if1]['rx'] = 0.95
            else:
>>>>>>> REPLACE
<<<<<<< SEARCH
        else:
             # External RX
            val1_rx = d1.get('rx_rate', 0.0)
            current_estimates[if1]['rx'] = val1_rx
            estimate_confidence[if1]['rx'] = 1.0
=======
        else:
             # External RX
            val1_rx = d1.get('rx_rate', 0.0)
            current_estimates[if1]['rx'] = val1_rx
            estimate_confidence[if1]['rx'] = 0.90
>>>>>>> REPLACE
<<<<<<< SEARCH
            if p1 > p2:
                winner_val = val_src
                # Confidence is probability mass of winner
                # If p1 ~ 0.5, confidence is low. If p1 ~ 1.0, high.
                # Map 0.5-1.0 to 0.0-1.0 roughly
                conf = (p1 - 0.5) * 2.0
                conf = max(0.0, min(1.0, conf))
            else:
                winner_val = val_dst
                conf = (p2 - 0.5) * 2.0
                conf = max(0.0, min(1.0, conf))
=======
            if p1 > p2:
                winner_val = val_src
                conf = p1
            else:
                winner_val = val_dst
                conf = p2
>>>>>>> REPLACE
</DIFF>