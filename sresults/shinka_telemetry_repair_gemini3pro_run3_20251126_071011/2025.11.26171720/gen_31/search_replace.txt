<NAME>
calibrate_confidence_and_add_zero_hypothesis
</NAME>

<DESCRIPTION>
1.  Introduces a `0.0` flow hypothesis in the Bayesian solver to correctly identify phantom traffic on down links or idle links with noise.
2.  Scales the confidence score by the absolute "goodness of fit" (likelihood score) rather than just relative probability. This ensures that "best of a bad bunch" solutions receive low confidence, improving calibration.
3.  Refines the global calibration step (Step 2.5) to protect hardened (symmetric) links from being penalized due to unrelated router imbalances (e.g., from external links), while still penalizing unverified external links.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # Evaluate Hypothesis 1: Value is val_src (Local TX measurement)
            # Evaluate Hypothesis 2: Value is val_dst (Peer RX measurement)
            hyps = [val_src, val_dst]
            scores = []

            for h_val in hyps:
                # Probability score based on Gaussian likelihood of imbalance

                # Check Source Router Imbalance if we use h_val for this TX interface
                old_tx = current_estimates[src_if]['tx']
                current_estimates[src_if]['tx'] = h_val
                imb_src, flow_src = get_router_imbalance(router_src)
                current_estimates[src_if]['tx'] = old_tx

                # Check Dest Router Imbalance if we use h_val for this RX interface
                old_rx = current_estimates[dst_if]['rx']
                current_estimates[dst_if]['rx'] = h_val
                imb_dst, flow_dst = get_router_imbalance(router_dst)
                current_estimates[dst_if]['rx'] = old_rx

                # Likelihood function: P ~ exp(- |imbalance| / sigma)
                # sigma is tolerance proportional to flow
                sigma_src = max(flow_src * CONSERVATION_TOLERANCE_PCT, 1.0)
                sigma_dst = max(flow_dst * CONSERVATION_TOLERANCE_PCT, 1.0)

                score_src = math.exp(-abs(imb_src) / sigma_src)
                score_dst = math.exp(-abs(imb_dst) / sigma_dst)

                scores.append(score_src * score_dst)

            # Select Winner
            s1, s2 = scores[0], scores[1]
            total_s = s1 + s2 + 1e-9

            p1 = s1 / total_s
            p2 = s2 / total_s

            if p1 > p2:
                winner_val = val_src
                conf = p1
            else:
                winner_val = val_dst
                conf = p2

            # Store update
            updates[(src_if, 'tx')] = (winner_val, conf)
            updates[(dst_if, 'rx')] = (winner_val, conf)
=======
            # Evaluate Hypotheses: Local, Peer, and Zero (Phantom traffic)
            # We use a set to handle duplicates (e.g. if Local == Peer, or Local == 0)
            unique_hyps = sorted(list(set([val_src, val_dst, 0.0])))
            scores = []

            for h_val in unique_hyps:
                # Probability score based on Gaussian likelihood of imbalance

                # Check Source Router Imbalance if we use h_val for this TX interface
                old_tx = current_estimates[src_if]['tx']
                current_estimates[src_if]['tx'] = h_val
                imb_src, flow_src = get_router_imbalance(router_src)
                current_estimates[src_if]['tx'] = old_tx

                # Check Dest Router Imbalance if we use h_val for this RX interface
                old_rx = current_estimates[dst_if]['rx']
                current_estimates[dst_if]['rx'] = h_val
                imb_dst, flow_dst = get_router_imbalance(router_dst)
                current_estimates[dst_if]['rx'] = old_rx

                # Likelihood function: P ~ exp(- |imbalance| / sigma)
                # sigma is tolerance proportional to flow
                sigma_src = max(flow_src * CONSERVATION_TOLERANCE_PCT, 1.0)
                sigma_dst = max(flow_dst * CONSERVATION_TOLERANCE_PCT, 1.0)

                score_src = math.exp(-abs(imb_src) / sigma_src)
                score_dst = math.exp(-abs(imb_dst) / sigma_dst)

                scores.append(score_src * score_dst)

            # Select Winner
            total_s = sum(scores) + 1e-9
            best_idx = 0
            best_p = 0.0

            for i, s in enumerate(scores):
                p = s / total_s
                if p > best_p:
                    best_p = p
                    best_idx = i

            winner_val = unique_hyps[best_idx]
            winner_score = scores[best_idx]

            # Calibration: Confidence = Probability * Absolute Goodness of Fit
            # Geometric mean of component scores gives per-router fit quality
            fit_quality = math.sqrt(winner_score)
            conf = best_p * fit_quality

            # Store update
            updates[(src_if, 'tx')] = (winner_val, conf)
            updates[(dst_if, 'rx')] = (winner_val, conf)
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Step 2.5: Global Confidence Calibration ---
    # Down-weight confidence for interfaces connected to routers that remain imbalanced.
    # This captures the "all hypotheses bad" or "external link invalid" cases.

    for rid, if_list in topology.items():
        imb, flow = get_router_imbalance(rid)
        imb_ratio = abs(imb) / flow

        # If imbalance > tolerance, penalize confidence
        # Penalty starts at tolerance (0.03) and reaches max (0 conf) at 13% imbalance
        if imb_ratio > CONSERVATION_TOLERANCE_PCT:
            penalty_factor = max(0.0, 1.0 - (imb_ratio - CONSERVATION_TOLERANCE_PCT) * 10.0)

            for iid in if_list:
                if iid in estimate_confidence:
                    if 'rx' in estimate_confidence[iid]:
                        estimate_confidence[iid]['rx'] *= penalty_factor
                    if 'tx' in estimate_confidence[iid]:
                        estimate_confidence[iid]['tx'] *= penalty_factor
=======
    # --- Step 2.5: Global Confidence Calibration ---
    # Down-weight confidence for interfaces connected to routers that remain imbalanced.
    # We primarily target external/suspect links, trusting hardened symmetric links more.

    for rid, if_list in topology.items():
        imb, flow = get_router_imbalance(rid)
        imb_ratio = abs(imb) / max(flow, 1.0)

        # If imbalance > tolerance, penalize confidence of non-hardened links
        # Penalty starts at tolerance (0.03) and reaches max penalty at 13% imbalance
        if imb_ratio > CONSERVATION_TOLERANCE_PCT:
            penalty_factor = max(0.0, 1.0 - (imb_ratio - CONSERVATION_TOLERANCE_PCT) * 10.0)

            for iid in if_list:
                if iid in estimate_confidence:
                    # Only penalize if confidence is not extremely high (hardened links are ~0.95)
                    # We assume 0.95+ implies verified symmetry which outweighs global imbalance
                    if 'rx' in estimate_confidence[iid] and estimate_confidence[iid]['rx'] < 0.94:
                        estimate_confidence[iid]['rx'] *= penalty_factor
                    if 'tx' in estimate_confidence[iid] and estimate_confidence[iid]['tx'] < 0.94:
                        estimate_confidence[iid]['tx'] *= penalty_factor
>>>>>>> REPLACE
</DIFF>