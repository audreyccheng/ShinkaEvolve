<NAME>
adaptive_trust_consensus
</NAME>

<DESCRIPTION>
This edit refines the `solve` (Phase 2) and `calibrate` (Phase 3) functions to improve repair accuracy and confidence calibration.

Key improvements:
1. **Dynamic Self-Trust**: Instead of a fixed weight (0.8) for `s_val` (local telemetry), we scale the weight based on the router's global `trust` score (`0.4 + 0.6 * trust`). This allows the model to trust "Self" more when the device is proven reliable, and less when it is noisy.
2. **Edge Trust Transfer**: For edge links (no peer), we significantly boost the weight of the Flow Hypothesis if the router is trusted (`trust > 0.8`). This allows verified internal traffic to "push" corrections to the edge.
3. **Magnitude-Dependent Zero Penalty**: The penalty for the zero-hypothesis (when Status=UP) is now dynamic. If alternative hypotheses suggest large traffic (high magnitude), the zero-hypothesis is penalized more heavily. This reduces false negatives (phantom traffic) while avoiding false positives in low-noise environments.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            def solve(current, s_val, p_val, is_rx):
                # Flow Target
                f_val = None
                f_w = 0.0
                f_sigma_mult = 1.0

                if r_info:
                    if is_rx:
                        others = r_info['sin'] - current
                        f_val = max(0.0, r_info['sout'] - others)
                    else:
                        others = r_info['sout'] - current
                        f_val = max(0.0, r_info['sin'] - others)

                    # Trust Boost: If router is verified (Trust > 0.8) and Balanced,
                    # we boost flow weight to override local errors.
                    base_w = 2.5 * r_info['trust'] * (0.2 + 0.8 * r_info['balance'])
                    if r_info['trust'] > 0.8 and r_info['balance'] > 0.8:
                        f_weight = base_w * 2.0
                    else:
                        f_weight = base_w

                    f_w = f_weight

                    # Adaptive Sigma: Widen acceptance window if router is imbalanced
                    f_sigma_mult = 1.0 + 3.0 * (1.0 - r_info['balance'])

                # Candidates
                candidates = [s_val, 0.0]
                if d['has_peer']: candidates.append(p_val)
                if f_val is not None: candidates.append(f_val)

                # Noise Cluster Mean
                if d['has_peer']:
                    diff = abs(s_val - p_val)
                    if diff > ABS_TOL and (diff / max(s_val, p_val, 1.0)) < 0.2:
                        candidates.append((s_val + p_val) / 2.0)

                # Evaluation
                best_val = current
                best_score = -1.0

                unique_cands = sorted(list(set(candidates)))

                for cand in unique_cands:
                    sigma = get_sigma(cand)

                    # Sources
                    sc_s = 0.8 * gaussian_score(cand, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(cand, p_val, sigma) if d['has_peer'] else 0.0

                    # Flow score with adaptive sigma
                    sc_f = 0.0
                    if f_val is not None:
                         eff_sigma = sigma * f_sigma_mult
                         sc_f = f_w * gaussian_score(cand, f_val, eff_sigma)

                    score = sc_s + sc_p + sc_f

                    # Status-Aware Priors
                    if is_zero(cand):
                        flow_says_zero = (f_val is not None) and (f_val < ABS_TOL)
                        if not flow_says_zero:
                            score *= 0.05
                        else:
                            score *= 0.5

                    if score > best_score:
                        best_score = score
                        best_val = cand

                return best_val
=======
            def solve(current, s_val, p_val, is_rx):
                # Flow Target
                f_val = None
                f_w = 0.0
                f_sigma_mult = 1.0

                # Dynamic Self Trust
                w_self = 0.4 + 0.6 * (r_info['trust'] if r_info else 0.5)

                if r_info:
                    if is_rx:
                        others = r_info['sin'] - current
                        f_val = max(0.0, r_info['sout'] - others)
                    else:
                        others = r_info['sout'] - current
                        f_val = max(0.0, r_info['sin'] - others)

                    # Flow Weighting
                    base_w = 2.0 * r_info['trust'] * (0.3 + 0.7 * r_info['balance'])
                    # Edge Trust Transfer: Boost flow for edge links if router is trusted
                    if not d['has_peer'] and r_info['trust'] > 0.8:
                        base_w *= 2.0
                    f_w = base_w

                    # Adaptive Sigma: Widen acceptance window if router is imbalanced
                    f_sigma_mult = 1.0 + 3.0 * (1.0 - r_info['balance'])

                # Candidates
                candidates = [s_val, 0.0]
                if d['has_peer']: candidates.append(p_val)
                if f_val is not None: candidates.append(f_val)

                # Noise Cluster Mean
                if d['has_peer']:
                    diff = abs(s_val - p_val)
                    if diff > ABS_TOL and (diff / max(s_val, p_val, 1.0)) < 0.2:
                        candidates.append((s_val + p_val) / 2.0)

                # Evaluation
                best_val = current
                best_score = -1.0

                unique_cands = sorted(list(set(candidates)))
                max_mag = max(unique_cands) if unique_cands else 0.0

                for cand in unique_cands:
                    sigma = get_sigma(cand)

                    # Sources
                    sc_s = w_self * gaussian_score(cand, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(cand, p_val, sigma) if d['has_peer'] else 0.0

                    # Flow score with adaptive sigma
                    sc_f = 0.0
                    if f_val is not None:
                         eff_sigma = sigma * f_sigma_mult
                         sc_f = f_w * gaussian_score(cand, f_val, eff_sigma)

                    score = sc_s + sc_p + sc_f

                    # Status-Aware Priors with Magnitude Dependency
                    if is_zero(cand):
                        flow_says_zero = (f_val is not None) and (f_val < ABS_TOL)
                        if flow_says_zero:
                            score *= 0.5
                        else:
                            # Higher alternative magnitude -> Zero is less likely
                            deg = 1.0 / (1.0 + max_mag / 10.0)
                            score *= (0.05 + 0.1 * deg)

                    if score > best_score:
                        best_score = score
                        best_val = cand

                return best_val
>>>>>>> REPLACE
<<<<<<< SEARCH
            def calibrate(val, s_val, p_val, is_rx):
                f_val = None
                f_w = 0.0
                f_sigma_mult = 1.0

                if r_info:
                    if is_rx: target = r_info['sout'] - (r_info['sin'] - d['est_rx'])
                    else:     target = r_info['sin'] - (r_info['sout'] - d['est_tx'])
                    f_val = max(0.0, target)

                    base_w = 2.5 * r_info['trust'] * (0.2 + 0.8 * r_info['bal'])
                    if r_info['trust'] > 0.8 and r_info['bal'] > 0.8:
                        f_w = base_w * 2.0
                    else:
                        f_w = base_w

                    f_sigma_mult = 1.0 + 3.0 * (1.0 - r_info['bal'])

                hyps = {val, s_val, 0.0}
                if d['has_peer']: hyps.add(p_val)
                if f_val is not None: hyps.add(f_val)
                if d['has_peer']: hyps.add((s_val + p_val)/2.0)

                cluster_mass = 0.0
                total_mass = 0.0
                sigma_win = get_sigma(val)

                def get_score(h, sigma):
                    sc_s = 0.8 * gaussian_score(h, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(h, p_val, sigma) if d['has_peer'] else 0.0
                    sc_f = 0.0
                    if f_val is not None:
                        sc_f = f_w * gaussian_score(h, f_val, sigma * f_sigma_mult)

                    tot = sc_s + sc_p + sc_f

                    if is_zero(h):
                        flow_zero = (f_val is not None) and (f_val < ABS_TOL)
                        if not flow_zero: tot *= 0.05
                        else: tot *= 0.5
                    return tot

                for h in hyps:
                    sigma = get_sigma(h)
                    s = get_score(h, sigma)
                    total_mass += s
                    if abs(h - val) <= sigma_win:
                        cluster_mass += s

                if total_mass < 1e-9: return 0.5

                raw_prob = cluster_mass / total_mass

                peer_support = d['has_peer'] and (abs(val - p_val) <= sigma_win)
                flow_support = (f_val is not None) and (abs(val - f_val) <= (sigma_win * f_sigma_mult))

                if not peer_support and not flow_support:
                    raw_prob = min(raw_prob, 0.75)

                if not peer_support and flow_support:
                    max_conf = 0.6 + 0.4 * r_info['trust']
                    raw_prob = min(raw_prob, max_conf)

                return max(0.5, min(1.0, raw_prob))
=======
            def calibrate(val, s_val, p_val, is_rx):
                f_val = None
                f_w = 0.0
                f_sigma_mult = 1.0

                w_self = 0.4 + 0.6 * (r_info['trust'] if r_info else 0.5)

                if r_info:
                    if is_rx: target = r_info['sout'] - (r_info['sin'] - d['est_rx'])
                    else:     target = r_info['sin'] - (r_info['sout'] - d['est_tx'])
                    f_val = max(0.0, target)

                    base_w = 2.0 * r_info['trust'] * (0.3 + 0.7 * r_info['bal'])
                    if not d['has_peer'] and r_info['trust'] > 0.8:
                        base_w *= 2.0
                    f_w = base_w

                    f_sigma_mult = 1.0 + 3.0 * (1.0 - r_info['bal'])

                hyps = {val, s_val, 0.0}
                if d['has_peer']: hyps.add(p_val)
                if f_val is not None: hyps.add(f_val)
                if d['has_peer']: hyps.add((s_val + p_val)/2.0)

                max_mag = max(hyps) if hyps else 0.0

                cluster_mass = 0.0
                total_mass = 0.0
                sigma_win = get_sigma(val)

                def get_score(h, sigma):
                    sc_s = w_self * gaussian_score(h, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(h, p_val, sigma) if d['has_peer'] else 0.0
                    sc_f = 0.0
                    if f_val is not None:
                        sc_f = f_w * gaussian_score(h, f_val, sigma * f_sigma_mult)

                    tot = sc_s + sc_p + sc_f

                    if is_zero(h):
                        flow_zero = (f_val is not None) and (f_val < ABS_TOL)
                        if flow_zero:
                            tot *= 0.5
                        else:
                            deg = 1.0 / (1.0 + max_mag / 10.0)
                            tot *= (0.05 + 0.1 * deg)
                    return tot

                for h in hyps:
                    sigma = get_sigma(h)
                    s = get_score(h, sigma)
                    total_mass += s
                    if abs(h - val) <= sigma_win:
                        cluster_mass += s

                if total_mass < 1e-9: return 0.5

                raw_prob = cluster_mass / total_mass

                peer_support = d['has_peer'] and (abs(val - p_val) <= sigma_win)
                flow_support = (f_val is not None) and (abs(val - f_val) <= (sigma_win * f_sigma_mult))

                if not peer_support and not flow_support:
                    raw_prob = min(raw_prob, 0.75)

                if not peer_support and flow_support:
                    max_conf = 0.6 + 0.4 * r_info['trust']
                    raw_prob = min(raw_prob, max_conf)

                return max(0.5, min(1.0, raw_prob))
>>>>>>> REPLACE
</DIFF>