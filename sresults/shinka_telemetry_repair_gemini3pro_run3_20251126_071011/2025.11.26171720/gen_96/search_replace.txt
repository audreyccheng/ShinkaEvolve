<NAME>
reliability_prior_and_conf_calib
</NAME>

<DESCRIPTION>
1. Implements a source-reliability weighted prior for internal links in Step 2. This biases the solver to trust measurements from reliable routers (anchors) over unreliable ones when conflicts occur.
2. Refines the final confidence calculation in Step 3. Replaces the pessimistic Harmonic Mean with a linear weighted model dominated by Router Fit. This addresses the underconfidence issue by ensuring that physically consistent repairs (high fit) receive high confidence even if solver margin was moderate.
3. Tightens the sigma used for final Router Fit calculation (from iter 0 to iter 2) to ensure the 'Good Fit' signal is meaningful and discriminatory.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    Improvements:
    1.  **Noise Model**: Adopts the 1.5x Sqrt scaling from the Momentum approach, which better handles
        high-variance noisy measurements than the stricter model.
    2.  **Discrete Hypothesis Space**: Removes the 'Mean' candidate used in the Calibrated approach.
        Experiments suggest forcing a choice between specific measurements (or 0) yields higher accuracy
        than averaging, likely because errors are often discrete (e.g. packet drops) rather than Gaussian noise.
    3.  **Hybrid Confidence**: Combines the Solver Probability (margin of victory) from the Calibrated approach
        with the Router Fit metric.
    4.  **Anchor-Aware External Validation**: Keeps the Anchor Ratio logic from the Calibrated approach to
        validate external links, but incorporates the Gaussian measurement prior from the Momentum approach.
=======
    Improvements:
    1.  **Reliability-Weighted Priors**: Biases internal link priors towards measurements from reliable routers
        (high anchor count), improving selection accuracy in conflicting scenarios.
    2.  **Calibrated Confidence Score**: Replaces the pessimistic Harmonic Mean with a linear scaling model
        weighted heavily by Router Fit, fixing underconfidence issues while maintaining discrimination.
    3.  **Refined Fit Calculation**: Uses a stricter sigma (iteration 2 equivalent) for final fit metrics
        to better differentiate between "plausible" and "excellent" repairs.
>>>>>>> REPLACE
<<<<<<< SEARCH
                    else:
                        # Distance to nearest candidate
                        min_dist = min([abs(h - c) for c in flow['cands']])
                        # Gaussian decay
                        prior = math.exp(-min_dist / max(h*0.05, 1.0))

                    scores.append(score_s * score_d * prior)
=======
                    else:
                        # Reliability-weighted measurement prior
                        # We trust the measurement from the more reliable router
                        p_max = 0.0
                        for i, c_val in enumerate(flow['cands']):
                             if c_val < 0: continue
                             # i=0 is src, i=1 is dst
                             r_score = rel_src if i == 0 else rel_dst
                             dist = abs(h - c_val)
                             # Gaussian decay
                             g = math.exp(-dist / max(h*0.05, 1.0))
                             # Reliability weight: 0.6 base + 0.4 * reliability
                             w = 0.6 + 0.4 * r_score
                             p_max = max(p_max, w * g)
                        prior = p_max

                    scores.append(score_s * score_d * prior)
>>>>>>> REPLACE
<<<<<<< SEARCH
    router_fits = {}
    for rid in topology:
        imb, flow = get_router_state(rid)
        # Use final iteration parameters (tightest sigma) for strict fit check
        rel = router_reliability.get(rid, 0.5)
        # Use base sigma (iter=0 for loose constraint) to not penalize small imbalances
        sig = calc_sigma(flow, rel, 0)
        fit = math.exp(-abs(imb) / sig)
        router_fits[rid] = fit

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        rep_rx = estimates[if_id]['rx']
        rep_tx = estimates[if_id]['tx']

        rid = if_to_router.get(if_id)
        r_fit = router_fits.get(rid, 0.8)

        def calc_conf(metric, rep_val, orig_val):
            if (if_id, metric) in anchors: return 0.98

            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Incorporate neighbor fit for internal links (Geometric Mean)
            # A good repair must satisfy conservation at both ends of the link
            effective_fit = r_fit
            if 'remote_router' in data and data['remote_router'] in router_fits:
                remote_fit = router_fits[data['remote_router']]
                effective_fit = math.sqrt(r_fit * remote_fit)

            # Harmonic Mean of Solver Probability and Effective Router Fit
            h_mean = 2 * (sol_prob * effective_fit) / (sol_prob + effective_fit + 1e-9)

            # Bonus for validating measurement (Small Repair)
            if abs(rep_val - orig_val) < max(orig_val * 0.05, 1.0):
                # If we trust the measurement, confidence is mainly limited by the router fit
                return max(h_mean, 0.85 * effective_fit + 0.1)
            else:
                return h_mean
=======
    router_fits = {}
    for rid in topology:
        imb, flow = get_router_state(rid)
        # Use computed reliability for sigma scaling
        rel = router_reliability.get(rid, 0.5)
        # Use moderate sigma (iteration 2) for fit calculation to ensure meaningful fitness differentiation
        # Too loose (iter 0) -> everyone fits. Too tight (iter 5) -> noise punishes too hard.
        sig = calc_sigma(flow, rel, 2)
        fit = math.exp(-abs(imb) / sig)
        router_fits[rid] = fit

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        rep_rx = estimates[if_id]['rx']
        rep_tx = estimates[if_id]['tx']

        rid = if_to_router.get(if_id)
        r_fit = router_fits.get(rid, 0.8)

        def calc_conf(metric, rep_val, orig_val):
            if (if_id, metric) in anchors: return 0.98

            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Incorporate neighbor fit for internal links (Geometric Mean)
            effective_fit = r_fit
            if 'remote_router' in data and data['remote_router'] in router_fits:
                remote_fit = router_fits[data['remote_router']]
                effective_fit = math.sqrt(r_fit * remote_fit)

            # Calibrated Confidence:
            # Primary signal is effective_fit (physical consistency).
            # Secondary signal is sol_prob (solver certainty/uniqueness).
            # Formula: Fit * (Base + Scale * Prob)
            # This avoids punishing good fits with moderate solver uncertainty.
            base_conf = effective_fit * (0.75 + 0.25 * sol_prob)

            # Bonus for validating measurement (Small Repair)
            if abs(rep_val - orig_val) < max(orig_val * 0.05, 1.0):
                # If we agree with measurement, confidence boosts slightly
                return max(base_conf, 0.85 * effective_fit + 0.1)
            else:
                return base_conf
>>>>>>> REPLACE
</DIFF>