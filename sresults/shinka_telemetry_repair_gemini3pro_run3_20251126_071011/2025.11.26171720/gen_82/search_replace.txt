<NAME>
reliability_adaptive_consensus
</NAME>

<DESCRIPTION>
Introduces a device-level "Anchor Score" (reliability) to weight the consensus process.
1.  Calculates `router_reliability` based on the ratio of trustworthy (Anchor) links to total flow on a router.
2.  Updates `calc_sigma` to be variance-adaptive: reliable routers get tighter sigma (stricter conservation), unreliable ones get looser sigma.
3.  Modifies External Link logic to transfer trust: if a router is reliable, we trust its conservation (Implied value) more than the measurement.
4.  Re-introduces "Adaptive Locking" to freeze high-confidence flows mid-convergence, stabilizing the network.
5.  Updates Confidence Calibration to use a Harmonic Mean of Solver Probability and Router Fit, rewarding solutions that are both statistically likely and physically consistent.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 2: Iterative Solver ---

    def get_router_state(rid):
        if rid not in topology: return 0.0, 1.0
        tin, tout = 0.0, 0.0
        max_f = 0.0
        for iid in topology[rid]:
            if iid in estimates:
                r, t = estimates[iid]['rx'], estimates[iid]['tx']
                tin += r
                tout += t
                max_f = max(max_f, r, t)
        return (tin - tout), max(max_f, 1.0)

    def calc_sigma(flow_val):
        # Adaptive noise model: Sqrt(flow) dominates at low rates, Pct(flow) at high rates
        return max(math.sqrt(flow_val), flow_val * CONSERVATION_TOLERANCE_PCT, 1.0)

    # Track solver confidence to pass to Step 3
    solver_confidences = {}

    for iter_idx in range(ITERATIONS):
        updates = []

        for flow in suspect_flows:
            # Prepare context
            if flow['type'] == 'internal':
                src, dst = flow['src'], flow['dst']
                r_src = if_to_router.get(src)
                r_dst = if_to_router.get(dst)

                # Candidates: [Meas1, Meas2, Mean?, 0.0]
                cands = [c for c in flow['cands'] if c >= 0]
                # Add mean if close
                if len(cands) == 2:
                    v1, v2 = cands
                    if abs(v1 - v2) < 0.1 * max(v1, v2, 1.0):
                        cands.append((v1 + v2) / 2.0)

                hyps = sorted(list(set(cands + [0.0])))

                curr_tx = estimates[src]['tx']
                curr_rx = estimates[dst]['rx']

                scores = []
                for h in hyps:
                    # Apply
                    estimates[src]['tx'] = h
                    estimates[dst]['rx'] = h

                    # Eval Src
                    imb_s, flow_s = get_router_state(r_src)
                    sig_s = calc_sigma(flow_s)
                    score_s = math.exp(-abs(imb_s)/sig_s) if r_src else 1.0

                    # Eval Dst
                    imb_d, flow_d = get_router_state(r_dst)
                    sig_d = calc_sigma(flow_d)
                    score_d = math.exp(-abs(imb_d)/sig_d) if r_dst else 1.0

                    # Prior
                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src', 'unknown')
                        s_dst = flow.get('status_dst', 'unknown')
                        if s_src == 'down' or s_dst == 'down':
                            prior = 0.95
                        else:
                            max_meas = max(flow['cands'])
                            if max_meas > 10.0: prior = 0.01
                            elif max_meas > 1.0: prior = 0.2

                    scores.append(score_s * score_d * prior)

                # Restore
                estimates[src]['tx'] = curr_tx
                estimates[dst]['rx'] = curr_rx

                # Pick winner
                total_score = sum(scores) + 1e-20
                probs = [s / total_score for s in scores]
                best_idx = scores.index(max(scores))
                win_val = hyps[best_idx]

                # Cluster probability for confidence
                win_prob = sum(p for i, p in enumerate(probs) if abs(hyps[i] - win_val) <= max(win_val * 0.05, 1.0))

                updates.append((src, 'tx', win_val, win_prob))
                updates.append((dst, 'rx', win_val, win_prob))

            elif flow['type'] == 'external':
                # External: We trust measurement unless implied value from conservation is much better
                if flow['src']: # TX external
                    if_id = flow['src']
                    r_id = if_to_router.get(if_id)
                    metric = 'tx'
                    meas = flow['cands'][0]
                    curr_val = estimates[if_id]['tx']
                    stat = flow.get('status_src')

                    imb, r_flow = get_router_state(r_id)
                    implied = max(0.0, curr_val + imb)

                else: # RX external
                    if_id = flow['dst']
                    r_id = if_to_router.get(if_id)
                    metric = 'rx'
                    meas = flow['cands'][0]
                    curr_val = estimates[if_id]['rx']
                    stat = flow.get('status_dst')

                    imb, r_flow = get_router_state(r_id)
                    implied = max(0.0, curr_val - imb)

                hyps = sorted(list(set([meas, implied, 0.0])))
                scores = []

                for h in hyps:
                    estimates[if_id][metric] = h
                    imb, rf = get_router_state(r_id)
                    sig = calc_sigma(rf)
                    lik = math.exp(-abs(imb)/sig) if r_id else 0.5

                    # Prior: Gaussian centered on measurement
                    sig_meas = max(meas * 0.05, 2.0)
                    prior = math.exp(-abs(h - meas)/sig_meas)

                    # Prior for 0.0
                    if h == 0.0:
                        if stat == 'down':
                            prior = 0.95
                        elif meas > 10.0: prior *= 0.01

                    scores.append(lik * prior)

                estimates[if_id][metric] = curr_val # Restore

                total_score = sum(scores) + 1e-20
                probs = [s / total_score for s in scores]
                best_idx = scores.index(max(scores))
                win_val = hyps[best_idx]

                win_prob = sum(p for i, p in enumerate(probs) if abs(hyps[i] - win_val) <= max(win_val * 0.05, 1.0))

                updates.append((if_id, metric, win_val, win_prob))

        # Apply Updates with Momentum
        for if_id, metric, val, prob in updates:
            old = estimates[if_id][metric]
            # Momentum update
            estimates[if_id][metric] = (old * (1 - MOMENTUM)) + (val * MOMENTUM)
            solver_confidences[(if_id, metric)] = prob
=======
    # --- Step 2: Iterative Solver ---

    # Pre-calculate Router Reliability (Anchor Score)
    # Ratios of trusted anchor flow to total flow. 1.0 = Highly Reliable.
    router_reliability = {}
    for rid in topology:
        trusted_flow = 0.0
        total_flow = 0.0
        for iid in topology[rid]:
            if iid in estimates:
                f = estimates[iid]['rx'] + estimates[iid]['tx']
                total_flow += f
                if (iid, 'rx') in anchors: trusted_flow += estimates[iid]['rx']
                if (iid, 'tx') in anchors: trusted_flow += estimates[iid]['tx']
        router_reliability[rid] = trusted_flow / max(total_flow, 1.0)

    def get_router_state(rid):
        if rid not in topology: return 0.0, 1.0
        tin, tout = 0.0, 0.0
        max_f = 0.0
        for iid in topology[rid]:
            if iid in estimates:
                r, t = estimates[iid]['rx'], estimates[iid]['tx']
                tin += r
                tout += t
                max_f = max(max_f, r, t)
        return (tin - tout), max(max_f, 1.0)

    def calc_sigma(flow_val, reliability=0.5):
        # Reliability-Aware Sigma:
        # Reliable routers (1.0) get tighter sigma (1.0x) to enforce strict conservation
        # Unreliable routers (0.0) get looser sigma (2.0x) to absorb their inherent noise
        base = max(1.5 * math.sqrt(flow_val), flow_val * CONSERVATION_TOLERANCE_PCT, 1.0)
        return base * (2.0 - reliability)

    solver_confidences = {}

    # Adaptive Locking: Lock high-confidence flows mid-convergence
    locked_indices = set()
    LOCKING_THRESHOLD = 0.92

    for iter_idx in range(ITERATIONS):
        updates = []
        allow_locking = (iter_idx == 2) # Attempt locking halfway

        for f_idx, flow in enumerate(suspect_flows):
            if f_idx in locked_indices: continue

            if flow['type'] == 'internal':
                src, dst = flow['src'], flow['dst']
                r_src = if_to_router.get(src)
                r_dst = if_to_router.get(dst)
                rel_src = router_reliability.get(r_src, 0.5)
                rel_dst = router_reliability.get(r_dst, 0.5)

                cands = [c for c in flow['cands'] if c >= 0]
                # Discrete choice + Mean if close
                if len(cands) == 2:
                    v1, v2 = cands
                    if abs(v1 - v2) < 0.15 * max(v1, v2, 1.0):
                        cands.append((v1 + v2) / 2.0)

                hyps = sorted(list(set(cands + [0.0])))
                curr_tx = estimates[src]['tx']
                curr_rx = estimates[dst]['rx']

                scores = []
                for h in hyps:
                    estimates[src]['tx'] = h
                    estimates[dst]['rx'] = h

                    imb_s, flow_s = get_router_state(r_src)
                    score_s = math.exp(-abs(imb_s)/calc_sigma(flow_s, rel_src)) if r_src else 1.0

                    imb_d, flow_d = get_router_state(r_dst)
                    score_d = math.exp(-abs(imb_d)/calc_sigma(flow_d, rel_dst)) if r_dst else 1.0

                    prior = 1.0
                    if h == 0.0:
                        s_src = flow.get('status_src')
                        s_dst = flow.get('status_dst')
                        if s_src == 'down' or s_dst == 'down': prior = 0.98
                        else:
                            max_meas = max(flow['cands'])
                            if max_meas > 10.0: prior = 0.01
                            elif max_meas > 1.0: prior = 0.2

                    scores.append(score_s * score_d * prior)

                estimates[src]['tx'] = curr_tx
                estimates[dst]['rx'] = curr_rx

                total = sum(scores) + 1e-20
                probs = [s/total for s in scores]
                best_idx = scores.index(max(scores))
                win_val = hyps[best_idx]
                win_prob = sum(p for i, p in enumerate(probs) if abs(hyps[i] - win_val) <= max(win_val * 0.05, 1.0))

                updates.append((src, 'tx', win_val, win_prob))
                updates.append((dst, 'rx', win_val, win_prob))

                if allow_locking and win_prob > LOCKING_THRESHOLD:
                    locked_indices.add(f_idx)

            elif flow['type'] == 'external':
                if flow['src']:
                    if_id = flow['src']; metric = 'tx'; meas = flow['cands'][0]
                    r_id = if_to_router.get(if_id)
                    curr = estimates[if_id]['tx']
                    stat = flow.get('status_src')
                    imb, r_flow = get_router_state(r_id)
                    implied = max(0.0, curr + imb)
                else:
                    if_id = flow['dst']; metric = 'rx'; meas = flow['cands'][0]
                    r_id = if_to_router.get(if_id)
                    curr = estimates[if_id]['rx']
                    stat = flow.get('status_dst')
                    imb, r_flow = get_router_state(r_id)
                    implied = max(0.0, curr - imb)

                hyps = sorted(list(set([meas, implied, 0.0])))
                scores = []
                rel = router_reliability.get(r_id, 0.5)

                for h in hyps:
                    estimates[if_id][metric] = h
                    imb, rf = get_router_state(r_id)
                    lik = math.exp(-abs(imb)/calc_sigma(rf, rel)) if r_id else 0.5

                    prior = 1.0
                    if h == 0.0:
                        if stat == 'down': prior = 0.98
                        elif meas > 10.0: prior = 0.01
                        else: prior = 0.5
                    elif abs(h - implied) < 1e-6:
                        # Trust Conservation (Implied) more if Router is Reliable
                        # If Rel=1.0 -> Prior=0.95. If Rel=0.0 -> Prior=0.5
                        prior = 0.5 + 0.45 * rel
                    elif abs(h - meas) < 1e-6:
                        # Trust Measurement more if Router is Unreliable
                        # If Rel=1.0 -> Prior=0.5. If Rel=0.0 -> Prior=0.95
                        prior = 0.95 - 0.45 * rel

                    scores.append(lik * prior)

                estimates[if_id][metric] = curr

                total = sum(scores) + 1e-20
                probs = [s/total for s in scores]
                best_idx = scores.index(max(scores))
                win_val = hyps[best_idx]
                win_prob = sum(p for i, p in enumerate(probs) if abs(hyps[i] - win_val) <= max(win_val * 0.05, 1.0))

                updates.append((if_id, metric, win_val, win_prob))

        for if_id, metric, val, prob in updates:
            old = estimates[if_id][metric]
            estimates[if_id][metric] = (old * (1 - MOMENTUM)) + (val * MOMENTUM)
            solver_confidences[(if_id, metric)] = prob
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Step 3: Confidence & Status ---
    result = {}

    # Pre-calculate final router fits
    router_fits = {}
    for rid in topology:
        imb, flow = get_router_state(rid)
        sigma = calc_sigma(flow)
        fit = math.exp(-abs(imb) / sigma)
        router_fits[rid] = fit

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        rep_rx = estimates[if_id]['rx']
        rep_tx = estimates[if_id]['tx']

        rid = if_to_router.get(if_id)
        r_fit = router_fits.get(rid, 0.8) # Default 0.8 for unknown router

        # Confidence Calculation
        # 1. Base Confidence: How much did we deviate?
        #    If Anchor -> High.
        #    If Deviation small -> High.
        #    If Deviation large -> Low (unless R_Fit is very high, meaning we fixed it)

        def calc_conf(metric):
            if (if_id, metric) in anchors: return 0.95

            # Retrieve solver probability (margin of victory)
            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Confidence is Solver_Certainty * Router_Fit_Quality
            # Weighted towards fit because a clear winner that balances poorly is still suspect
            final_conf = sol_prob * (0.2 + 0.8 * r_fit)

            return final_conf

        conf_rx = calc_conf('rx')
        conf_tx = calc_conf('tx')
=======
    # --- Step 3: Confidence & Status ---
    result = {}

    # Pre-calculate final router fits
    router_fits = {}
    for rid in topology:
        imb, flow = get_router_state(rid)
        # Use computed reliability for final fit check
        rel = router_reliability.get(rid, 0.5)
        sigma = calc_sigma(flow, rel)
        fit = math.exp(-abs(imb) / sigma)
        router_fits[rid] = fit

    for if_id, data in telemetry.items():
        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_status = data.get('interface_status', 'unknown')

        rep_rx = estimates[if_id]['rx']
        rep_tx = estimates[if_id]['tx']

        rid = if_to_router.get(if_id)
        r_fit = router_fits.get(rid, 0.8) # Default 0.8 for unknown router

        # Confidence Calculation
        def calc_conf(metric, rep_val, orig_val):
            if (if_id, metric) in anchors: return 0.98

            sol_prob = solver_confidences.get((if_id, metric), 0.5)

            # Harmonic Mean of Solver Probability and Router Fit
            # Requires both to be high for high confidence, penalizes if either is low
            h_mean = 2 * (sol_prob * r_fit) / (sol_prob + r_fit + 1e-9)

            # Bonus for validating measurement (small repair)
            if abs(rep_val - orig_val) < max(orig_val * 0.1, 1.0):
                return max(h_mean, 0.8 * r_fit + 0.1)
            else:
                return h_mean

        conf_rx = calc_conf('rx', rep_rx, orig_rx)
        conf_tx = calc_conf('tx', rep_tx, orig_tx)
>>>>>>> REPLACE
</DIFF>