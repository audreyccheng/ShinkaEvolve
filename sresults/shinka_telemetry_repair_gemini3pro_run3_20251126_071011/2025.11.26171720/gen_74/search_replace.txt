<NAME>
mass_weighted_anchor_and_boosted_flow
</NAME>

<DESCRIPTION>
Implements "Weighted External Link Validation" and refined confidence calibration.
1. Replaces the simple 'anchor' score (average agreement) with a 'trust' ratio: the proportion of total traffic mass on the router that flows through 'Trusted' interfaces (high agreement with peer/self).
2. Boosts the weight of Flow Conservation signals (f_weight) significantly when a router is both highly trusted (>80% traffic verified) and balanced. This allows strong anchors to override noise on suspect links.
3. Refines the confidence calibration to use the new 'trust' metric and applies a stricter quadratic penalty for poor fits, while maintaining the probability dominance logic.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 1. Router Anchor Analysis
        router_metrics = {}
        for r_id, if_list in topology.items():
            valid_ifs = [i for i in if_list if i in state]
            if not valid_ifs: continue

            sum_in, sum_out, sum_agreement = 0.0, 0.0, 0.0

            for i in valid_ifs:
                d = state[i]
                sum_in += d['est_rx']
                sum_out += d['est_tx']

                # Agreement Score
                if d['has_peer']:
                    ag_rx = gaussian_score(d['est_rx'], d['p_tx'], get_sigma(d['est_rx']))
                    ag_tx = gaussian_score(d['est_tx'], d['p_rx'], get_sigma(d['est_tx']))
                    sum_agreement += (ag_rx + ag_tx) / 2.0
                else:
                    sum_agreement += 0.5

            anchor = sum_agreement / len(valid_ifs)

            imb = abs(sum_in - sum_out)
            mag = max(sum_in, sum_out, 1.0)
            balance = math.exp(- (imb / (mag * 0.05))**2 )

            router_metrics[r_id] = {
                'sin': sum_in, 'sout': sum_out,
                'anchor': anchor, 'balance': balance
            }
=======
        # 1. Router Anchor Analysis
        router_metrics = {}
        for r_id, if_list in topology.items():
            valid_ifs = [i for i in if_list if i in state]
            if not valid_ifs: continue

            sum_in, sum_out = 0.0, 0.0
            sum_trusted_mass, total_mass = 0.0, 0.0

            for i in valid_ifs:
                d = state[i]
                sum_in += d['est_rx']
                sum_out += d['est_tx']

                # Traffic Mass
                m = d['est_rx'] + d['est_tx']
                total_mass += m

                # Agreement/Trust Score
                # We trust an interface if its current estimate aligns with its peer (Symmetry)
                # or if it aligns with its original self (Stability in absence of peer)
                if d['has_peer']:
                    ag_rx = gaussian_score(d['est_rx'], d['p_tx'], get_sigma(d['est_rx']))
                    ag_tx = gaussian_score(d['est_tx'], d['p_rx'], get_sigma(d['est_tx']))
                    agree = (ag_rx + ag_tx) / 2.0
                else:
                    # Weak trust for isolated interfaces, unless they are very clean (match self)
                    ag_rx = gaussian_score(d['est_rx'], d['s_rx'], get_sigma(d['est_rx']))
                    ag_tx = gaussian_score(d['est_tx'], d['s_tx'], get_sigma(d['est_tx']))
                    agree = (ag_rx + ag_tx) / 2.0

                # Hard Trust Threshold for Anchor Classification
                if agree > 0.8:
                    sum_trusted_mass += m

            # Trust Ratio: Portion of traffic on this router that is verified/anchored
            trust_ratio = sum_trusted_mass / max(total_mass, 1.0)

            imb = abs(sum_in - sum_out)
            mag = max(sum_in, sum_out, 1.0)
            # Balance score (Conservation)
            balance = math.exp(- (imb / (mag * 0.05))**2 )

            router_metrics[r_id] = {
                'sin': sum_in, 'sout': sum_out,
                'trust': trust_ratio, 'balance': balance
            }
>>>>>>> REPLACE
<<<<<<< SEARCH
            def solve_direction(current, s_val, p_val, is_rx):
                f_val = None
                f_weight = 0.0

                if r_info:
                    if is_rx:
                        others = r_info['sin'] - current
                        f_val = max(0.0, r_info['sout'] - others)
                    else:
                        others = r_info['sout'] - current
                        f_val = max(0.0, r_info['sin'] - others)

                    f_weight = 2.5 * r_info['anchor'] * (0.2 + 0.8 * r_info['balance'])

                candidates = [s_val, 0.0]
=======
            def solve_direction(current, s_val, p_val, is_rx):
                f_val = None
                f_weight = 0.0

                if r_info:
                    if is_rx:
                        others = r_info['sin'] - current
                        f_val = max(0.0, r_info['sout'] - others)
                    else:
                        others = r_info['sout'] - current
                        f_val = max(0.0, r_info['sin'] - others)

                    # Adaptive Weighting:
                    # If the router is highly trusted (many anchors) and balanced,
                    # the implied flow value is extremely reliable.
                    # We boost weight significantly if trust > 0.8
                    base_w = 2.5 * r_info['trust'] * (0.2 + 0.8 * r_info['balance'])
                    if r_info['trust'] > 0.8 and r_info['balance'] > 0.8:
                        f_weight = base_w * 2.0 # Boost to override local noise
                    else:
                        f_weight = base_w

                candidates = [s_val, 0.0]
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Phase 3: Final Output & Probability Calibration ---
    results = {}

    final_metrics = {}
    for r_id, if_list in topology.items():
        valid_ifs = [i for i in if_list if i in state]
        sin = sum(state[i]['est_rx'] for i in valid_ifs)
        sout = sum(state[i]['est_tx'] for i in valid_ifs)

        ag_sum = 0
        for i in valid_ifs:
            entry = state[i]
            if entry['has_peer']:
                 ag_sum += (gaussian_score(entry['est_rx'], entry['p_tx'], get_sigma(entry['est_rx'])) +
                            gaussian_score(entry['est_tx'], entry['p_rx'], get_sigma(entry['est_tx']))) / 2.0
            else: ag_sum += 0.5
        anchor = ag_sum / len(valid_ifs) if valid_ifs else 0.0
        bal = math.exp(-(abs(sin-sout)/max(sin,sout,1.0)*20)**2)
        final_metrics[r_id] = {'sin': sin, 'sout': sout, 'anchor': anchor, 'bal': bal}

    for if_id, d in state.items():
        res = telemetry[if_id].copy()

        if d['status'] == 'down':
            crx = 1.0 if d['s_rx'] <= ABS_TOL else 0.95
            ctx = 1.0 if d['s_tx'] <= ABS_TOL else 0.95
            res['rx_rate'] = (d['s_rx'], 0.0, crx)
            res['tx_rate'] = (d['s_tx'], 0.0, ctx)
        else:
            r_id = telemetry[if_id].get('local_router')
            r_info = final_metrics.get(r_id)

            def calc_conf(val, s_val, p_val, is_rx):
                f_val = None
                f_w = 0.0
                if r_info:
                    if is_rx: target = r_info['sout'] - (r_info['sin'] - d['est_rx'])
                    else:     target = r_info['sin'] - (r_info['sout'] - d['est_tx'])
                    f_val = max(0.0, target)
                    f_w = 2.5 * r_info['anchor'] * (0.2 + 0.8 * r_info['bal'])

                hyps = {val, s_val, 0.0}
                if d['has_peer']: hyps.add(p_val)
                if f_val is not None: hyps.add(f_val)
                if d['has_peer']: hyps.add((s_val + p_val)/2.0)

                sigma_win = get_sigma(val)

                def get_score(h, sigma):
                    sc_s = 0.8 * gaussian_score(h, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(h, p_val, sigma) if d['has_peer'] else 0.0
                    sc_f = f_w * gaussian_score(h, f_val, sigma) if f_val is not None else 0.0
                    tot = sc_s + sc_p + sc_f
                    if is_zero(h): tot *= 0.1
                    return tot

                winner_score = get_score(val, sigma_win)

                runner_up_score = 0.0
                sorted_hyps = sorted(list(hyps))
                for h in sorted_hyps:
                    if abs(h - val) <= sigma_win: continue
                    sigma_h = get_sigma(h)
                    s = get_score(h, sigma_h)
                    if s > runner_up_score:
                        runner_up_score = s

                total = winner_score + runner_up_score + 1e-9
                prob = winner_score / total

                max_possible = 0.8 + (1.0 if d['has_peer'] else 0.0) + (f_w if f_val is not None else 0.0)
                fit_ratio = winner_score / max(1.0, max_possible)

                final_conf = prob
                if fit_ratio < 0.5:
                    final_conf *= fit_ratio * 2.0

                peer_agrees = d['has_peer'] and abs(val - p_val) <= sigma_win
                flow_agrees = f_val is not None and abs(val - f_val) <= sigma_win

                if not peer_agrees and not flow_agrees:
                    final_conf = min(final_conf, 0.75)

                return max(0.5, min(1.0, final_conf))
=======
    # --- Phase 3: Final Output & Probability Calibration ---
    results = {}

    final_metrics = {}
    for r_id, if_list in topology.items():
        valid_ifs = [i for i in if_list if i in state]
        sin = sum(state[i]['est_rx'] for i in valid_ifs)
        sout = sum(state[i]['est_tx'] for i in valid_ifs)

        sum_trusted_mass, total_mass = 0.0, 0.0
        for i in valid_ifs:
            d = state[i]
            m = d['est_rx'] + d['est_tx']
            total_mass += m
            agree = 0.0
            if d['has_peer']:
                 agree = (gaussian_score(d['est_rx'], d['p_tx'], get_sigma(d['est_rx'])) +
                          gaussian_score(d['est_tx'], d['p_rx'], get_sigma(d['est_tx']))) / 2.0
            else:
                 agree = (gaussian_score(d['est_rx'], d['s_rx'], get_sigma(d['est_rx'])) +
                          gaussian_score(d['est_tx'], d['s_tx'], get_sigma(d['est_tx']))) / 2.0
            if agree > 0.8: sum_trusted_mass += m

        trust = sum_trusted_mass / max(total_mass, 1.0)
        bal = math.exp(-(abs(sin-sout)/max(sin,sout,1.0)*20)**2)
        final_metrics[r_id] = {'sin': sin, 'sout': sout, 'trust': trust, 'bal': bal}

    for if_id, d in state.items():
        res = telemetry[if_id].copy()

        if d['status'] == 'down':
            crx = 1.0 if d['s_rx'] <= ABS_TOL else 0.95
            ctx = 1.0 if d['s_tx'] <= ABS_TOL else 0.95
            res['rx_rate'] = (d['s_rx'], 0.0, crx)
            res['tx_rate'] = (d['s_tx'], 0.0, ctx)
        else:
            r_id = telemetry[if_id].get('local_router')
            r_info = final_metrics.get(r_id)

            def calc_conf(val, s_val, p_val, is_rx):
                f_val = None
                f_w = 0.0
                if r_info:
                    if is_rx: target = r_info['sout'] - (r_info['sin'] - d['est_rx'])
                    else:     target = r_info['sin'] - (r_info['sout'] - d['est_tx'])
                    f_val = max(0.0, target)
                    base_w = 2.5 * r_info['trust'] * (0.2 + 0.8 * r_info['bal'])
                    f_w = base_w * 2.0 if (r_info['trust'] > 0.8 and r_info['bal'] > 0.8) else base_w

                hyps = {val, s_val, 0.0}
                if d['has_peer']: hyps.add(p_val)
                if f_val is not None: hyps.add(f_val)
                if d['has_peer']: hyps.add((s_val + p_val)/2.0)

                sigma_win = get_sigma(val)

                def get_score(h, sigma):
                    sc_s = 0.8 * gaussian_score(h, s_val, sigma)
                    sc_p = 1.0 * gaussian_score(h, p_val, sigma) if d['has_peer'] else 0.0
                    sc_f = f_w * gaussian_score(h, f_val, sigma) if f_val is not None else 0.0
                    tot = sc_s + sc_p + sc_f
                    if is_zero(h): tot *= 0.1
                    return tot

                winner_score = get_score(val, sigma_win)

                runner_up_score = 0.0
                sorted_hyps = sorted(list(hyps))
                for h in sorted_hyps:
                    if abs(h - val) <= sigma_win: continue
                    sigma_h = get_sigma(h)
                    s = get_score(h, sigma_h)
                    if s > runner_up_score:
                        runner_up_score = s

                # Calibration: Probability Dominance
                # High confidence if winner score is much larger than runner up
                total = winner_score + runner_up_score + 1e-9
                prob = winner_score / total

                # Scale by Fit Quality
                # Even if dominant, if the fit is poor (score is low absolute value), reduce confidence
                max_possible = 0.8 + (1.0 if d['has_peer'] else 0.0) + (f_w if f_val is not None else 0.0)
                fit_ratio = winner_score / max(1.0, max_possible)

                # Sigmoid scaling for fit_ratio to punish poor fits harder
                if fit_ratio < 0.6:
                    prob *= (fit_ratio / 0.6) ** 2

                # Sanity cap for single-source
                peer_agrees = d['has_peer'] and abs(val - p_val) <= sigma_win
                flow_agrees = f_val is not None and abs(val - f_val) <= sigma_win

                if not peer_agrees and not flow_agrees:
                     prob = min(prob, 0.75)

                return max(0.5, min(1.0, prob))
>>>>>>> REPLACE
</DIFF>