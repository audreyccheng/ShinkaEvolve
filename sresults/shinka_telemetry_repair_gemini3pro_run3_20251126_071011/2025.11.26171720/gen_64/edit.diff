--- a/original.py
+++ b/original.py
@@ -1,330 +1,348 @@
 # EVOLVE-BLOCK-START
 """
-Network telemetry repair algorithm that detects and corrects inconsistencies
-in network interface telemetry data using topology relationships.
-
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
+Bayesian Hypothesis Competition Telemetry Repair
+Implements a probabilistic solver that scores discrete hypotheses (Self, Peer, Flow, Zero)
+and calibrates confidence based on the margin of victory between the best and second-best explanations.
 """
+import math
 from typing import Dict, Any, Tuple, List
 
-
-import math
-
-def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
+def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]], 
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
-    """
-    Repairs telemetry using an Iterative Consensus model with Momentum.
-
-    Key Features:
-    1. Hypothesis Selection: Arbitrates between Self, Peer, Flow, and Zero.
-    2. Momentum Updates: Uses a rolling average during iteration to stabilize flow calculations.
-    3. Dynamic Flow Trust: Flow signals are weighted by the router's current balance quality.
-    4. Calibration: Confidence reflects the Gaussian likelihood of the chosen value against available signals.
-    """
-
+    
     # --- Configuration ---
     REL_TOL = 0.02
     ABS_TOL = 0.5
-    MOMENTUM_ALPHA = 0.4 # How much new value contributes (0.4 means 60% retention)
-    ITERATIONS = 4
-
-    results = {}
-
-    # --- Helper: Similarity Score ---
-    def gaussian_similarity(v1, v2):
-        if v1 is None or v2 is None: return 0.0
-        diff = abs(v1 - v2)
-        # Square Root Noise Model: sigma proportional to sqrt of magnitude
-        # This models physical counting processes better than linear scaling
-        mag = max(abs(v1), abs(v2))
-        sigma = max(ABS_TOL, math.sqrt(mag) * 0.5)
-        return math.exp(- (diff**2) / (2 * (sigma**2)))
+    ITERATIONS = 5
+    
+    # --- Helper Functions ---
+    def get_sigma(val: float) -> float:
+        """Returns standard deviation for Gaussian scoring based on value magnitude."""
+        return max(ABS_TOL, abs(val) * REL_TOL)
+
+    def gaussian_sim(x: float, mu: float, sigma: float) -> float:
+        """Calculates unnormalized Gaussian likelihood."""
+        if mu is None: return 0.0
+        diff = abs(x - mu)
+        return math.exp(-0.5 * (diff / sigma) ** 2)
+
+    def looks_like_zero(val: float) -> bool:
+        return val < ABS_TOL
 
     # --- Phase 1: Initialization & Status Repair ---
-    working_state = {}
-
+    state = {}
+    
     for if_id, data in telemetry.items():
         s_rx = float(data.get('rx_rate', 0.0))
         s_tx = float(data.get('tx_rate', 0.0))
-        s_status = data.get('interface_status', 'unknown')
-
+        s_stat = data.get('interface_status', 'unknown')
+        
         peer_id = data.get('connected_to')
         has_peer = False
-        p_rx, p_tx, p_status = 0.0, 0.0, 'unknown'
-
+        p_rx, p_tx, p_stat = 0.0, 0.0, 'unknown'
+        
         if peer_id and peer_id in telemetry:
             has_peer = True
             p_data = telemetry[peer_id]
             p_rx = float(p_data.get('rx_rate', 0.0))
             p_tx = float(p_data.get('tx_rate', 0.0))
-            p_status = p_data.get('interface_status', 'unknown')
+            p_stat = p_data.get('interface_status', 'unknown')
 
         # Status Logic
-        has_traffic = (s_rx > ABS_TOL or s_tx > ABS_TOL or
-                       p_rx > ABS_TOL or p_tx > ABS_TOL)
-
-        final_status = s_status
-        status_conf = 1.0
-
-        if s_status == 'down' and has_traffic:
-            final_status = 'up'
-            status_conf = 0.95
-        elif s_status == 'up' and not has_traffic and p_status == 'down':
-            final_status = 'down'
-            status_conf = 0.90
-
-        # Initial Estimate Seeding
-        if final_status == 'down':
+        traffic = (s_rx > ABS_TOL or s_tx > ABS_TOL or p_rx > ABS_TOL or p_tx > ABS_TOL)
+        final_stat = s_stat
+        stat_conf = 1.0
+        
+        if s_stat == 'down' and traffic:
+            final_stat = 'up'
+            stat_conf = 0.95
+        elif s_stat == 'up' and not traffic and p_stat == 'down':
+            final_stat = 'down'
+            stat_conf = 0.90
+            
+        # Initial Value Estimation (Prefer Peer)
+        if final_stat == 'down':
             est_rx, est_tx = 0.0, 0.0
         else:
-            # Seed with Peer if available (Symmetry), else Self
             est_rx = p_tx if has_peer else s_rx
             est_tx = p_rx if has_peer else s_tx
-
-        working_state[if_id] = {
+            
+        # Initial Agreement Score (used to determine if this interface is an "Anchor")
+        agree_rx = 0.5
+        agree_tx = 0.5
+        if has_peer:
+             sigma_rx = get_sigma(max(s_rx, p_tx))
+             agree_rx = gaussian_sim(s_rx, p_tx, sigma_rx)
+             sigma_tx = get_sigma(max(s_tx, p_rx))
+             agree_tx = gaussian_sim(s_tx, p_rx, sigma_tx)
+        
+        state[if_id] = {
             's_rx': s_rx, 's_tx': s_tx,
-            'p_rx': p_rx if has_peer else None,
-            'p_tx': p_tx if has_peer else None,
+            'p_rx': p_rx, 'p_tx': p_tx,
             'est_rx': est_rx, 'est_tx': est_tx,
-            'status': final_status,
-            'status_conf': status_conf,
-            'orig_status': s_status,
-            'has_peer': has_peer
+            'status': final_stat,
+            'status_conf': stat_conf,
+            'orig_stat': s_stat,
+            'has_peer': has_peer,
+            'agree_score': (agree_rx + agree_tx) / 2.0
         }
 
-    # --- Phase 2: Iterative Refinement ---
-    for _ in range(ITERATIONS):
-        # 1. Build Router Context
-        router_context = {}
+    # --- Phase 2: Iterative Bayesian Solver ---
+    
+    for iteration in range(ITERATIONS):
+        # 1. Router Analysis (Compute "Anchor Scores")
+        router_stats = {}
         for r_id, if_list in topology.items():
-            valid_ifs = [i for i in if_list if i in working_state]
-            sum_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
-            sum_out = sum(working_state[i]['est_tx'] for i in valid_ifs)
-
-            # Reliability based on imbalance
-            # We want a score that is high when balance is good
+            valid_ifs = [i for i in if_list if i in state]
+            if not valid_ifs: continue
+            
+            sum_in = 0.0
+            sum_out = 0.0
+            total_agreement = 0.0
+            
+            for i in valid_ifs:
+                sum_in += state[i]['est_rx']
+                sum_out += state[i]['est_tx']
+                total_agreement += state[i]['agree_score']
+                
+            # Anchor Score: Average agreement of interfaces on this router.
+            # High score means the router's environment is trustworthy.
+            anchor_score = total_agreement / len(valid_ifs)
+            
+            # Balance Score: How well current estimates balance
             imbalance = abs(sum_in - sum_out)
             magnitude = max(sum_in, sum_out, 1.0)
-
-            # Score: 1.0 at 0 imbalance, drops to ~0.0 at 10% imbalance
-            # Using exponential decay for sharper distinction
-            rel_imbalance = imbalance / magnitude
-            reliability = math.exp(- rel_imbalance * 20.0) # at 5% (0.05), exp(-1) = 0.36
-
-            router_context[r_id] = {
-                'sum_in': sum_in, 'sum_out': sum_out,
-                'reliability': reliability
+            balance_score = math.exp(- (imbalance / (magnitude * 0.05))**2 )
+            
+            router_stats[r_id] = {
+                'sum_in': sum_in,
+                'sum_out': sum_out,
+                'anchor': anchor_score,
+                'balance': balance_score
             }
-
+            
         # 2. Update Estimates
-        for if_id, d in working_state.items():
+        for if_id, d in state.items():
             if d['status'] == 'down':
-                continue # Fixed at 0.0
-
+                continue # Fixed at 0
+            
             r_id = telemetry[if_id].get('local_router')
-
-            # Define Signal Hypotheses
-            # We will score candidate values.
-
-            # --- RX Update ---
-            candidates_rx = [d['s_rx']]
-            if d['p_tx'] is not None: candidates_rx.append(d['p_tx'])
-            candidates_rx.append(0.0) # Zero hypothesis
-
-            f_rx = None
-            f_weight_rx = 0.0
-
-            if r_id and r_id in router_context:
-                rc = router_context[r_id]
-                # Implied flow value: Total_Out - (Total_In - Me)
-                other_in = rc['sum_in'] - d['est_rx']
-                f_rx = max(0.0, rc['sum_out'] - other_in)
-                candidates_rx.append(f_rx)
-
-                # Dynamic weight for flow
-                # If the router is consistent, flow is strong.
-                # However, if we are the CAUSE of inconsistency, the router looks bad.
-                # We use a heuristic: Trust flow more if we have no peer.
-                base_flow_w = 2.0
-                if not d['has_peer']: base_flow_w = 3.0 # External link needs flow
-                f_weight_rx = base_flow_w * rc['reliability']
-
-            # Scoring function
-            def score_candidate(val, s_val, p_val, f_val, f_w):
-                score = 0.0
-                # Support from Self
-                score += 1.0 * gaussian_similarity(val, s_val)
-                # Support from Peer
-                if p_val is not None:
-                    score += 2.0 * gaussian_similarity(val, p_val)
-                # Support from Flow
-                if f_val is not None:
-                    score += f_w * gaussian_similarity(val, f_val)
-                return score
-
-            best_rx = d['est_rx']
-            best_score_rx = -1.0
-
-            # Optimization: Try the candidates themselves as the best value
-            for c in candidates_rx:
-                s = score_candidate(c, d['s_rx'], d['p_tx'], f_rx, f_weight_rx)
-                if s > best_score_rx:
-                    best_score_rx = s
-                    best_rx = c
-
-            # Momentum Update
-            d['est_rx'] = (1.0 - MOMENTUM_ALPHA) * d['est_rx'] + MOMENTUM_ALPHA * best_rx
-
-            # --- TX Update ---
-            candidates_tx = [d['s_tx']]
-            if d['p_rx'] is not None: candidates_tx.append(d['p_rx'])
-            candidates_tx.append(0.0)
-
-            f_tx = None
-            f_weight_tx = 0.0
-
-            if r_id and r_id in router_context:
-                rc = router_context[r_id]
-                other_out = rc['sum_out'] - d['est_tx']
-                f_tx = max(0.0, rc['sum_in'] - other_out)
-                candidates_tx.append(f_tx)
-
-                base_flow_w = 2.0
-                if not d['has_peer']: base_flow_w = 3.0
-                f_weight_tx = base_flow_w * rc['reliability']
-
-            best_tx = d['est_tx']
-            best_score_tx = -1.0
-
-            for c in candidates_tx:
-                s = score_candidate(c, d['s_tx'], d['p_rx'], f_tx, f_weight_tx)
-                if s > best_score_tx:
-                    best_score_tx = s
-                    best_tx = c
-
-            d['est_tx'] = (1.0 - MOMENTUM_ALPHA) * d['est_tx'] + MOMENTUM_ALPHA * best_tx
-
-    # --- Phase 3: Final Output Construction ---
-    # 1. Calculate Final Router Context for Confidence Scoring
-    final_router_context = {}
+            r_info = router_stats.get(r_id)
+            
+            # Helper to solve for one direction
+            def solve_direction(current_est, s_val, p_val, is_rx):
+                # Calculate Flow Target
+                flow_val = None
+                flow_weight = 0.0
+                
+                if r_info:
+                    # Target = what the rest of the router demands
+                    # Sum_Others = Total - Me
+                    if is_rx:
+                        other_in = r_info['sum_in'] - current_est
+                        flow_val = max(0.0, r_info['sum_out'] - other_in)
+                    else:
+                        other_out = r_info['sum_out'] - current_est
+                        flow_val = max(0.0, r_info['sum_in'] - other_out)
+                    
+                    # Trust Flow?
+                    # Weight = 2.0 (High) if Anchor & Balance are perfect.
+                    # This allows Flow to override Self+Peer if the router context is very strong.
+                    flow_weight = 2.5 * r_info['anchor'] * (0.4 + 0.6 * r_info['balance'])
+                
+                # Generate Hypotheses
+                hyps = []
+                hyps.append(s_val) # H_self
+                if d['has_peer']: hyps.append(p_val) # H_peer
+                if flow_val is not None: hyps.append(flow_val) # H_flow
+                hyps.append(0.0) # H_zero
+                
+                # H_mean: Add average if Self/Peer are close (noise model)
+                if d['has_peer']:
+                     diff = abs(s_val - p_val)
+                     mx = max(s_val, p_val, 1.0)
+                     if diff / mx < 0.2: # 20% divergence threshold
+                         hyps.append((s_val + p_val) / 2.0)
+
+                candidates = sorted(list(set(hyps)))
+                
+                best_val = current_est
+                best_score = -1.0
+                
+                for c in candidates:
+                    sigma = get_sigma(c)
+                    
+                    # Likelihoods
+                    s_lik = gaussian_sim(c, s_val, sigma)
+                    p_lik = gaussian_sim(c, p_val, sigma) if d['has_peer'] else 0.0
+                    f_lik = gaussian_sim(c, flow_val, sigma) if flow_val is not None else 0.0
+                    
+                    # Score = Weighted Sum of Likelihoods
+                    # Peer=1.0, Self=0.8, Flow=Variable
+                    score = (0.8 * s_lik) + (1.0 * p_lik) + (flow_weight * f_lik)
+                    
+                    # Prior: Penalize Zero if status is UP
+                    if looks_like_zero(c):
+                        score *= 0.2 
+                        
+                    if score > best_score:
+                        best_score = score
+                        best_val = c
+                
+                return best_val
+
+            # Solve RX
+            new_rx = solve_direction(d['est_rx'], d['s_rx'], d['p_tx'], True)
+            d['est_rx'] = 0.5 * d['est_rx'] + 0.5 * new_rx
+            
+            # Solve TX
+            new_tx = solve_direction(d['est_tx'], d['s_tx'], d['p_rx'], False)
+            d['est_tx'] = 0.5 * d['est_tx'] + 0.5 * new_tx
+
+            # Update Agreement Score for next iteration
+            new_agree_rx = 0.0
+            new_agree_tx = 0.0
+            if d['has_peer']:
+                # Check convergence against Peer Raw
+                new_agree_rx = gaussian_sim(d['est_rx'], d['p_tx'], get_sigma(d['est_rx']))
+                new_agree_tx = gaussian_sim(d['est_tx'], d['p_rx'], get_sigma(d['est_tx']))
+            else:
+                new_agree_rx = gaussian_sim(d['est_rx'], d['s_rx'], get_sigma(d['est_rx']))
+                new_agree_tx = gaussian_sim(d['est_tx'], d['s_tx'], get_sigma(d['est_tx']))
+            
+            d['agree_score'] = (new_agree_rx + new_agree_tx) / 2.0
+
+    # --- Phase 3: Final Output & Confidence Calibration ---
+    results = {}
+    
+    # Final Router Context
+    final_router_stats = {}
     for r_id, if_list in topology.items():
-        valid_ifs = [i for i in if_list if i in working_state]
-        s_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
-        s_out = sum(working_state[i]['est_tx'] for i in valid_ifs)
+        valid_ifs = [i for i in if_list if i in state]
+        s_in = sum(state[i]['est_rx'] for i in valid_ifs)
+        s_out = sum(state[i]['est_tx'] for i in valid_ifs)
+        tot_agree = sum(state[i]['agree_score'] for i in valid_ifs)
+        anchor = tot_agree / len(valid_ifs) if valid_ifs else 0.0
         imb = abs(s_in - s_out)
-        mag = max(s_in, s_out, 1.0)
-        rel = math.exp(-(imb/mag) * 20.0)
-        final_router_context[r_id] = {'sum_in': s_in, 'sum_out': s_out, 'rel': rel}
-
-    # 2. Construct Results with Calibrated Confidence
-    for if_id, d in working_state.items():
+        bal = math.exp(-(imb/max(s_in, s_out, 1.0)*20.0)**2) 
+        final_router_stats[r_id] = {'sin': s_in, 'sout': s_out, 'anchor': anchor, 'bal': bal}
+    
+    for if_id, d in state.items():
         res = telemetry[if_id].copy()
-
+        
         if d['status'] == 'down':
-            c_rx = 0.95 if d['s_rx'] > ABS_TOL else 1.0
-            c_tx = 0.95 if d['s_tx'] > ABS_TOL else 1.0
-            res['rx_rate'] = (d['s_rx'], 0.0, c_rx)
-            res['tx_rate'] = (d['s_tx'], 0.0, c_tx)
+             conf_rx = 0.95 if d['s_rx'] > ABS_TOL else 1.0
+             conf_tx = 0.95 if d['s_tx'] > ABS_TOL else 1.0
+             res['rx_rate'] = (d['s_rx'], 0.0, conf_rx)
+             res['tx_rate'] = (d['s_tx'], 0.0, conf_tx)
         else:
-            # Flow context for this interface
             r_id = telemetry[if_id].get('local_router')
-            f_rx, f_tx, f_rel = None, None, 0.0
-
-            if r_id in final_router_context:
-                rc = final_router_context[r_id]
-                f_rel = rc['rel']
-                # Infer flow target from final router state
-                other_in = rc['sum_in'] - d['est_rx']
-                f_rx = max(0.0, rc['sum_out'] - other_in)
-                other_out = rc['sum_out'] - d['est_tx']
-                f_tx = max(0.0, rc['sum_in'] - other_out)
-
-            # Confidence Calculator: Weighted Consensus
-            def get_conf(val, s_val, p_val, f_val, f_rel, has_peer):
-                # Weights for sources
-                w_s = 1.0 # Self baseline
-                w_p = 2.0 if has_peer else 0.0 # Peer is strong
-                w_f = 1.5 * f_rel # Flow depends on router balance reliability
-
-                # Similarities
-                sim_s = gaussian_similarity(val, s_val)
-                sim_p = gaussian_similarity(val, p_val) if has_peer else 0.0
-                sim_f = gaussian_similarity(val, f_val) if f_val is not None else 0.0
-
-                weighted_sim = (sim_s * w_s) + (sim_p * w_p) + (sim_f * w_f)
-                total_weight = w_s + w_p + w_f
-
-                if total_weight < 0.1: return 0.5
-
-                return weighted_sim / total_weight
-
-            final_rx = d['est_rx']
-            final_tx = d['est_tx']
-
-            conf_rx = get_conf(final_rx, d['s_rx'], d['p_tx'], f_rx, f_rel, d['has_peer'])
-            conf_tx = get_conf(final_tx, d['s_tx'], d['p_rx'], f_tx, f_rel, d['has_peer'])
-
-            # Boost confidence slightly if it's very high (rounding/precision)
-            if conf_rx > 0.95: conf_rx = 1.0
-            if conf_tx > 0.95: conf_tx = 1.0
-
-            res['rx_rate'] = (d['s_rx'], final_rx, conf_rx)
-            res['tx_rate'] = (d['s_tx'], final_tx, conf_tx)
-
-        res['interface_status'] = (d['orig_status'], d['status'], d['status_conf'])
+            r_info = final_router_stats.get(r_id)
+            
+            def calc_conf(val, s_val, p_val, is_rx):
+                # Reconstruct Targets
+                f_val = None
+                f_w = 0.0
+                if r_info:
+                    # Note: Must subtract FINAL estimate to get the network invariant
+                    if is_rx:
+                        target = r_info['sout'] - (r_info['sin'] - d['est_rx'])
+                    else:
+                        target = r_info['sin'] - (r_info['sout'] - d['est_tx'])
+                    f_val = max(0.0, target)
+                    f_w = 2.5 * r_info['anchor'] * r_info['bal']
+                
+                # Calculate Score of Winner
+                sigma = get_sigma(val)
+                sc_s = 0.8 * gaussian_sim(val, s_val, sigma)
+                sc_p = 1.0 * gaussian_sim(val, p_val, sigma) if d['has_peer'] else 0.0
+                sc_f = f_w * gaussian_sim(val, f_val, sigma) if f_val is not None else 0.0
+                winner_score = sc_s + sc_p + sc_f
+                
+                # Calculate Score of Best Runner-Up
+                alts = [s_val, 0.0]
+                if d['has_peer']: alts.append(p_val)
+                if f_val is not None: alts.append(f_val)
+                
+                runner_up_score = 0.0
+                for alt in alts:
+                    if abs(alt - val) < sigma: continue # Same cluster
+                    
+                    asigma = get_sigma(alt)
+                    a_s = 0.8 * gaussian_sim(alt, s_val, asigma)
+                    a_p = 1.0 * gaussian_sim(alt, p_val, asigma) if d['has_peer'] else 0.0
+                    a_f = f_w * gaussian_sim(alt, f_val, asigma) if f_val is not None else 0.0
+                    
+                    score = a_s + a_p + a_f
+                    if looks_like_zero(alt): score *= 0.2
+                    
+                    if score > runner_up_score:
+                        runner_up_score = score
+                        
+                # Probability = Winner / (Winner + RunnerUp)
+                # This measures dominance of the explanation
+                total_mass = winner_score + runner_up_score + 0.001
+                prob = winner_score / total_mass
+                return max(0.5, min(1.0, prob))
+
+            conf_rx = calc_conf(d['est_rx'], d['s_rx'], d['p_tx'], True)
+            conf_tx = calc_conf(d['est_tx'], d['s_tx'], d['p_rx'], False)
+            
+            res['rx_rate'] = (d['s_rx'], d['est_rx'], conf_rx)
+            res['tx_rate'] = (d['s_tx'], d['est_tx'], conf_tx)
+
+        res['interface_status'] = (d['orig_stat'], d['status'], d['status_conf'])
         results[if_id] = res
 
     return results
-
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")