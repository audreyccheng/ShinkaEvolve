<edit_name>
peer_trusted_flow_conservation
</edit_name>

<description>
Introduces a "Router Trust" metric based on the consensus of peer-connected interfaces to break the circular dependency in flow conservation reliability.
Previously, flow reliability depended on the global router imbalance, which was corrupted by the very errors we tried to fix.
Now, we calculate `router_trust` as the average agreement between the router's interfaces and their peers. If a router has verified neighbors, we trust its flow conservation target implicitly, allowing it to forcefully correct corrupted external/edge links.
This replaces the imbalance-based reliability with a neighbor-consensus-based trust model.
Also standardizes the Gaussian scoring to return probabilities (0-1) and applies weights externally.
</description>

<diff>
<<<<<<< SEARCH
    # --- Helper: Gaussian Scoring ---
    def get_score(candidate: float, target: float, weight: float) -> float:
        """Calculates score based on Gaussian likelihood."""
        if target is None: return 0.0
        diff = abs(candidate - target)
        # Sigma scales with magnitude (Linear approx of physical variance)
        sigma = max(ABS_TOL, max(abs(candidate), abs(target)) * REL_TOL)
        return weight * math.exp(-0.5 * (diff / sigma) ** 2)

    # --- Phase 2: Iterative Refinement ---
    for _ in range(ITERATIONS):
        # 1. Build Router Context
        router_stats = {}
        for r_id, if_list in topology.items():
            valid_ifs = [i for i in if_list if i in working_state]
            sum_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
            sum_out = sum(working_state[i]['est_tx'] for i in valid_ifs)

            # Reliability score (Sigmoid decay based on imbalance)
            diff = abs(sum_in - sum_out)
            mag = max(sum_in, sum_out, 1.0)
            # 5% imbalance -> ~0.36 reliability score
            rel = math.exp(- (diff / (mag * 0.05)) ** 2)

            router_stats[r_id] = {'in': sum_in, 'out': sum_out, 'rel': rel}

        # 2. Update Estimates
        for if_id, d in working_state.items():
            if d['status'] == 'down': continue

            r_id = telemetry[if_id].get('local_router')
            rs = router_stats.get(r_id)

            # --- RX Update ---
            f_rx, f_w_rx = None, 0.0
            if rs:
                # Flow Target: Total_Out - (Total_In - Me)
                other_in = rs['in'] - d['est_rx']
                f_rx = max(0.0, rs['out'] - other_in)
                # Boost flow weight if isolated (no peer to contradict)
                base_w = 2.0 if not d['has_peer'] else 1.5
                f_w_rx = base_w * rs['rel']

            # Candidates: Self, Zero, Peer, Flow
            candidates = [d['s_rx'], 0.0]
            if d['has_peer']: candidates.append(d['p_tx'])
            if f_rx is not None: candidates.append(f_rx)

            best_val_rx = d['est_rx']
            best_score_rx = -1.0

            for cand in candidates:
                score = 0.0
                score += get_score(cand, d['s_rx'], 1.0) # Self
                if d['has_peer']: score += get_score(cand, d['p_tx'], 1.2) # Peer
                if f_rx is not None: score += get_score(cand, f_rx, f_w_rx) # Flow

                if score > best_score_rx:
                    best_score_rx = score
                    best_val_rx = cand

            # Momentum Update
            d['est_rx'] = MOMENTUM * d['est_rx'] + (1 - MOMENTUM) * best_val_rx

            # --- TX Update ---
            f_tx, f_w_tx = None, 0.0
            if rs:
                other_out = rs['out'] - d['est_tx']
                f_tx = max(0.0, rs['in'] - other_out)
                base_w = 2.0 if not d['has_peer'] else 1.5
                f_w_tx = base_w * rs['rel']

            candidates_tx = [d['s_tx'], 0.0]
            if d['has_peer']: candidates_tx.append(d['p_rx'])
            if f_tx is not None: candidates_tx.append(f_tx)

            best_val_tx = d['est_tx']
            best_score_tx = -1.0

            for cand in candidates_tx:
                score = 0.0
                score += get_score(cand, d['s_tx'], 1.0)
                if d['has_peer']: score += get_score(cand, d['p_rx'], 1.2)
                if f_tx is not None: score += get_score(cand, f_tx, f_w_tx)

                if score > best_score_tx:
                    best_score_tx = score
                    best_val_tx = cand

            d['est_tx'] = MOMENTUM * d['est_tx'] + (1 - MOMENTUM) * best_val_tx

    # --- Phase 3: Final Output & Confidence ---
    # Re-calculate router stats one last time for final confidence assessment
    final_rs = {}
    for r_id, if_list in topology.items():
        valid_ifs = [i for i in if_list if i in working_state]
        sum_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
        sum_out = sum(working_state[i]['est_tx'] for i in valid_ifs)
        diff = abs(sum_in - sum_out)
        mag = max(sum_in, sum_out, 1.0)
        rel = math.exp(- (diff / (mag * 0.05)) ** 2)
        final_rs[r_id] = {'in': sum_in, 'out': sum_out, 'rel': rel}

    for if_id, d in working_state.items():
        res = telemetry[if_id].copy()

        if d['status'] == 'down':
             # High confidence if signals are quiet
             c_rx = 0.95 if d['s_rx'] > ABS_TOL else 1.0
             c_tx = 0.95 if d['s_tx'] > ABS_TOL else 1.0
             res['rx_rate'] = (d['s_rx'], 0.0, c_rx)
             res['tx_rate'] = (d['s_tx'], 0.0, c_tx)
        else:
             r_id = telemetry[if_id].get('local_router')
             rs = final_rs.get(r_id)

             # --- RX Confidence ---
             f_rx, f_w_rx = None, 0.0
             if rs:
                 other_in = rs['in'] - d['est_rx']
                 f_rx = max(0.0, rs['out'] - other_in)
                 base_w = 2.0 if not d['has_peer'] else 1.5
                 f_w_rx = base_w * rs['rel']

             score_rx = 0.0
             max_score_rx = 1.0 # Self
             score_rx += get_score(d['est_rx'], d['s_rx'], 1.0)

             if d['has_peer']:
                 max_score_rx += 1.2
                 score_rx += get_score(d['est_rx'], d['p_tx'], 1.2)

             if f_rx is not None:
                 max_score_rx += f_w_rx
                 score_rx += get_score(d['est_rx'], f_rx, f_w_rx)

             conf_rx = score_rx / max_score_rx
             # Bonus for perfect agreement
             conf_rx = min(1.0, conf_rx * 1.1)

             # --- TX Confidence ---
             f_tx, f_w_tx = None, 0.0
             if rs:
                 other_out = rs['out'] - d['est_tx']
                 f_tx = max(0.0, rs['in'] - other_out)
                 base_w = 2.0 if not d['has_peer'] else 1.5
                 f_w_tx = base_w * rs['rel']

             score_tx = 0.0
             max_score_tx = 1.0
             score_tx += get_score(d['est_tx'], d['s_tx'], 1.0)

             if d['has_peer']:
                 max_score_tx += 1.2
                 score_tx += get_score(d['est_tx'], d['p_rx'], 1.2)

             if f_tx is not None:
                 max_score_tx += f_w_tx
                 score_tx += get_score(d['est_tx'], f_tx, f_w_tx)

             conf_tx = score_tx / max_score_tx
             conf_tx = min(1.0, conf_tx * 1.1)

             res['rx_rate'] = (d['s_rx'], d['est_rx'], conf_rx)
             res['tx_rate'] = (d['s_tx'], d['est_tx'], conf_tx)
=======
    # --- Helper: Gaussian Scoring ---
    def get_score(candidate: float, target: float) -> float:
        """Calculates probability (0.0-1.0) based on Gaussian likelihood."""
        if target is None: return 0.0
        diff = abs(candidate - target)
        # Sigma scales with magnitude (Linear approx of physical variance)
        sigma = max(ABS_TOL, max(abs(candidate), abs(target)) * REL_TOL)
        return math.exp(-0.5 * (diff / sigma) ** 2)

    # --- Phase 2: Iterative Refinement ---
    for _ in range(ITERATIONS):
        # 1. Build Router Context & Trust
        router_stats = {}
        router_trust = {} # r_id -> float (0.0 to 1.0) indicating peer consensus

        for r_id, if_list in topology.items():
            valid_ifs = [i for i in if_list if i in working_state]
            sum_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
            sum_out = sum(working_state[i]['est_tx'] for i in valid_ifs)

            router_stats[r_id] = {'in': sum_in, 'out': sum_out}

            # Calculate Trust: Average agreement of interfaces with their peers
            # This decouples flow reliability from the current router imbalance
            trust_scores = []
            for i in valid_ifs:
                wd = working_state[i]
                if wd['has_peer']:
                    # Check agreement with peer
                    t_rx = get_score(wd['est_rx'], wd['p_tx'])
                    t_tx = get_score(wd['est_tx'], wd['p_rx'])
                    trust_scores.append((t_rx + t_tx) / 2.0)

            if trust_scores:
                avg_trust = sum(trust_scores) / len(trust_scores)
                # Apply sigmoid-like boost to favor "mostly good" routers
                router_trust[r_id] = 1.0 / (1.0 + math.exp(-10.0 * (avg_trust - 0.5)))
            else:
                router_trust[r_id] = 0.5 # Neutral trust for isolated routers

        # 2. Update Estimates
        for if_id, d in working_state.items():
            if d['status'] == 'down': continue

            r_id = telemetry[if_id].get('local_router')
            rs = router_stats.get(r_id)
            trust = router_trust.get(r_id, 0.5)

            # --- RX Update ---
            f_rx, f_w_rx = None, 0.0
            if rs:
                # Flow Target: Total_Out - (Total_In - Me)
                other_in = rs['in'] - d['est_rx']
                f_rx = max(0.0, rs['out'] - other_in)

                # Flow Weight: Heavily trusted if neighbors are good
                # Base weight 2.0 (stronger than peer 1.2) if trust is high
                f_w_rx = 3.0 * trust

            # Candidates: Self, Zero, Peer, Flow
            candidates = [d['s_rx'], 0.0]
            if d['has_peer']: candidates.append(d['p_tx'])
            if f_rx is not None: candidates.append(f_rx)

            best_val_rx = d['est_rx']
            best_score_rx = -1.0

            for cand in candidates:
                score = 0.0
                score += 1.0 * get_score(cand, d['s_rx']) # Self
                if d['has_peer']:
                    score += 1.2 * get_score(cand, d['p_tx']) # Peer
                if f_rx is not None:
                    score += f_w_rx * get_score(cand, f_rx) # Flow

                if score > best_score_rx:
                    best_score_rx = score
                    best_val_rx = cand

            d['est_rx'] = MOMENTUM * d['est_rx'] + (1 - MOMENTUM) * best_val_rx

            # --- TX Update ---
            f_tx, f_w_tx = None, 0.0
            if rs:
                other_out = rs['out'] - d['est_tx']
                f_tx = max(0.0, rs['in'] - other_out)
                f_w_tx = 3.0 * trust

            candidates_tx = [d['s_tx'], 0.0]
            if d['has_peer']: candidates_tx.append(d['p_rx'])
            if f_tx is not None: candidates_tx.append(f_tx)

            best_val_tx = d['est_tx']
            best_score_tx = -1.0

            for cand in candidates_tx:
                score = 0.0
                score += 1.0 * get_score(cand, d['s_tx'])
                if d['has_peer']:
                    score += 1.2 * get_score(cand, d['p_rx'])
                if f_tx is not None:
                    score += f_w_tx * get_score(cand, f_tx)

                if score > best_score_tx:
                    best_score_tx = score
                    best_val_tx = cand

            d['est_tx'] = MOMENTUM * d['est_tx'] + (1 - MOMENTUM) * best_val_tx

    # --- Phase 3: Final Output & Confidence ---
    # Re-calculate context for final confidence
    final_rs = {}
    final_trust = {}

    for r_id, if_list in topology.items():
        valid_ifs = [i for i in if_list if i in working_state]
        sum_in = sum(working_state[i]['est_rx'] for i in valid_ifs)
        sum_out = sum(working_state[i]['est_tx'] for i in valid_ifs)
        final_rs[r_id] = {'in': sum_in, 'out': sum_out}

        trust_scores = []
        for i in valid_ifs:
            wd = working_state[i]
            if wd['has_peer']:
                t_rx = get_score(wd['est_rx'], wd['p_tx'])
                t_tx = get_score(wd['est_tx'], wd['p_rx'])
                trust_scores.append((t_rx + t_tx) / 2.0)

        if trust_scores:
            avg_trust = sum(trust_scores) / len(trust_scores)
            final_trust[r_id] = 1.0 / (1.0 + math.exp(-10.0 * (avg_trust - 0.5)))
        else:
            final_trust[r_id] = 0.5

    for if_id, d in working_state.items():
        res = telemetry[if_id].copy()

        if d['status'] == 'down':
             c_rx = 0.95 if d['s_rx'] > ABS_TOL else 1.0
             c_tx = 0.95 if d['s_tx'] > ABS_TOL else 1.0
             res['rx_rate'] = (d['s_rx'], 0.0, c_rx)
             res['tx_rate'] = (d['s_tx'], 0.0, c_tx)
        else:
             r_id = telemetry[if_id].get('local_router')
             rs = final_rs.get(r_id)
             trust = final_trust.get(r_id, 0.5)

             # --- RX Confidence ---
             f_rx, f_w_rx = None, 0.0
             if rs:
                 other_in = rs['in'] - d['est_rx']
                 f_rx = max(0.0, rs['out'] - other_in)
                 f_w_rx = 3.0 * trust

             score_rx = 0.0
             max_score_rx = 1.0 # Self
             score_rx += 1.0 * get_score(d['est_rx'], d['s_rx'])

             if d['has_peer']:
                 max_score_rx += 1.2
                 score_rx += 1.2 * get_score(d['est_rx'], d['p_tx'])

             if f_rx is not None:
                 max_score_rx += f_w_rx
                 score_rx += f_w_rx * get_score(d['est_rx'], f_rx)

             conf_rx = score_rx / max_score_rx
             conf_rx = min(1.0, conf_rx * 1.1) # Boost for agreement

             # --- TX Confidence ---
             f_tx, f_w_tx = None, 0.0
             if rs:
                 other_out = rs['out'] - d['est_tx']
                 f_tx = max(0.0, rs['in'] - other_out)
                 f_w_tx = 3.0 * trust

             score_tx = 0.0
             max_score_tx = 1.0
             score_tx += 1.0 * get_score(d['est_tx'], d['s_tx'])

             if d['has_peer']:
                 max_score_tx += 1.2
                 score_tx += 1.2 * get_score(d['est_tx'], d['p_rx'])

             if f_tx is not None:
                 max_score_tx += f_w_tx
                 score_tx += f_w_tx * get_score(d['est_tx'], f_tx)

             conf_tx = score_tx / max_score_tx
             conf_tx = min(1.0, conf_tx * 1.1)

             res['rx_rate'] = (d['s_rx'], d['est_rx'], conf_rx)
             res['tx_rate'] = (d['s_tx'], d['est_tx'], conf_tx)
>>>>>>> REPLACE
</diff>