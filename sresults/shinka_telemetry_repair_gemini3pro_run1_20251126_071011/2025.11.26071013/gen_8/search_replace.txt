<NAME>
consensus_refinement
</NAME>

<DESCRIPTION>
Refines the iterative consensus algorithm (Step 3) to use a weighted cost function instead of binary voting. This allows the algorithm to prefer repair candidates that minimize flow error magnitude, rather than just treating all passing candidates equally. It also integrates the "dead counter" heuristic directly into the cost function to handle edge cases more gracefully.

Additionally, improves confidence calibration (Step 4) by calculating confidence based on the consistency of the *final* state (Symmetry and Flow compliance) rather than just the repair action taken. This ensures that confidence scores accurately reflect the reliability of the output, penalizing cases where flow conservation or link symmetry are still violated.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Cost Function
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                def evaluate_candidate(val, is_dead_heuristic):
                    # Cost function: Sum of errors.
                    # High penalty (0.5) if error > tolerance or unverifiable
                    # This prefers "Verified Good" over "Unverified" over "Verified Bad"
                    cost = 0.0
                    verified_count = 0

                    # Check Router A (Local)
                    err_a = calc_flow_error(rid_a, if_id, 'tx', val)
                    if err_a is not None:
                        if err_a < FLOW_TOLERANCE:
                            cost += err_a
                            verified_count += 1
                        else:
                            cost += 0.5 # Penalty for violating flow

                    # Check Router B (Remote)
                    err_b = calc_flow_error(rid_b, peer_id, 'rx', val)
                    if err_b is not None:
                        if err_b < FLOW_TOLERANCE:
                            cost += err_b
                            verified_count += 1
                        else:
                            cost += 0.5 # Penalty for violating flow

                    # Heuristic: If this value is ~0 but peer is active, penalize
                    if is_dead_heuristic:
                        cost += 0.2

                    return cost

                # Identify if candidates look like "Dead Counters"
                # (Self is 0, Peer is Active)
                tx_is_dead = (cand_tx <= MIN_ACTIVITY and cand_rx > MIN_ACTIVITY)
                rx_is_dead = (cand_rx <= MIN_ACTIVITY and cand_tx > MIN_ACTIVITY)

                cost_tx = evaluate_candidate(cand_tx, tx_is_dead)
                cost_rx = evaluate_candidate(cand_rx, rx_is_dead)

                if cost_tx < cost_rx:
                    best_val = cand_tx
                elif cost_rx < cost_tx:
                    best_val = cand_rx
                else:
                    # Tie: Average
                    best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
<<<<<<< SEARCH
        # -- Calibrate Confidence --

        # Helper to check remote verification
        def is_remotely_verified(val, field):
            rem_rid = data.get('remote_router')
            peer_id = data.get('connected_to')
            if not rem_rid or not peer_id:
                return False
            # If checking local RX, we check remote TX flow
            # If checking local TX, we check remote RX flow
            check_field = 'tx' if field == 'rx' else 'rx'

            err = calc_flow_error(rem_rid, peer_id, check_field, val)
            return err is not None and err < FLOW_TOLERANCE

        def get_rate_confidence(orig, final, field):
            # 1. Did we change the value?
            if abs(orig - final) < 0.001:
                return 1.0 # High confidence in original/unchanged data

            # 2. Is it just smoothing? (Small relative change < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95 # Smoothing is safe

            # 3. Noise Consensus (Both < Min Activity)
            if orig < MIN_ACTIVITY and final < MIN_ACTIVITY:
                return 0.95

            # 4. If changed, was it verified by LOCAL flow?
            rid = data.get('local_router')
            flow_err = calc_flow_error(rid, if_id, field, final)

            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                return 0.95 # Very high confidence: Mathematics supports this

            # 5. Was it verified by REMOTE flow?
            if is_remotely_verified(final, field):
                return 0.90 # High confidence: Peer is verified

            # 6. Was it a "Dead Counter" repair (0 -> Non-Zero)?
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Moderately high: 0 is a common error mode

            # 7. Fallback
            return 0.5 # Low confidence: Changed based on peer but no verification
=======
        # -- Calibrate Confidence --

        def get_rate_confidence(orig, final, field):
            # Check consistency of the FINAL state
            rid = data.get('local_router')
            peer_id = data.get('connected_to')

            # 1. Link Symmetry Consistency
            symmetry_penalty = 0.0
            if peer_id and peer_id in state:
                # If checking RX, compare to Peer TX, and vice versa
                peer_final = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                diff = abs(final - peer_final)
                mag = max(final, peer_final, 1.0)
                if diff / mag > TOLERANCE:
                    symmetry_penalty = 0.4 # Significant penalty if we end in disagreement

            # 2. Flow Conservation Consistency (Local)
            flow_penalty = 0.0
            flow_verified = False
            flow_err = calc_flow_error(rid, if_id, field, final)

            if flow_err is not None:
                if flow_err < FLOW_TOLERANCE:
                    flow_verified = True
                else:
                    flow_penalty = 0.4 # Significant penalty if physically impossible

            # 3. Change Magnitude / Heuristics
            changed = abs(orig - final) > 0.001
            dead_repair = (orig < MIN_ACTIVITY and final > MIN_ACTIVITY)

            base_conf = 1.0
            if changed:
                if flow_verified:
                    base_conf = 0.95
                elif dead_repair:
                    base_conf = 0.85
                else:
                    base_conf = 0.7 # Unverified change
            else:
                # Unchanged
                if symmetry_penalty > 0 or flow_penalty > 0:
                     # We kept original but it's consistent with nothing?
                     base_conf = 0.6

            # Apply Consistency Penalties
            conf = base_conf * (1.0 - symmetry_penalty) * (1.0 - flow_penalty)

            return max(0.0, min(1.0, conf))
>>>>>>> REPLACE
</DIFF>