<NAME>
adaptive_flow_consensus
</NAME>

<DESCRIPTION>
Replaces the reliability-weighted logic with an "Adaptive Consensus" approach.
1. Removes the circular dependency where router imbalance reduces the weight of the very hints needed to fix that imbalance.
2. Implements outlier rejection for flow hints: if hints disagree, selects the one most consistent with measured non-zero values.
3. Refines confidence calibration with SNR scaling to avoid overconfidence in low-traffic (noisy) scenarios.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
Network telemetry repair algorithm using Reliability-Weighted Flow Consensus.
1. Computes 'Router Reliability' scores based on flow balance strictness.
2. Resolves link rates using a weighted consensus of Flow Hints (weighted by source reliability).
3. Employs an Adaptive Confidence Model that scales with signal magnitude (SNR) and verification quality.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:

    # Constants
    HARDENING_THRESHOLD = 0.02   # 2% tolerance
    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps active threshold
    ITERATIONS = 5               # Convergence passes

    # --- Phase 1: Initialization & Status Repair ---
    state = {}

    # Identify Verifiable Routers (All interfaces monitored)
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            verifiable_routers.add(r_id)

    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')

        peer_id = data.get('connected_to')
        peer_data = telemetry.get(peer_id, {}) if (peer_id and peer_id in telemetry) else {}

        # Traffic Evidence
        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(signals) if signals else 0.0

        # Status Logic
        status = raw_status
        status_conf = 1.0
        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                status = 'up'
                status_conf = 0.95
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
            status = 'down'
            status_conf = 0.8

        cur_rx = raw_rx if status == 'up' else 0.0
        cur_tx = raw_tx if status == 'up' else 0.0

        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }

    # --- Phase 2: Iterative Weighted Consensus ---
    for _ in range(ITERATIONS):
        # 1. Calculate Router Reliability Scores
        router_metrics = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)

            # Reliability: How well does this router conserve flow currently?
            mag = max(sum_rx, sum_tx, 1.0)
            imbalance = abs(sum_rx - sum_tx) / mag
            # Strict reliability metric: >50% imbalance = 0 reliability
            reliability = max(0.0, 1.0 - (imbalance * 2.0))

            router_metrics[r_id] = {'rx': sum_rx, 'tx': sum_tx, 'reliability': reliability}

        next_state = {}
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            def resolve_direction(local_val, peer_val, is_rx):
                # Gather Hints with Weights
                hints = []
                weights = []

                # Local Hint
                r_id = curr.get('local_router')
                if r_id in router_metrics:
                    rm = router_metrics[r_id]
                    if is_rx: h = rm['tx'] - (rm['rx'] - local_val)
                    else:     h = rm['rx'] - (rm['tx'] - local_val)
                    hints.append(max(0.0, h))
                    weights.append(rm['reliability'])

                # Remote Hint (Dual-Sided)
                rr_id = curr.get('remote_router')
                if rr_id in router_metrics:
                    rm = router_metrics[rr_id]
                    if is_rx: h = rm['rx'] - (rm['tx'] - peer_val)
                    else:     h = rm['tx'] - (rm['rx'] - peer_val)
                    hints.append(max(0.0, h))
                    weights.append(rm['reliability'])

                # Weighted Consensus Target
                target = None
                if hints:
                    total_w = sum(weights)
                    if total_w > 0.01:
                        target = sum(h * w for h, w in zip(hints, weights)) / total_w
                    else:
                        # Fallback if both routers unreliable: Average hints
                        target = sum(hints) / len(hints)

                # Decision Logic

                # 1. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    avg = (local_val + peer_val) / 2.0
                    # Dead Sensor Check: If both sensors 0 but Target suggests traffic
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    return avg

                # 2. Symmetry Broken
                if target is not None:
                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Standard logic: Pick closest to Target
                    d_l = abs(local_val - target)
                    d_p = abs(peer_val - target)
                    return local_val if d_l < d_p else peer_val

                else:
                    # 3. No Hints (Heuristic)
                    # Trust Non-Zero
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD: return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD: return peer_val
                    return (local_val + peer_val) / 2.0

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_direction(curr['rx'], peer_tx, True)

            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_direction(curr['tx'], peer_rx, False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply Updates
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Final Metrics for Calibration
    final_metrics = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        mag = max(sum_rx, sum_tx, 1.0)
        imbalance = abs(sum_rx - sum_tx) / mag
        reliability = max(0.0, 1.0 - (imbalance * 2.0))
        final_metrics[r_id] = {'rx': sum_rx, 'tx': sum_tx, 'reliability': reliability}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        def calibrate(val, peer_val, local_r, remote_r, is_rx, status_down, stat_conf):
            if status_down: return stat_conf

            # 1. Symmetry Error
            denom_s = max(val, peer_val, 1.0)
            err_sym = abs(val - peer_val) / denom_s

            # 2. Flow Error & Reliability
            hints = []
            weights = []

            if local_r in final_metrics:
                m = final_metrics[local_r]
                if is_rx: h = m['tx'] - (m['rx'] - val)
                else:     h = m['rx'] - (m['tx'] - val)
                hints.append(max(0.0, h))
                weights.append(m['reliability'])

            if remote_r in final_metrics:
                m = final_metrics[remote_r]
                if is_rx: h = m['rx'] - (m['tx'] - peer_val)
                else:     h = m['tx'] - (m['rx'] - peer_val)
                hints.append(max(0.0, h))
                weights.append(m['reliability'])

            err_flow = None
            avg_reliability = 0.0

            if hints:
                total_w = sum(weights)
                if total_w > 0.01:
                    target = sum(h * w for h, w in zip(hints, weights)) / total_w
                    avg_reliability = total_w / len(weights)
                else:
                    target = sum(hints) / len(hints)
                    avg_reliability = 0.0

                denom_f = max(val, target, 1.0)
                err_flow = abs(val - target) / denom_f

            # 3. Signal Magnitude (SNR Adjustment)
            snr_factor = 1.0
            if val < 10.0:
                snr_factor = 0.95 # Slight penalty for low traffic

            # Tiered Confidence Logic

            # A. Perfect Corroboration (Flow + Symmetry agree)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                # High confidence, scaled by how reliable the flow hints were
                base = 0.95 + (0.05 * avg_reliability)
                return min(1.0, base * snr_factor)

            # B. Flow Verification (Symmetry Broken, Flow fixes it)
            if err_flow is not None and err_flow < 0.05:
                base = 0.90 + (0.05 * avg_reliability)
                return min(1.0, base * snr_factor)

            # C. Symmetry Verification (Flow Missing or Disagrees)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only (Strong)
                    return 0.95 * snr_factor
                else:
                    # Symmetry holds, but Flow disagrees (Conflict)
                    return 0.75 * snr_factor

            # D. Heuristic (No Flow, Broken Symmetry)
            if err_flow is None:
                # Trust Non-Zero Heuristic
                # Apply heavier SNR scaling here
                mag = max(val, peer_val)
                if mag > 100.0: return 0.85
                if mag > 10.0:  return 0.75
                return 0.60

            # E. Conflict (Broken Sym, Broken Flow)
            return 0.30

        conf_rx = calibrate(final_rx, peer_tx, data['local_router'], data['remote_router'], True, data['status']=='down', data['status_conf'])
        conf_tx = calibrate(final_tx, peer_rx, data['local_router'], data['remote_router'], False, data['status']=='down', data['status_conf'])

        result[iface_id] = {
            'rx_rate': (data['orig_rx'], final_rx, conf_rx),
            'tx_rate': (data['orig_tx'], final_tx, conf_tx),
            'interface_status': (data['orig_status'], data['status'], data['status_conf']),
            'connected_to': peer_id,
            'local_router': data['local_router'],
            'remote_router': data['remote_router']
        }

    return result
=======
"""
Network telemetry repair algorithm using Adaptive Consensus and Flow Conservation.
1. Identifies Verifiable Routers.
2. Resolves rates using a priority logic: Symmetry > Flow Consensus > Heuristic.
3. Implements 'Double Dead' detection where valid flow implies traffic despite zero readings.
4. Calibrates confidence using a multi-factor model (Symmetry, Flow, SNR).
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:

    # Constants
    HARDENING_THRESHOLD = 0.02   # 2% tolerance
    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps active threshold
    ITERATIONS = 5               # Refinement passes

    # --- Phase 1: Initialization & Status Repair ---
    state = {}

    # Helper to get peer data safely
    def get_peer_data(curr_data):
        pid = curr_data.get('connected_to')
        if pid and pid in telemetry:
            return telemetry[pid]
        return {}

    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')
        peer_data = get_peer_data(data)

        # Traffic Evidence: Look for any sign of life
        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(signals) if signals else 0.0

        # Status Logic
        status = raw_status
        status_conf = 1.0

        # If any significant traffic is detected, link must be UP
        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                status = 'up'
                status_conf = 0.95
        # If I say UP but Peer says DOWN, and no traffic -> Likely DOWN
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
            status = 'down'
            status_conf = 0.8

        cur_rx = raw_rx if raw_rx > 0 else 0.0
        cur_tx = raw_tx if raw_tx > 0 else 0.0

        # If status determined DOWN, zero out rates initially
        if status == 'down':
            cur_rx, cur_tx = 0.0, 0.0

        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }

    # --- Phase 2: Iterative Consensus ---

    # Identify Verifiable Routers (All interfaces monitored)
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in state for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_state = {}

        # 1. Calculate Flow Balances for Verifiable Routers
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            s_rx = sum(state[i]['rx'] for i in ifaces)
            s_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': s_rx, 'tx': s_tx}

        # 2. Resolve Links
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            # Helper to solve for one direction (e.g., My RX)
            def resolve_rate(local_val, peer_val, is_rx):
                # Gather Hints
                hints = []

                # Local Hint
                r_id = curr.get('local_router')
                if r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx: h = rb['tx'] - (rb['rx'] - local_val)
                    else:     h = rb['rx'] - (rb['tx'] - local_val)
                    hints.append(max(0.0, h))

                # Remote Hint
                rr_id = curr.get('remote_router')
                if rr_id in router_balances:
                    rb = router_balances[rr_id]
                    if is_rx: h = rb['rx'] - (rb['tx'] - peer_val)
                    else:     h = rb['tx'] - (rb['rx'] - peer_val)
                    hints.append(max(0.0, h))

                # Consensus Hint
                target = None
                if hints:
                    if len(hints) > 1 and abs(hints[0] - hints[1]) > (0.2 * max(hints) + 1.0):
                        # Hints disagree. Use the one closer to the max measured value.
                        # Logic: Failures usually drop values. The higher measured value is likely more correct.
                        ref = max(local_val, peer_val)
                        target = min(hints, key=lambda x: abs(x - ref))
                    else:
                        target = sum(hints) / len(hints)

                # Decision Priority

                # 1. Symmetry (Agreement between sensors)
                denom = max(local_val, peer_val, 1.0)
                if abs(local_val - peer_val) <= HARDENING_THRESHOLD * denom:
                    avg = (local_val + peer_val) / 2.0
                    # Double Dead Check: Sensors agree on 0, but Physics says Traffic?
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    return avg

                # 2. Flow Conservation (External Truth)
                if target is not None:
                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        if target > 5.0: return target
                        return 0.0

                    # Trust Target if sensors disagree
                    return target

                # 3. Heuristic (Fallback)
                # Trust Non-Zero / Max
                if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD: return local_val
                if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD: return peer_val
                return (local_val + peer_val) / 2.0

            # Resolve RX (Target Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_rate(curr['rx'], peer_tx, True)

            # Resolve TX (Target Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_rate(curr['tx'], peer_rx, False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Update State
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Recompute balances for final checking
    final_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        s_rx = sum(state[i]['rx'] for i in ifaces)
        s_tx = sum(state[i]['tx'] for i in ifaces)
        final_balances[r_id] = {'rx': s_rx, 'tx': s_tx}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        def calibrate(val, peer_val, local_r, remote_r, is_rx, is_down, stat_conf):
            if is_down: return stat_conf

            # 1. Symmetry Error
            denom_s = max(val, peer_val, 1.0)
            err_sym = abs(val - peer_val) / denom_s

            # 2. Flow Error
            hints = []
            if local_r in final_balances:
                rb = final_balances[local_r]
                if is_rx: h = rb['tx'] - (rb['rx'] - val)
                else:     h = rb['rx'] - (rb['tx'] - val)
                hints.append(max(0.0, h))
            if remote_r in final_balances:
                rb = final_balances[remote_r]
                if is_rx: h = rb['rx'] - (rb['tx'] - peer_val)
                else:     h = rb['tx'] - (rb['rx'] - peer_val)
                hints.append(max(0.0, h))

            err_flow = None
            if hints:
                # Use best matching hint for calibration (optimistic verification)
                best_hint = min(hints, key=lambda x: abs(x - val))
                denom_f = max(val, best_hint, 1.0)
                err_flow = abs(val - best_hint) / denom_f

            # 3. SNR Scaling (Penalty for low signal noise)
            snr_score = 1.0
            if val < 5.0: snr_score = 0.8
            elif val < 20.0: snr_score = 0.95

            # Confidence Tiers

            # A. Verified (Symmetry + Flow)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                return 1.0 * snr_score

            # B. Flow Rescue (Symmetry Broken, Flow Verified)
            if err_flow is not None and err_flow < 0.05:
                # We trusted flow.
                return 0.90 * snr_score

            # C. Symmetry Verified (Flow Unknown/Disagree)
            if err_sym < 0.05:
                if err_flow is None: return 0.95 * snr_score
                return 0.75 * snr_score # Flow disagrees

            # D. Heuristic (Trust Non-Zero)
            if err_flow is None:
                return 0.60 * snr_score

            # E. Conflict
            return 0.30

        conf_rx = calibrate(final_rx, peer_tx, data['local_router'], data['remote_router'], True, data['status']=='down', data['status_conf'])
        conf_tx = calibrate(final_tx, peer_rx, data['local_router'], data['remote_router'], False, data['status']=='down', data['status_conf'])

        result[iface_id] = {
            'rx_rate': (data['orig_rx'], final_rx, conf_rx),
            'tx_rate': (data['orig_tx'], final_tx, conf_tx),
            'interface_status': (data['orig_status'], data['status'], data['status_conf']),
            'connected_to': peer_id,
            'local_router': data['local_router'],
            'remote_router': data['remote_router']
        }

    return result
>>>>>>> REPLACE
</DIFF>