<NAME>
residual_synthesis_repair
</NAME>

<DESCRIPTION>
Integrates a "Residual Synthesis" mechanism to detect and repair "Double-Dead" links (where both ends erroneously report zero). The algorithm calculates the residual traffic required to balance verifiable routers and injects this as a synthetic candidate into the voting pool. This allows the system to recover missing traffic flows that are invisible to local telemetry but implied by flow conservation constraints on the connected routers.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    def calc_flow_error(rid, if_target, field, value):
        """Calculates flow error for a router given a hypothetical value for one interface."""
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute hypothetical value
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            # Check Agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agreement: Average to smooth noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagreement: Solve using Flow Conservation
                rid_local = s['local_router']
                rid_remote = state[peer_id]['local_router']

                err_local_1 = calc_flow_error(rid_local, if_id, 'tx', cand_tx)
                err_remote_1 = calc_flow_error(rid_remote, peer_id, 'rx', cand_tx)

                err_local_2 = calc_flow_error(rid_local, if_id, 'tx', cand_rx)
                err_remote_2 = calc_flow_error(rid_remote, peer_id, 'rx', cand_rx)

                # Scoring: Lower is better
                def get_score(err):
                    if err is None: return 0.05  # Neutral penalty for unverifiable
                    return min(err, 1.0)         # Clamp error impact

                score_1 = get_score(err_local_1) + get_score(err_remote_1)
                score_2 = get_score(err_local_2) + get_score(err_remote_2)

                # Heuristic: Penalize zero if the other side has significant traffic
                if cand_tx < MIN_ACTIVITY and cand_rx > MIN_ACTIVITY: score_1 += 0.5
                if cand_rx < MIN_ACTIVITY and cand_tx > MIN_ACTIVITY: score_2 += 0.5

                if score_1 < score_2:
                    best_val = cand_tx
                elif score_2 < score_1:
                    best_val = cand_rx
                else:
                    best_val = (cand_tx + cand_rx) / 2.0

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    def calc_flow_error(rid, if_target, field, value):
        """Calculates flow error for a router given a hypothetical value for one interface."""
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute hypothetical value
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    def get_residual_val(rid, if_target, field):
        """Calculates value required to perfectly balance a verifiable router."""
        if rid not in verifiable_routers: return None

        sum_in, sum_out = 0.0, 0.0
        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']
            # Exclude the specific component we are solving for
            if iface == if_target:
                if field == 'rx': r = 0.0
                else: t = 0.0
            sum_in += r
            sum_out += t

        # Balance: In = Out
        val = sum_out - sum_in if field == 'rx' else sum_in - sum_out
        return max(val, 0.0)

    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            candidates = [cand_tx, cand_rx]
            has_synth = False

            # Residual Synthesis: If link appears dead, check if verifiable routers imply a flow
            if cand_tx < MIN_ACTIVITY and cand_rx < MIN_ACTIVITY:
                synth_tx = get_residual_val(rid_local, if_id, 'tx')
                if synth_tx is not None and synth_tx > MIN_ACTIVITY:
                    candidates.append(synth_tx)
                    has_synth = True

                synth_rx = get_residual_val(rid_remote, peer_id, 'rx')
                if synth_rx is not None and synth_rx > MIN_ACTIVITY:
                    candidates.append(synth_rx)
                    has_synth = True

            # Deduplicate candidates
            unique_cands = []
            for c in candidates:
                if not any(abs(c - x) < 1e-4 for x in unique_cands):
                    unique_cands.append(c)

            # Decision Logic
            best_val = cand_tx
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            # If we have synthetic candidates or disagreement, we vote. Otherwise average.
            if not has_synth and diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                best_score = float('inf')

                for cand in unique_cands:
                    err_local = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    def get_score(err):
                        if err is None: return 0.05
                        return min(err, 1.0)

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize zero if we have a better active alternative
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>