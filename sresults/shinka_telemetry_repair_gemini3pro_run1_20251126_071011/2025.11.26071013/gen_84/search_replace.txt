<NAME>
implement_residual_consensus
</NAME>

<DESCRIPTION>
Replaces the pairwise voting logic with a robust clustering consensus algorithm that includes "Residual Synthesis".
1. Calculates `residual` values (what the rate *should* be to balance the router) for both local and remote routers if they are verifiable.
2. Creates a pool of candidates: Local Measurement, Remote Measurement, Local Residual, Remote Residual.
3. Groups these candidates into clusters based on value similarity.
4. Scores clusters based on weight (Residuals get higher weight as they represent aggregate evidence).
5. Applies a heuristic to penalize "Dead" (zero) clusters if "Alive" clusters exist, fixing "Double Dead" scenarios where both links report 0 but traffic is flowing.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    def calc_flow_error(rid, if_target, field, value):
        """Calculates flow error for a router given a hypothetical value."""
        if rid not in verifiable_routers: return None
        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value
            sum_rx += r
            sum_tx += t
        return abs(sum_rx - sum_tx) / max(sum_rx, sum_tx, 1.0)

    def calculate_residual(rid, if_target, field):
        """Calculates the value required to perfectly balance the router."""
        if rid not in verifiable_routers: return None
        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_interfaces[rid]:
            # Exclude the target component from the sum
            if iface == if_target:
                r = 0.0 if field == 'rx' else state[iface]['rx']
                t = 0.0 if field == 'tx' else state[iface]['tx']
            else:
                r = state[iface]['rx']
                t = state[iface]['tx']
            sum_rx += r
            sum_tx += t
        # Balance: Sum(Rx) = Sum(Tx) -> Target = Total_Opposite - Sum_Others
        val = sum_tx - sum_rx if field == 'rx' else sum_rx - sum_tx
        return max(val, 0.0)

    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # Link: Tx(Local) -> Rx(Peer)
            meas_tx = s['tx']
            meas_rx = state[peer_id]['rx']

            # Candidates: (value, weight, source_type)
            candidates = []
            candidates.append((meas_tx, 1.0, 'meas'))
            candidates.append((meas_rx, 1.0, 'meas'))

            # Calculate Residuals (Derived candidates)
            rid_loc = s['local_router']
            res_tx = calculate_residual(rid_loc, if_id, 'tx')
            if res_tx is not None:
                # High weight: Residuals represent the consensus of N other interfaces
                candidates.append((res_tx, 2.0, 'resid'))

            rid_rem = state[peer_id]['local_router']
            res_rx = calculate_residual(rid_rem, peer_id, 'rx')
            if res_rx is not None:
                candidates.append((res_rx, 2.0, 'resid'))

            # Clustering
            clusters = []
            for val, w, src in candidates:
                matched = False
                for c in clusters:
                    avg = c['sum'] / c['count']
                    diff = abs(val - avg)
                    if diff < max(avg * TOLERANCE, MIN_ACTIVITY):
                        c['sum'] += val
                        c['w'] += w
                        c['count'] += 1
                        matched = True
                        break
                if not matched:
                    clusters.append({'sum': val, 'w': w, 'count': 1})

            # Select Best Cluster
            best_val = meas_tx
            best_score = -1.0

            # Find max value to detect "Dead vs Alive" scenarios
            max_val = max((c['sum']/c['count'] for c in clusters), default=0.0)

            for c in clusters:
                val = c['sum'] / c['count']
                score = c['w']

                # Heuristic: If we have a significant "Alive" signal, penalize "Dead" signals
                # This fixes "Double Dead" or "One Dead" scenarios where flow implies traffic
                if val < MIN_ACTIVITY and max_val > MIN_ACTIVITY:
                    score *= 0.1

                if score > best_score:
                    best_score = score
                    best_val = val

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>

<NAME>
refine_confidence_calibration
</NAME>

<DESCRIPTION>
Updates confidence logic to clearly distinguish between "Verified" (fits flow conservation), "Consistent" (fits peer), and "Unverifiable" states. Penalizes confidence when flow conservation is broken (detects bad repairs or broken routers) and boosts confidence when flow conservation is satisfied.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        def get_rate_confidence(orig, final, field):
            # Check verification status
            rid = data.get('local_router')
            local_verified = False
            flow_err = calc_flow_error(rid, if_id, field, final)
            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                local_verified = True

            remote_verified = is_remotely_verified(final, field)

            # Check consistency with peer (Symmetry)
            peer_consistent = True
            peer_id = data.get('connected_to')
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 1. Unchanged Data
            if abs(orig - final) < 0.001:
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.95
                if not peer_consistent: return 0.6 # Unchanged but disagrees with peer
                # If unverifiable (edge) but consistent with peer
                if flow_err is None: return 0.9
                # If unverifiable and inconsistent with flow (but we didn't change it)
                if flow_err is not None and flow_err >= FLOW_TOLERANCE: return 0.7
                return 0.9

            # 2. Changed Data

            # Smoothing (Small relative change < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Noise Consensus (Both < Min Activity)
            if orig < MIN_ACTIVITY and final < MIN_ACTIVITY:
                return 0.95

            # Verified changes
            if local_verified and remote_verified:
                return 0.98
            if local_verified:
                return 0.95
            if remote_verified:
                return 0.90

            # Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Dead counter repair

            # Fallback
            return 0.5 # Changed but unverifiable
=======
        def get_rate_confidence(orig, final, field):
            # Check verification status (Flow Conservation)
            rid = data.get('local_router')
            flow_err = calc_flow_error(rid, if_id, field, final)
            local_verified = (flow_err is not None and flow_err < FLOW_TOLERANCE)

            remote_verified = is_remotely_verified(final, field)

            # Check consistency with peer (Symmetry)
            peer_consistent = True
            peer_id = data.get('connected_to')
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            changed = abs(orig - final) > 0.001

            # --- Confidence Scoring ---

            # Case 1: Verified Correctness (Gold Standard)
            if local_verified and remote_verified:
                return 0.99 if not changed else 0.98

            # Case 2: Local Verification (Silver Standard)
            if local_verified:
                if not changed: return 0.98
                return 0.95

            # Case 3: Remote Verification (Silver Standard)
            if remote_verified:
                if not changed: return 0.95
                return 0.90

            # Case 4: No Verification (Unverifiable Routers)
            if flow_err is None:
                if not peer_consistent:
                    return 0.6 # Disagreement and no way to check

                if not changed:
                    return 0.9 # Assume innocence

                # We changed it: Why?
                # Smoothing
                if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                    return 0.95
                # Dead Repair (0 -> Active)
                if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                    return 0.85

                # Changed to match peer?
                return 0.75

            # Case 5: Verification Failed (Broken Router or Bad Value)
            # If we are here, flow_err is High (>= TOLERANCE)
            if not changed:
                return 0.6 # Retaining a value that breaks flow conservation is suspicious

            # We changed it, but it still doesn't satisfy flow?
            # Maybe the router is just broken (packet loss).
            return 0.5
>>>>>>> REPLACE
</DIFF>