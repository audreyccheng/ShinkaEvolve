# EVOLVE-BLOCK-START
"""
Network telemetry repair algorithm using SNR-Aware Flow Consensus.
1. Iteratively refines traffic rates using Flow Conservation hints from verifiable routers.
2. Resolves asymmetries by anchoring to Flow Hints or using a 'Trust Max' heuristic for strong signals.
3. Calculates confidence based on Flow/Symmetry agreement, scaled by Signal Magnitude (SNR).
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:

    # Constants
    HARDENING_THRESHOLD = 0.02   # 2% tolerance for symmetry
    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps active threshold
    ITERATIONS = 10              # More iterations for deep convergence

    # --- Phase 1: Initialization & Status Repair ---
    state = {}

    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')

        peer_id = data.get('connected_to')
        peer_data = telemetry.get(peer_id) if (peer_id and peer_id in telemetry) else {}

        # Traffic Evidence
        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(signals) if signals else 0.0

        # Status Inference
        status = raw_status
        status_conf = 1.0

        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                status = 'up'
                status_conf = 0.95
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
            status = 'down'
            status_conf = 0.8

        # Initial Rate Beliefs
        if status == 'down':
            cur_rx, cur_tx = 0.0, 0.0
        else:
            cur_rx = raw_rx if raw_rx > 0 else 0.0
            cur_tx = raw_tx if raw_tx > 0 else 0.0

        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }

    # --- Phase 2: Iterative Consensus ---

    # Identify Verifiable Routers (Fully Monitored)
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in state for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_state = {}

        # Calculate Flow Balances for Verifiable Routers
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            # --- Logic to Resolve One Direction ---
            def resolve_direction(local_val, peer_val, is_rx):
                # Candidates: local_val, peer_val
                # Goal: Find true rate
                
                hints = []
                
                # 1. Local Hint (Conservation at Local Router)
                r_id = curr.get('local_router')
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # In = Out - (Other_In) -> RX = Total_TX - (Total_RX - RX)
                        h = rb['tx'] - (rb['rx'] - local_val)
                    else:
                        h = rb['rx'] - (rb['tx'] - local_val)
                    hints.append(max(0.0, h))

                # 2. Remote Hint (Conservation at Remote Router)
                rr_id = curr.get('remote_router')
                if rr_id and rr_id in router_balances:
                    rb_r = router_balances[rr_id]
                    if is_rx:
                        # Link RX = Remote TX. Remote TX = Rem_Total_RX - (Rem_Total_TX - Rem_Link_TX)
                        # We use peer_val as current belief of Rem_Link_TX
                        h = rb_r['rx'] - (rb_r['tx'] - peer_val)
                    else:
                        h = rb_r['tx'] - (rb_r['rx'] - peer_val)
                    hints.append(max(0.0, h))

                # Calculate Target from Hints
                target = None
                if hints:
                    target = sum(hints) / len(hints)

                # Decision Logic

                # A. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds
                    avg = (local_val + peer_val) / 2.0
                    
                    # Double Dead Check: If sensors say 0 but hints say Traffic, trust hints
                    # Only if target is significant (> 5 Mbps) to avoid noise amplification
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    
                    return avg

                # B. Symmetry Broken
                if target is not None:
                    # We have hints. Use them to pick the best candidate.
                    
                    # Special Case: Double Dead in measurements
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        if target > 5.0: return target
                        return 0.0

                    # Choose candidate closest to target
                    dist_l = abs(local_val - target)
                    dist_p = abs(peer_val - target)

                    if dist_l < dist_p:
                        return local_val
                    else:
                        return peer_val
                
                else:
                    # C. No Hints + Broken Symmetry
                    # Heuristic: Trust Max (Assume "Drop to Zero" failure mode)
                    return max(local_val, peer_val)

            # Resolve RX
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_direction(curr['rx'], peer_tx, is_rx=True)

            # Resolve TX
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_direction(curr['tx'], peer_rx, is_rx=False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply Updates
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Recalculate balances for final error checking
    final_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state
        
        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        def calibrate(val, peer_val, local_r, remote_r, is_rx, is_down, stat_conf):
            if is_down:
                # If down, we are confident if value is effectively 0
                return stat_conf if val < TRAFFIC_THRESHOLD else 0.5 * stat_conf

            # 1. Symmetry Error
            denom_s = max(val, peer_val, 1.0)
            err_sym = abs(val - peer_val) / denom_s

            # 2. Flow Error (Best Hint Match)
            err_flow = None
            hints = []
            if local_r in final_balances:
                rb = final_balances[local_r]
                if is_rx: h = rb['tx'] - (rb['rx'] - val)
                else:     h = rb['rx'] - (rb['tx'] - val)
                hints.append(max(0.0, h))
            
            if remote_r in final_balances:
                rb = final_balances[remote_r]
                if is_rx: h = rb['rx'] - (rb['tx'] - peer_val)
                else:     h = rb['tx'] - (rb['rx'] - peer_val)
                hints.append(max(0.0, h))
            
            if hints:
                target = sum(hints) / len(hints)
                denom_f = max(val, target, 1.0)
                err_flow = abs(val - target) / denom_f

            # 3. SNR Scaling (Signal-to-Noise Ratio)
            # We trust larger values more easily when relying on heuristics, 
            # but we also penalize errors more on large values? 
            # Actually, standardizing on magnitude: 
            # Recovering 100Mbps is more "significant" than 0.1Mbps.
            # Low magnitude (noise floor) reduces confidence in Heuristic repairs.
            mag = max(val, peer_val)
            snr_score = 1.0
            if mag < 5.0:
                snr_score = 0.8  # Penalty for noise floor ambiguity

            # Confidence Tiers

            # A. Perfect (Flow + Sym)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                return 1.0

            # B. Flow Verified (Sym Broken, but Flow confirms current val)
            if err_flow is not None and err_flow < 0.05:
                # We trusted flow over symmetry.
                return 0.90

            # C. Symmetry Verified (No Flow, or Flow disagrees slightly)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer. Strong.
                    return 0.95
                else:
                    # Conflict with flow? (e.g. router imbalance due to OTHER link)
                    # Peer agreement is still strong evidence for THIS link.
                    return 0.80

            # D. Heuristic (No Hint, Broken Sym)
            if err_flow is None:
                # We picked max(local, peer).
                # If the signal is strong, we are fairly confident (telemetry usually drops packets, not invents them).
                if mag > 50.0: return 0.85
                if mag > 10.0: return 0.75
                return 0.50 * snr_score # Low confidence in noise

            # E. Conflict (Broken Sym, Broken Flow)
            # Nothing matches.
            return 0.30

        conf_rx = calibrate(final_rx, peer_tx, data['local_router'], data['remote_router'], True, data['status']=='down', data['status_conf'])
        conf_tx = calibrate(final_tx, peer_rx, data['local_router'], data['remote_router'], False, data['status']=='down', data['status_conf'])

        result[iface_id] = {
            'rx_rate': (data['orig_rx'], final_rx, conf_rx),
            'tx_rate': (data['orig_tx'], final_tx, conf_tx),
            'interface_status': (data['orig_status'], data['status'], data['status_conf']),
            'connected_to': peer_id,
            'local_router': data['local_router'],
            'remote_router': data['remote_router']
        }

    return result
# EVOLVE-BLOCK-END