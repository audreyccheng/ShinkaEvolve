<NAME>
residual_synthesis_rate_repair
</NAME>

<DESCRIPTION>
This edit enhances the rate repair algorithm by introducing "Residual Synthesis". When both ends of a link report low/zero traffic (which might be a double failure), the algorithm now attempts to infer the correct traffic rate using flow conservation constraints from verifiable neighbors. It also generalizes the candidate selection logic to handle multiple candidates (local, remote, synthesized) with robust scoring and tie-breaking via averaging, improving repair accuracy in complex failure scenarios.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Helper: Flow Error Calculation ---
    def get_flow_error(rid, if_target=None, field=None, value=None):
        """
        Calculates the relative flow error (imbalance) for a router.
        Optionally allows substituting a speculative value for one interface.
        """
        if rid not in verifiable_routers:
            return None

        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_map[rid]:
            # Use speculative value if this is the target interface
            if iface == if_target:
                r = value if field == 'rx' else state[iface]['rx']
                t = value if field == 'tx' else state[iface]['tx']
            else:
                r = state[iface]['rx']
                t = state[iface]['tx']
            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    # --- 2. Status Repair ---
=======
    # --- Helper: Flow Error Calculation ---
    def get_flow_error(rid, if_target=None, field=None, value=None):
        """
        Calculates the relative flow error (imbalance) for a router.
        Optionally allows substituting a speculative value for one interface.
        """
        if rid not in verifiable_routers:
            return None

        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_map[rid]:
            # Use speculative value if this is the target interface
            if iface == if_target:
                r = value if field == 'rx' else state[iface]['rx']
                t = value if field == 'tx' else state[iface]['tx']
            else:
                r = state[iface]['rx']
                t = state[iface]['tx']
            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    def get_residual(rid, if_target, field):
        """Calculates the value needed to satisfy flow conservation at rid."""
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_map[rid]:
            if iface == if_target:
                continue
            sum_rx += state[iface]['rx']
            sum_tx += state[iface]['tx']

        # Conservation: Sum_Rx = Sum_Tx
        if field == 'rx':
            # Target is Rx. Rx_Target + Rx_Others = Tx_Total
            val = sum_tx - sum_rx
        else:
            # Target is Tx. Rx_Total = Tx_Target + Tx_Others
            val = sum_rx - sum_tx

        return max(0.0, val)

    # --- 2. Status Repair ---
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---
    # Run multiple passes to allow flow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # The link connects Local(Tx) -> Remote(Rx)
            # We want to find the consensus value for this traffic flow

            val_tx = s['tx']              # Local view
            val_rx = state[peer_id]['rx'] # Remote view

            # Check for Agreement
            diff = abs(val_tx - val_rx)
            mag = max(val_tx, val_rx, 1.0)

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agreement: Just smooth out noise
                new_val = (val_tx + val_rx) / 2.0
            else:
                # Disagreement: Resolve conflict using Flow Conservation constraints
                rid_local = s['local_router']
                rid_remote = s['remote_router']

                # Calculate errors if we chose TX value
                err_local_tx = get_flow_error(rid_local, if_id, 'tx', val_tx)
                err_remote_tx = get_flow_error(rid_remote, peer_id, 'rx', val_tx)

                # Calculate errors if we chose RX value
                err_local_rx = get_flow_error(rid_local, if_id, 'tx', val_rx)
                err_remote_rx = get_flow_error(rid_remote, peer_id, 'rx', val_rx)

                # Scoring (Lower is better)
                # 0.0 = Verified Good, 0.5 = Unverifiable, 1.0 = Verified Bad
                def get_vote(err):
                    if err is None: return 0.5
                    if err < FLOW_TOLERANCE: return 0.0
                    return 1.0

                score_tx = get_vote(err_local_tx) + get_vote(err_remote_tx)
                score_rx = get_vote(err_local_rx) + get_vote(err_remote_rx)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                if val_tx < MIN_ACTIVITY and val_rx > MIN_ACTIVITY: score_tx += 0.4
                if val_rx < MIN_ACTIVITY and val_tx > MIN_ACTIVITY: score_rx += 0.4

                # Selection
                if score_tx < score_rx:
                    new_val = val_tx
                elif score_rx < score_tx:
                    new_val = val_rx
                else:
                    new_val = (val_tx + val_rx) / 2.0 # Tie -> Average

            # Update state immediately (Gauss-Seidel style)
            state[if_id]['tx'] = new_val
            state[peer_id]['rx'] = new_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---
    # Run multiple passes to allow flow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # The link connects Local(Tx) -> Remote(Rx)
            # We want to find the consensus value for this traffic flow

            val_tx = s['tx']              # Local view
            val_rx = state[peer_id]['rx'] # Remote view

            candidates = [val_tx, val_rx]
            has_synth = False

            # Residual Synthesis: If link appears dead, check if verifiable routers imply a flow
            if val_tx < MIN_ACTIVITY and val_rx < MIN_ACTIVITY:
                rid_local = s['local_router']
                res_tx = get_residual(rid_local, if_id, 'tx')
                if res_tx is not None and res_tx > MIN_ACTIVITY:
                    candidates.append(res_tx)
                    has_synth = True

                rid_remote = s['remote_router']
                res_rx = get_residual(rid_remote, peer_id, 'rx')
                if res_rx is not None and res_rx > MIN_ACTIVITY:
                    candidates.append(res_rx)
                    has_synth = True

            # Deduplicate candidates
            unique_cands = []
            for c in candidates:
                if not any(abs(c - x) < 1e-4 for x in unique_cands):
                    unique_cands.append(c)

            # Check for Agreement (only if no synthesis was triggered)
            diff = abs(val_tx - val_rx)
            mag = max(val_tx, val_rx, 1.0)

            if not has_synth and diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agreement: Just smooth out noise
                new_val = (val_tx + val_rx) / 2.0
            else:
                # Disagreement or Synthetic Candidates: Score all unique candidates
                rid_local = s['local_router']
                rid_remote = s['remote_router']

                best_score = float('inf')
                best_cands = []

                for cand in unique_cands:
                    # Calculate errors if we chose this candidate
                    err_local = get_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = get_flow_error(rid_remote, peer_id, 'rx', cand)

                    # Scoring (Lower is better)
                    # 0.0 = Verified Good, 0.5 = Unverifiable, 1.0 = Verified Bad
                    def get_vote(err):
                        if err is None: return 0.5
                        if err < FLOW_TOLERANCE: return 0.0
                        return 1.0

                    score = get_vote(err_local) + get_vote(err_remote)

                    # Heuristic: Penalize zero/low values if we have a significantly higher alternative
                    # This helps avoid getting stuck in a local minimum where zero looks "ok" because of broken verification
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_cands = [cand]
                    elif abs(score - best_score) < 1e-4:
                        best_cands.append(cand)

                # If multiple best candidates, average them (Tie-breaking)
                new_val = sum(best_cands) / len(best_cands)

            # Update state immediately (Gauss-Seidel style)
            state[if_id]['tx'] = new_val
            state[peer_id]['rx'] = new_val
>>>>>>> REPLACE
</DIFF>