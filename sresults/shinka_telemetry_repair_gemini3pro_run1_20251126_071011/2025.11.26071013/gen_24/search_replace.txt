<NAME>
rate_repair_with_synthesis
</NAME>

<DESCRIPTION>
Replaces the pairwise consensus logic in the rate repair phase with a candidate-based selection system that includes flow synthesis.
Current logic only considers the two reported values (local TX and remote RX) and their average.
The new logic calculates "required" values based on flow conservation (synthesis) and adds them to the candidate pool.
This allows the algorithm to repair links where both sides report zero (double-dead) but the router's other interfaces indicate traffic must be flowing.
It also unifies the scoring and selection logic, using continuous error scores and a heuristic penalty for zero values when valid active candidates exist.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_local = s['local_router']
                rid_remote = state[peer_id]['local_router']

                # Helper to score a candidate value based on flow impact
                # Lower score is better
                def get_candidate_score(val):
                    # Check local router (TX side)
                    err_local = calc_flow_error(rid_local, if_id, 'tx', val)
                    # Check remote router (RX side)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', val)

                    score = 0.0

                    # Cost for Local
                    if err_local is None: score += 0.02 # Unverifiable = small cost
                    else: score += min(err_local, 1.0)  # Verifiable = actual error

                    # Cost for Remote
                    if err_remote is None: score += 0.02
                    else: score += min(err_remote, 1.0)

                    return score

                score_tx = get_candidate_score(cand_tx)
                score_rx = get_candidate_score(cand_rx)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                # Penalize the zero value
                if cand_tx < MIN_ACTIVITY and cand_rx > MIN_ACTIVITY: score_tx += 0.5
                if cand_rx < MIN_ACTIVITY and cand_tx > MIN_ACTIVITY: score_rx += 0.5

                if score_tx < score_rx:
                    best_val = cand_tx
                elif score_rx < score_tx:
                    best_val = cand_rx
                else:
                    best_val = (cand_tx + cand_rx) / 2.0 # Tie -> Average

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Helper: Calculate the required value for an interface to perfectly balance its router
    def get_required_val(rid, if_target, field):
        if rid not in verifiable_routers:
            return None

        sum_in = 0.0
        sum_out = 0.0

        for iface in router_interfaces[rid]:
            if iface == if_target: continue
            sum_in += state[iface]['rx']
            sum_out += state[iface]['tx']

        # If target is TX (outgoing), it must balance Total_IN - Other_OUT
        if field == 'tx':
            req = sum_in - sum_out
        # If target is RX (incoming), it must balance Total_OUT - Other_IN
        else:
            req = sum_out - sum_in

        return max(0.0, req)

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx
            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            # Generate Candidate Pool
            # 1. Existing measurements and their average
            candidates = {cand_tx, cand_rx, (cand_tx + cand_rx) / 2.0}

            # 2. Synthesized values from Flow Conservation (if routers are verifiable)
            synth_tx = get_required_val(rid_local, if_id, 'tx')
            if synth_tx is not None: candidates.add(synth_tx)

            synth_rx = get_required_val(rid_remote, peer_id, 'rx')
            if synth_rx is not None: candidates.add(synth_rx)

            # Filter invalid candidates (deduplicate, non-negative)
            candidates = sorted(list({c for c in candidates if c >= 0}))
            if not candidates: candidates = [0.0]

            # Score candidates
            best_val = cand_tx
            best_score = float('inf')

            # Check for activity in candidates to apply "Dead Counter" heuristic
            has_active_candidate = any(c > MIN_ACTIVITY for c in candidates)

            for val in candidates:
                # Calculate Flow Errors for this candidate
                err_local = calc_flow_error(rid_local, if_id, 'tx', val)
                err_remote = calc_flow_error(rid_remote, peer_id, 'rx', val)

                score = 0.0

                # Cost for Local Router
                if err_local is None: score += 0.02 # Unverifiable = small constant cost
                else: score += min(err_local, 1.0)  # Verifiable = actual error magnitude

                # Cost for Remote Router
                if err_remote is None: score += 0.02
                else: score += min(err_remote, 1.0)

                # Heuristic: Penalize Zero/Low values if other signals suggest activity
                # This fixes "Dead" counters (reporting 0) when synthesis or peer suggests traffic
                if val < MIN_ACTIVITY and has_active_candidate:
                    score += 0.5

                # Tie-breaker: Slight bonus for the Average value to promote smoothing when signals agree
                avg = (cand_tx + cand_rx) / 2.0
                if abs(val - avg) < 0.0001:
                    score -= 0.0001

                if score < best_score:
                    best_score = score
                    best_val = val

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>