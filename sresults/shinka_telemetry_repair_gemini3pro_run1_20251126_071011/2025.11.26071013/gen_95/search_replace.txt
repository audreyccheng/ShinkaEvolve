<NAME>
restore_dual_sided_flow_consensus_with_snr_calibration
</NAME>

<DESCRIPTION>
Reinstates the robust "Dual-Sided Flow Verification" logic which calculates flow hints from both local and remote routers to reach consensus. This provides stronger error correction than the previous simplified model.
Refines the confidence calibration by:
1. Using a tiered system (Perfect > Symmetry > Heuristic > Conflict) which aligns better with evaluation metrics than exponential decay.
2. Enhancing the "Heuristic" tier (used when flow verification is impossible) with Signal-to-Noise Ratio (SNR) awareness. It assigns higher confidence to repairs of high-magnitude traffic (likely real) versus low-magnitude traffic (likely noise/zombies).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 2: Iterative Constraint Satisfaction ---
    # We iteratively refine rates to satisfy Flow Conservation and Link Symmetry.

    # Identify routers where we have full visibility
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_state = {}

        # Calculate Router Balances (Flow Hints) based on current beliefs
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0, 'imp_rx': False, 'imp_tx': False}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state
            r_id = curr.get('local_router')

            # Sub-function to resolve a specific direction (RX or TX)
            def resolve_direction(local_val, peer_val, is_rx):
                # A. Get Flow Hint (if available)
                hint = None
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX should match Total TX - (Other RX)
                        hint = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        hint = max(0.0, rb['rx'] - (rb['tx'] - local_val))

                # B. Symmetry Logic
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                # Case 1: Symmetry holds (Agreement)
                if diff_sym <= HARDENING_THRESHOLD:
                    # Check for "Double Dead" masking a real flow
                    # If both 0, but hint says > 10 Mbps, trust hint.
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        if hint is not None and hint > 10.0:
                            return hint, True # Imputed
                    return (local_val + peer_val) / 2.0, False

                # Case 2: Symmetry Broken
                # If we have no hint, we can't objectively decide.
                if hint is None:
                    # Heuristic: If one is 0 and other is substantial, take substantial
                    if local_val < TRAFFIC_THRESHOLD and peer_val > TRAFFIC_THRESHOLD:
                        return peer_val, False
                    if peer_val < TRAFFIC_THRESHOLD and local_val > TRAFFIC_THRESHOLD:
                        return local_val, False
                    # Fallback: Trust Local
                    return local_val, False

                # We have a hint: Use it as arbiter
                denom_l = max(local_val, hint, 1.0)
                err_l = abs(local_val - hint) / denom_l

                denom_p = max(peer_val, hint, 1.0)
                err_p = abs(peer_val - hint) / denom_p

                if err_l < err_p:
                    return local_val, False
                else:
                    return peer_val, False

            # Resolve RX (Target Peer TX)
            tgt_peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            nxt_rx, imp_rx = resolve_direction(curr['rx'], tgt_peer_tx, is_rx=True)

            # Resolve TX (Target Peer RX)
            tgt_peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            nxt_tx, imp_tx = resolve_direction(curr['tx'], tgt_peer_rx, is_rx=False)

            next_state[iface_id] = {'rx': nxt_rx, 'tx': nxt_tx, 'imp_rx': imp_rx, 'imp_tx': imp_tx}

        # Apply updates synchronously
        for i, vals in next_state.items():
            state[i]['rx'] = vals['rx']
            state[i]['tx'] = vals['tx']
            state[i]['imp_rx'] = vals['imp_rx']
            state[i]['imp_tx'] = vals['imp_tx']

    # --- Phase 3: Final Calibration & Output ---
    result = {}

    # Final Flow Balance Calculation for confidence scoring
    final_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, curr in state.items():
        if curr['status'] == 'down':
             # inherit confidence from status determination
             c_rx = curr['status_conf'] if curr['orig_rx'] > TRAFFIC_THRESHOLD else 1.0
             c_tx = curr['status_conf'] if curr['orig_tx'] > TRAFFIC_THRESHOLD else 1.0

             result[iface_id] = {
                'rx_rate': (curr['orig_rx'], 0.0, c_rx),
                'tx_rate': (curr['orig_tx'], 0.0, c_tx),
                'interface_status': (curr['orig_status'], 'down', curr['status_conf']),
                'connected_to': curr['peer_id'],
                'local_router': curr['local_router'],
                'remote_router': telemetry[iface_id].get('remote_router')
             }
             continue

        # Calculate Confidence for Active Links
        peer_id = curr['peer_id']
        has_peer = peer_id and peer_id in state
        r_id = curr.get('local_router')

        def calculate_confidence(val, peer_val, is_rx):
            is_imputed = curr.get('imp_rx' if is_rx else 'imp_tx', False)
            if is_imputed:
                return IMPUTATION_CONFIDENCE

            # 1. Symmetry Error
            denom_s = max(val, peer_val, 1.0)
            err_sym = abs(val - peer_val) / denom_s
            if not has_peer: err_sym = 0.0

            # 2. Flow Error
            err_flow = 1.0 # Default high error
            if r_id and r_id in final_balances:
                rb = final_balances[r_id]
                hint = max(0.0, rb['tx'] - (rb['rx'] - val)) if is_rx else max(0.0, rb['rx'] - (rb['tx'] - val))
                denom_f = max(val, hint, 1.0)
                err_flow = abs(val - hint) / denom_f

            best_error = min(err_sym, err_flow)

            # Continuous Calibration
            conf = math.exp(-CONFIDENCE_DECAY * best_error)

            # Penalty for contradiction
            if best_error == err_flow and err_sym > 0.2:
                conf *= 0.9

            return max(0.0, min(1.0, conf))

        peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
        c_rx = calculate_confidence(curr['rx'], peer_tx, is_rx=True)

        peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
        c_tx = calculate_confidence(curr['tx'], peer_rx, is_rx=False)

        result[iface_id] = {
            'rx_rate': (curr['orig_rx'], curr['rx'], c_rx),
            'tx_rate': (curr['orig_tx'], curr['tx'], c_tx),
            'interface_status': (curr['orig_status'], curr['status'], curr['status_conf']),
            'connected_to': curr['peer_id'],
            'local_router': curr['local_router'],
            'remote_router': telemetry[iface_id].get('remote_router')
        }
=======
    # --- Phase 2: Iterative Constraint Satisfaction ---
    # We iteratively refine rates to satisfy Flow Conservation and Link Symmetry.

    # Identify routers where we have full visibility
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_state = {}

        # Calculate Router Balances (Flow Hints) based on current beliefs
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state
            r_id = curr.get('local_router')
            rr_id = curr.get('remote_router')

            # Sub-function to resolve a specific direction (RX or TX)
            def resolve_direction(local_val, peer_val, is_rx):
                # Gather Flow Hints from Local and Remote routers
                hints = []

                # 1. Local Hint (Conservation at Local Router)
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX (In) must balance Total TX (Out)
                        h = rb['tx'] - (rb['rx'] - local_val)
                    else:
                        # TX (Out) must balance Total RX (In)
                        h = rb['rx'] - (rb['tx'] - local_val)
                    hints.append(max(0.0, h))

                # 2. Remote Hint (Conservation at Remote Router)
                if rr_id and rr_id in router_balances:
                    rb_r = router_balances[rr_id]
                    if is_rx:
                        # Link is My_RX -> Peer_TX. Peer_TX is 'Out' for Remote.
                        # Peer_TX = Remote_Total_In - (Remote_Total_Out - Peer_TX)
                        h = rb_r['rx'] - (rb_r['tx'] - peer_val)
                    else:
                        # Link is My_TX -> Peer_RX. Peer_RX is 'In' for Remote.
                        h = rb_r['tx'] - (rb_r['rx'] - peer_val)
                    hints.append(max(0.0, h))

                # Determine Consensus Target
                target = sum(hints) / len(hints) if hints else None

                # Decision Logic

                # A. Symmetry Check
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check: If sensors 0 but flow says > 5, trust flow
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    return avg

                # B. Symmetry Broken
                if target is not None:
                    # Double Dead Safety
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Pick candidate closer to Target
                    denom_l = max(local_val, target, 1.0)
                    err_l = abs(local_val - target) / denom_l

                    denom_p = max(peer_val, target, 1.0)
                    err_p = abs(peer_val - target) / denom_p

                    if err_l < err_p: return local_val
                    return peer_val

                # C. No Hint + Broken Symmetry (Partial Observability)
                # Heuristic: Trust Non-Zero (Undercounting/Zeroing is common)
                if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                    return local_val
                if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD:
                    return peer_val

                # Fallback
                return (local_val + peer_val) / 2.0

            # Resolve RX (Target Peer TX)
            tgt_peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            nxt_rx = resolve_direction(curr['rx'], tgt_peer_tx, is_rx=True)

            # Resolve TX (Target Peer RX)
            tgt_peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            nxt_tx = resolve_direction(curr['tx'], tgt_peer_rx, is_rx=False)

            next_state[iface_id] = {'rx': nxt_rx, 'tx': nxt_tx}

        # Apply updates synchronously
        for i, vals in next_state.items():
            state[i]['rx'] = vals['rx']
            state[i]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration & Output ---
    result = {}

    # Final Flow Balance Calculation for confidence scoring
    final_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, curr in state.items():
        if curr['status'] == 'down':
             # High confidence in 0.0 if status is confidently down
             c_rx = curr['status_conf'] if curr['orig_rx'] > TRAFFIC_THRESHOLD else 1.0
             c_tx = curr['status_conf'] if curr['orig_tx'] > TRAFFIC_THRESHOLD else 1.0

             result[iface_id] = {
                'rx_rate': (curr['orig_rx'], 0.0, c_rx),
                'tx_rate': (curr['orig_tx'], 0.0, c_tx),
                'interface_status': (curr['orig_status'], 'down', curr['status_conf']),
                'connected_to': curr['peer_id'],
                'local_router': curr['local_router'],
                'remote_router': curr['remote_router']
             }
             continue

        # Calculate Confidence for Active Links
        peer_id = curr['peer_id']
        has_peer = peer_id and peer_id in state
        r_id = curr.get('local_router')
        rr_id = curr.get('remote_router')

        def calculate_confidence(val, peer_val, is_rx):
            # 1. Symmetry Error
            denom_s = max(val, peer_val, 1.0)
            err_sym = abs(val - peer_val) / denom_s if has_peer else 0.0

            # 2. Flow Error (Best Matching Hint)
            hints = []
            if r_id and r_id in final_balances:
                rb = final_balances[r_id]
                h = rb['tx'] - (rb['rx'] - val) if is_rx else rb['rx'] - (rb['tx'] - val)
                hints.append(max(0.0, h))
            if rr_id and rr_id in final_balances:
                rb_r = final_balances[rr_id]
                h = rb_r['rx'] - (rb_r['tx'] - peer_val) if is_rx else rb_r['tx'] - (rb_r['rx'] - peer_val)
                hints.append(max(0.0, h))

            err_flow = None
            if hints:
                target = sum(hints) / len(hints)
                denom_f = max(val, target, 1.0)
                err_flow = abs(val - target) / denom_f

            # Tiered Confidence Assignment with SNR Adjustment

            # Tier A: Perfect Verification (Symmetry + Flow)
            if err_flow is not None and err_flow < 0.05:
                if err_sym < 0.05: return 1.0
                return 0.90 # Flow Fixed Symmetry

            # Tier B: Symmetry Only
            if err_sym < 0.05:
                if err_flow is None: return 0.95
                return 0.75 # Flow Disagreement (Conflict)

            # Tier C: Heuristic (No Verification)
            if err_flow is None:
                # Signal-to-Noise Confidence
                if val > 50.0: return 0.85 # High traffic -> Real
                if val > 5.0:  return 0.70 # Moderate
                return 0.50 # Low traffic repair is uncertain

            # Tier D: Conflict (No Sym, No Flow Match)
            return 0.30

        peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
        c_rx = calculate_confidence(curr['rx'], peer_tx, is_rx=True)

        peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
        c_tx = calculate_confidence(curr['tx'], peer_rx, is_rx=False)

        result[iface_id] = {
            'rx_rate': (curr['orig_rx'], curr['rx'], c_rx),
            'tx_rate': (curr['orig_tx'], curr['tx'], c_tx),
            'interface_status': (curr['orig_status'], curr['status'], curr['status_conf']),
            'connected_to': curr['peer_id'],
            'local_router': curr['local_router'],
            'remote_router': curr['remote_router']
        }
>>>>>>> REPLACE
</DIFF>