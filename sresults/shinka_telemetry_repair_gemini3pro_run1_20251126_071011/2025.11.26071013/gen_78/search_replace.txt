<NAME>
cluster_aware_flow_consensus
</NAME>

<DESCRIPTION>
Implements "Smart Target Selection" in the flow consensus phase. Instead of blindly averaging divergent flow hints (e.g., 0 vs 100), the algorithm now checks if one of the hints strongly corroborates the active traffic signal (max of local/peer measurements). This effectively handles cases where one router generates a correct hint and the other generates a faulty hint due to sensor failures. Additionally, the calibration logic is refined to better reward high-magnitude signal recovery (SNR) while maintaining appropriate penalties for unverified heuristics.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 2: Iterative Weighted Consensus ---
    for _ in range(ITERATIONS):
        # 1. Calculate Router Reliability Scores
        router_metrics = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)

            # Reliability: How well does this router conserve flow currently?
            mag = max(sum_rx, sum_tx, 1.0)
            imbalance = abs(sum_rx - sum_tx) / mag
            # Strict reliability metric: >50% imbalance = 0 reliability
            reliability = max(0.0, 1.0 - (imbalance * 2.0))

            router_metrics[r_id] = {'rx': sum_rx, 'tx': sum_tx, 'reliability': reliability}

        next_state = {}
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            def resolve_direction(local_val, peer_val, is_rx):
                # Gather Hints with Weights
                hints = []
                weights = []

                # Local Hint
                r_id = curr.get('local_router')
                if r_id in router_metrics:
                    rm = router_metrics[r_id]
                    if is_rx: h = rm['tx'] - (rm['rx'] - local_val)
                    else:     h = rm['rx'] - (rm['tx'] - local_val)
                    hints.append(max(0.0, h))
                    weights.append(rm['reliability'])

                # Remote Hint (Dual-Sided)
                rr_id = curr.get('remote_router')
                if rr_id in router_metrics:
                    rm = router_metrics[rr_id]
                    if is_rx: h = rm['rx'] - (rm['tx'] - peer_val)
                    else:     h = rm['tx'] - (rm['rx'] - peer_val)
                    hints.append(max(0.0, h))
                    weights.append(rm['reliability'])

                # Weighted Consensus Target
                target = None
                if hints:
                    total_w = sum(weights)
                    if total_w > 0.01:
                        target = sum(h * w for h, w in zip(hints, weights)) / total_w
                    else:
                        # Fallback if both routers unreliable: Average hints
                        target = sum(hints) / len(hints)

                # Decision Logic

                # 1. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    avg = (local_val + peer_val) / 2.0
                    # Dead Sensor Check: If both sensors 0 but Target suggests traffic
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    return avg

                # 2. Symmetry Broken
                if target is not None:
                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Standard logic: Pick closest to Target
                    d_l = abs(local_val - target)
                    d_p = abs(peer_val - target)
                    return local_val if d_l < d_p else peer_val

                else:
                    # 3. No Hints (Heuristic)
                    # Trust Non-Zero
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD: return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD: return peer_val
                    return (local_val + peer_val) / 2.0

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_direction(curr['rx'], peer_tx, True)

            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_direction(curr['tx'], peer_rx, False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply Updates
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']
=======
    # --- Phase 2: Iterative Weighted Consensus ---
    for _ in range(ITERATIONS):
        # 1. Calculate Router Reliability Scores
        router_metrics = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)

            # Reliability: How well does this router conserve flow currently?
            mag = max(sum_rx, sum_tx, 1.0)
            imbalance = abs(sum_rx - sum_tx) / mag
            # Strict reliability metric: >50% imbalance = 0 reliability
            reliability = max(0.0, 1.0 - (imbalance * 2.0))

            router_metrics[r_id] = {'rx': sum_rx, 'tx': sum_tx, 'reliability': reliability}

        next_state = {}
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            def resolve_direction(local_val, peer_val, is_rx):
                # Gather Hints with Weights
                raw_hints = []

                # Local Hint
                r_id = curr.get('local_router')
                if r_id in router_metrics:
                    rm = router_metrics[r_id]
                    if is_rx: h = rm['tx'] - (rm['rx'] - local_val)
                    else:     h = rm['rx'] - (rm['tx'] - local_val)
                    raw_hints.append((max(0.0, h), rm['reliability']))

                # Remote Hint (Dual-Sided)
                rr_id = curr.get('remote_router')
                if rr_id in router_metrics:
                    rm = router_metrics[rr_id]
                    if is_rx: h = rm['rx'] - (rm['tx'] - peer_val)
                    else:     h = rm['tx'] - (rm['rx'] - peer_val)
                    raw_hints.append((max(0.0, h), rm['reliability']))

                # Smart Target Selection
                target = None
                if raw_hints:
                    # Filter out low reliability hints if high reliability ones exist
                    max_rel = max(w for h, w in raw_hints)
                    valid_hints = [(h, w) for h, w in raw_hints if w >= (max_rel * 0.5)]

                    if not valid_hints: valid_hints = raw_hints

                    # Cluster/Corroboration Logic
                    # If hints diverge (e.g. 0 vs 100), trust the one supported by high traffic signal
                    max_signal = max(local_val, peer_val)

                    if max_signal > TRAFFIC_THRESHOLD and len(valid_hints) > 1:
                        # Check if one hint matches max_signal significantly better than others
                        best_h = None
                        min_diff = float('inf')

                        for h, w in valid_hints:
                            diff = abs(h - max_signal)
                            if diff < min_diff:
                                min_diff = diff
                                best_h = h

                        # If the best hint is close (within 20% or 5Mbps) and others are far, pick it
                        if min_diff < max(5.0, max_signal * 0.2):
                            target = best_h

                    if target is None:
                        # Weighted Average Fallback
                        total_w = sum(w for h, w in valid_hints)
                        if total_w > 0.01:
                            target = sum(h * w for h, w in valid_hints) / total_w
                        else:
                            target = sum(h for h, w in raw_hints) / len(raw_hints)

                # Decision Logic

                # 1. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    avg = (local_val + peer_val) / 2.0
                    # Dead Sensor Check
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                        return target
                    return avg

                # 2. Symmetry Broken
                if target is not None:
                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Pick closest to Target
                    d_l = abs(local_val - target)
                    d_p = abs(peer_val - target)

                    # Tie-breaking: If equidistant (e.g. target is average of 0 and 100 -> 50)
                    # and one value is near zero, favor local_val if d_l <= d_p (prefer first)
                    # This relies on the Smart Target selection above to fix the target.
                    return local_val if d_l <= d_p else peer_val

                else:
                    # 3. No Hints (Heuristic)
                    # Trust Non-Zero
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD: return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD: return peer_val
                    return (local_val + peer_val) / 2.0

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_direction(curr['rx'], peer_tx, True)

            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_direction(curr['tx'], peer_rx, False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply Updates
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']
>>>>>>> REPLACE
<<<<<<< SEARCH
            # 3. Signal Magnitude (SNR Adjustment)
            snr_factor = 1.0
            if val < 10.0:
                snr_factor = 0.95 # Slight penalty for low traffic

            # Tiered Confidence Logic

            # A. Perfect Corroboration (Flow + Symmetry agree)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                # High confidence, scaled by how reliable the flow hints were
                base = 0.95 + (0.05 * avg_reliability)
                return min(1.0, base * snr_factor)

            # B. Flow Verification (Symmetry Broken, Flow fixes it)
            if err_flow is not None and err_flow < 0.05:
                base = 0.90 + (0.05 * avg_reliability)
                return min(1.0, base * snr_factor)

            # C. Symmetry Verification (Flow Missing or Disagrees)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only (Strong)
                    return 0.95 * snr_factor
                else:
                    # Symmetry holds, but Flow disagrees (Conflict)
                    return 0.75 * snr_factor

            # D. Heuristic (No Flow, Broken Symmetry)
            if err_flow is None:
                # Trust Non-Zero Heuristic
                # Apply heavier SNR scaling here
                mag = max(val, peer_val)
                if mag > 100.0: return 0.85
                if mag > 10.0:  return 0.75
                return 0.60

            # E. Conflict (Broken Sym, Broken Flow)
            return 0.30
=======
            # 3. Signal Magnitude (SNR Adjustment)
            snr_factor = 1.0
            if val < 5.0:
                snr_factor = 0.90 # Penalty for low traffic/noise floor

            # Tiered Confidence Logic

            # A. Perfect Corroboration (Flow + Symmetry agree)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                # High confidence, scaled by reliability
                base = 0.96 + (0.04 * avg_reliability)
                return min(1.0, base * snr_factor)

            # B. Flow Verification (Symmetry Broken, Flow fixes it)
            if err_flow is not None and err_flow < 0.05:
                base = 0.92 + (0.03 * avg_reliability)
                return min(1.0, base * snr_factor)

            # C. Symmetry Verification (Flow Missing or Disagrees)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only (Strong)
                    return 0.95 * snr_factor
                else:
                    # Symmetry holds, but Flow disagrees (Conflict)
                    # Likely a topology mismatch or multi-point failure
                    return 0.70 * snr_factor

            # D. Heuristic (No Flow, Broken Symmetry)
            if err_flow is None:
                # Trust Non-Zero Heuristic (Unverified)
                mag = max(val, peer_val)
                # If recovering high magnitude signal, confidence is higher than noise
                if mag > 50.0: return 0.85
                if mag > 5.0:  return 0.75
                return 0.50

            # E. Conflict (Broken Sym, Broken Flow)
            return 0.30
>>>>>>> REPLACE
</DIFF>