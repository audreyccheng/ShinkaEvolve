To improve the performance of the telemetry repair algorithm, I will introduce continuous error scoring and rate synthesis into the consensus loop.

In the current implementation, the rate repair logic relies on a binary voting system where a candidate value gets a "vote" if it results in a flow error below a fixed threshold. This approach fails to distinguish between a perfect repair (0.1% error) and a barely acceptable one (4.9% error), and it treats all unverifiable (but potentially correct) values as equally suspect. Furthermore, it only considers the locally and remotely measured values (and their average), failing to recover traffic data when both measurements are corrupted (e.g., "double-dead" links where both ends report zero).

I will implement the following changes:

1.  **Rate Synthesis**: Introduce a helper to calculate `get_flow_suggestion`. This calculates the exact traffic rate required on an interface to satisfy flow conservation at its router (e.g., `Required_Tx = Sum(In) - Sum(Other_Out)`). These synthesized values are added to the candidate pool, allowing the algorithm to "fill in the blanks" even when measurements are missing.

2.  **Continuous Error Scoring**: Replace the voting system with a continuous cost function. The score for a candidate value will be the sum of flow errors it induces at both ends of the link. This prioritizes values that result in tighter flow conservation (minimizing residuals). Unverifiable routers contribute a small constant cost to the score, acting as a soft regularizer that prefers verifiable solutions without ruling out unverifiable ones.

3.  **Continuous Confidence Calibration**: Instead of assigning fixed confidence buckets (0.95, 0.90) based on binary verification checks, I will scale the confidence score linearly based on the residual flow error. A repair that results in 0.0% error will have higher confidence than one with 4.9% error, improving the calibration metric.

These changes target the counter repair accuracy (by finding better values) and the confidence calibration (by accurately reporting the quality of the repair).

<NAME>
continuous_scoring_and_synthesis
</NAME>

<DESCRIPTION>
Improves the rate repair and confidence calibration logic by:
1. Replacing binary voting with continuous error scoring in the consensus loop. This allows the algorithm to distinguish between marginally valid and perfectly balanced flows.
2. Introducing "Rate Synthesis": calculating the exact traffic value required to satisfy flow conservation at a router, and adding this as a candidate. This handles cases where all measured values are wrong (e.g., double-dead links) but the router balance implies the true value.
3. Implementing continuous confidence calibration derived from residual flow errors, providing more accurate confidence scores for verified repairs.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    for if_id, data in telemetry.items():
        # Get Final Values
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        # -- Calibrate Confidence --

        def get_rate_confidence(orig, final, field):
            # 1. Did we change the value?
            if abs(orig - final) < 0.001:
                return 1.0 # High confidence in original/unchanged data

            # 2. If changed, was it verified by flow?
            rid = data.get('local_router')
            flow_err = calc_flow_error(rid, if_id, field, final)

            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                return 0.95 # Very high confidence: Mathematics supports this

            # 3. Was it a "Dead Counter" repair (0 -> Non-Zero)?
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Moderately high: 0 is a common error mode

            # 4. Fallback
            return 0.6 # Low confidence: Changed based on peer but no verification

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check: If Down but Traffic, lower confidence
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf *= 0.5
            tx_conf *= 0.5
            st_conf *= 0.5

        # Construct Output Tuple
        res_entry = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
        result[if_id] = res_entry

    return result
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Helper: Synthesize the value required to balance the router flow
    def get_flow_suggestion(rid, if_target, field):
        if rid not in verifiable_routers:
            return None

        sum_in = 0.0
        sum_out = 0.0

        for iface in router_interfaces[rid]:
            if iface == if_target: continue
            sum_in += state[iface]['rx']
            sum_out += state[iface]['tx']

        # Flow Conservation: Sum(In) = Sum(Out)
        if field == 'tx':
            # Target_Tx = Sum(In) - Sum(Other_Out)
            val = sum_in - sum_out
        else:
            # Target_Rx = Sum(Out) - Sum(Other_In)
            val = sum_out - sum_in

        return max(0.0, val)

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # Link: Local(Tx) -> Remote(Rx)
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            # Check Agreement
            diff = abs(cand_tx - cand_rx)
            avg = (cand_tx + cand_rx) / 2.0

            if diff < max(avg * TOLERANCE, MIN_ACTIVITY):
                best_val = avg
            else:
                # Disagreement. Generate candidates.
                candidates = {cand_tx, cand_rx, avg}

                # Synthesize values from flow conservation
                rid_local = s['local_router']
                synth_tx = get_flow_suggestion(rid_local, if_id, 'tx')
                if synth_tx is not None: candidates.add(synth_tx)

                rid_remote = state[peer_id]['local_router']
                synth_rx = get_flow_suggestion(rid_remote, peer_id, 'rx')
                if synth_rx is not None: candidates.add(synth_rx)

                # Filter candidates
                candidates = [c for c in candidates if c >= 0.0]

                # Score candidates
                best_score = float('inf')
                best_val = avg

                for val in candidates:
                    # Score based on flow error magnitude
                    err_local = calc_flow_error(rid_local, if_id, 'tx', val)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', val)

                    score = 0.0

                    # Cost Function: Unverified = small constant cost, Verified = actual error cost
                    # This prefers verified solutions (if error is small) over unverified guesses.
                    if err_local is None: score += 0.05
                    else: score += min(err_local, 1.0) * 2.0

                    if err_remote is None: score += 0.05
                    else: score += min(err_remote, 1.0) * 2.0

                    # Heuristic: Avoid Zero if alternatives exist
                    if val < MIN_ACTIVITY and any(c > MIN_ACTIVITY for c in candidates):
                        score += 0.5

                    # Preference for Average (Smoothing) if errors are similar
                    if abs(val - avg) < 0.001:
                        score -= 0.01

                    if score < best_score:
                        best_score = score
                        best_val = val

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    for if_id, data in telemetry.items():
        # Get Final Values
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        # -- Calibrate Confidence --
        def get_rate_confidence(orig, final, field):
            changed = abs(orig - final) > 0.001

            # Calculate final flow error for verification
            rid = data.get('local_router')
            flow_err = calc_flow_error(rid, if_id, field, final)
            is_verified = flow_err is not None and flow_err < FLOW_TOLERANCE

            # Remote verification check
            remote_verified = False
            peer_id = data.get('connected_to')
            rem_rid = data.get('remote_router')
            if rem_rid and peer_id:
                check_field = 'tx' if field == 'rx' else 'rx'
                rem_err = calc_flow_error(rem_rid, peer_id, check_field, final)
                if rem_err is not None and rem_err < FLOW_TOLERANCE:
                    remote_verified = True

            # 1. High Confidence: Verified by Flow
            if is_verified:
                # Continuous confidence based on residual error
                # 0% error -> 0.99 confidence
                # 5% error -> 0.90 confidence
                base = 0.99
                penalty = (flow_err / FLOW_TOLERANCE) * 0.09
                return base - penalty

            if remote_verified:
                return 0.90

            # 2. Unverified Scenarios
            if not changed:
                return 0.9 # Default trust in data

            # Smoothing (changed but < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Dead Counter Repair
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8

            # Forced Agreement / Guess
            return 0.6

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check: If Down but Traffic, lower confidence
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf *= 0.5
            tx_conf *= 0.5
            st_conf *= 0.5

        # Construct Output Tuple
        res_entry = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
        result[if_id] = res_entry

    return result
>>>>>>> REPLACE
</DIFF>