<NAME>
continuous_flow_scoring_and_discrete_confidence
</NAME>

<DESCRIPTION>
1.  **Continuous Flow-Error Scoring**: Replaces the binary voting system in the repair loop with a continuous scoring function. This allows the algorithm to distinguish between "slightly wrong" and "very wrong" flow states, and better resolves conflicts by minimizing total system error. A neutral penalty is assigned to unverifiable routers to prevent them from overriding verified (but slightly noisy) data, while still preferring them over broken routers.
2.  **Discrete Confidence Calibration**: Replaces the linear penalty confidence model (which was causing poor calibration) with a discrete bucket model inspired by the best-performing prior program. This model explicitly handles "Remote Verification" (propagating trust from neighbors) and distinguishes between different types of repairs (smoothing vs dead-counter fix vs conflict resolution), ensuring confidence scores better reflect the probability of correctness.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Continuous Scoring Function (Lower is better)
                def get_score(err):
                    if err is None: return 0.05 # Neutral penalty for unverifiable
                    return min(err, 1.0)        # Actual error for verifiable

                score_1 = get_score(err_a_1) + get_score(err_b_1)
                score_2 = get_score(err_a_2) + get_score(err_b_2)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                # Add heavy penalty to the zero candidate
                if cand_tx < MIN_ACTIVITY and cand_rx > MIN_ACTIVITY: score_1 += 0.5
                if cand_rx < MIN_ACTIVITY and cand_tx > MIN_ACTIVITY: score_2 += 0.5

                # Tie-breaking/Continuous Selection
                if score_1 < score_2:
                    best_val = cand_tx
                elif score_2 < score_1:
                    best_val = cand_rx
                else:
                    best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- 4. Final Result Generation & Confidence Calibration ---

    # Pre-calculate residual flow errors for verifiable routers
    final_flow_errors = {}
    for rid in verifiable_routers:
        sum_rx = sum(state[iface]['rx'] for iface in router_interfaces[rid])
        sum_tx = sum(state[iface]['tx'] for iface in router_interfaces[rid])
        # Avoid division by zero
        denom = max(sum_rx, sum_tx, 1.0)
        final_flow_errors[rid] = abs(sum_rx - sum_tx) / denom

    result = {}

    for if_id, data in telemetry.items():
        # Get Final Values
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        # Get Context for Confidence
        rid = data.get('local_router')
        peer_id = data.get('connected_to')

        # Get peer original values for conflict checking
        peer_orig_rx = 0.0
        peer_orig_tx = 0.0
        if peer_id and peer_id in telemetry:
            peer_orig_rx = telemetry[peer_id].get('rx_rate', 0.0)
            peer_orig_tx = telemetry[peer_id].get('tx_rate', 0.0)

        # Get residual flow error for this router (if verifiable)
        flow_err = final_flow_errors.get(rid) # None if not verifiable

        def calculate_confidence(orig, final, peer_orig_complement, flow_err):
            # 1. Did we detect a conflict initially?
            conflict = False
            if peer_id and peer_id in telemetry:
                conflict = abs(orig - peer_orig_complement) / max(orig, peer_orig_complement, 1.0) > TOLERANCE

            # 2. Did we change the value?
            changed = abs(orig - final) > 0.001

            # Base Confidence
            conf = 1.0

            if changed:
                # We intervened.
                if flow_err is not None and flow_err < FLOW_TOLERANCE:
                    conf = 0.95  # Verified repair
                elif flow_err is None:
                    conf = 0.75  # Unverified repair (edge router)
                else:
                    conf = 0.6   # Changed but flow still broken
            else:
                # We kept the original.
                if conflict:
                    # Conflict existed, but we stuck to our guns.
                    if flow_err is not None and flow_err < FLOW_TOLERANCE:
                        conf = 0.95 # Verified to be correct
                    else:
                        conf = 0.8  # Unverified choice in conflict
                else:
                    conf = 1.0  # No conflict, no change. Happy.

            # 3. Global Consistency Penalty
            # If the router is still violating flow conservation, reduce confidence
            if flow_err is not None:
                # Penalty scales with error magnitude
                penalty_factor = max(0.0, 1.0 - flow_err)
                conf *= penalty_factor

            return conf

        # Calculate confidence for RX (compare with Peer TX) and TX (compare with Peer RX)
        rx_conf = calculate_confidence(orig_rx, final_rx, peer_orig_tx, flow_err)
        tx_conf = calculate_confidence(orig_tx, final_tx, peer_orig_rx, flow_err)

        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check: If Down but Traffic, lower confidence
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf *= 0.5
            tx_conf *= 0.5
            st_conf *= 0.5

        # Construct Output Tuple
        res_entry = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
        result[if_id] = res_entry
=======
    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    # Map final flow errors
    final_errors = {}
    for rid in verifiable_routers:
        # Re-calc based on final state
        sum_rx = sum(state[iface]['rx'] for iface in router_interfaces[rid])
        sum_tx = sum(state[iface]['tx'] for iface in router_interfaces[rid])
        denom = max(sum_rx, sum_tx, 1.0)
        final_errors[rid] = abs(sum_rx - sum_tx) / denom

    for if_id, data in telemetry.items():
        # Get Final Values
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        rid = data.get('local_router')
        peer_id = data.get('connected_to')

        def get_rate_confidence(orig, final, field):
            # 1. Verification Logic
            # Local Verification (strongest)
            local_err = final_errors.get(rid)
            local_verified = (local_err is not None and local_err < FLOW_TOLERANCE)

            # Remote Verification
            remote_verified = False
            rem_rid = data.get('remote_router')
            if rem_rid and rem_rid in final_errors:
                 if final_errors[rem_rid] < FLOW_TOLERANCE:
                     remote_verified = True

            # Peer Consistency (Symmetry)
            peer_consistent = True
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 2. Change Logic
            changed = abs(orig - final) > 0.001
            # Smoothing (small change)
            smoothed = changed and (abs(orig - final) < max(orig * 0.05, 0.1))

            # --- Scoring Buckets ---

            if not changed:
                # We kept the original value
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.98
                if not peer_consistent: return 0.7 # Conflict existed, but we didn't change (ambiguous)
                # If unverifiable but consistent with peer
                if remote_verified: return 0.95
                return 0.9

            if smoothed:
                return 0.95 # High confidence in small adjustments

            # Significant Repairs
            if local_verified and remote_verified:
                return 0.98
            if local_verified:
                return 0.95
            if remote_verified:
                return 0.90

            # Heuristic Repairs (Unverified)
            # 0 -> Value
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.85

            # Fallback for unverified repairs
            return 0.6

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check: If Down but Traffic, lower confidence
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf = 0.0
            tx_conf = 0.0

        # Construct Output Tuple
        res_entry = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
        result[if_id] = res_entry
>>>>>>> REPLACE
</DIFF>