<NAME>
introduce_residual_synthesis_and_continuous_scoring
</NAME>

<DESCRIPTION>
Improves the Rate Repair phase by introducing "Residual Synthesis". This calculates the theoretical value for an interface required to balance its router's flow (based on Flow Conservation). These synthetic values are added as candidates alongside the raw telemetry.

The scoring mechanism is upgraded from a discrete voting system to a continuous error penalty function. This allows the algorithm to distinguish between candidates that are "slightly off" versus "completely wrong," and allows verified synthetic values (which yield 0 flow error) to win over corrupted raw measurements.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Helper: Flow Error Calculation ---
    def get_flow_error(rid, if_target=None, field=None, value=None):
        """
        Calculates the relative flow error (imbalance) for a router.
        Optionally allows substituting a speculative value for one interface.
        """
        if rid not in verifiable_routers:
            return None

        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_map[rid]:
            # Use speculative value if this is the target interface
            if iface == if_target:
                r = value if field == 'rx' else state[iface]['rx']
                t = value if field == 'tx' else state[iface]['tx']
            else:
                r = state[iface]['rx']
                t = state[iface]['tx']
            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    # --- 2. Status Repair ---
    status_confidence = {}

    for if_id, s in state.items():
        orig = s['orig_status']
        peer_id = s['connected_to']

        # Check for traffic activity
        local_traffic = (s['orig_rx'] > MIN_ACTIVITY) or (s['orig_tx'] > MIN_ACTIVITY)
        peer_traffic = False
        peer_status = 'unknown'

        if peer_id and peer_id in state:
            peer = state[peer_id]
            peer_traffic = (peer['orig_rx'] > MIN_ACTIVITY) or (peer['orig_tx'] > MIN_ACTIVITY)
            peer_status = peer['orig_status']

        # Decision Logic
        final_status = orig
        conf = 1.0

        if local_traffic or peer_traffic:
            # Traffic implies UP
            final_status = 'up'
            if orig == 'down':
                conf = 0.95 # Correcting a false negative
        elif orig == 'up' and peer_status == 'down':
            # Peer says down + no traffic -> likely down
            final_status = 'down'
            conf = 0.8
        elif orig != peer_status:
            # Conflict with no traffic info. Conservative choice: Down.
            final_status = 'down'
            conf = 0.7

        state[if_id]['status'] = final_status
        status_confidence[if_id] = conf

        # Enforce consistency: Down interfaces have zero rate
        if final_status == 'down':
            state[if_id]['rx'] = 0.0
            state[if_id]['tx'] = 0.0

    # --- 3. Rate Repair (Iterative Consensus) ---
    # Run multiple passes to allow flow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # The link connects Local(Tx) -> Remote(Rx)
            # We want to find the consensus value for this traffic flow

            val_tx = s['tx']              # Local view
            val_rx = state[peer_id]['rx'] # Remote view

            # Check for Agreement
            diff = abs(val_tx - val_rx)
            mag = max(val_tx, val_rx, 1.0)

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agreement: Just smooth out noise
                new_val = (val_tx + val_rx) / 2.0
            else:
                # Disagreement: Resolve conflict using Flow Conservation constraints
                rid_local = s['local_router']
                rid_remote = s['remote_router']

                # Calculate errors if we chose TX value
                err_local_tx = get_flow_error(rid_local, if_id, 'tx', val_tx)
                err_remote_tx = get_flow_error(rid_remote, peer_id, 'rx', val_tx)

                # Calculate errors if we chose RX value
                err_local_rx = get_flow_error(rid_local, if_id, 'tx', val_rx)
                err_remote_rx = get_flow_error(rid_remote, peer_id, 'rx', val_rx)

                # Scoring (Lower is better)
                # 0.0 = Verified Good, 0.5 = Unverifiable, 1.0 = Verified Bad
                def get_vote(err):
                    if err is None: return 0.5
                    if err < FLOW_TOLERANCE: return 0.0
                    return 1.0

                score_tx = get_vote(err_local_tx) + get_vote(err_remote_tx)
                score_rx = get_vote(err_local_rx) + get_vote(err_remote_rx)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                if val_tx < MIN_ACTIVITY and val_rx > MIN_ACTIVITY: score_tx += 0.4
                if val_rx < MIN_ACTIVITY and val_tx > MIN_ACTIVITY: score_rx += 0.4

                # Selection
                if score_tx < score_rx:
                    new_val = val_tx
                elif score_rx < score_tx:
                    new_val = val_rx
                else:
                    new_val = (val_tx + val_rx) / 2.0 # Tie -> Average

            # Update state immediately (Gauss-Seidel style)
            state[if_id]['tx'] = new_val
            state[peer_id]['rx'] = new_val
=======
    # --- Helper: Flow Error Calculation ---
    def get_flow_error(rid, if_target=None, field=None, value=None):
        """
        Calculates the relative flow error (imbalance) for a router.
        Optionally allows substituting a speculative value for one interface.
        """
        if rid not in verifiable_routers:
            return None

        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_map[rid]:
            # Use speculative value if this is the target interface
            if iface == if_target:
                r = value if field == 'rx' else state[iface]['rx']
                t = value if field == 'tx' else state[iface]['tx']
            else:
                r = state[iface]['rx']
                t = state[iface]['tx']
            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    def get_residual(rid, if_target, field):
        """Calculates the value needed at an interface to perfectly balance a router."""
        if rid not in verifiable_routers:
            return None

        sum_in, sum_out = 0.0, 0.0
        for iface in router_map[rid]:
            if iface == if_target: continue
            sum_in += state[iface]['rx']
            sum_out += state[iface]['tx']

        # We want Sum_In = Sum_Out
        # If solving for Tx (out): x = Sum_In - Sum_Out_Other
        # If solving for Rx (in):  x = Sum_Out - Sum_In_Other
        val = sum_in - sum_out if field == 'tx' else sum_out - sum_in
        return max(val, 0.0)

    # --- 2. Status Repair ---
    status_confidence = {}

    for if_id, s in state.items():
        orig = s['orig_status']
        peer_id = s['connected_to']

        # Check for traffic activity
        local_traffic = (s['orig_rx'] > MIN_ACTIVITY) or (s['orig_tx'] > MIN_ACTIVITY)
        peer_traffic = False
        peer_status = 'unknown'

        if peer_id and peer_id in state:
            peer = state[peer_id]
            peer_traffic = (peer['orig_rx'] > MIN_ACTIVITY) or (peer['orig_tx'] > MIN_ACTIVITY)
            peer_status = peer['orig_status']

        # Decision Logic
        final_status = orig
        conf = 1.0

        if local_traffic or peer_traffic:
            # Traffic implies UP
            final_status = 'up'
            if orig == 'down':
                conf = 0.95 # Correcting a false negative
        elif orig == 'up' and peer_status == 'down':
            # Peer says down + no traffic -> likely down
            final_status = 'down'
            conf = 0.8
        elif orig != peer_status:
            # Conflict with no traffic info. Conservative choice: Down.
            final_status = 'down'
            conf = 0.7

        state[if_id]['status'] = final_status
        status_confidence[if_id] = conf

        # Enforce consistency: Down interfaces have zero rate
        if final_status == 'down':
            state[if_id]['rx'] = 0.0
            state[if_id]['tx'] = 0.0

    # --- 3. Rate Repair (Iterative Consensus) ---
    # Run multiple passes to allow flow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # The link connects Local(Tx) -> Remote(Rx)
            cand_tx = s['tx']              # Local view
            cand_rx = state[peer_id]['rx'] # Remote view

            # Agreement Check
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                new_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagreement: Use Flow Conservation
                rid_local = s['local_router']
                rid_remote = s['remote_router']

                # Gather Candidates
                candidates = [cand_tx, cand_rx]

                # Try to synthesize values from flow conservation
                res_local = get_residual(rid_local, if_id, 'tx')
                if res_local is not None: candidates.append(res_local)

                res_remote = get_residual(rid_remote, peer_id, 'rx')
                if res_remote is not None: candidates.append(res_remote)

                # Deduplicate and Score
                best_score = float('inf')
                best_val = cand_tx

                # Filter candidates close to each other
                unique_cands = []
                for c in candidates:
                    if not any(abs(c - u) < 1e-4 for u in unique_cands):
                        unique_cands.append(c)

                for cand in unique_cands:
                    err_local = get_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = get_flow_error(rid_remote, peer_id, 'rx', cand)

                    def get_penalty(err):
                        if err is None: return 0.05 # Unverifiable: small penalty
                        return min(err, 2.0)        # Verifiable: proportional penalty

                    score = get_penalty(err_local) + get_penalty(err_remote)

                    # Heuristic: Penalize zero if alternatives exist (Dead counter)
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

                new_val = best_val

            # Update state immediately
            state[if_id]['tx'] = new_val
            state[peer_id]['rx'] = new_val
>>>>>>> REPLACE
</DIFF>