<NAME>
continuous_scoring_and_synthesis
</NAME>

<DESCRIPTION>
Replaces the discrete voting mechanism with continuous flow-error scoring to better resolve rate conflicts.
Introduces "Residual-Based Synthesis" (infer_flow_value) to generate synthetic candidates derived from local flow conservation. This handles "Double Zero" scenarios where both link ends report zero traffic but the router has a verifiable imbalance, allowing the algorithm to infer the correct rate rather than just choosing between two zero measurements.
Increases repair passes from 2 to 3 to allow synthesized values to propagate.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Helper: Infer required value to satisfy flow conservation
    def infer_flow_value(rid, if_target, is_tx):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        # Sum everything except the target interface
        for iface in router_interfaces[rid]:
            if iface == if_target: continue
            sum_rx += state[iface]['rx']
            sum_tx += state[iface]['tx']

        # If we are solving for Tx: Sum(Rx) = Sum(Tx_others) + Target
        # Target = Sum(Rx) - Sum(Tx_others)
        if is_tx:
            val = sum_rx - sum_tx
        else:
            # If solving for Rx: Sum(Rx_others) + Target = Sum(Tx)
            val = sum_tx - sum_rx

        return max(0.0, val)

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_local = s['local_router']
                rid_remote = state[peer_id]['local_router']

                # Identify candidates
                candidates = [cand_tx, cand_rx]

                # Infer values (Synthesis) if routers are verifiable
                # This handles "Double Zero" cases where both measures are 0 but flow requires X
                synth_local = infer_flow_value(rid_local, if_id, True)
                if synth_local is not None and synth_local > MIN_ACTIVITY:
                    candidates.append(synth_local)

                # Evaluate candidates
                best_score = float('inf')

                for val in candidates:
                    # Score Local (Tx side)
                    err_local = calc_flow_error(rid_local, if_id, 'tx', val)
                    # Score Remote (Rx side)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', val)

                    # Continuous Scoring Function
                    # Use bounded error to prevent one bad node from dominating
                    def get_score(err):
                        if err is None: return 0.05 # Unverifiable -> neutral small penalty
                        return min(err, 1.0)        # Verifiable -> proportional penalty

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize exactly zero if alternative exists (Dead Counter)
                    if val < MIN_ACTIVITY and max(candidates) > MIN_ACTIVITY:
                         score += 0.2

                    if score < best_score:
                        best_score = score
                        best_val = val
                    elif score == best_score:
                        # Tie-break: prefer average of tied values
                        best_val = (best_val + val) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>