<NAME>
restore_dual_sided_logic_with_snr
</NAME>

<DESCRIPTION>
Reverts to the high-performing "Dual-Sided Flow Verification" architecture which uses flow hints from both local and remote routers to resolve link rates.
Adds an SNR-based confidence boost for the "Trust Non-Zero" heuristic in the calibration phase: when flow verification is unavailable and symmetry is broken, large non-zero values (high signal-to-noise) are assigned higher confidence than small values.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:

    HARDENING_THRESHOLD = 0.02  # 2% tolerance for measurement timing
    TRAFFIC_THRESHOLD = 1.0     # 1 Mbps threshold for active link detection
    ITERATIONS = 5              # Increased iterations for convergence

    # --- Phase 1: State Initialization ---
    # Establish a trusted belief state for Status and initial Rates
    state = {}

    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')

        peer_id = data.get('connected_to')
        peer_data = telemetry.get(peer_id, {}) if (peer_id and peer_id in telemetry) else {}

        # 1. Status Repair Logic
        traffic_signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(traffic_signals) if traffic_signals else 0.0

        eff_status = raw_status
        status_conf = 1.0

        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                eff_status = 'up'
                status_conf = 0.95
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
             eff_status = 'down'
             status_conf = 0.8

        # Initial rates based on status
        if eff_status == 'down':
            cur_rx, cur_tx = 0.0, 0.0
        else:
            cur_rx, cur_tx = raw_rx, raw_tx

        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': eff_status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'has_peer': bool(peer_data)
        }

    # --- Phase 2: Iterative Refinement ---

    # Identify Verifiable Routers (Fully Monitored)
    # Flow conservation only applies if we can see all interfaces.
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        # 1. Calculate Flow Hints based on current state
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            # No need to check if i in state, verifiable means all are in telemetry/state
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        updates = {}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                updates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            # Get Hints
            r_id = telemetry[iface_id].get('local_router')
            hint_rx, hint_tx = None, None
            if r_id and r_id in router_balances:
                rb = router_balances[r_id]
                # Hint RX: The value needed to balance total TX
                hint_rx = max(0.0, rb['tx'] - (rb['rx'] - curr['rx']))
                # Hint TX: The value needed to balance total RX
                hint_tx = max(0.0, rb['rx'] - (rb['tx'] - curr['tx']))

            # Get Peer Values
            peer_rx, peer_tx = 0.0, 0.0
            if curr['has_peer']:
                p_state = state[curr['peer_id']]
                peer_rx, peer_tx = p_state['rx'], p_state['tx']

            def resolve_rate_iterative(local_val, peer_val, hint_val):
                # 1. Symmetry
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check: If both 0 but hint is high, trust hint
                    if avg < TRAFFIC_THRESHOLD and hint_val is not None and hint_val > 5.0:
                         # Only do this if hint is significantly non-zero
                         return hint_val
                    return avg

                # 2. Symmetry Broken
                if hint_val is None:
                    # Fallback Heuristics for Partial Observability

                    # Heuristic A: If one side is zero and other is substantial, trust substantial
                    # (Assuming link is UP but one sensor failed to 0)
                    if local_val < TRAFFIC_THRESHOLD and peer_val > TRAFFIC_THRESHOLD:
                        return peer_val
                    if peer_val < TRAFFIC_THRESHOLD and local_val > TRAFFIC_THRESHOLD:
                        return local_val

                    # Default: Trust local sensor if no other strong evidence
                    return local_val

                # 3. Symmetry Broken + Have Hint
                # Compare against hint
                denom_l = max(local_val, hint_val, 1.0)
                diff_l = abs(local_val - hint_val) / denom_l

                denom_p = max(peer_val, hint_val, 1.0)
                diff_p = abs(peer_val - hint_val) / denom_p

                # Trust the one closer to Flow Hint
                if diff_l < diff_p:
                    return local_val
                else:
                    return peer_val

            # Resolve RX (Target: Peer TX)
            tgt_peer_tx = peer_tx if curr['has_peer'] else curr['rx']
            next_rx = resolve_rate_iterative(curr['rx'], tgt_peer_tx, hint_rx)

            # Resolve TX (Target: Peer RX)
            tgt_peer_rx = peer_rx if curr['has_peer'] else curr['tx']
            next_tx = resolve_rate_iterative(curr['tx'], tgt_peer_rx, hint_tx)

            updates[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply updates
        for i_id, vals in updates.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Recalculate hints one last time for confidence scoring
    final_router_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, curr in state.items():
        if curr['status'] == 'down':
             # If we suppressed real traffic, confidence is inherited from status
             c_rx = curr['status_conf'] if curr['orig_rx'] > TRAFFIC_THRESHOLD else 1.0
             c_tx = curr['status_conf'] if curr['orig_tx'] > TRAFFIC_THRESHOLD else 1.0

             result[iface_id] = {
                'rx_rate': (curr['orig_rx'], 0.0, c_rx),
                'tx_rate': (curr['orig_tx'], 0.0, c_tx),
                'interface_status': (curr['orig_status'], 'down', curr['status_conf']),
                'connected_to': curr['peer_id'],
                'local_router': telemetry[iface_id].get('local_router'),
                'remote_router': telemetry[iface_id].get('remote_router')
             }
             continue

        # Get Final Reference Values
        r_id = telemetry[iface_id].get('local_router')
        hint_rx, hint_tx = None, None
        if r_id and r_id in final_router_balances:
            rb = final_router_balances[r_id]
            hint_rx = max(0.0, rb['tx'] - (rb['rx'] - curr['rx']))
            hint_tx = max(0.0, rb['rx'] - (rb['tx'] - curr['tx']))

        peer_rx, peer_tx = 0.0, 0.0
        if curr['has_peer']:
            p_state = state[curr['peer_id']]
            peer_rx, peer_tx = p_state['rx'], p_state['tx']
        else:
            # Self-reference if no peer
            peer_rx, peer_tx = curr['tx'], curr['rx']

        def get_confidence(final_val, peer_ref, hint_ref):
            # Calculate errors against available evidence

            # Error vs Peer (Symmetry)
            denom_s = max(final_val, peer_ref, 1.0)
            err_sym = abs(final_val - peer_ref) / denom_s

            # Error vs Hint (Flow)
            err_flow = None
            if hint_ref is not None:
                denom_f = max(final_val, hint_ref, 1.0)
                err_flow = abs(final_val - hint_ref) / denom_f

            # Logic: We are confident if we match EITHER Peer OR Hint.

            support_err = err_sym
            if err_flow is not None:
                # If we have flow hint, we take the best of Symmetry or Flow
                support_err = min(err_sym, err_flow)

            # Continuous calibration
            conf = max(0.0, 1.0 - (support_err * 2.0))

            # Penalize if we have no Hint and Symmetry is broken
            if err_flow is None and err_sym > HARDENING_THRESHOLD:
                # We relied on heuristic (e.g. non-zero preference).
                # Confidence should be lower than if we had flow verification.
                conf *= 0.8

            return conf

        # Calculate Confidences
        # RX compared to Peer TX and RX Hint
        conf_rx = get_confidence(curr['rx'], peer_tx, hint_rx)
        # TX compared to Peer RX and TX Hint
        conf_tx = get_confidence(curr['tx'], peer_rx, hint_tx)

        result[iface_id] = {
            'rx_rate': (curr['orig_rx'], curr['rx'], conf_rx),
            'tx_rate': (curr['orig_tx'], curr['tx'], conf_tx),
            'interface_status': (curr['orig_status'], curr['status'], curr['status_conf']),
            'connected_to': curr['peer_id'],
            'local_router': telemetry[iface_id].get('local_router'),
            'remote_router': telemetry[iface_id].get('remote_router')
        }

    return result
=======
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:

    # Constants
    HARDENING_THRESHOLD = 0.02   # 2% tolerance
    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps active threshold
    ITERATIONS = 5               # Refinement passes

    # --- Phase 1: Initialization & Status Repair ---
    state = {}

    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')

        peer_id = data.get('connected_to')
        peer_data = telemetry.get(peer_id) if (peer_id and peer_id in telemetry) else {}

        # Traffic Evidence
        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(signals) if signals else 0.0

        # Status Inference
        status = raw_status
        status_conf = 1.0

        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                status = 'up'
                status_conf = 0.95
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
            status = 'down'
            status_conf = 0.8

        # Initial Rate Beliefs
        if status == 'down':
            cur_rx, cur_tx = 0.0, 0.0
        else:
            cur_rx = raw_rx if raw_rx > 0 else 0.0
            cur_tx = raw_tx if raw_tx > 0 else 0.0

        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }

    # --- Phase 2: Iterative Consensus ---

    # Identify Verifiable Routers (Fully Monitored)
    verifiable_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in state for i in ifaces):
            verifiable_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_state = {}

        # Calculate Flow Balances for Verifiable Routers
        router_balances = {}
        for r_id in verifiable_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state

            # --- Logic to Resolve One Direction ---
            def resolve_direction(local_val, peer_val, is_rx):
                # We are solving for the true rate of the link in this direction.
                # Candidates: local_val, peer_val.
                # Constraints: Local Router Balance, Remote Router Balance.

                hints = []

                # 1. Local Hint
                r_id = curr.get('local_router')
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX must match Total TX
                        h = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                        hints.append(h)
                    else:
                        # TX must match Total RX
                        h = max(0.0, rb['rx'] - (rb['tx'] - local_val))
                        hints.append(h)

                # 2. Remote Hint (Dual-Sided)
                # If we are RX, peer is TX. Remote router balance constrains peer TX.
                rr_id = curr.get('remote_router')
                if rr_id and rr_id in router_balances:
                    rb_r = router_balances[rr_id]
                    if is_rx:
                        # Link is My_RX / Peer_TX.
                        # Remote router (Peer's router) sees this as OUT (TX).
                        # Peer_TX = Remote_RX_Total - (Remote_TX_Total - Peer_TX)
                        h = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_val))
                        hints.append(h)
                    else:
                        # Link is My_TX / Peer_RX.
                        # Remote router sees this as IN (RX).
                        # Peer_RX = Remote_TX_Total - (Remote_RX_Total - Peer_RX)
                        h = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_val))
                        hints.append(h)

                # Consensus Target from Hints
                target = None
                if hints:
                    target = sum(hints) / len(hints)

                # Decision Logic

                # A. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check with Hint
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                         return target
                    return avg

                # B. Symmetry Broken
                if target is not None:
                    # We have a trusted target from Flow Conservation.

                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Pick candidate closer to Target
                    denom_l = max(local_val, target, 1.0)
                    err_l = abs(local_val - target) / denom_l

                    denom_p = max(peer_val, target, 1.0)
                    err_p = abs(peer_val - target) / denom_p

                    if err_l < err_p:
                        return local_val
                    else:
                        return peer_val

                else:
                    # C. No Hint + Broken Symmetry (Partial Topology or multiple failures)
                    # Use Heuristic: Trust Non-Zero (assuming counters undercount/drop/fail to 0)
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD:
                        return peer_val

                    # If both non-zero but different, average (reduce variance)
                    return (local_val + peer_val) / 2.0

            # Resolve RX
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_direction(curr['rx'], peer_tx, is_rx=True)

            # Resolve TX
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_direction(curr['tx'], peer_rx, is_rx=False)

            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply Updates
        for i_id, vals in next_state.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Final Balances
    final_balances = {}
    for r_id in verifiable_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state

        # Calibration Helper
        def calibrate(val, peer_val, local_hint, remote_hint, is_down, stat_conf):
            if is_down:
                return stat_conf if val > TRAFFIC_THRESHOLD else stat_conf

            # 1. Symmetry Error
            err_sym = 0.0
            if has_peer:
                denom = max(val, peer_val, 1.0)
                err_sym = abs(val - peer_val) / denom

            # 2. Flow Error (Best matching hint)
            err_flow = None
            hints = []
            if local_hint is not None: hints.append(local_hint)
            if remote_hint is not None: hints.append(remote_hint)

            if hints:
                target = sum(hints) / len(hints)
                denom = max(val, target, 1.0)
                err_flow = abs(val - target) / denom

            # Tiered Confidence Assignment

            # Case A: Strong Corroboration (Flow matches Result)
            if err_flow is not None and err_flow < 0.05:
                # If Symmetry also matches, Perfect.
                if err_sym < 0.05:
                    return 1.0
                # If Symmetry broken, we fixed it using Flow. High confidence.
                return 0.90

            # Case B: Symmetry Holds (No Flow Hint or Flow matches)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only. Good but not perfect.
                    return 0.95
                else:
                    # Symmetry holds, but Flow disagrees? (err_flow > 0.05)
                    # This means we ignored flow? Or flow is impossible?
                    return 0.75

            # Case C: No Verification (Broken Symmetry, No Flow Hint)
            if err_flow is None:
                # We guessed based on heuristic "Trust Non-Zero".
                # SNR Adjustment: High values are less likely to be noise.
                if val > 50.0: return 0.80
                if val > 10.0: return 0.70
                return 0.50

            # Case D: Conflict (Broken Symmetry, Broken Flow)
            # We picked something, but it matches nothing well.
            return 0.30

        # Get Final Hints
        local_hint_rx, local_hint_tx = None, None
        r_id = data['local_router']
        if r_id in final_balances:
            rb = final_balances[r_id]
            local_hint_rx = max(0.0, rb['tx'] - (rb['rx'] - final_rx))
            local_hint_tx = max(0.0, rb['rx'] - (rb['tx'] - final_tx))

        remote_hint_rx, remote_hint_tx = None, None
        rr_id = data['remote_router']
        if rr_id in final_balances:
            rb_r = final_balances[rr_id]
            # Link RX = Remote Out (TX). Hint based on Remote In.
            peer_tx_val = state[peer_id]['tx'] if has_peer else final_rx
            remote_hint_rx = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_tx_val))

            # Link TX = Remote In (RX). Hint based on Remote Out.
            peer_rx_val = state[peer_id]['rx'] if has_peer else final_tx
            remote_hint_tx = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_rx_val))

        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        conf_rx = calibrate(final_rx, peer_tx, local_hint_rx, remote_hint_rx, data['status']=='down', data['status_conf'])
        conf_tx = calibrate(final_tx, peer_rx, local_hint_tx, remote_hint_tx, data['status']=='down', data['status_conf'])

        result[iface_id] = {
            'rx_rate': (data['orig_rx'], final_rx, conf_rx),
            'tx_rate': (data['orig_tx'], final_tx, conf_tx),
            'interface_status': (data['orig_status'], data['status'], data['status_conf']),
            'connected_to': peer_id,
            'local_router': r_id,
            'remote_router': data['remote_router']
        }

    return result
>>>>>>> REPLACE
</DIFF>