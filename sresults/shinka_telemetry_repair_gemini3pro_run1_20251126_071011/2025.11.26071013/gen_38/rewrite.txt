# EVOLVE-BLOCK-START
"""
Network telemetry repair algorithm using Reliability-Weighted Flow Consensus.
Iteratively repairs rates by weighing Flow Conservation hints against Link Symmetry,
modulated by the historical reliability of the participating routers.
"""
from typing import Dict, Any, Tuple, List

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]], 
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    
    # Constants
    HARDENING_THRESHOLD = 0.02   # 2% tolerance for measurement timing
    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps threshold for "active" link
    ITERATIONS = 4               # Number of passes for convergence
    
    # --- Phase 1: State Initialization ---
    # Create a trusted baseline for Status and Rates
    state = {}
    
    for iface_id, data in telemetry.items():
        raw_rx = data.get('rx_rate', 0.0)
        raw_tx = data.get('tx_rate', 0.0)
        raw_status = data.get('interface_status', 'unknown')
        
        peer_id = data.get('connected_to')
        peer_data = telemetry.get(peer_id, {}) if (peer_id and peer_id in telemetry) else {}
        
        # Traffic Evidence: Check if any sensor reports traffic
        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
        max_traffic = max(signals) if signals else 0.0
        
        # Status Repair: Traffic presence is the strongest signal for UP
        status = raw_status
        status_conf = 1.0
        
        if max_traffic > TRAFFIC_THRESHOLD:
            if raw_status != 'up':
                status = 'up'
                status_conf = 0.95
        elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
             # Conflict with no traffic -> Likely DOWN
             status = 'down'
             status_conf = 0.8
             
        # Normalize Rates based on Status
        cur_rx = raw_rx if status == 'up' else 0.0
        cur_tx = raw_tx if status == 'up' else 0.0
            
        state[iface_id] = {
            'rx': cur_rx, 'tx': cur_tx,
            'status': status, 'status_conf': status_conf,
            'orig_rx': raw_rx, 'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router')
        }

    # --- Phase 2: Iterative Refinement ---
    for _ in range(ITERATIONS):
        
        # 1. Calculate Router Reliability
        # A router is "Reliable" if its interfaces generally match their peers (Symmetry).
        # We use this score to decide whether to trust Flow Hints from this router.
        router_reliability = {}
        for r_id, ifaces in topology.items():
            valid_ifaces = [i for i in ifaces if i in state]
            if not valid_ifaces:
                router_reliability[r_id] = 0.5
                continue
            
            scores = []
            for i in valid_ifaces:
                curr = state[i]
                if curr['status'] == 'down':
                    # DOWN links are trivially consistent (0=0), count as valid
                    scores.append(1.0) 
                    continue
                    
                peer_id = curr['peer_id']
                if peer_id and peer_id in state:
                    p_state = state[peer_id]
                    # Check Symmetry for this link
                    d_rx = max(curr['rx'], p_state['tx'], 1.0)
                    e_rx = abs(curr['rx'] - p_state['tx']) / d_rx
                    
                    d_tx = max(curr['tx'], p_state['rx'], 1.0)
                    e_tx = abs(curr['tx'] - p_state['rx']) / d_tx
                    
                    # Score drops as error increases. 
                    # error=0 -> score=1. error=10% -> score=0.9
                    link_score = 1.0 - ((e_rx + e_tx) / 2.0)
                    scores.append(max(0.0, link_score))
                else:
                    scores.append(0.5) # Neutral if no peer
            
            router_reliability[r_id] = sum(scores) / len(scores) if scores else 0.5

        # 2. Calculate Router Flow Balances (Hints)
        router_balances = {}
        for r_id, ifaces in topology.items():
            sum_rx = sum(state[i]['rx'] for i in ifaces if i in state)
            sum_tx = sum(state[i]['tx'] for i in ifaces if i in state)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        # 3. Update Rates based on Weighted Consensus
        next_rates = {}
        
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_rates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue
                
            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state
            r_id = curr.get('local_router')
            
            def resolve(local_val, peer_val, is_rx):
                # A. Check Symmetry (Direct Evidence)
                denom_s = max(local_val, peer_val, 1.0)
                err_s = abs(local_val - peer_val) / denom_s
                
                if err_s <= HARDENING_THRESHOLD:
                    # Consistent: Average to reduce jitter
                    return (local_val + peer_val) / 2.0
                
                # B. Symmetry Broken: Consult Flow Hint
                hint_val = None
                local_rel = router_reliability.get(r_id, 0.5)
                
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # Target: Sum_Out - (Other_In)
                        hint_val = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        # Target: Sum_In - (Other_Out)
                        hint_val = max(0.0, rb['rx'] - (rb['tx'] - local_val))
                
                # Special Case: "Double Dead" Synthesis
                # Both sensors dead (0), but reliable router says traffic should exist.
                if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                    if hint_val is not None and hint_val > 5.0 and local_rel > 0.8:
                        return hint_val
                
                # Standard Conflict Resolution
                # If we have no valid hint or our router is unreliable, default to average.
                if hint_val is None or local_rel < 0.6:
                    return (local_val + peer_val) / 2.0
                
                # Compare Local vs Peer against the Hint
                denom_l = max(local_val, hint_val, 1.0)
                err_l = abs(local_val - hint_val) / denom_l
                
                denom_p = max(peer_val, hint_val, 1.0)
                err_p = abs(peer_val - hint_val) / denom_p
                
                # Trust the candidate closer to the Reliable Hint
                if err_l < err_p:
                    return local_val
                else:
                    return peer_val

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            nxt_rx = resolve(curr['rx'], peer_tx, True)
            
            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            nxt_tx = resolve(curr['tx'], peer_rx, False)
            
            next_rates[iface_id] = {'rx': nxt_rx, 'tx': nxt_tx}
            
        # Apply Updates
        for i, vals in next_rates.items():
            state[i]['rx'] = vals['rx']
            state[i]['tx'] = vals['tx']

    # --- Phase 3: Final Output & Confidence Calibration ---
    result = {}
    
    # Calculate final balances for accurate confidence scoring
    final_balances = {}
    for r_id, ifaces in topology.items():
        sum_rx = sum(state[i]['rx'] for i in ifaces if i in state)
        sum_tx = sum(state[i]['tx'] for i in ifaces if i in state)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}
        
    for iface_id, curr in state.items():
        # Handle Down Interfaces
        if curr['status'] == 'down':
             c_rx = curr['status_conf'] if curr['orig_rx'] > TRAFFIC_THRESHOLD else 1.0
             c_tx = curr['status_conf'] if curr['orig_tx'] > TRAFFIC_THRESHOLD else 1.0
             result[iface_id] = {
                'rx_rate': (curr['orig_rx'], 0.0, c_rx),
                'tx_rate': (curr['orig_tx'], 0.0, c_tx),
                'interface_status': (curr['orig_status'], 'down', curr['status_conf']),
                'connected_to': curr['peer_id'],
                'local_router': curr['local_router'],
                'remote_router': telemetry[iface_id].get('remote_router')
             }
             continue
             
        # Handle Up Interfaces
        peer_id = curr['peer_id']
        has_peer = peer_id and peer_id in state
        
        def get_calibrated_conf(val, peer_val, is_rx):
            # 1. Symmetry Error
            ds = max(val, peer_val, 1.0)
            es = abs(val - peer_val) / ds
            
            # 2. Flow Error
            r_id = curr['local_router']
            ef = 1.0
            if r_id and r_id in final_balances:
                rb = final_balances[r_id]
                hint = max(0.0, rb['tx'] - (rb['rx'] - val)) if is_rx else max(0.0, rb['rx'] - (rb['tx'] - val))
                df = max(val, hint, 1.0)
                ef = abs(val - hint) / df
            
            # Calibration: We are confident if EITHER signal is very strong.
            best_err = min(es, ef)
            
            # Discrete Bucketing for stable calibration
            if best_err < 0.01: return 1.0
            if best_err < 0.05: return 0.95
            if best_err < 0.10: return 0.90
            if best_err < 0.20: return 0.80
            return max(0.5, 1.0 - best_err * 1.5)

        peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
        c_rx = get_calibrated_conf(curr['rx'], peer_tx, True)
        
        peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
        c_tx = get_calibrated_conf(curr['tx'], peer_rx, False)
        
        result[iface_id] = {
            'rx_rate': (curr['orig_rx'], curr['rx'], c_rx),
            'tx_rate': (curr['orig_tx'], curr['tx'], c_tx),
            'interface_status': (curr['orig_status'], curr['status'], curr['status_conf']),
            'connected_to': curr['peer_id'],
            'local_router': curr['local_router'],
            'remote_router': telemetry[iface_id].get('remote_router')
        }
        
    return result
# EVOLVE-BLOCK-END