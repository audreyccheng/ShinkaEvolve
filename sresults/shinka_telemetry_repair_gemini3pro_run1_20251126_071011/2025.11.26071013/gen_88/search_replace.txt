<NAME>
weighted_consensus_and_broken_router_calibration
</NAME>

<DESCRIPTION>
1.  **Weighted Consensus for Rate Repair**: Replaces the hard "Pick Best or Average" logic with a weighted average based on flow error scores. This allows smoother convergence and handles tie-breaking more naturally (e.g., favoring a candidate with 1% error over one with 10% error, rather than averaging them).
2.  **Broken Router Detection**: Post-repair, identifies routers that failed to satisfy flow conservation (error > 5%). This flags routers that are inherently unreliable.
3.  **Refined Confidence Calibration**:
    - Downgrades confidence for repairs that rely on consistency with a "Broken Router".
    - Increases granularity for verified repairs (Local vs Remote vs Both).
    - Prevents overconfidence when "Trusting Peer" if the peer's router is unstable.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                if score_tx < score_rx:
                    best_val = cand_tx
                elif score_rx < score_tx:
                    best_val = cand_rx
                else:
                    best_val = (cand_tx + cand_rx) / 2.0 # Tie -> Average

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    for if_id, data in telemetry.items():
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        # -- Calibrate Confidence --

        # Helper: check for peer consistency
        def is_peer_consistent(val, field):
            peer_id = data.get('connected_to')
            if not peer_id or peer_id not in state:
                return True # Can't check, assume consistent

            # Compare with peer's finalized value (which should be symmetric)
            peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']

            # Use same tolerance as repair loop
            diff = abs(val - peer_val)
            mag = max(val, peer_val, 1.0)
            return diff < max(mag * TOLERANCE, MIN_ACTIVITY)

        # Helper: check verification
        def get_verification_level(val, field):
            # Local Verification
            rid = data.get('local_router')
            local_err = calc_flow_error(rid, if_id, field, val)
            local_ok = (local_err is not None and local_err < FLOW_TOLERANCE)

            # Remote Verification
            remote_ok = False
            peer_id = data.get('connected_to')
            rem_rid = data.get('remote_router')

            if rem_rid and peer_id:
                check_field = 'tx' if field == 'rx' else 'rx'
                rem_err = calc_flow_error(rem_rid, peer_id, check_field, val)
                if rem_err is not None and rem_err < FLOW_TOLERANCE:
                    remote_ok = True

            if local_ok and remote_ok: return 3 # Both
            if local_ok: return 2 # Local only
            if remote_ok: return 1 # Remote only
            return 0 # None

        def get_rate_confidence(orig, final, field):
            changed = abs(orig - final) > 0.001
            ver_level = get_verification_level(final, field)
            consistent_with_peer = is_peer_consistent(final, field)

            # 1. High Confidence Scenarios
            if ver_level == 3: return 0.99 # Verified by both ends
            if ver_level == 2: return 0.95 # Verified locally (strongest signal)

            # 2. Unchanged Data
            if not changed:
                # If we didn't change it, but it contradicts the peer, confidence drops
                if not consistent_with_peer:
                    return 0.7
                # If consistent and unchanged
                if ver_level == 1: return 0.95 # Verified remote
                return 0.9 # Good default

            # 3. Changed Data
            # Smoothing (small change)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Significant changes
            if ver_level == 1: return 0.90 # Verified remote

            # Unverified Repairs
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.85 # Dead counter repair

            # If we changed it, it's not verified, but now consistent with peer (by definition of repair)
            # This is a "Trust Peer" repair
            return 0.75

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)
=======
                # Weighted combination based on scores (lower score = higher weight)
                # This naturally handles ties and slight preferences better than hard switching
                w_tx = 1.0 / (score_tx + 1e-4)
                w_rx = 1.0 / (score_rx + 1e-4)

                best_val = (cand_tx * w_tx + cand_rx * w_rx) / (w_tx + w_rx)

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    # Identify Broken Routers (High residual error after all repairs)
    # These routers are verifiable but failed to converge to a consistent state
    broken_routers = set()
    for rid in verifiable_routers:
        err = calc_flow_error(rid, None, None, None) # Calc error with current state
        if err is not None and err > FLOW_TOLERANCE:
            broken_routers.add(rid)

    for if_id, data in telemetry.items():
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        rid_local = data.get('local_router')
        rid_remote = data.get('remote_router')

        # -- Calibrate Confidence --

        # Helper: check for peer consistency
        def is_peer_consistent(val, field):
            peer_id = data.get('connected_to')
            if not peer_id or peer_id not in state:
                return True # Can't check, assume consistent

            # Compare with peer's finalized value (which should be symmetric)
            peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']

            # Use same tolerance as repair loop
            diff = abs(val - peer_val)
            mag = max(val, peer_val, 1.0)
            return diff < max(mag * TOLERANCE, MIN_ACTIVITY)

        # Helper: check verification
        def get_verification_level(val, field):
            # Local Verification
            local_err = calc_flow_error(rid_local, if_id, field, val)
            local_ok = (local_err is not None and local_err < FLOW_TOLERANCE)
            if rid_local in broken_routers: local_ok = False

            # Remote Verification
            remote_ok = False
            peer_id = data.get('connected_to')

            if rid_remote and peer_id:
                check_field = 'tx' if field == 'rx' else 'rx'
                rem_err = calc_flow_error(rid_remote, peer_id, check_field, val)
                if rem_err is not None and rem_err < FLOW_TOLERANCE:
                    remote_ok = True
                if rid_remote in broken_routers: remote_ok = False

            if local_ok and remote_ok: return 3 # Both
            if local_ok: return 2 # Local only
            if remote_ok: return 1 # Remote only
            return 0 # None

        def get_rate_confidence(orig, final, field):
            changed = abs(orig - final) > 0.001
            ver_level = get_verification_level(final, field)
            consistent_with_peer = is_peer_consistent(final, field)

            # 1. High Confidence Scenarios (Verified)
            if ver_level == 3: return 0.99
            if ver_level == 2: return 0.96

            # 2. Unchanged Data
            if not changed:
                # If we didn't change it, but it contradicts the peer, confidence drops
                if not consistent_with_peer:
                    return 0.7
                # If consistent and unchanged
                if ver_level == 1: return 0.95 # Verified remote

                # If unverifiable but stable
                return 0.9

            # 3. Changed Data

            # Smoothing (small change)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Significant changes
            if ver_level == 1: return 0.92 # Verified remote

            # Unverified Repairs
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                # Dead counter repair.
                # If connected to a broken router, be careful
                if rid_remote in broken_routers: return 0.75
                return 0.85

            # Trust Peer (Unverified change to match peer)
            if rid_remote in broken_routers: return 0.6 # Don't trust peer if their router is broken
            return 0.75

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)
>>>>>>> REPLACE
</DIFF>