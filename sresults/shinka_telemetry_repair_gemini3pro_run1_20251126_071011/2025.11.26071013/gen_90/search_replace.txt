<NAME>
resolve_direction_outlier_rejection
</NAME>

<DESCRIPTION>
Refines `resolve_direction` to handle divergent hints using outlier rejection. When hints disagree significantly, the algorithm selects the hint closest to the maximum observed signal (local or peer). This handles cases where one hint is corrupted or inconsistent with the physical link state, improving robustness.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # --- Logic to Resolve One Direction ---
            def resolve_direction(local_val, peer_val, is_rx):
                # Candidates: local_val, peer_val.
                # Constraints: Local Router Balance, Remote Router Balance.

                hints = []

                # 1. Local Hint
                r_id = curr.get('local_router')
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX must match Total TX
                        h = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        # TX must match Total RX
                        h = max(0.0, rb['rx'] - (rb['tx'] - local_val))
                    hints.append(h)

                # 2. Remote Hint (Dual-Sided)
                rr_id = curr.get('remote_router')
                if rr_id and rr_id in router_balances:
                    rb_r = router_balances[rr_id]
                    if is_rx:
                        # Link is My_RX / Peer_TX.
                        # Peer_TX = Remote_RX_Total - (Remote_TX_Total - Peer_TX)
                        h = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_val))
                    else:
                        # Link is My_TX / Peer_RX.
                        # Remote router sees this as IN (RX).
                        # Peer_RX = Remote_TX_Total - (Remote_RX_Total - Peer_RX)
                        h = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_val))
                    hints.append(h)

                # Consensus Target from Hints
                target = None
                if hints:
                    target = sum(hints) / len(hints)

                # Decision Logic

                # A. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check with Hint
                    # If traffic is near-zero but hint suggests significant traffic, trust hint.
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                         return target
                    return avg

                # B. Symmetry Broken
                if target is not None:
                    # We have a trusted target from Flow Conservation.

                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Pick candidate closer to Target
                    denom_l = max(local_val, target, 1.0)
                    err_l = abs(local_val - target) / denom_l

                    denom_p = max(peer_val, target, 1.0)
                    err_p = abs(peer_val - target) / denom_p

                    if err_l < err_p:
                        return local_val
                    else:
                        return peer_val

                else:
                    # C. No Hint + Broken Symmetry (Partial Topology or multiple failures)
                    # Heuristic: Trust Non-Zero (assuming counters undercount/drop/fail to 0)
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD:
                        return peer_val

                    # If both non-zero but different, average (reduce variance)
                    return (local_val + peer_val) / 2.0
=======
            # --- Logic to Resolve One Direction ---
            def resolve_direction(local_val, peer_val, is_rx):
                # Candidates: local_val, peer_val.
                # Constraints: Local Router Balance, Remote Router Balance.

                hints = []

                # 1. Local Hint
                r_id = curr.get('local_router')
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX must match Total TX
                        h = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        # TX must match Total RX
                        h = max(0.0, rb['rx'] - (rb['tx'] - local_val))
                    hints.append(h)

                # 2. Remote Hint (Dual-Sided)
                rr_id = curr.get('remote_router')
                if rr_id and rr_id in router_balances:
                    rb_r = router_balances[rr_id]
                    if is_rx:
                        # Link is My_RX / Peer_TX.
                        # Peer_TX = Remote_RX_Total - (Remote_TX_Total - Peer_TX)
                        h = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_val))
                    else:
                        # Link is My_TX / Peer_RX.
                        # Remote router sees this as IN (RX).
                        # Peer_RX = Remote_TX_Total - (Remote_RX_Total - Peer_RX)
                        h = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_val))
                    hints.append(h)

                # Consensus Target from Hints with Outlier Rejection
                target = None
                if hints:
                    if len(hints) > 1:
                        h1, h2 = hints[0], hints[1]
                        # If hints diverge significantly (>10% or >5Mbps)
                        if abs(h1 - h2) > max(5.0, 0.1 * max(h1, h2)):
                            # Select hint closest to the maximum observed signal
                            # Rationale: Counters tend to under-report (drops, failures) not over-report.
                            # We trust the hint that matches the evidence of traffic.
                            max_sig = max(local_val, peer_val)
                            d1 = abs(h1 - max_sig)
                            d2 = abs(h2 - max_sig)
                            target = h1 if d1 < d2 else h2
                        else:
                            target = (h1 + h2) / 2.0
                    else:
                        target = hints[0]

                # Decision Logic

                # A. Symmetry Check
                denom = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check with Hint
                    # If traffic is near-zero but hint suggests significant traffic, trust hint.
                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
                         return target
                    return avg

                # B. Symmetry Broken
                if target is not None:
                    # We have a trusted target from Flow Conservation.

                    # Double Dead Check
                    if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                         if target > 5.0: return target
                         return 0.0

                    # Pick candidate closer to Target
                    denom_l = max(local_val, target, 1.0)
                    err_l = abs(local_val - target) / denom_l

                    denom_p = max(peer_val, target, 1.0)
                    err_p = abs(peer_val - target) / denom_p

                    if err_l < err_p:
                        return local_val
                    else:
                        return peer_val

                else:
                    # C. No Hint + Broken Symmetry (Partial Topology or multiple failures)
                    # Heuristic: Trust Non-Zero (assuming counters undercount/drop/fail to 0)
                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                        return local_val
                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD:
                        return peer_val

                    # If both non-zero but different, average (reduce variance)
                    return (local_val + peer_val) / 2.0
>>>>>>> REPLACE
</DIFF>

<NAME>
calibrate_snr_divergence
</NAME>

<DESCRIPTION>
Updates `calibrate` to include the same outlier rejection logic for target calculation, ensuring the confidence score reflects the actual decision logic. Also adds SNR-based confidence boosting for heuristic repairs (Trust Non-Zero), assigning higher confidence to large values which are statistically less likely to be noise.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Hybrid Calibration Helper
        def calibrate(val, peer_val, local_hint, remote_hint, is_down, stat_conf):
            if is_down:
                return stat_conf if val > TRAFFIC_THRESHOLD else stat_conf

            # 1. Symmetry Error
            err_sym = 0.0
            if has_peer:
                denom = max(val, peer_val, 1.0)
                err_sym = abs(val - peer_val) / denom

            # 2. Flow Error (Best matching hint)
            err_flow = None
            hints = []
            if local_hint is not None: hints.append(local_hint)
            if remote_hint is not None: hints.append(remote_hint)

            if hints:
                target = sum(hints) / len(hints)
                denom = max(val, target, 1.0)
                err_flow = abs(val - target) / denom

            # Tiered Confidence Assignment with Continuous Adjustments

            # Case A: Perfect Corroboration (Flow matches Result + Symmetry matches)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                # Perfect score 1.0, slightly penalized by actual deviations
                return max(0.95, 1.0 - (err_sym + err_flow))

            # Case B: Flow Rescue (Symmetry Broken, Flow Fixes)
            if err_flow is not None and err_flow < 0.05:
                # We trusted Flow. Symmetry was broken.
                # Base 0.90. Penalize if the disagreement (symmetry error) was massive.
                return max(0.80, 0.90 - (0.1 * err_sym))

            # Case C: Symmetry Holds (No Flow Hint or Flow disagrees)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only. Good.
                    return max(0.90, 0.95 - err_sym)
                else:
                    # Symmetry holds, but Flow disagrees.
                    # Local consistency vs Global inconsistency.
                    # Penalize based on how bad the flow error is.
                    return max(0.50, 0.75 - (0.5 * err_flow))

            # Case D: No Verification (Broken Symmetry, No Flow Hint)
            if err_flow is None:
                # Heuristic guess.
                return 0.50

            # Case E: Conflict (Broken Symmetry, Broken Flow)
            # We picked something, but it matches nothing well.
            return max(0.10, 0.30 - err_flow)
=======
        # Hybrid Calibration Helper
        def calibrate(val, peer_val, local_hint, remote_hint, is_down, stat_conf):
            if is_down:
                return stat_conf if val > TRAFFIC_THRESHOLD else stat_conf

            # 1. Symmetry Error
            err_sym = 0.0
            if has_peer:
                denom = max(val, peer_val, 1.0)
                err_sym = abs(val - peer_val) / denom

            # 2. Flow Error (Match logic in resolve_direction)
            err_flow = None
            hints = []
            if local_hint is not None: hints.append(local_hint)
            if remote_hint is not None: hints.append(remote_hint)

            target = None
            if hints:
                if len(hints) > 1:
                    h1, h2 = hints[0], hints[1]
                    # Divergence check
                    if abs(h1 - h2) > max(5.0, 0.1 * max(h1, h2)):
                        d1 = abs(h1 - val)
                        d2 = abs(h2 - val)
                        target = h1 if d1 < d2 else h2
                    else:
                        target = (h1 + h2) / 2.0
                else:
                    target = hints[0]

                denom = max(val, target, 1.0)
                err_flow = abs(val - target) / denom

            # Tiered Confidence Assignment

            # Case A: Perfect Corroboration (Flow matches Result + Symmetry matches)
            if err_flow is not None and err_flow < 0.05 and err_sym < 0.05:
                return 1.0

            # Case B: Flow Rescue (Symmetry Broken, Flow Fixes)
            if err_flow is not None and err_flow < 0.05:
                # Trusted Flow to fix broken symmetry.
                return 0.90

            # Case C: Symmetry Holds (No Flow Hint or Flow disagrees)
            if err_sym < 0.05:
                if err_flow is None:
                    # Verified by peer only. Good.
                    return 0.95
                else:
                    # Symmetry holds, but Flow disagrees.
                    return 0.70

            # Case D: No Verification (Broken Symmetry, No Flow Hint)
            if err_flow is None:
                # Heuristic: Trust Non-Zero.
                # SNR Boost: High bandwidth is less likely to be noise.
                if val > 50.0: return 0.80
                if val > 10.0: return 0.70
                return 0.50

            # Case E: Conflict (Broken Symmetry, Broken Flow)
            return 0.30
>>>>>>> REPLACE
</DIFF>