<NAME>
enforce_down_zero_rates
</NAME>

<DESCRIPTION>
When a link's status is determined to be 'down', explicitly force the RX and TX rates in the working state to 0.0. This prevents 'ghost' traffic from down interfaces (which might be corrupted telemetry) from polluting the flow conservation calculations of the router during the subsequent rate repair phase.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        state[if_id]['status'] = new_status
        status_conf_map[if_id] = conf

    # --- 3. Rate Repair (Iterative Consensus) ---
=======
        state[if_id]['status'] = new_status
        status_conf_map[if_id] = conf

        # If status is DOWN, force rates to zero to prevent pollution of flow calc
        if new_status == 'down':
            state[if_id]['rx'] = 0.0
            state[if_id]['tx'] = 0.0

    # --- 3. Rate Repair (Iterative Consensus) ---
>>>>>>> REPLACE
</DIFF>

<NAME>
improve_confidence_calibration
</NAME>

<DESCRIPTION>
Enhance the confidence calibration logic to:
1. Penalize 'unchanged' values if they are inconsistent with peer or violate flow conservation (prevent overconfidence in bad data we failed to repair).
2. Reward repairs that are verified by both local and remote flow conservation.
3. Provide more granular confidence scores based on verification status.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Helper to check remote verification
        def is_remotely_verified(val, field):
            rem_rid = data.get('remote_router')
            peer_id = data.get('connected_to')
            if not rem_rid or not peer_id:
                return False
            # If checking local RX, we check remote TX flow
            # If checking local TX, we check remote RX flow
            check_field = 'tx' if field == 'rx' else 'rx'

            err = calc_flow_error(rem_rid, peer_id, check_field, val)
            return err is not None and err < FLOW_TOLERANCE

        def get_rate_confidence(orig, final, field):
            # 1. Did we change the value?
            if abs(orig - final) < 0.001:
                return 1.0 # High confidence in original/unchanged data

            # 2. Is it just smoothing? (Small relative change < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95 # Smoothing is safe

            # 3. Noise Consensus (Both < Min Activity)
            if orig < MIN_ACTIVITY and final < MIN_ACTIVITY:
                return 0.95

            # 4. If changed, was it verified by LOCAL flow?
            rid = data.get('local_router')
            flow_err = calc_flow_error(rid, if_id, field, final)

            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                return 0.95 # Very high confidence: Mathematics supports this

            # 5. Was it verified by REMOTE flow?
            if is_remotely_verified(final, field):
                return 0.90 # High confidence: Peer is verified

            # 6. Was it a "Dead Counter" repair (0 -> Non-Zero)?
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Moderately high: 0 is a common error mode

            # 7. Fallback
            return 0.5 # Low confidence: Changed based on peer but no verification
=======
        # Helper to check remote verification
        def is_remotely_verified(val, field):
            rem_rid = data.get('remote_router')
            peer_id = data.get('connected_to')
            if not rem_rid or not peer_id:
                return False
            # If checking local RX, we check remote TX flow
            # If checking local TX, we check remote RX flow
            check_field = 'tx' if field == 'rx' else 'rx'

            err = calc_flow_error(rem_rid, peer_id, check_field, val)
            return err is not None and err < FLOW_TOLERANCE

        def get_rate_confidence(orig, final, field):
            # Check verification status
            rid = data.get('local_router')
            local_verified = False
            flow_err = calc_flow_error(rid, if_id, field, final)
            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                local_verified = True

            remote_verified = is_remotely_verified(final, field)

            # Check consistency with peer (Symmetry)
            peer_consistent = True
            peer_id = data.get('connected_to')
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 1. Unchanged Data
            if abs(orig - final) < 0.001:
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.95
                if not peer_consistent: return 0.6 # Unchanged but disagrees with peer
                # If unverifiable (edge) but consistent with peer
                if flow_err is None: return 0.9
                # If unverifiable and inconsistent with flow (but we didn't change it)
                if flow_err is not None and flow_err >= FLOW_TOLERANCE: return 0.7
                return 0.9

            # 2. Changed Data

            # Smoothing (Small relative change < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Noise Consensus (Both < Min Activity)
            if orig < MIN_ACTIVITY and final < MIN_ACTIVITY:
                return 0.95

            # Verified changes
            if local_verified and remote_verified:
                return 0.98
            if local_verified:
                return 0.95
            if remote_verified:
                return 0.90

            # Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Dead counter repair

            # Fallback
            return 0.5 # Changed but unverifiable
>>>>>>> REPLACE
</DIFF>