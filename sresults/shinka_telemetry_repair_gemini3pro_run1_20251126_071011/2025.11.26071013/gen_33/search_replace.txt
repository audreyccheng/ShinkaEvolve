<NAME>
hybrid_cost_scoring
</NAME>

<DESCRIPTION>
Replaces the purely continuous cost function with a Hybrid Cost function that defines three discrete tiers:
1. Verified Good (< Tolerance): Cost = Actual Error (0.0 - 0.05). Allows continuous tie-breaking.
2. Unverified: Cost = 0.1. Worse than any valid flow, but better than invalid flow.
3. Verified Bad (> Tolerance): Cost = 1.0 + Error. Strict penalty.

This structure ensures that the algorithm prioritizes finding a solution that satisfies flow conservation (Tier 1) over unverified guesses (Tier 2), and prioritizes unverified guesses over solutions that actively violate flow conservation (Tier 3). The continuous component within Tier 1 preserves the ability to pick the "tightest" fit.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                # Continuous Cost Scoring (Lower is better)
                # Instead of binary good/bad, use actual error magnitude
                def get_cost(err):
                    if err is None: return 0.05 # Unverified = small neutral cost
                    return min(err, 1.0)        # Verified = actual error cost

                score_tx = get_cost(err_local_tx) + get_cost(err_remote_tx)
                score_rx = get_cost(err_local_rx) + get_cost(err_remote_rx)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                if val_tx < MIN_ACTIVITY and val_rx > MIN_ACTIVITY: score_tx += 0.5
                if val_rx < MIN_ACTIVITY and val_tx > MIN_ACTIVITY: score_rx += 0.5
=======
                # Hybrid Cost Scoring (Lower is better)
                # Combines discrete tiers (Valid vs Invalid) with continuous gradients
                def get_score(err):
                    if err is None: return 0.1          # Tier 2: Unverified (neutral-bad)
                    if err < FLOW_TOLERANCE: return err # Tier 1: Verified Good (use error for tie-break)
                    return 1.0 + err                    # Tier 3: Verified Bad (strict penalty)

                score_tx = get_score(err_local_tx) + get_score(err_remote_tx)
                score_rx = get_score(err_local_rx) + get_score(err_remote_rx)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                # We apply a penalty that can override "slightly better flow" but not "strict flow violation"
                # Penalty 0.2 is enough to bridge the gap between 0.0 error and 0.05 error (max valid),
                # but smaller than 1.0 (invalid).
                if val_tx < MIN_ACTIVITY and val_rx > MIN_ACTIVITY: score_tx += 0.2
                if val_rx < MIN_ACTIVITY and val_tx > MIN_ACTIVITY: score_rx += 0.2
>>>>>>> REPLACE
</DIFF>