<NAME>
adaptive_flow_repair
</NAME>

<DESCRIPTION>
Introduces an adaptive candidate generation mechanism in the rate repair loop. If the best candidate from existing measurements (local/remote) still violates flow conservation on a verifiable router, the algorithm generates a synthetic candidate based on the residual flow of that router. This allows the system to recover correct rates even when both local and remote measurements are corrupted, provided the routers obey flow conservation.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            candidates = [cand_tx, cand_rx]
            has_synth = False

            # Residual Synthesis: If link appears dead, check if verifiable routers imply a flow
            if cand_tx < MIN_ACTIVITY and cand_rx < MIN_ACTIVITY:
                synth_tx = get_residual_val(rid_local, if_id, 'tx')
                if synth_tx is not None and synth_tx > MIN_ACTIVITY:
                    candidates.append(synth_tx)
                    has_synth = True

                synth_rx = get_residual_val(rid_remote, peer_id, 'rx')
                if synth_rx is not None and synth_rx > MIN_ACTIVITY:
                    candidates.append(synth_rx)
                    has_synth = True

            # Deduplicate candidates
            unique_cands = []
            for c in candidates:
                if not any(abs(c - x) < 1e-4 for x in unique_cands):
                    unique_cands.append(c)

            # Decision Logic
            best_val = cand_tx
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            # If we have synthetic candidates or disagreement, we vote. Otherwise average.
            if not has_synth and diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                best_score = float('inf')

                for cand in unique_cands:
                    err_local = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    def get_score(err):
                        if err is None: return 0.05
                        return min(err, 1.0)

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize zero if we have a better active alternative
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            # Start with measured values
            candidates = [cand_tx, cand_rx]

            # Helper to find best candidate from a list
            def select_best_candidate(cands):
                # Deduplicate
                unique = []
                for c in cands:
                    if not any(abs(c - x) < 1e-4 for x in unique):
                        unique.append(c)

                best_v = unique[0]
                best_s = float('inf')

                for cand in unique:
                    # Score based on flow conservation
                    err_loc = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_rem = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    # Cost function
                    # Small baseline cost (0.02) for unverifiable routers to prefer verifiable ones
                    cost_loc = min(err_loc, 2.0) if err_loc is not None else 0.02
                    cost_rem = min(err_rem, 2.0) if err_rem is not None else 0.02

                    score = cost_loc + cost_rem

                    # Heuristic: Avoid zero if a valid active candidate exists
                    if cand < MIN_ACTIVITY and max(unique) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_s:
                        best_s = score
                        best_v = cand
                return best_v, best_s

            # 1. Initial Selection
            best_val, best_score = select_best_candidate(candidates)

            # 2. Adaptive Expansion
            # If the best value still violates a verifiable router, try to synthesize a value
            # that satisfies that router.

            expanded = False

            # Check Local
            err_local = calc_flow_error(rid_local, if_id, 'tx', best_val)
            if err_local is not None and err_local > FLOW_TOLERANCE:
                synth = get_residual_val(rid_local, if_id, 'tx')
                if synth is not None:
                    candidates.append(synth)
                    expanded = True

            # Check Remote
            err_remote = calc_flow_error(rid_remote, peer_id, 'rx', best_val)
            if err_remote is not None and err_remote > FLOW_TOLERANCE:
                synth = get_residual_val(rid_remote, peer_id, 'rx')
                if synth is not None:
                    candidates.append(synth)
                    expanded = True

            # 3. Final Selection (if we added candidates)
            if expanded:
                best_val, best_score = select_best_candidate(candidates)

            # 4. Smoothing for Agreement
            # If the selected value is close to the average of measurements, use average
            # to reduce noise, but ONLY if the average is also flow-valid.
            avg = (cand_tx + cand_rx) / 2.0
            diff_orig = abs(cand_tx - cand_rx)
            if diff_orig < max(avg * TOLERANCE, MIN_ACTIVITY):
                # Measurements agree. Check if average is worse than best_val.
                # If best_val is significantly different from avg, it means flow conservation
                # pulled us away from the measurements. We trust flow.
                # If best_val is close to avg, we use avg.
                if abs(best_val - avg) < max(avg * 0.05, 1.0):
                    best_val = avg

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>

<NAME>
continuous_confidence_scoring
</NAME>

<DESCRIPTION>
Replaces the discrete bucket-based confidence scoring with a continuous penalty model. Confidence starts at 1.0 and is reduced by residual flow errors (scaled by their magnitude), lack of verification, and peer inconsistency. This provides finer granularity in confidence calibration, better reflecting the uncertainty in "partially broken" scenarios.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    for if_id, data in telemetry.items():
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        rid = data.get('local_router')
        peer_id = data.get('connected_to')

        def get_rate_confidence(orig, final, field):
            # 1. Verification Logic
            local_err = final_errors.get(rid)
            local_verified = (local_err is not None and local_err < FLOW_TOLERANCE)

            remote_verified = False
            rem_rid = data.get('remote_router')
            if rem_rid and rem_rid in final_errors:
                 if final_errors[rem_rid] < FLOW_TOLERANCE:
                     remote_verified = True

            # Peer Consistency
            peer_consistent = True
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 2. Change Analysis
            changed = abs(orig - final) > 0.001
            smoothed = changed and (abs(orig - final) < max(orig * 0.05, 0.1))

            # --- Scoring ---
            if not changed:
                # Value retained
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.98
                if not peer_consistent: return 0.7
                if remote_verified: return 0.95

                # Check for Broken Router (Unverified AND High Error)
                if local_err is not None and local_err >= FLOW_TOLERANCE:
                    return 0.6

                return 0.9

            if smoothed:
                return 0.95

            # Significant Repair
            if local_verified and remote_verified: return 0.98
            if local_verified: return 0.95
            if remote_verified: return 0.90

            # Unverified Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.85 # Fixed dead counter

            return 0.6 # Fallback

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check for Down state
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf = 0.0
            tx_conf = 0.0

        result[if_id] = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
=======
    for if_id, data in telemetry.items():
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        rid = data.get('local_router')
        peer_id = data.get('connected_to')

        def get_rate_confidence(orig, final, field):
            # 1. Verification & Residual Penalties
            # Calculate a base confidence derived from how well the router balances
            local_err = final_errors.get(rid)
            rem_rid = data.get('remote_router')
            remote_err = final_errors.get(rem_rid) if rem_rid else None

            # Start High
            score = 1.0

            # Penalty for Local Flow Error
            if local_err is not None:
                # If error is within tolerance, no penalty.
                # If error exceeds tolerance, scale penalty.
                if local_err > FLOW_TOLERANCE:
                    penalty = min((local_err - FLOW_TOLERANCE) * 5.0, 0.4)
                    score -= penalty
            else:
                # Unverifiable local router: slight penalty for uncertainty
                score -= 0.05

            # Penalty for Remote Flow Error (less weight than local)
            if remote_err is not None:
                if remote_err > FLOW_TOLERANCE:
                    penalty = min((remote_err - FLOW_TOLERANCE) * 2.5, 0.2)
                    score -= penalty
            else:
                score -= 0.02

            # 2. Peer Consistency
            peer_val = 0.0
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                diff_peer = abs(final - peer_val)
                # If mismatch exists (after repair loop), it's bad
                if diff_peer > max(final * TOLERANCE, MIN_ACTIVITY):
                     score -= 0.1

            # 3. Change Analysis
            changed = abs(orig - final) > 0.001

            if not changed:
                # We trusted the original value.
                # If there was a peer conflict we ignored, penalize
                orig_peer_val = 0.0
                if peer_id and peer_id in telemetry:
                     orig_peer_val = telemetry[peer_id].get('tx_rate' if field == 'rx' else 'rx_rate', 0.0)
                     if abs(orig - orig_peer_val) > max(orig, orig_peer_val, 1.0) * TOLERANCE:
                         # Conflict existed, we did nothing.
                         if local_err is None: score -= 0.2
                         else: score -= 0.1
            else:
                # We changed the value.
                # If we are unverified, we should be careful.
                if local_err is None and remote_err is None:
                    # Total guess / Heuristic
                    score = min(score, 0.75)

                # Boost for "Dead Repair" (0 -> Active) if consistent with peer
                if orig < MIN_ACTIVITY and final > MIN_ACTIVITY and abs(final - peer_val) < 1.0:
                    score = max(score, 0.85)

            return max(0.0, min(score, 1.0))

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check for Down state
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf = 0.0
            tx_conf = 0.0

        result[if_id] = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
>>>>>>> REPLACE
</DIFF>