<NAME>
inject_residual_logic
</NAME>
<DESCRIPTION>
Introduces a `get_residual` helper function and updates the rate repair loop to consider residual values (values that would perfectly balance a router) as candidates. This helps in scenarios where both link endpoints have corrupted (e.g., zero) counters but the router flow implies traffic.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Continuous Scoring Function (Lower is better)
                def get_score(err):
                    if err is None: return 0.05 # Neutral penalty for unverifiable
                    return min(err, 1.0)        # Actual error for verifiable

                score_1 = get_score(err_a_1) + get_score(err_b_1)
                score_2 = get_score(err_a_2) + get_score(err_b_2)

                # Heuristic: Dead counters (0) are often wrong if the other side is active
                # Add heavy penalty to the zero candidate
                if cand_tx < MIN_ACTIVITY and cand_rx > MIN_ACTIVITY: score_1 += 0.5
                if cand_rx < MIN_ACTIVITY and cand_tx > MIN_ACTIVITY: score_2 += 0.5

                # Tie-breaking/Continuous Selection
                if score_1 < score_2:
                    best_val = cand_tx
                elif score_2 < score_1:
                    best_val = cand_rx
                else:
                    best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Helper: Calculate the value required to perfectly balance a router
    def get_residual(rid, if_target, field):
        if rid not in verifiable_routers:
            return None

        sum_in = 0.0
        sum_out = 0.0

        for iface in router_interfaces[rid]:
            if iface == if_target: continue # Skip the target
            sum_in += state[iface]['rx']
            sum_out += state[iface]['tx']

        # Target must balance the difference
        # If calculating Tx: Out_Target = Sum_In - Sum_Out_Others
        # If calculating Rx: In_Target = Sum_Out - Sum_In_Others
        if field == 'tx':
            val = sum_in - sum_out
        else:
            val = sum_out - sum_in

        return max(0.0, val)

    # Run 3 passes to allow corrections to propagate across the network
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus: Tx(Local) -> Rx(Peer)
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            # Collect candidates
            candidates = {cand_tx, cand_rx}

            # Add Residuals (Synthesized values from Flow Conservation)
            res_local = get_residual(rid_local, if_id, 'tx')
            if res_local is not None: candidates.add(res_local)

            res_remote = get_residual(rid_remote, peer_id, 'rx')
            if res_remote is not None: candidates.add(res_remote)

            # Evaluate Candidates
            best_score = float('inf')
            best_val = cand_tx

            # Pre-check: If all candidates are very close, just average them
            cands_list = list(candidates)
            if max(cands_list) - min(cands_list) < max(max(cands_list) * TOLERANCE, MIN_ACTIVITY):
                best_val = sum(cands_list) / len(cands_list)
            else:
                for cand in candidates:
                    # Calculate System Error for this candidate
                    err_local = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    def get_score(err):
                        if err is None: return 0.05
                        return min(err, 1.0)

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize zero if alternatives exist (Dead counter heuristic)
                    if cand < MIN_ACTIVITY and max(cands_list) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
</DIFF>

<NAME>
penalize_broken_routers
</NAME>
<DESCRIPTION>
Updates the confidence calibration logic to explicitly penalize "Broken Routers" - routers that are theoretically verifiable (all interfaces present) but exhibit high flow errors after repair. This prevents overconfidence in scenarios where equipment is malfunctioning or the topology is incorrect.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
            if not changed:
                # We kept the original value
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.98
                if not peer_consistent: return 0.7 # Conflict existed, but we didn't change (ambiguous)
                # If unverifiable but consistent with peer
                if remote_verified: return 0.95
                return 0.9

            if smoothed:
                return 0.95 # High confidence in small adjustments
=======
            if not changed:
                # We kept the original value
                if local_verified and remote_verified: return 1.0

                # Check for "Broken Router" (Verifiable but High Error)
                # If we are verifying locally, but the error is high, we shouldn't trust it.
                if local_err is not None and local_err > FLOW_TOLERANCE:
                     return 0.6

                if local_verified: return 0.98
                if not peer_consistent: return 0.7 # Conflict existed, but we didn't change (ambiguous)
                # If unverifiable but consistent with peer
                if remote_verified: return 0.95
                return 0.9

            if smoothed:
                return 0.95 # High confidence in small adjustments
>>>>>>> REPLACE
</DIFF>