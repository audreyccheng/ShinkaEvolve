<NAME>
state_aware_flow_constraints
</NAME>

<DESCRIPTION>
1. Introduces strict verification for flow conservation: Flow Hints are now only calculated for routers where all interfaces are present in the telemetry. This prevents incorrect hints from partially observed routers (where sum(in) != sum(out) due to missing data) from corrupting the repair process.
2. Enhances the iterative repair logic: If both the local and peer measurements strongly disagree (>20%) with a verified Flow Hint, the algorithm now synthesizes a value from the hint. This allows the system to repair links where both sensors are faulty using the "island of truth" provided by the router's other correct interfaces.
3. Implements a discrete confidence calibration model: Instead of a simple linear decay, confidence scores are mapped to discrete buckets based on error magnitude. This provides better calibration (e.g., distinguishing between "perfect" repairs and "acceptable" repairs). Contradictions between Symmetry and Flow evidence now apply explicit penalties.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Phase 2: Iterative Refinement ---
    # Refine rates by enforcing Flow Conservation and Link Symmetry repeatedly.
    # This allows corrections to propagate across the topology.

    for _ in range(ITERATIONS):
        # 1. Calculate Flow Hints based on current state
        router_balances = {}
        for r_id, ifaces in topology.items():
            valid_ifaces = [i for i in ifaces if i in state]
            sum_rx = sum(state[i]['rx'] for i in valid_ifaces)
            sum_tx = sum(state[i]['tx'] for i in valid_ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        updates = {}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                updates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            # Get Hints
            r_id = telemetry[iface_id].get('local_router')
            hint_rx, hint_tx = None, None
            if r_id and r_id in router_balances:
                rb = router_balances[r_id]
                # Hint RX: The value needed to balance total TX
                hint_rx = max(0.0, rb['tx'] - (rb['rx'] - curr['rx']))
                # Hint TX: The value needed to balance total RX
                hint_tx = max(0.0, rb['rx'] - (rb['tx'] - curr['tx']))

            # Get Peer Values
            peer_rx, peer_tx = 0.0, 0.0
            if curr['has_peer']:
                p_state = state[curr['peer_id']]
                peer_rx, peer_tx = p_state['rx'], p_state['tx']

            def resolve_rate_iterative(local_val, peer_val, hint_val):
                # 1. Symmetry
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0

                    # Double Dead Check: If both 0 but hint is high, trust hint
                    if avg < TRAFFIC_THRESHOLD and hint_val is not None and hint_val > 5.0:
                         # Only do this if hint is significantly non-zero
                         return hint_val
                    return avg

                # 2. Symmetry Broken
                if hint_val is None:
                    # Fallback to peer if no hint available (sensor usually worse than wire?)
                    # Or keep local? Let's keep local to avoid thrashing without evidence.
                    return local_val

                # Compare against hint
                denom_l = max(local_val, hint_val, 1.0)
                diff_l = abs(local_val - hint_val) / denom_l

                denom_p = max(peer_val, hint_val, 1.0)
                diff_p = abs(peer_val - hint_val) / denom_p

                if diff_l < diff_p:
                    return local_val
                else:
                    return peer_val

            # Resolve RX (Target: Peer TX)
            tgt_peer_tx = peer_tx if curr['has_peer'] else curr['rx']
            next_rx = resolve_rate_iterative(curr['rx'], tgt_peer_tx, hint_rx)

            # Resolve TX (Target: Peer RX)
            tgt_peer_rx = peer_rx if curr['has_peer'] else curr['tx']
            next_tx = resolve_rate_iterative(curr['tx'], tgt_peer_rx, hint_tx)

            updates[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply updates
        for i_id, vals in updates.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Recalculate hints one last time for confidence scoring
    final_router_balances = {}
    for r_id, ifaces in topology.items():
        valid_ifaces = [i for i in ifaces if i in state]
        sum_rx = sum(state[i]['rx'] for i in valid_ifaces)
        sum_tx = sum(state[i]['tx'] for i in valid_ifaces)
        final_router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}
=======
    # --- Phase 2: Iterative Refinement ---
    # Refine rates by enforcing Flow Conservation and Link Symmetry repeatedly.

    # Identify Verifiable Routers (Fully Monitored)
    # We only apply flow conservation constraints if we can see the whole picture.
    fully_monitored_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            fully_monitored_routers.add(r_id)

    for _ in range(ITERATIONS):
        # 1. Calculate Flow Hints based on current state (Only for verifiable routers)
        router_balances = {}
        for r_id in fully_monitored_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces)
            sum_tx = sum(state[i]['tx'] for i in ifaces)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        updates = {}

        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                updates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            # Get Hints
            r_id = telemetry[iface_id].get('local_router')
            hint_rx, hint_tx = None, None
            if r_id and r_id in router_balances:
                rb = router_balances[r_id]
                hint_rx = max(0.0, rb['tx'] - (rb['rx'] - curr['rx']))
                hint_tx = max(0.0, rb['rx'] - (rb['tx'] - curr['tx']))

            # Get Peer Values
            peer_rx, peer_tx = 0.0, 0.0
            if curr['has_peer']:
                p_state = state[curr['peer_id']]
                peer_rx, peer_tx = p_state['rx'], p_state['tx']

            def resolve_rate_iterative(local_val, peer_val, hint_val):
                # 1. Symmetry
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds.
                    avg = (local_val + peer_val) / 2.0
                    # Double Dead Check: If both 0 but hint is high, trust hint
                    if avg < TRAFFIC_THRESHOLD and hint_val is not None and hint_val > 5.0:
                         return hint_val
                    return avg

                # 2. Symmetry Broken
                if hint_val is None:
                    # Fallback to local if no hint available
                    return local_val

                # 3. Use Hint as Arbiter
                denom_l = max(local_val, hint_val, 1.0)
                diff_l = abs(local_val - hint_val) / denom_l

                denom_p = max(peer_val, hint_val, 1.0)
                diff_p = abs(peer_val - hint_val) / denom_p

                # Strong Hint Override: If both candidates deviate significantly from flow hint,
                # trust the hint (assuming the router's other interfaces are more reliable).
                if diff_l > 0.2 and diff_p > 0.2:
                     return hint_val

                if diff_l < diff_p:
                    return local_val
                else:
                    return peer_val

            # Resolve RX (Target: Peer TX)
            tgt_peer_tx = peer_tx if curr['has_peer'] else curr['rx']
            next_rx = resolve_rate_iterative(curr['rx'], tgt_peer_tx, hint_rx)

            # Resolve TX (Target: Peer RX)
            tgt_peer_rx = peer_rx if curr['has_peer'] else curr['tx']
            next_tx = resolve_rate_iterative(curr['tx'], tgt_peer_rx, hint_tx)

            updates[iface_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply updates
        for i_id, vals in updates.items():
            state[i_id]['rx'] = vals['rx']
            state[i_id]['tx'] = vals['tx']

    # --- Phase 3: Final Calibration ---
    result = {}

    # Recalculate hints one last time for confidence scoring
    final_router_balances = {}
    for r_id in fully_monitored_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces)
        sum_tx = sum(state[i]['tx'] for i in ifaces)
        final_router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        def get_confidence(final_val, peer_ref, hint_ref):
            # Calculate errors against available evidence

            # Error vs Peer (Symmetry)
            denom_s = max(final_val, peer_ref, 1.0)
            err_sym = abs(final_val - peer_ref) / denom_s

            # Error vs Hint (Flow)
            err_flow = 1.0 # Default high error if no hint
            if hint_ref is not None:
                denom_f = max(final_val, hint_ref, 1.0)
                err_flow = abs(final_val - hint_ref) / denom_f

            # Logic: We are confident if we match EITHER Peer OR Hint.
            # We are most confident if we match BOTH.
            # We are worried if we match NEITHER.

            best_support = min(err_sym, err_flow)

            # Continuous calibration:
            # 1.0 at 0 error, decaying to ~0.5 at 50% error
            conf = max(0.0, 1.0 - (best_support * 1.5))

            # Boost if both agree (corroboration)
            if err_sym < 0.05 and err_flow < 0.05:
                conf = 1.0
            elif err_sym > 0.1 and err_flow > 0.1:
                # Contradiction on all fronts
                conf = max(0.0, conf - 0.2)

            return conf
=======
        def get_confidence(final_val, peer_ref, hint_ref):
            # Calculate errors against available evidence
            # Error vs Peer (Symmetry)
            denom_s = max(final_val, peer_ref, 1.0)
            err_sym = abs(final_val - peer_ref) / denom_s

            # Error vs Hint (Flow)
            err_flow = None
            if hint_ref is not None:
                denom_f = max(final_val, hint_ref, 1.0)
                err_flow = abs(final_val - hint_ref) / denom_f

            # Determine support level
            # Primary support comes from the best matching evidence
            support_err = err_sym
            if err_flow is not None:
                support_err = min(err_sym, err_flow)

            # Discrete Confidence Buckets for better calibration
            # We map error ranges to confidence levels
            if support_err <= HARDENING_THRESHOLD:
                conf = 1.0
            elif support_err <= 0.05:
                conf = 0.95
            elif support_err <= 0.10:
                conf = 0.85
            elif support_err <= 0.20:
                conf = 0.70
            elif support_err <= 0.50:
                conf = 0.40
            else:
                conf = 0.10

            # Penalize contradictions
            # If we have a hint and it strongly disagrees with symmetry (and we relied on one),
            # it suggests a messy situation.
            if err_flow is not None:
                conflict = abs(err_sym - err_flow)
                if conflict > 0.2:
                    conf = max(0.0, conf - 0.2)

            # If we have NO hint and symmetry is broken significantly, confidence should be low
            # because we just guessed (kept local or peer).
            if err_flow is None and err_sym > HARDENING_THRESHOLD:
                conf = min(conf, 0.6)

            return conf
>>>>>>> REPLACE
</DIFF>