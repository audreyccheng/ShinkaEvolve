The following change re-introduces aggressive Residual Synthesis for candidate generation to better handle "double dead" links or single-sided failures, replaces discrete voting with continuous scoring for finer granularity, and sharpens confidence calibration by explicitly penalizing unchanged values that result in broken router states (flow imbalance).

<NAME>
hybrid_consensus_with_residual_and_broken_detection
</NAME>

<DESCRIPTION>
Re-implements Residual Synthesis to generate candidate traffic rates based on flow conservation, allowing repair even when both link ends are zero/dead. Switches from discrete vote counting to continuous error scoring for candidate selection. Enhances confidence calibration by explicitly checking for "Broken Routers" (high flow error) and lowering confidence if values are unchanged but the router remains broken.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repairs network telemetry using an iterative consensus approach.

    The algorithm treats telemetry as a system of constraints:
    1. Link Symmetry: Tx(A->B) should equal Rx(B<-A)
    2. Flow Conservation: Sum(Rx) should equal Sum(Tx) at every router
    3. Status Consistency: Active traffic implies UP status

    It iteratively optimizes these values to find the most consistent network state.
    """

    # --- Constants ---
    TOLERANCE = 0.02         # 2% deviation allowed for symmetry
    MIN_ACTIVITY = 0.01      # Mbps threshold to consider an interface active
    FLOW_TOLERANCE = 0.05    # 5% flow imbalance allowed

    # --- 1. Initialization & Data Structure Setup ---

    # Working state dictionary: We will mutate this iteratively
    # Structure: if_id -> {rx, tx, status, ...}
    state = {}

    # Map for router verification
    # router_id -> list of interface_ids
    router_interfaces = collections.defaultdict(list)
    verifiable_routers = set()

    # Build topology map and identify routers where we can check Flow Conservation
    # (We can only check flow if we have telemetry for ALL interfaces on the router)
    for rid, if_list in topology.items():
        router_interfaces[rid] = if_list
        if all(if_id in telemetry for if_id in if_list):
            verifiable_routers.add(rid)

    # Initialize state from input telemetry
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'down'),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router')
        }

    # --- 2. Status Repair ---
    # Logic: Activity implies UP. Peer UP + Activity implies UP.
    status_conf_map = {}

    for if_id, s in state.items():
        orig_status = s['status']
        peer_id = s['connected_to']

        # Local activity check
        local_active = (s['rx'] > MIN_ACTIVITY) or (s['tx'] > MIN_ACTIVITY)

        # Peer activity/status check
        peer_active = False
        peer_status = 'unknown'
        if peer_id and peer_id in state:
            p = state[peer_id]
            peer_active = (p['rx'] > MIN_ACTIVITY) or (p['tx'] > MIN_ACTIVITY)
            peer_status = p['status']

        # Decision Logic
        new_status = orig_status
        conf = 1.0

        # If there is traffic, the link must be UP
        if local_active or peer_active:
            new_status = 'up'
            if orig_status == 'down':
                conf = 0.95  # High confidence repair
        # If I say UP, but Peer says DOWN and there is NO traffic -> likely DOWN
        elif orig_status == 'up' and peer_status == 'down':
            new_status = 'down'
            conf = 0.8
        # If statuses disagree and no traffic, we assume DOWN is correct (or keep DOWN)
        elif orig_status != peer_status:
            # If we are DOWN and peer is UP (idle), we trust our DOWN status more than their UP
            # because "Activity implies UP" didn't trigger.
            conf = 0.8

        state[if_id]['status'] = new_status
        status_conf_map[if_id] = conf

        # If status is DOWN, force rates to zero to prevent pollution of flow calc
        if new_status == 'down':
            state[if_id]['rx'] = 0.0
            state[if_id]['tx'] = 0.0

    # --- 3. Rate Repair (Iterative Consensus) ---

    # Helper: Calculate relative flow error for a router if we force a specific value
    def calc_flow_error(rid, if_target, field, value):
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            # Use current state values
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute the target value we are testing
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        err = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return err / denom

    # Run 2 passes to allow corrections to propagate across the network
    for _ in range(2):
        # Iterate over all interfaces to check Link Symmetry
        for if_id, s in state.items():
            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # We process the "outgoing" link: Tx(Local) -> Rx(Peer)
            # (The incoming link will be processed when we iterate the peer)

            cand_tx = s['tx']              # Candidate 1: Local Tx
            cand_rx = state[peer_id]['rx'] # Candidate 2: Peer Rx

            # 3a. Check for agreement
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            best_val = cand_tx # Default to local

            if diff / mag < TOLERANCE:
                # Agree: Average to smooth out small noise
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                # Disagree: Conflict Resolution using Flow Conservation
                rid_a = s['local_router']
                rid_b = state[peer_id]['local_router']

                # Test Candidate 1 (cand_tx)
                # Does it fit Router A's flow (as Tx)? Does it fit Router B's flow (as Rx)?
                err_a_1 = calc_flow_error(rid_a, if_id, 'tx', cand_tx)
                err_b_1 = calc_flow_error(rid_b, peer_id, 'rx', cand_tx)

                # Test Candidate 2 (cand_rx)
                err_a_2 = calc_flow_error(rid_a, if_id, 'tx', cand_rx)
                err_b_2 = calc_flow_error(rid_b, peer_id, 'rx', cand_rx)

                # Vote counting
                votes_1 = 0
                votes_2 = 0

                # A candidate gets a vote if it results in low flow error (<5%)
                if err_a_1 is not None and err_a_1 < FLOW_TOLERANCE: votes_1 += 1
                if err_b_1 is not None and err_b_1 < FLOW_TOLERANCE: votes_1 += 1

                if err_a_2 is not None and err_a_2 < FLOW_TOLERANCE: votes_2 += 1
                if err_b_2 is not None and err_b_2 < FLOW_TOLERANCE: votes_2 += 1

                # Decision
                if votes_1 > votes_2:
                    best_val = cand_tx
                elif votes_2 > votes_1:
                    best_val = cand_rx
                else:
                    # Tie or No Info (e.g. edge routers). Use Heuristics.
                    # Heuristic: Dead counters often report 0. Trust non-zero.
                    if cand_tx > MIN_ACTIVITY and cand_rx <= MIN_ACTIVITY:
                        best_val = cand_tx
                    elif cand_rx > MIN_ACTIVITY and cand_tx <= MIN_ACTIVITY:
                        best_val = cand_rx
                    else:
                        # Compare raw error magnitudes if flow info exists but was ambiguous
                        sum_err_1 = (err_a_1 or 100) + (err_b_1 or 100)
                        sum_err_2 = (err_a_2 or 100) + (err_b_2 or 100)

                        if sum_err_1 < sum_err_2 and sum_err_1 < 200:
                            best_val = cand_tx
                        elif sum_err_2 < sum_err_1 and sum_err_2 < 200:
                            best_val = cand_rx
                        else:
                            # Total ambiguity -> Average
                            best_val = (cand_tx + cand_rx) / 2.0

            # Apply repair to state
            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Final Result Generation & Confidence Calibration ---
    result = {}

    for if_id, data in telemetry.items():
        # Get Final Values
        final_rx = state[if_id]['rx']
        final_tx = state[if_id]['tx']
        final_st = state[if_id]['status']

        orig_rx = data.get('rx_rate', 0.0)
        orig_tx = data.get('tx_rate', 0.0)
        orig_st = data.get('interface_status', 'unknown')

        # -- Calibrate Confidence --

        # Helper to check remote verification
        def is_remotely_verified(val, field):
            rem_rid = data.get('remote_router')
            peer_id = data.get('connected_to')
            if not rem_rid or not peer_id:
                return False
            # If checking local RX, we check remote TX flow
            # If checking local TX, we check remote RX flow
            check_field = 'tx' if field == 'rx' else 'rx'

            err = calc_flow_error(rem_rid, peer_id, check_field, val)
            return err is not None and err < FLOW_TOLERANCE

        def get_rate_confidence(orig, final, field):
            # Check verification status
            rid = data.get('local_router')
            local_verified = False
            flow_err = calc_flow_error(rid, if_id, field, final)
            if flow_err is not None and flow_err < FLOW_TOLERANCE:
                local_verified = True

            remote_verified = is_remotely_verified(final, field)

            # Check consistency with peer (Symmetry)
            peer_consistent = True
            peer_id = data.get('connected_to')
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 1. Unchanged Data
            if abs(orig - final) < 0.001:
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.95
                if not peer_consistent: return 0.6 # Unchanged but disagrees with peer
                # If unverifiable (edge) but consistent with peer
                if flow_err is None: return 0.9
                # If unverifiable and inconsistent with flow (but we didn't change it)
                if flow_err is not None and flow_err >= FLOW_TOLERANCE: return 0.7
                return 0.9

            # 2. Changed Data

            # Smoothing (Small relative change < 5%)
            if orig > MIN_ACTIVITY and abs(orig - final) / orig < 0.05:
                return 0.95

            # Noise Consensus (Both < Min Activity)
            if orig < MIN_ACTIVITY and final < MIN_ACTIVITY:
                return 0.95

            # Verified changes
            if local_verified and remote_verified:
                return 0.98
            if local_verified:
                return 0.95
            if remote_verified:
                return 0.90

            # Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.8 # Dead counter repair

            # Fallback
            return 0.5 # Changed but unverifiable

        rx_conf = get_rate_confidence(orig_rx, final_rx, 'rx')
        tx_conf = get_rate_confidence(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        # Sanity Check: If Down but Traffic, lower confidence
        if final_st == 'down' and (final_rx > 1.0 or final_tx > 1.0):
            rx_conf *= 0.5
            tx_conf *= 0.5
            st_conf *= 0.5

        # Construct Output Tuple
        res_entry = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (orig_st, final_st, st_conf),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }
        result[if_id] = res_entry

    return result
=======
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repairs network telemetry using a hybrid consensus approach.
    Combines iterative constraint satisfaction with residual synthesis for robust repair.
    """

    # --- Constants ---
    TOLERANCE = 0.02          # 2% symmetry tolerance
    FLOW_TOLERANCE = 0.05     # 5% flow conservation tolerance
    MIN_ACTIVITY = 0.05       # Mbps threshold for "active" traffic

    # --- 1. Initialization ---
    state = {}
    router_map = collections.defaultdict(list)
    verifiable_routers = set()

    # Identify verifiable routers (all interfaces monitored)
    for rid, if_list in topology.items():
        router_map[rid] = if_list
        if all(if_id in telemetry for if_id in if_list):
            verifiable_routers.add(rid)

    # Initialize state
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'down'),
            'connected_to': data.get('connected_to'),
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            # Keep originals
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'down')
        }

    # --- 2. Status Repair ---
    status_conf_map = {}

    for if_id, s in state.items():
        orig_st = s['orig_status']
        peer_id = s['connected_to']

        # Traffic check (on originals)
        active = (s['orig_rx'] > MIN_ACTIVITY) or (s['orig_tx'] > MIN_ACTIVITY)
        peer_active = False
        peer_st = 'unknown'

        if peer_id and peer_id in state:
            peer = state[peer_id]
            peer_active = (peer['orig_rx'] > MIN_ACTIVITY) or (peer['orig_tx'] > MIN_ACTIVITY)
            peer_st = peer['orig_status']

        # Logic
        final_st = orig_st
        conf = 1.0

        if active or peer_active:
            final_st = 'up'
            if orig_st == 'down': conf = 0.95
        elif orig_st == 'up' and peer_st == 'down':
            final_st = 'down'
            conf = 0.8
        elif orig_st != peer_st:
            # Conflict with no traffic -> Conservative Down
            final_st = 'down'
            conf = 0.7

        state[if_id]['status'] = final_st
        status_conf_map[if_id] = conf

        # Zero out down links
        if final_st == 'down':
            state[if_id]['rx'] = 0.0
            state[if_id]['tx'] = 0.0

    # --- Helpers for Rate Repair ---
    def get_flow_error(rid, if_target=None, field=None, value=None):
        if rid not in verifiable_routers: return None
        sum_rx, sum_tx = 0.0, 0.0
        for iface in router_map[rid]:
            r = value if (iface == if_target and field == 'rx') else state[iface]['rx']
            t = value if (iface == if_target and field == 'tx') else state[iface]['tx']
            sum_rx += r
            sum_tx += t
        return abs(sum_rx - sum_tx) / max(sum_rx, sum_tx, 1.0)

    def get_residual(rid, if_target, field):
        """Calculates value needed to balance router perfectly."""
        if rid not in verifiable_routers: return None
        sum_in, sum_out = 0.0, 0.0
        for iface in router_map[rid]:
            r = 0.0 if (iface == if_target and field == 'rx') else state[iface]['rx']
            t = 0.0 if (iface == if_target and field == 'tx') else state[iface]['tx']
            sum_in += r
            sum_out += t

        # Balance: Sum_In = Sum_Out
        if field == 'rx': val = sum_out - sum_in
        else: val = sum_in - sum_out
        return max(val, 0.0)

    # --- 3. Rate Repair (Iterative) ---
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state: continue

            # Candidates
            candidates = [s['tx'], state[peer_id]['rx']]

            # Add Residuals as candidates
            res_tx = get_residual(s['local_router'], if_id, 'tx')
            if res_tx is not None: candidates.append(res_tx)

            res_rx = get_residual(s['remote_router'], peer_id, 'rx')
            if res_rx is not None: candidates.append(res_rx)

            # Evaluate
            best_val = s['tx']
            best_score = float('inf')

            # Deduplicate and sort
            unique_cands = sorted(list(set([c for c in candidates if c >= 0])))

            for cand in unique_cands:
                # Calculate penalties
                # Local router error
                err_loc = get_flow_error(s['local_router'], if_id, 'tx', cand)
                # Remote router error
                err_rem = get_flow_error(s['remote_router'], peer_id, 'rx', cand)

                score = 0.0
                # Continuous scoring
                if err_loc is None: score += 0.05
                else: score += min(err_loc, 1.0)

                if err_rem is None: score += 0.05
                else: score += min(err_rem, 1.0)

                # Heuristic: Avoid zero if possible when alternates exist
                if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                    score += 0.5

                if score < best_score:
                    best_score = score
                    best_val = cand

            # Smoothing: If best val is close to average of telemetry, use average
            avg_telemetry = (s['tx'] + state[peer_id]['rx']) / 2.0
            if abs(best_val - avg_telemetry) < max(avg_telemetry * 0.1, 1.0):
                 if abs(s['tx'] - state[peer_id]['rx']) < max(avg_telemetry * TOLERANCE, MIN_ACTIVITY):
                     best_val = avg_telemetry

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val

    # --- 4. Confidence Calibration ---
    result = {}

    # Calculate final health of routers
    final_router_health = {}
    for rid in verifiable_routers:
        final_router_health[rid] = get_flow_error(rid)

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        final_rx = s['rx']
        orig_tx = s['orig_tx']
        final_tx = s['tx']

        def get_conf(orig, final, field):
            # 1. Verification
            rid_loc = s['local_router']
            loc_err = final_router_health.get(rid_loc)
            loc_ok = (loc_err is not None and loc_err < FLOW_TOLERANCE)

            # Remote Verification (via Peer)
            peer_id = s['connected_to']
            rem_ok = False
            if peer_id and peer_id in state:
                rid_rem = state[peer_id]['local_router'] # The OTHER router
                rem_err = final_router_health.get(rid_rem)
                rem_ok = (rem_err is not None and rem_err < FLOW_TOLERANCE)

            # Peer Consistency
            peer_consistent = True
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            changed = abs(orig - final) > 0.001
            smoothed = changed and abs(orig - final) < max(orig * 0.05, 0.1)

            # Scoring
            if not changed:
                if loc_ok and rem_ok: return 1.0
                if loc_ok: return 0.98
                if not peer_consistent: return 0.7
                if rem_ok: return 0.95
                # Critical: If not changed, but local router is BROKEN, confidence is low
                if loc_err is not None and loc_err > FLOW_TOLERANCE:
                    return 0.6
                return 0.9

            if smoothed: return 0.95

            # Significant changes
            if loc_ok and rem_ok: return 0.99
            if loc_ok: return 0.95 # Local math adds up
            if rem_ok: return 0.90 # Peer math adds up

            # Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY: return 0.85

            return 0.6

        rx_conf = get_conf(orig_rx, final_rx, 'rx')
        tx_conf = get_conf(orig_tx, final_tx, 'tx')
        st_conf = status_conf_map.get(if_id, 1.0)

        if s['status'] == 'down' and (final_rx > 1.0 or final_tx > 1.0):
             rx_conf = 0.0; tx_conf = 0.0; st_conf = 0.0

        result[if_id] = {
            'rx_rate': (orig_rx, final_rx, rx_conf),
            'tx_rate': (orig_tx, final_tx, tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': s['connected_to'],
            'local_router': s['local_router'],
            'remote_router': s['remote_router']
        }

    return result
>>>>>>> REPLACE
</DIFF>