<NAME>
active_residual_synthesis_and_penalty_calibration
</NAME>

<DESCRIPTION>
1.  **Expanded Residual Synthesis**: In the rate repair loop, if there is disagreement between counters, the algorithm now calculates "residual" values (what the value *should* be to satisfy flow conservation) from both local and remote routers (if verifiable). These are added as candidates. This helps find the true value when both measurements are corrupted but flow constraints can deduce the correct rate.
2.  **Robust Scoring Function**: The candidate scoring function is refined to explicitly prefer "Verified Good" (error < tolerance) over "Unverified" (score 0.02) over "Verified Bad" (score = error). This ensures that a plausible solution derived from flow conservation beats an unverified measurement, but an unverified measurement beats a demonstrably invalid one.
3.  **Proportional Confidence Penalty**: Instead of a binary "Broken Router" fallback, the confidence score is now penalized proportionally to the flow error on the local router. This provides better calibration: if a router is broken (high flow error), our confidence in its interfaces scales down with the severity of the breakage.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 3. Rate Repair (Iterative Consensus) ---

    def calc_flow_error(rid, if_target, field, value):
        """Calculates flow error for a router given a hypothetical value for one interface."""
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute hypothetical value
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    def get_residual_val(rid, if_target, field):
        """Calculates value required to perfectly balance a verifiable router."""
        if rid not in verifiable_routers: return None

        sum_in, sum_out = 0.0, 0.0
        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']
            # Exclude the specific component we are solving for
            if iface == if_target:
                if field == 'rx': r = 0.0
                else: t = 0.0
            sum_in += r
            sum_out += t

        # Balance: In = Out
        val = sum_out - sum_in if field == 'rx' else sum_in - sum_out
        return max(val, 0.0)

    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            candidates = [cand_tx, cand_rx]
            has_synth = False

            # Residual Synthesis: If link appears dead, check if verifiable routers imply a flow
            if cand_tx < MIN_ACTIVITY and cand_rx < MIN_ACTIVITY:
                synth_tx = get_residual_val(rid_local, if_id, 'tx')
                if synth_tx is not None and synth_tx > MIN_ACTIVITY:
                    candidates.append(synth_tx)
                    has_synth = True

                synth_rx = get_residual_val(rid_remote, peer_id, 'rx')
                if synth_rx is not None and synth_rx > MIN_ACTIVITY:
                    candidates.append(synth_rx)
                    has_synth = True

            # Deduplicate candidates
            unique_cands = []
            for c in candidates:
                if not any(abs(c - x) < 1e-4 for x in unique_cands):
                    unique_cands.append(c)

            # Decision Logic
            best_val = cand_tx
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)

            # If we have synthetic candidates or disagreement, we vote. Otherwise average.
            if not has_synth and diff < max(mag * TOLERANCE, MIN_ACTIVITY):
                best_val = (cand_tx + cand_rx) / 2.0
            else:
                best_score = float('inf')

                for cand in unique_cands:
                    err_local = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    def get_score(err):
                        if err is None: return 0.05
                        return min(err, 1.0)

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize zero if we have a better active alternative
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
=======
    # --- 3. Rate Repair (Iterative Consensus) ---

    def calc_flow_error(rid, if_target, field, value):
        """Calculates flow error for a router given a hypothetical value for one interface."""
        if rid not in verifiable_routers:
            return None

        sum_rx = 0.0
        sum_tx = 0.0

        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']

            # Substitute hypothetical value
            if iface == if_target:
                if field == 'rx': r = value
                else: t = value

            sum_rx += r
            sum_tx += t

        diff = abs(sum_rx - sum_tx)
        denom = max(sum_rx, sum_tx, 1.0)
        return diff / denom

    def get_residual_val(rid, if_target, field):
        """Calculates value required to perfectly balance a verifiable router."""
        if rid not in verifiable_routers: return None

        sum_in, sum_out = 0.0, 0.0
        for iface in router_interfaces[rid]:
            r = state[iface]['rx']
            t = state[iface]['tx']
            # Exclude the specific component we are solving for
            if iface == if_target:
                if field == 'rx': r = 0.0
                else: t = 0.0
            sum_in += r
            sum_out += t

        # Balance: In = Out
        val = sum_out - sum_in if field == 'rx' else sum_in - sum_out
        return max(val, 0.0)

    # Run 3 passes to allow corrections to propagate
    for _ in range(3):
        for if_id, s in state.items():
            if s['status'] == 'down': continue

            peer_id = s['connected_to']
            if not peer_id or peer_id not in state:
                continue

            # Consensus for the link: Local Tx -> Remote Rx
            cand_tx = s['tx']
            cand_rx = state[peer_id]['rx']

            rid_local = s['local_router']
            rid_remote = state[peer_id]['local_router']

            candidates = [cand_tx, cand_rx]

            # Check for disagreement or potential dead counters
            diff = abs(cand_tx - cand_rx)
            mag = max(cand_tx, cand_rx, 1.0)
            disagreement = diff > max(mag * TOLERANCE, MIN_ACTIVITY)

            # Expanded Residual Synthesis:
            # If there is disagreement OR if both look dead (potential double failure),
            # check if verifiable routers suggest a specific value.
            if disagreement or (cand_tx < MIN_ACTIVITY and cand_rx < MIN_ACTIVITY):
                synth_tx = get_residual_val(rid_local, if_id, 'tx')
                if synth_tx is not None:
                    candidates.append(synth_tx)

                synth_rx = get_residual_val(rid_remote, peer_id, 'rx')
                if synth_rx is not None:
                    candidates.append(synth_rx)

            # Deduplicate candidates
            unique_cands = []
            for c in candidates:
                if c < 0: continue # residual might be negative if flow is broken elsewhere
                if not any(abs(c - x) < 1e-4 for x in unique_cands):
                    unique_cands.append(c)

            # Decision Logic
            best_val = cand_tx

            # If no disagreement and no synth needed, just average
            if not disagreement and len(unique_cands) <= 2:
                 best_val = (cand_tx + cand_rx) / 2.0
            else:
                best_score = float('inf')

                for cand in unique_cands:
                    err_local = calc_flow_error(rid_local, if_id, 'tx', cand)
                    err_remote = calc_flow_error(rid_remote, peer_id, 'rx', cand)

                    # Enhanced Scoring:
                    # Prefer "Verified Good" (err < TOL) over "Unverified" (err is None)
                    # over "Verified Bad" (err > TOL).
                    def get_score(err):
                        if err is None: return 0.02 # Unverified: small penalty
                        if err < FLOW_TOLERANCE: return 0.0 # Verified: no penalty
                        return min(err, 1.0) # Invalid: penalty = error magnitude

                    score = get_score(err_local) + get_score(err_remote)

                    # Heuristic: Penalize zero if we have a better active alternative
                    # But don't penalize if zero is the verified residual!
                    if cand < MIN_ACTIVITY and max(unique_cands) > MIN_ACTIVITY:
                        # Only penalize if it's NOT a verified zero
                        is_verified_zero = False
                        if err_local is not None and err_local < FLOW_TOLERANCE: is_verified_zero = True
                        if err_remote is not None and err_remote < FLOW_TOLERANCE: is_verified_zero = True

                        if not is_verified_zero:
                            score += 0.5

                    if score < best_score:
                        best_score = score
                        best_val = cand

            state[if_id]['tx'] = best_val
            state[peer_id]['rx'] = best_val
>>>>>>> REPLACE
<<<<<<< SEARCH
        def get_rate_confidence(orig, final, field):
            # 1. Verification Logic
            local_err = final_errors.get(rid)
            local_verified = (local_err is not None and local_err < FLOW_TOLERANCE)

            remote_verified = False
            rem_rid = data.get('remote_router')
            if rem_rid and rem_rid in final_errors:
                 if final_errors[rem_rid] < FLOW_TOLERANCE:
                     remote_verified = True

            # Peer Consistency
            peer_consistent = True
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 2. Change Analysis
            changed = abs(orig - final) > 0.001
            smoothed = changed and (abs(orig - final) < max(orig * 0.05, 0.1))

            # --- Scoring ---
            if not changed:
                # Value retained
                if local_verified and remote_verified: return 1.0
                if local_verified: return 0.98
                if not peer_consistent: return 0.7
                if remote_verified: return 0.95

                # Check for Broken Router (Unverified AND High Error)
                if local_err is not None and local_err >= FLOW_TOLERANCE:
                    return 0.6

                return 0.9

            if smoothed:
                return 0.95

            # Significant Repair
            if local_verified and remote_verified: return 0.98
            if local_verified: return 0.95
            if remote_verified: return 0.90

            # Unverified Heuristics
            if orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                return 0.85 # Fixed dead counter

            return 0.6 # Fallback
=======
        def get_rate_confidence(orig, final, field):
            # 1. Verification Logic
            local_err = final_errors.get(rid)
            local_verified = (local_err is not None and local_err < FLOW_TOLERANCE)

            remote_verified = False
            rem_rid = data.get('remote_router')
            if rem_rid and rem_rid in final_errors:
                 if final_errors[rem_rid] < FLOW_TOLERANCE:
                     remote_verified = True

            # Peer Consistency
            peer_consistent = True
            if peer_id and peer_id in state:
                peer_val = state[peer_id]['tx'] if field == 'rx' else state[peer_id]['rx']
                if abs(final - peer_val) > max(final, peer_val, 1.0) * TOLERANCE:
                    peer_consistent = False

            # 2. Change Analysis
            changed = abs(orig - final) > 0.001
            smoothed = changed and (abs(orig - final) < max(orig * 0.05, 0.1))

            # --- Scoring ---
            conf = 0.6 # Default base

            if not changed:
                # Value retained
                if local_verified and remote_verified: conf = 1.0
                elif local_verified: conf = 0.98
                elif remote_verified: conf = 0.95
                elif not peer_consistent: conf = 0.7
                else: conf = 0.9 # Unverified but consistent
            elif smoothed:
                # Smoothing (noise reduction)
                conf = 0.95
            else:
                # Significant Repair
                if local_verified and remote_verified: conf = 0.98
                elif local_verified: conf = 0.95
                elif remote_verified: conf = 0.90
                elif orig < MIN_ACTIVITY and final > MIN_ACTIVITY:
                     conf = 0.85 # Fixed dead counter
                else:
                     conf = 0.6 # Unverified guess

            # Global Consistency Penalty
            # If the router is demonstrably broken (high flow error), reduce confidence
            if local_err is not None and local_err >= FLOW_TOLERANCE:
                # If verified remotely, we trust it somewhat, but local error is worrying
                # If unverified, we trust it less
                penalty = min(local_err, 0.5)
                conf *= (1.0 - penalty)

            return conf
>>>>>>> REPLACE
</DIFF>