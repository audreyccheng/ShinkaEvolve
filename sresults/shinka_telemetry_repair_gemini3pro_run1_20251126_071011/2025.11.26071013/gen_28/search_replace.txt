<NAME>
bilateral_flow_consensus
</NAME>

<DESCRIPTION>
Introduces a Bilateral Flow Consensus algorithm that improves repair accuracy and confidence calibration.
1.  **Topology Awareness**: Explicitly detects fully monitored routers. Flow hints are only generated for routers where all interfaces are observed, preventing false hints from unmonitored links.
2.  **Bilateral Verification**: When symmetry is broken, the algorithm checks consistency against *both* the local router's flow balance (Local Hint) and the remote router's flow balance (Peer Hint). It prioritizes the value that is consistent with its respective router.
3.  **Continuous Confidence Calibration**: Replaces the discrete confidence logic with a continuous decay function (1.0 - 2.5*error), providing a smoother and more accurate confidence score proportional to the residual error.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router')
        }

    # --- Phase 2: Iterative Constraint Satisfaction ---
    # We iterate to allow corrections (e.g., fixing a bad link) to propagate
    # to the Flow Hints of neighbors.

    for _ in range(ITERATIONS):
        next_rates = {}

        # 1. Calculate Router Balances (Flow Hints) based on CURRENT beliefs
        router_balances = {} # router_id -> {'rx': float, 'tx': float}

        for r_id, ifaces in topology.items():
            sum_rx = 0.0
            sum_tx = 0.0
            for i in ifaces:
                if i in state:
                    sum_rx += state[i]['rx']
                    sum_tx += state[i]['tx']
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        # 2. Evaluate each interface
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_rates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state
            r_id = curr.get('local_router')

            # Helper to resolve a rate (RX or TX)
            def resolve_rate(local_val, peer_val, is_rx):
                # Calculate Flow Hint for this specific direction
                # Hint = Target_Total - (Current_Total - My_Val)
                val_hint = local_val # Default
                if r_id and r_id in router_balances:
                    rb = router_balances[r_id]
                    if is_rx:
                        # RX must match Total TX
                        val_hint = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        # TX must match Total RX
                        val_hint = max(0.0, rb['rx'] - (rb['tx'] - local_val))

                # Decision Logic

                # 1. Check Symmetry (Strongest signal)
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    # Symmetry holds: Reinforce by averaging
                    return (local_val + peer_val) / 2.0

                # 2. Symmetry Broken: Check for "Double Dead" scenario
                # If both sides are near zero, but Physics says there should be flow.
                if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                    if val_hint > 5.0: # Significant missing flow detected
                        return val_hint
                    return 0.0

                # 3. Standard Broken Symmetry: Use Hint as arbiter
                denom_l = max(local_val, val_hint, 1.0)
                dist_l = abs(local_val - val_hint) / denom_l

                denom_p = max(peer_val, val_hint, 1.0)
                dist_p = abs(peer_val - val_hint) / denom_p

                if dist_l < dist_p:
                    return local_val
                else:
                    return peer_val

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_rate(curr['rx'], peer_tx, is_rx=True)

            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_rate(curr['tx'], peer_rx, is_rx=False)

            next_rates[iface_id] = {'rx': next_rx, 'tx': next_tx}
=======
        state[iface_id] = {
            'rx': cur_rx,
            'tx': cur_tx,
            'status': status,
            'status_conf': status_conf,
            'orig_rx': raw_rx,
            'orig_tx': raw_tx,
            'orig_status': raw_status,
            'peer_id': peer_id,
            'local_router': data.get('local_router'),
            'remote_router': data.get('remote_router')
        }

    # --- Phase 2: Iterative Constraint Satisfaction ---

    # Pre-computation: Identify fully monitored routers
    # We can only strictly enforce flow conservation on routers where we see all interfaces.
    fully_monitored_routers = set()
    for r_id, ifaces in topology.items():
        if all(i in telemetry for i in ifaces):
            fully_monitored_routers.add(r_id)

    for _ in range(ITERATIONS):
        next_rates = {}

        # 1. Calculate Router Balances (Flow Hints) based on CURRENT beliefs
        # Only for fully monitored routers to avoid garbage hints
        router_balances = {}

        for r_id in fully_monitored_routers:
            ifaces = topology[r_id]
            sum_rx = sum(state[i]['rx'] for i in ifaces if i in state)
            sum_tx = sum(state[i]['tx'] for i in ifaces if i in state)
            router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

        # 2. Evaluate each interface
        for iface_id, curr in state.items():
            if curr['status'] == 'down':
                next_rates[iface_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = curr['peer_id']
            has_peer = peer_id and peer_id in state
            local_r_id = curr.get('local_router')
            remote_r_id = curr.get('remote_router')

            # Helper to resolve a rate (RX or TX)
            def resolve_rate(local_val, peer_val, is_rx):

                # --- A. Get Hints ---
                # Local Hint
                local_hint = None
                if local_r_id and local_r_id in router_balances:
                    rb = router_balances[local_r_id]
                    if is_rx:
                        local_hint = max(0.0, rb['tx'] - (rb['rx'] - local_val))
                    else:
                        local_hint = max(0.0, rb['rx'] - (rb['tx'] - local_val))

                # Peer Hint (Check consistency of peer value against its own router)
                # Note: peer_val is the value coming FROM the peer.
                # If is_rx=True (Local RX), peer_val is Peer TX. Peer TX should match Peer RX sums.
                peer_hint = None
                if remote_r_id and remote_r_id in router_balances:
                    rb_p = router_balances[remote_r_id]
                    if is_rx:
                        # Peer Val is Peer TX. Hint is Peer TX needed to balance Peer RX.
                        peer_hint = max(0.0, rb_p['rx'] - (rb_p['tx'] - peer_val))
                    else:
                        # Peer Val is Peer RX. Hint is Peer RX needed to balance Peer TX.
                        peer_hint = max(0.0, rb_p['tx'] - (rb_p['rx'] - peer_val))

                # --- B. Decision Logic ---

                # 1. Symmetry Check
                denom_sym = max(local_val, peer_val, 1.0)
                diff_sym = abs(local_val - peer_val) / denom_sym

                if diff_sym <= HARDENING_THRESHOLD:
                    return (local_val + peer_val) / 2.0

                # 2. Double Dead Check
                if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
                    if local_hint is not None and local_hint > 5.0:
                        return local_hint
                    if peer_hint is not None and peer_hint > 5.0:
                        return peer_hint
                    return 0.0

                # 3. Bilateral Consistency Check
                # Calculate consistency scores (Lower is better)
                score_local = float('inf')
                if local_hint is not None:
                    denom = max(local_val, local_hint, 1.0)
                    score_local = abs(local_val - local_hint) / denom

                score_peer = float('inf')
                if peer_hint is not None:
                    denom = max(peer_val, peer_hint, 1.0)
                    score_peer = abs(peer_val - peer_hint) / denom

                # Compare scores
                if score_local < 0.1 and score_peer < 0.1:
                    if score_local < score_peer:
                        return local_val
                    else:
                        return peer_val

                if score_local < score_peer:
                    return local_val
                elif score_peer < score_local:
                    return peer_val
                else:
                    return local_val

            # Resolve RX (Target: Peer TX)
            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
            next_rx = resolve_rate(curr['rx'], peer_tx, is_rx=True)

            # Resolve TX (Target: Peer RX)
            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
            next_tx = resolve_rate(curr['tx'], peer_rx, is_rx=False)

            next_rates[iface_id] = {'rx': next_rx, 'tx': next_tx}
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Phase 3: Final Confidence Calibration ---
    result = {}

    # Recalculate final router sums for accurate calibration
    final_balances = {}
    for r_id, ifaces in topology.items():
        sum_rx = sum(state[i]['rx'] for i in ifaces if i in state)
        sum_tx = sum(state[i]['tx'] for i in ifaces if i in state)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state

        # Calibration Function
        def get_confidence(val, peer_val, hint_val, status_conf, is_down):
            if is_down:
                # If we suppressed real traffic, reduce confidence
                if val > TRAFFIC_THRESHOLD:
                    return status_conf
                return status_conf

            # Calculate Residuals (Errors)
            err_sym = 0.0
            if has_peer:
                denom = max(val, peer_val, 1.0)
                err_sym = abs(val - peer_val) / denom

            err_flow = 0.0
            if hint_val is not None:
                denom = max(val, hint_val, 1.0)
                err_flow = abs(val - hint_val) / denom
            else:
                # Without flow hint, we rely solely on symmetry
                err_flow = err_sym

            # Confidence Score:
            # High if we match EITHER Symmetry OR Flow Hint perfectly.
            # Penalized if the one we didn't match is wildly different (contradiction).

            primary_support = min(err_sym, err_flow)
            secondary_conflict = max(err_sym, err_flow)

            # Base score derived from best supporting evidence
            score = 1.0 - primary_support

            # Penalty for contradiction (if evidence conflicts)
            # We weight this lower because one sensor being wrong is the expected fault case
            score -= (0.2 * secondary_conflict)

            return max(0.0, score)

        # Get Hints for final verification
        r_id = data['local_router']
        hint_rx = None
        hint_tx = None
        if r_id and r_id in final_balances:
            rb = final_balances[r_id]
            hint_rx = max(0.0, rb['tx'] - (rb['rx'] - final_rx))
            hint_tx = max(0.0, rb['rx'] - (rb['tx'] - final_tx))

        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        conf_rx = get_confidence(final_rx, peer_tx, hint_rx, data['status_conf'], data['status'] == 'down')
        conf_tx = get_confidence(final_tx, peer_rx, hint_tx, data['status_conf'], data['status'] == 'down')
=======
    # --- Phase 3: Final Confidence Calibration ---
    result = {}

    # Recalculate final router sums for accurate calibration
    final_balances = {}
    for r_id in fully_monitored_routers:
        ifaces = topology[r_id]
        sum_rx = sum(state[i]['rx'] for i in ifaces if i in state)
        sum_tx = sum(state[i]['tx'] for i in ifaces if i in state)
        final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}

    for iface_id, data in state.items():
        final_rx = data['rx']
        final_tx = data['tx']
        peer_id = data['peer_id']
        has_peer = peer_id and peer_id in state

        # Calibration Function
        def get_confidence(val, peer_val, hint_val, status_conf, is_down):
            if is_down:
                return status_conf

            # Calculate Residuals (Errors)
            err_sym = 0.0
            if has_peer:
                denom = max(val, peer_val, 1.0)
                err_sym = abs(val - peer_val) / denom

            err_flow = None
            if hint_val is not None:
                denom = max(val, hint_val, 1.0)
                err_flow = abs(val - hint_val) / denom

            # Calibration Logic
            # Determine Best Support
            support_err = err_sym
            if err_flow is not None:
                support_err = min(err_sym, err_flow)

            # Base Score: 1.0 - 2.5 * error
            base_score = max(0.0, 1.0 - (2.5 * support_err))

            # Contradiction Penalty
            if err_flow is not None:
                conflict = max(err_sym, err_flow)
                if conflict > 0.2 and support_err > 0.1:
                     # Both are kinda bad.
                     base_score *= 0.8

            return base_score * status_conf

        # Get Hints for final verification
        r_id = data['local_router']
        hint_rx = None
        hint_tx = None
        if r_id and r_id in final_balances:
            rb = final_balances[r_id]
            hint_rx = max(0.0, rb['tx'] - (rb['rx'] - final_rx))
            hint_tx = max(0.0, rb['rx'] - (rb['tx'] - final_tx))

        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
        peer_rx = state[peer_id]['rx'] if has_peer else final_tx

        conf_rx = get_confidence(final_rx, peer_tx, hint_rx, data['status_conf'], data['status'] == 'down')
        conf_tx = get_confidence(final_tx, peer_rx, hint_tx, data['status_conf'], data['status'] == 'down')
>>>>>>> REPLACE
</DIFF>