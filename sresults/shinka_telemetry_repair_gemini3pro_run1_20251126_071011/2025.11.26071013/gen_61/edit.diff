--- a/original.py
+++ b/original.py
@@ -1,292 +1,354 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm using Adaptive Flow Imputation.
 Detects valid traffic flow through conservation laws even when link sensors fail completely.
 Uses iterative constraint solving with continuous confidence calibration.
 """
 from typing import Dict, Any, Tuple, List
 import math
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
 
-    # --- Configuration Parameters ---
-    HARDENING_THRESHOLD = 0.02   # 2% tolerance for measurement timing/jitter
-    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps threshold for "active" link detection
-    ITERATIONS = 5               # Sufficient passes for network-wide propagation
-    CONFIDENCE_DECAY = 5.0       # k-factor for exp(-k*err) confidence curve
-    IMPUTATION_CONFIDENCE = 0.85 # Base confidence for synthesized (double-dead) values
-
-    # --- Phase 1: Initialization & Status Inference ---
-    # Construct belief state, prioritizing traffic evidence over status flags.
+    # Constants
+    HARDENING_THRESHOLD = 0.02   # 2% tolerance
+    TRAFFIC_THRESHOLD = 1.0      # 1 Mbps active threshold
+    ITERATIONS = 5               # Refinement passes
+
+    # --- Phase 1: Initialization & Status Repair ---
     state = {}
 
     for iface_id, data in telemetry.items():
         raw_rx = data.get('rx_rate', 0.0)
         raw_tx = data.get('tx_rate', 0.0)
         raw_status = data.get('interface_status', 'unknown')
 
         peer_id = data.get('connected_to')
         peer_data = telemetry.get(peer_id) if (peer_id and peer_id in telemetry) else {}
 
-        # 1. Infer Effective Status
-        # Traffic on *either* side of the link is evidence of life.
-        traffic_signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
-        max_traffic = max(traffic_signals) if traffic_signals else 0.0
-
-        eff_status = raw_status
+        # Traffic Evidence
+        signals = [raw_rx, raw_tx, peer_data.get('rx_rate', 0.0), peer_data.get('tx_rate', 0.0)]
+        max_traffic = max(signals) if signals else 0.0
+
+        # Status Inference
+        status = raw_status
         status_conf = 1.0
 
         if max_traffic > TRAFFIC_THRESHOLD:
             if raw_status != 'up':
-                eff_status = 'up'
-                status_conf = 0.95 # Flag was wrong
+                status = 'up'
+                status_conf = 0.95
         elif raw_status == 'up' and peer_data.get('interface_status') == 'down':
-             # I say UP, peer says DOWN, and no traffic -> Assume DOWN
-             eff_status = 'down'
-             status_conf = 0.8
-
-        # 2. Initialize Rates
-        # If status is DOWN, force 0. Else start with raw values.
-        if eff_status == 'down':
-            curr_rx, curr_tx = 0.0, 0.0
+            status = 'down'
+            status_conf = 0.8
+
+        # Initial Rate Beliefs
+        if status == 'down':
+            cur_rx, cur_tx = 0.0, 0.0
         else:
-            curr_rx = raw_rx if raw_rx > TRAFFIC_THRESHOLD else 0.0
-            curr_tx = raw_tx if raw_tx > TRAFFIC_THRESHOLD else 0.0
+            cur_rx = raw_rx if raw_rx > 0 else 0.0
+            cur_tx = raw_tx if raw_tx > 0 else 0.0
 
         state[iface_id] = {
-            'rx': curr_rx,
-            'tx': curr_tx,
-            'status': eff_status,
+            'rx': cur_rx,
+            'tx': cur_tx,
+            'status': status,
             'status_conf': status_conf,
             'orig_rx': raw_rx,
             'orig_tx': raw_tx,
             'orig_status': raw_status,
             'peer_id': peer_id,
             'local_router': data.get('local_router'),
-            'imp_rx': False,
-            'imp_tx': False
+            'remote_router': data.get('remote_router')
         }
 
-    # --- Phase 2: Iterative Constraint Satisfaction ---
-    # We iteratively refine rates to satisfy Flow Conservation and Link Symmetry.
-
-    # Identify routers where we have full visibility
+    # --- Phase 2: Iterative Consensus ---
+
+    # Identify Verifiable Routers (Fully Monitored)
+    # A router is verifiable if all its interfaces are present in the telemetry/state.
     verifiable_routers = set()
     for r_id, ifaces in topology.items():
-        if all(i in telemetry for i in ifaces):
+        # Check if all interfaces in topology are known in our state
+        if all(i in state for i in ifaces):
             verifiable_routers.add(r_id)
 
     for _ in range(ITERATIONS):
         next_state = {}
 
-        # Calculate Router Balances (Flow Hints) based on current beliefs
+        # Calculate Flow Balances for Verifiable Routers
         router_balances = {}
         for r_id in verifiable_routers:
             ifaces = topology[r_id]
             sum_rx = sum(state[i]['rx'] for i in ifaces)
             sum_tx = sum(state[i]['tx'] for i in ifaces)
             router_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}
 
         for iface_id, curr in state.items():
             if curr['status'] == 'down':
-                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0, 'imp_rx': False, 'imp_tx': False}
+                next_state[iface_id] = {'rx': 0.0, 'tx': 0.0}
                 continue
 
             peer_id = curr['peer_id']
             has_peer = peer_id and peer_id in state
-            r_id = curr.get('local_router')
-
-            # Sub-function to resolve a specific direction (RX or TX)
+
+            # --- Logic to Resolve One Direction ---
             def resolve_direction(local_val, peer_val, is_rx):
-                # A. Get Flow Hint (if available)
-                hint = None
+                # We are solving for the true rate of the link in this direction.
+                # Candidates: local_val, peer_val.
+                # Constraints: Local Router Balance, Remote Router Balance.
+
+                hints = []
+
+                # 1. Local Hint
+                r_id = curr.get('local_router')
                 if r_id and r_id in router_balances:
                     rb = router_balances[r_id]
                     if is_rx:
-                        # RX should match Total TX - (Other RX)
-                        hint = max(0.0, rb['tx'] - (rb['rx'] - local_val))
+                        # RX must match Total TX
+                        h = max(0.0, rb['tx'] - (rb['rx'] - local_val))
+                        hints.append(h)
                     else:
-                        hint = max(0.0, rb['rx'] - (rb['tx'] - local_val))
-
-                # B. Symmetry Logic
-                denom_sym = max(local_val, peer_val, 1.0)
-                diff_sym = abs(local_val - peer_val) / denom_sym
-
-                # Case 1: Symmetry holds (Agreement)
+                        # TX must match Total RX
+                        h = max(0.0, rb['rx'] - (rb['tx'] - local_val))
+                        hints.append(h)
+
+                # 2. Remote Hint (Dual-Sided)
+                # If we are RX, peer is TX. Remote router balance constrains peer TX.
+                rr_id = curr.get('remote_router')
+                if rr_id and rr_id in router_balances:
+                    rb_r = router_balances[rr_id]
+                    if is_rx:
+                        # Link is My_RX / Peer_TX.
+                        # Remote router (Peer's router) sees this as OUT (TX).
+                        # Peer_TX = Remote_RX_Total - (Remote_TX_Total - Peer_TX)
+                        h = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_val))
+                        hints.append(h)
+                    else:
+                        # Link is My_TX / Peer_RX.
+                        # Remote router sees this as IN (RX).
+                        # Peer_RX = Remote_TX_Total - (Remote_RX_Total - Peer_RX)
+                        h = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_val))
+                        hints.append(h)
+
+                # Consensus Target from Hints
+                target = None
+                if hints:
+                    target = sum(hints) / len(hints)
+
+                # Decision Logic
+
+                # A. Symmetry Check
+                denom = max(local_val, peer_val, 1.0)
+                diff_sym = abs(local_val - peer_val) / denom
+
                 if diff_sym <= HARDENING_THRESHOLD:
-                    # Check for "Double Dead" masking a real flow
-                    # If both 0, but hint says > 10 Mbps, trust hint.
+                    # Symmetry holds.
+                    avg = (local_val + peer_val) / 2.0
+
+                    # Double Dead Check with Hint
+                    if target is not None and avg < TRAFFIC_THRESHOLD and target > 5.0:
+                         return target
+                    return avg
+
+                # B. Symmetry Broken
+                if target is not None:
+                    # We have a trusted target from Flow Conservation.
+
+                    # Double Dead Check
                     if local_val < TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
-                        if hint is not None and hint > 10.0:
-                            return hint, True # Imputed
-                    return (local_val + peer_val) / 2.0, False
-
-                # Case 2: Symmetry Broken
-                # If we have no hint, we can't objectively decide.
-                if hint is None:
-                    # Heuristic: If one is 0 and other is substantial, take substantial
-                    if local_val < TRAFFIC_THRESHOLD and peer_val > TRAFFIC_THRESHOLD:
-                        return peer_val, False
-                    if peer_val < TRAFFIC_THRESHOLD and local_val > TRAFFIC_THRESHOLD:
-                        return local_val, False
-                    # Fallback: Trust Local
-                    return local_val, False
-
-                # We have a hint: Use it as arbiter
-                denom_l = max(local_val, hint, 1.0)
-                err_l = abs(local_val - hint) / denom_l
-
-                denom_p = max(peer_val, hint, 1.0)
-                err_p = abs(peer_val - hint) / denom_p
-
-                if err_l < err_p:
-                    return local_val, False
+                         if target > 5.0: return target
+                         return 0.0
+
+                    # Pick candidate closer to Target
+                    denom_l = max(local_val, target, 1.0)
+                    err_l = abs(local_val - target) / denom_l
+
+                    denom_p = max(peer_val, target, 1.0)
+                    err_p = abs(peer_val - target) / denom_p
+
+                    if err_l < err_p:
+                        return local_val
+                    else:
+                        return peer_val
+
                 else:
-                    return peer_val, False
-
-            # Resolve RX (Target Peer TX)
-            tgt_peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
-            nxt_rx, imp_rx = resolve_direction(curr['rx'], tgt_peer_tx, is_rx=True)
-
-            # Resolve TX (Target Peer RX)
-            tgt_peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
-            nxt_tx, imp_tx = resolve_direction(curr['tx'], tgt_peer_rx, is_rx=False)
-
-            next_state[iface_id] = {'rx': nxt_rx, 'tx': nxt_tx, 'imp_rx': imp_rx, 'imp_tx': imp_tx}
-
-        # Apply updates synchronously
-        for i, vals in next_state.items():
-            state[i]['rx'] = vals['rx']
-            state[i]['tx'] = vals['tx']
-            state[i]['imp_rx'] = vals['imp_rx']
-            state[i]['imp_tx'] = vals['imp_tx']
-
-    # --- Phase 3: Final Calibration & Output ---
+                    # C. No Hint + Broken Symmetry (Partial Topology or multiple failures)
+                    # Use Heuristic: Trust Non-Zero (assuming counters undercount/drop/fail to 0)
+                    if local_val > TRAFFIC_THRESHOLD and peer_val < TRAFFIC_THRESHOLD:
+                        return local_val
+                    if peer_val > TRAFFIC_THRESHOLD and local_val < TRAFFIC_THRESHOLD:
+                        return peer_val
+
+                    # If both non-zero but different, average (reduce variance)
+                    return (local_val + peer_val) / 2.0
+
+            # Resolve RX
+            peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
+            next_rx = resolve_direction(curr['rx'], peer_tx, is_rx=True)
+
+            # Resolve TX
+            peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
+            next_tx = resolve_direction(curr['tx'], peer_rx, is_rx=False)
+
+            next_state[iface_id] = {'rx': next_rx, 'tx': next_tx}
+
+        # Apply Updates
+        for i_id, vals in next_state.items():
+            state[i_id]['rx'] = vals['rx']
+            state[i_id]['tx'] = vals['tx']
+
+    # --- Phase 3: Final Calibration ---
     result = {}
 
-    # Final Flow Balance Calculation for confidence scoring
+    # Final Balances
     final_balances = {}
     for r_id in verifiable_routers:
         ifaces = topology[r_id]
         sum_rx = sum(state[i]['rx'] for i in ifaces)
         sum_tx = sum(state[i]['tx'] for i in ifaces)
         final_balances[r_id] = {'rx': sum_rx, 'tx': sum_tx}
 
-    for iface_id, curr in state.items():
-        if curr['status'] == 'down':
-             # inherit confidence from status determination
-             c_rx = curr['status_conf'] if curr['orig_rx'] > TRAFFIC_THRESHOLD else 1.0
-             c_tx = curr['status_conf'] if curr['orig_tx'] > TRAFFIC_THRESHOLD else 1.0
-
-             result[iface_id] = {
-                'rx_rate': (curr['orig_rx'], 0.0, c_rx),
-                'tx_rate': (curr['orig_tx'], 0.0, c_tx),
-                'interface_status': (curr['orig_status'], 'down', curr['status_conf']),
-                'connected_to': curr['peer_id'],
-                'local_router': curr['local_router'],
-                'remote_router': telemetry[iface_id].get('remote_router')
-             }
-             continue
-
-        # Calculate Confidence for Active Links
-        peer_id = curr['peer_id']
+    for iface_id, data in state.items():
+        final_rx = data['rx']
+        final_tx = data['tx']
+        peer_id = data['peer_id']
         has_peer = peer_id and peer_id in state
-        r_id = curr.get('local_router')
-
-        def calculate_confidence(val, peer_val, is_rx):
-            is_imputed = curr.get('imp_rx' if is_rx else 'imp_tx', False)
-            if is_imputed:
-                return IMPUTATION_CONFIDENCE
+
+        # Calibration Helper
+        def calibrate(val, peer_val, local_hint, remote_hint, is_down, stat_conf):
+            if is_down:
+                return stat_conf if val > TRAFFIC_THRESHOLD else stat_conf
 
             # 1. Symmetry Error
-            denom_s = max(val, peer_val, 1.0)
-            err_sym = abs(val - peer_val) / denom_s
-            if not has_peer: err_sym = 0.0
-
-            # 2. Flow Error
-            err_flow = 1.0 # Default high error
-            if r_id and r_id in final_balances:
-                rb = final_balances[r_id]
-                hint = max(0.0, rb['tx'] - (rb['rx'] - val)) if is_rx else max(0.0, rb['rx'] - (rb['tx'] - val))
-                denom_f = max(val, hint, 1.0)
-                err_flow = abs(val - hint) / denom_f
-
-            best_error = min(err_sym, err_flow)
-
-            # Continuous Calibration
-            conf = math.exp(-CONFIDENCE_DECAY * best_error)
-
-            # Penalty for contradiction
-            if best_error == err_flow and err_sym > 0.2:
-                conf *= 0.9
-
-            return max(0.0, min(1.0, conf))
-
-        peer_tx = state[peer_id]['tx'] if has_peer else curr['rx']
-        c_rx = calculate_confidence(curr['rx'], peer_tx, is_rx=True)
-
-        peer_rx = state[peer_id]['rx'] if has_peer else curr['tx']
-        c_tx = calculate_confidence(curr['tx'], peer_rx, is_rx=False)
+            err_sym = 0.0
+            if has_peer:
+                denom = max(val, peer_val, 1.0)
+                err_sym = abs(val - peer_val) / denom
+
+            # 2. Flow Error (Best matching hint)
+            err_flow = None
+            hints = []
+            if local_hint is not None: hints.append(local_hint)
+            if remote_hint is not None: hints.append(remote_hint)
+
+            if hints:
+                target = sum(hints) / len(hints)
+                denom = max(val, target, 1.0)
+                err_flow = abs(val - target) / denom
+
+            # Tiered Confidence Assignment
+
+            # Case A: Strong Corroboration (Flow matches Result)
+            if err_flow is not None and err_flow < 0.05:
+                # If Symmetry also matches, Perfect.
+                if err_sym < 0.05:
+                    return 1.0
+                # If Symmetry broken, we fixed it using Flow. High confidence.
+                return 0.90
+
+            # Case B: Symmetry Holds (No Flow Hint or Flow matches)
+            if err_sym < 0.05:
+                if err_flow is None:
+                    # Verified by peer only. Good but not perfect.
+                    return 0.95
+                else:
+                    # Symmetry holds, but Flow disagrees? (err_flow > 0.05)
+                    # This means we ignored flow? Or flow is impossible?
+                    return 0.75
+
+            # Case C: No Verification (Broken Symmetry, No Flow Hint)
+            if err_flow is None:
+                # We guessed based on heuristic.
+                return 0.50
+
+            # Case D: Conflict (Broken Symmetry, Broken Flow)
+            # We picked something, but it matches nothing well.
+            return 0.30
+
+        # Get Final Hints
+        local_hint_rx, local_hint_tx = None, None
+        r_id = data['local_router']
+        if r_id in final_balances:
+            rb = final_balances[r_id]
+            local_hint_rx = max(0.0, rb['tx'] - (rb['rx'] - final_rx))
+            local_hint_tx = max(0.0, rb['rx'] - (rb['tx'] - final_tx))
+
+        remote_hint_rx, remote_hint_tx = None, None
+        rr_id = data['remote_router']
+        if rr_id in final_balances:
+            rb_r = final_balances[rr_id]
+            # Link RX = Remote Out (TX). Hint based on Remote In.
+            peer_tx_val = state[peer_id]['tx'] if has_peer else final_rx
+            remote_hint_rx = max(0.0, rb_r['rx'] - (rb_r['tx'] - peer_tx_val))
+
+            # Link TX = Remote In (RX). Hint based on Remote Out.
+            peer_rx_val = state[peer_id]['rx'] if has_peer else final_tx
+            remote_hint_tx = max(0.0, rb_r['tx'] - (rb_r['rx'] - peer_rx_val))
+
+        peer_tx = state[peer_id]['tx'] if has_peer else final_rx
+        peer_rx = state[peer_id]['rx'] if has_peer else final_tx
+
+        conf_rx = calibrate(final_rx, peer_tx, local_hint_rx, remote_hint_rx, data['status']=='down', data['status_conf'])
+        conf_tx = calibrate(final_tx, peer_rx, local_hint_tx, remote_hint_tx, data['status']=='down', data['status_conf'])
 
         result[iface_id] = {
-            'rx_rate': (curr['orig_rx'], curr['rx'], c_rx),
-            'tx_rate': (curr['orig_tx'], curr['tx'], c_tx),
-            'interface_status': (curr['orig_status'], curr['status'], curr['status_conf']),
-            'connected_to': curr['peer_id'],
-            'local_router': curr['local_router'],
-            'remote_router': telemetry[iface_id].get('remote_router')
+            'rx_rate': (data['orig_rx'], final_rx, conf_rx),
+            'tx_rate': (data['orig_tx'], final_tx, conf_tx),
+            'interface_status': (data['orig_status'], data['status'], data['status_conf']),
+            'connected_to': peer_id,
+            'local_router': r_id,
+            'remote_router': data['remote_router']
         }
 
     return result
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")
