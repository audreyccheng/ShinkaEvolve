<NAME>
bias_gating_tuning_and_router_budget_trim
</NAME>

<DESCRIPTION>
I propose targeted tweaks to improve counter repair accuracy while preserving confidence calibration:

1) Make the Stage 0 pair-bias multiplicative harmonization safer. In prior runs, this pre-scaling can over-correct, slightly degrading counter accuracy. I tighten its gating so it only applies when both directions on a link are clear violations (diffs exceed 1.6×tol for low rates or 1.2×tol otherwise) and reduce its adjustment intensity with a new BETA_BIAS factor. This aligns with robust hardening and reduces risk of moving already reasonable values away from truth.

2) Trim the router-balanced reconciliation (Stage 2) budget and require a stronger improvement check before committing. Reducing the cap from 1.2% to 0.8% and increasing the required residual improvement from 8% to 10% makes these router-wide nudges less intrusive, which should improve counter accuracy without hurting calibration.

These changes are small, consistent, and focus on reducing harmful over-adjustments, a common culprit for slight accuracy drops in previous iterations. They preserve the current successful consensus logic and confidence design while improving the safety profile of global adjustments.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Micro-adjuster parameters (Recommendation 2)
    ROUTER_RESID_TRIGGER = 0.03      # trigger micro-adjust when residual ≥ 3%
    DOMINANCE_SHARE = 0.60           # candidate must contribute ≥60% of same-direction mass
    MI_ALPHA_CAP = 0.02              # cap nudge at 2%
    IMPROVE_REQ = 0.10               # require ≥10% residual improvement to commit
=======
    # Micro-adjuster parameters (Recommendation 2)
    ROUTER_RESID_TRIGGER = 0.03      # trigger micro-adjust when residual ≥ 3%
    DOMINANCE_SHARE = 0.60           # candidate must contribute ≥60% of same-direction mass
    MI_ALPHA_CAP = 0.02              # cap nudge at 2%
    IMPROVE_REQ = 0.10               # require ≥10% residual improvement to commit

    # Pair-bias stage moderation
    BETA_BIAS = 0.6                  # partial application strength for pair-bias scaling
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        hi = max(a_tx, a_rx, b_tx, b_rx)
        tol = LOW_RATE_THRESHOLD if hi < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
        # Directional diffs and guards must both be significant to apply multiplicative harmonization
        tol_ab = dir_threshold(a_tx, b_rx)
        tol_ba = dir_threshold(b_tx, a_rx)
        diff_ab = abs(a_tx - b_rx) / max(1.0, a_tx, b_rx)
        diff_ba = abs(b_tx - a_rx) / max(1.0, b_tx, a_rx)
        abs_guard_dyn = 0.3 if hi < LOW_RATE_CUTOFF else ABS_GUARD
        abs_ab = abs(a_tx - b_rx)
        abs_ba = abs(b_tx - a_rx)

        if (not ratio_consistent) or (abs(s - 1.0) <= tol) or (diff_ab <= tol_ab) or (diff_ba <= tol_ba) or (abs_ab <= abs_guard_dyn) or (abs_ba <= abs_guard_dyn):
            continue

        # Adjust the lower-activity side toward the bias-corrected scale (partial application)
        act_a = max(a_tx, a_rx)
        act_b = max(b_tx, b_rx)
        if act_a < act_b:
            target = a_id
            scale = s
        else:
            target = b_id
            scale = 1.0 / max(1e-9, s)

        k = (abs(s - 1.0) - tol) / max(tol, 1e-9)
        k = clamp(k, 0.0, 1.0)
        factor = 1.0 + k * (scale - 1.0)

        vals[target]['tx'] = max(0.0, vals[target]['tx'] * factor)
        vals[target]['rx'] = max(0.0, vals[target]['rx'] * factor)
=======
        hi = max(a_tx, a_rx, b_tx, b_rx)
        tol = LOW_RATE_THRESHOLD if hi < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
        # Directional diffs and guards must both be significant to apply multiplicative harmonization
        tol_ab = dir_threshold(a_tx, b_rx)
        tol_ba = dir_threshold(b_tx, a_rx)
        diff_ab = abs(a_tx - b_rx) / max(1.0, a_tx, b_rx)
        diff_ba = abs(b_tx - a_rx) / max(1.0, b_tx, a_rx)
        abs_guard_dyn = 0.3 if hi < LOW_RATE_CUTOFF else ABS_GUARD
        abs_ab = abs(a_tx - b_rx)
        abs_ba = abs(b_tx - a_rx)
        # Require clear violations in both directions (more decisive gating)
        mult = 1.6 if hi < LOW_RATE_CUTOFF else 1.2

        if (not ratio_consistent) or (abs(s - 1.0) <= tol) or (diff_ab <= mult * tol_ab) or (diff_ba <= mult * tol_ba) or (abs_ab <= abs_guard_dyn) or (abs_ba <= abs_guard_dyn):
            continue

        # Adjust the lower-activity side toward the bias-corrected scale (partial application, moderated)
        act_a = max(a_tx, a_rx)
        act_b = max(b_tx, b_rx)
        if act_a < act_b:
            target = a_id
            scale = s
        else:
            target = b_id
            scale = 1.0 / max(1e-9, s)

        k = (abs(s - 1.0) - tol) / max(tol, 1e-9)
        k = clamp(k, 0.0, 1.0)
        factor = 1.0 + BETA_BIAS * k * (scale - 1.0)

        vals[target]['tx'] = max(0.0, vals[target]['tx'] * factor)
        vals[target]['rx'] = max(0.0, vals[target]['rx'] * factor)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        budget = min(abs(delta), 0.012 * denom_r)  # small 1.2% cap to protect counters
=======
        budget = min(abs(delta), 0.008 * denom_r)  # small 0.8% cap to protect counters
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        if resid_after > (1.0 - 0.08) * resid_before:
=======
        if resid_after > (1.0 - 0.10) * resid_before:
>>>>>>> REPLACE

</DIFF>