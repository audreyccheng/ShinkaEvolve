<NAME>
residual_tilted_consensus_weights
</NAME>

<DESCRIPTION>
I propose adding residual-tilted, direction-aware consensus weights during the link-level repair step. Before performing pairwise consensus, we compute per-router signed residuals (sum_tx − sum_rx)/max(1,sum_tx,sum_rx) from the raw telemetry using the provided topology and router hints. Then, for each direction on a link (a->b and b->a), when a discrepancy exceeds both the relative tolerance and absolute guard, we slightly tilt the activity-based weights away from the local router whose signed residual has the same sign as the directional mismatch. This follows the Hodor-inspired idea to leverage flow-conservation residuals to bias consensus to reduce router imbalance.

Concretely:
- Precompute pre_router_resid_signed per router from original telemetry, zeroing rates on explicitly-down interfaces.
- In direction a->b, if sign(a_tx − b_rx) matches sign(resid_signed[a_router]), reduce w_a by γ and re-normalize (w_a’ in [0.2,0.8], w_b’ = 1 − w_a’), with γ = min(0.08, 0.1·|resid_signed|).
- Symmetric logic for direction b->a.
- Apply this tilt only when both triggers fire (diff > tol and |delta| > ABS_GUARD), preserving existing guards and partial/full convergence logic.

This targeted change improves counter repair accuracy by nudging fixes to both satisfy link symmetry and reduce router flow imbalance, while keeping existing confidence calibration logic unchanged, preserving good calibration and status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    result: Dict[str, Dict[str, Tuple]] = {}

    # Build peer mapping for quick, validated lookup
    peers: Dict[str, str] = {}
    for if_id, data in telemetry.items():
        peer_id = data.get('connected_to')
        peers[if_id] = peer_id if peer_id in telemetry else None

    # Plan pairwise consensus adjustments so both ends change consistently
    field_value_adjust: Dict[Tuple[str, str], float] = {}   # (iface, 'tx'|'rx') -> new_value
=======
    result: Dict[str, Dict[str, Tuple]] = {}

    # Build peer mapping for quick, validated lookup
    peers: Dict[str, str] = {}
    for if_id, data in telemetry.items():
        peer_id = data.get('connected_to')
        peers[if_id] = peer_id if peer_id in telemetry else None

    # Precompute router signed residuals from raw telemetry (for residual-tilted consensus)
    pre_router_ifaces: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        if lr:
            pre_router_ifaces.setdefault(lr, [])
            if if_id not in pre_router_ifaces[lr]:
                pre_router_ifaces[lr].append(if_id)
        rr = d.get('remote_router')
        if rr and rr not in pre_router_ifaces:
            pre_router_ifaces[rr] = []
    pre_router_resid_signed: Dict[str, float] = {}
    for r, if_list in pre_router_ifaces.items():
        sum_tx_raw = 0.0
        sum_rx_raw = 0.0
        for iid in if_list:
            if iid in telemetry:
                d = telemetry[iid]
                st = d.get('interface_status', 'unknown')
                txv = float(d.get('tx_rate', 0.0)) if st != 'down' else 0.0
                rxv = float(d.get('rx_rate', 0.0)) if st != 'down' else 0.0
                sum_tx_raw += txv
                sum_rx_raw += rxv
        denom = max(1.0, sum_tx_raw, sum_rx_raw)
        pre_router_resid_signed[r] = (sum_tx_raw - sum_rx_raw) / denom

    # Plan pairwise consensus adjustments so both ends change consistently
    field_value_adjust: Dict[Tuple[str, str], float] = {}   # (iface, 'tx'|'rx') -> new_value
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
=======
                    # Trust-weighted consensus with residual-tilted weights to reduce local router residual
                    w_a_dir = w_a
                    w_b_dir = w_b
                    a_router = a_data.get('local_router')
                    resid_local_a = 0.0 if a_router is None else pre_router_resid_signed.get(a_router, 0.0)
                    sgn_delta = 1 if (a_tx - b_rx) > 0 else (-1 if (a_tx - b_rx) < 0 else 0)
                    sgn_resid = 1 if resid_local_a > 0 else (-1 if resid_local_a < 0 else 0)
                    if sgn_delta == sgn_resid and sgn_delta != 0:
                        gamma = min(0.08, 0.1 * abs(resid_local_a))
                        # Tilt weights away from local side to pull toward reducing residual
                        w_a_dir = clamp(max(0.2, min(0.8, w_a - gamma)))
                        w_b_dir = 1.0 - w_a_dir
                    consensus_ab = w_a_dir * a_tx + w_b_dir * b_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                    consensus_ba = w_b * b_tx + w_a * a_rx
=======
                    # Trust-weighted consensus with residual-tilted weights (direction b->a)
                    w_b_dir = w_b
                    w_a_dir = w_a
                    b_router = telemetry[b_id].get('local_router')
                    resid_local_b = 0.0 if b_router is None else pre_router_resid_signed.get(b_router, 0.0)
                    sgn_delta = 1 if (b_tx - a_rx) > 0 else (-1 if (b_tx - a_rx) < 0 else 0)
                    sgn_resid = 1 if resid_local_b > 0 else (-1 if resid_local_b < 0 else 0)
                    if sgn_delta == sgn_resid and sgn_delta != 0:
                        gamma = min(0.08, 0.1 * abs(resid_local_b))
                        w_b_dir = clamp(max(0.2, min(0.8, w_b - gamma)))
                        w_a_dir = 1.0 - w_b_dir
                    consensus_ba = w_b_dir * b_tx + w_a_dir * a_rx
>>>>>>> REPLACE
</DIFF>