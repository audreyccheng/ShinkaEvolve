<NAME>
lowrate_tilt_and_safe_micro
</NAME>

<DESCRIPTION>
I propose two targeted improvements to boost counter repair accuracy while keeping confidence well-calibrated:

1) Low-rate–aware, asymmetric partial consensus with dynamic absolute guard:
   - For each link direction, when rates are in the low band (<10 Mbps), lower the full convergence multiplier (2.0 → 1.6), use a slightly aggressive exponent (k_raw^1.2), and a smaller absolute guard (0.5 → 0.3 Mbps). Additionally, in the partial band, move the “louder” endpoint more toward the consensus and the “quieter” endpoint less, proportional to their magnitude share. This makes convergence more decisive and realistic for tiny flows and reduces residual bias when one side dominates.

2) Safer, benefit-checked micro-adjustments on dominant unpaired interfaces:
   - Add guards to avoid nudging tiny flows and only adjust when router residual is meaningful (≥3%). Make a tentative single-direction nudge on the dominant unpaired interface, recompute router residual, and commit only if it improves the residual by ≥8% and does not worsen the interface’s internal tx/rx imbalance by more than 3% relative. Otherwise, revert. This improves counter accuracy and prevents harmful nudges, thus improving calibration.

These changes align with the research guidance on magnitude-aware hardening and flow-conservation-aware adjustments, and should improve both counter repair accuracy and confidence calibration without impacting status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # a->b hardening
            if diff_ab > tol_ab:
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    if diff_ab <= 2 * tol_ab:
                        # Partial averaging near threshold to reduce overcorrection
                        k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
=======
            # a->b hardening
            if diff_ab > tol_ab:
                # Low-rate–aware absolute guard and convergence shaping
                low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
                abs_guard_ab = 0.3 if low_band_ab else ABS_GUARD
                full_mult_ab = 1.6 if low_band_ab else 2.0
                exp_ab = 1.2 if low_band_ab else 1.0

                if abs_ab > abs_guard_ab:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    if diff_ab <= full_mult_ab * tol_ab:
                        # Asymmetric partial averaging: move the louder side more
                        k_raw = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ab))
                        # Determine loud/quiet shares
                        s = max(1e-9, a_tx + b_rx)
                        a_share = a_tx / s
                        b_share = b_rx / s
                        # Scale factors so louder moves more, quieter moves less
                        if a_tx >= b_rx:
                            k_a = clamp(k_base * (1.0 + 0.5 * a_share))
                            k_b = clamp(k_base * (1.0 - 0.5 * b_share))
                        else:
                            k_b = clamp(k_base * (1.0 + 0.5 * b_share))
                            k_a = clamp(k_base * (1.0 - 0.5 * a_share))
                        new_a_tx = a_tx * (1.0 - k_a) + consensus_ab * k_a
                        new_b_rx = b_rx * (1.0 - k_b) + consensus_ab * k_b
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # b->a hardening
            if diff_ba > tol_ba:
                if abs_ba > ABS_GUARD:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    if diff_ba <= 2 * tol_ba:
                        k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
=======
            # b->a hardening
            if diff_ba > tol_ba:
                # Low-rate–aware absolute guard and convergence shaping
                low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                abs_guard_ba = 0.3 if low_band_ba else ABS_GUARD
                full_mult_ba = 1.6 if low_band_ba else 2.0
                exp_ba = 1.2 if low_band_ba else 1.0

                if abs_ba > abs_guard_ba:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    if diff_ba <= full_mult_ba * tol_ba:
                        k_raw = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ba))
                        s = max(1e-9, b_tx + a_rx)
                        b_share = b_tx / s
                        a_share = a_rx / s
                        if b_tx >= a_rx:
                            k_b = clamp(k_base * (1.0 + 0.5 * b_share))
                            k_a = clamp(k_base * (1.0 - 0.5 * a_share))
                        else:
                            k_a = clamp(k_base * (1.0 + 0.5 * a_share))
                            k_b = clamp(k_base * (1.0 - 0.5 * b_share))
                        new_b_tx = b_tx * (1.0 - k_b) + consensus_ba * k_b
                        new_a_rx = a_rx * (1.0 - k_a) + consensus_ba * k_a
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces (recommendation 4)
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom

        # Identify unpaired, up interfaces
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if peer missing in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Adjust only the larger counter toward reducing the router imbalance
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        if imbalance > 0.0:
            # sum_tx > sum_rx: reduce tx or increase rx; nudge only larger counter
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                # reduce confidence to reflect heuristic adjustment
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_rx = rrx * (1.0 + alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        else:
            # sum_tx < sum_rx: reduce rx or increase tx; nudge only larger counter
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
            else:
                new_tx = rtx * (1.0 + alpha)
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
=======
    # Apply tightly scoped, benefit-checked micro-adjustments only on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom
        # Require sufficient residual to attempt micro-adjustments
        if resid_frac < 0.03:
            continue

        # Identify unpaired, up interfaces with non-trivial traffic
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if peer missing in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                if max(txv, rxv) < LOW_RATE_CUTOFF:
                    continue  # avoid nudging tiny flows
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Helper to compute router residual for a single router from current result snapshot
        def compute_router_resid_local(router_id: str) -> float:
            stx, srx = 0.0, 0.0
            for iid in router_ifaces.get(router_id, []):
                if iid in result:
                    stx += float(result[iid]['tx_rate'][1])
                    srx += float(result[iid]['rx_rate'][1])
            return abs(stx - srx) / max(1.0, stx, srx)

        # Adjust only the larger counter toward reducing the router imbalance, tentatively
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        pre_internal = abs(rtx - rrx) / max(1.0, max(rtx, rrx))

        if imbalance > 0.0:
            # sum_tx > sum_rx: reduce tx or increase rx; nudge only the larger counter
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                new_rx = rrx
                adjust_kind = 'tx'
            else:
                new_rx = rrx * (1.0 + alpha)
                new_tx = rtx
                adjust_kind = 'rx'
        else:
            # sum_tx < sum_rx: reduce rx or increase tx; nudge only the larger counter
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_tx = rtx
                adjust_kind = 'rx'
            else:
                new_tx = rtx * (1.0 + alpha)
                new_rx = rrx
                adjust_kind = 'tx'

        # Apply tentatively
        if adjust_kind == 'tx':
            result[top_if]['tx_rate'] = (otx, new_tx, tc)
        else:
            result[top_if]['rx_rate'] = (orx, new_rx, rc)

        resid_after = compute_router_resid_local(r)
        post_internal = abs(new_tx - new_rx) / max(1.0, max(new_tx, new_rx))

        # Commit only if improves residual >=8% and internal imbalance doesn't worsen by >3% relative
        if resid_after <= (1.0 - 0.08) * resid_frac and post_internal <= pre_internal + 0.03:
            # Reduce confidence to reflect heuristic adjustment
            if adjust_kind == 'tx':
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        else:
            # Revert
            result[top_if]['tx_rate'] = (otx, rtx, tc)
            result[top_if]['rx_rate'] = (orx, rrx, rc)
>>>>>>> REPLACE
</DIFF>