<NAME>
residual_tilted_consensus_adaptive_penalties
</NAME>

<DESCRIPTION>
Two targeted improvements to increase repair accuracy and confidence calibration:

1) Residual-tilted consensus weights in pair repair:
   - Compute signed per-router residuals on original telemetry.
   - When correcting a directional discrepancy, slightly tilt the activity-based weights toward reducing the local router’s imbalance. This preserves existing guards and low-rate shaping while nudging consensus in the imbalance-reducing direction.

2) Residual-severity–adaptive router penalties and ultra-agreement floor:
   - Make confidence penalties adaptive to residual severity via an amplitude amp based on max(resid_local, resid_remote), yielding milder penalties on well-balanced routers and stronger on severe imbalances.
   - Add an ultra-agreement confidence floor (0.995) when both link directions are extremely aligned (diff ≤ 0.003) and both routers are well-balanced (residual ≤ 0.02), improving calibration on pristine links.

These changes respect the topology and flow conservation principles and should improve combined score by more accurate counter repairs and better-calibrated confidences.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    peers: Dict[str, str] = {}
    # Working values used by consensus (can be pre-scaled by pair-bias detection)
    work_vals: Dict[str, Dict[str, float]] = {}
    for if_id, data in telemetry.items():
        peer_id = data.get('connected_to')
        peers[if_id] = peer_id if peer_id in telemetry else None
        work_vals[if_id] = {
            'tx': float(data.get('tx_rate', 0.0)),
            'rx': float(data.get('rx_rate', 0.0))
        }
=======
    peers: Dict[str, str] = {}
    # Working values used by consensus (can be pre-scaled by pair-bias detection)
    work_vals: Dict[str, Dict[str, float]] = {}
    for if_id, data in telemetry.items():
        peer_id = data.get('connected_to')
        peers[if_id] = peer_id if peer_id in telemetry else None
        work_vals[if_id] = {
            'tx': float(data.get('tx_rate', 0.0)),
            'rx': float(data.get('rx_rate', 0.0))
        }

    # Build early router->interfaces mapping and compute signed residuals on original telemetry.
    # Used to gently tilt pairwise consensus to reduce local router imbalance.
    router_ifaces_early: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        if lr:
            router_ifaces_early.setdefault(lr, [])
            if if_id not in router_ifaces_early[lr]:
                router_ifaces_early[lr].append(if_id)
        rr = d.get('remote_router')
        if rr and rr not in router_ifaces_early:
            router_ifaces_early[rr] = []

    resid_signed: Dict[str, float] = {}
    for r, if_list in router_ifaces_early.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for iid in if_list:
            d = telemetry.get(iid, {})
            sum_tx += float(d.get('tx_rate', 0.0))
            sum_rx += float(d.get('rx_rate', 0.0))
        denom = max(1.0, sum_tx, sum_rx)
        resid_signed[r] = (sum_tx - sum_rx) / denom if denom > 0 else 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    # Low-rate–aware shaping parameters
                    low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
                    full_mult_ab = 1.6 if low_band_ab else 2.0
                    exp_ab = 1.2 if low_band_ab else 1.0
=======
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus with residual-tilted weights
                    w_a_eff, w_b_eff = w_a, w_b
                    resid_a = resid_signed.get(a_data.get('local_router'), 0.0)
                    sgn_ab = 1.0 if (a_tx - b_rx) > 0.0 else (-1.0 if (a_tx - b_rx) < 0.0 else 0.0)
                    if sgn_ab != 0.0 and resid_a != 0.0 and (sgn_ab * resid_a) > 0.0:
                        gamma = min(0.08, 0.1 * abs(resid_a))
                        w_a_eff = clamp(w_a - gamma, 0.2, 0.8)
                        w_b_eff = 1.0 - w_a_eff
                    consensus_ab = w_a_eff * a_tx + w_b_eff * b_rx
                    # Low-rate–aware shaping parameters
                    low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
                    full_mult_ab = 1.6 if low_band_ab else 2.0
                    exp_ab = 1.2 if low_band_ab else 1.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                if abs_ba > ABS_GUARD:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    # Low-rate–aware shaping parameters
                    low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                    full_mult_ba = 1.6 if low_band_ba else 2.0
                    exp_ba = 1.2 if low_band_ba else 1.0
=======
                if abs_ba > ABS_GUARD:
                    # Trust-weighted consensus with residual-tilted weights
                    w_b_eff, w_a_eff = w_b, w_a
                    resid_b = resid_signed.get(telemetry[b_id].get('local_router'), 0.0)
                    sgn_ba = 1.0 if (b_tx - a_rx) > 0.0 else (-1.0 if (b_tx - a_rx) < 0.0 else 0.0)
                    if sgn_ba != 0.0 and resid_b != 0.0 and (sgn_ba * resid_b) > 0.0:
                        gamma = min(0.08, 0.1 * abs(resid_b))
                        w_b_eff = clamp(w_b - gamma, 0.2, 0.8)
                        w_a_eff = 1.0 - w_b_eff
                    consensus_ba = w_b_eff * b_tx + w_a_eff * a_rx
                    # Low-rate–aware shaping parameters
                    low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                    full_mult_ba = 1.6 if low_band_ba else 2.0
                    exp_ba = 1.2 if low_band_ba else 1.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        tx_share = rtx / max(1.0, router_sum_tx.get(lr, 0.0))
        rx_share = rrx / max(1.0, router_sum_rx.get(lr, 0.0))
        penalty_tx = clamp(1.0 - ((0.6 + 0.2 * tx_share) * resid_local + (0.4 - 0.2 * tx_share) * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - ((0.6 + 0.2 * rx_share) * resid_local + (0.4 - 0.2 * rx_share) * resid_remote), 0.5, 1.0)
=======
        tx_share = rtx / max(1.0, router_sum_tx.get(lr, 0.0))
        rx_share = rrx / max(1.0, router_sum_rx.get(lr, 0.0))
        severity = max(resid_local, resid_remote)
        if severity < 0.03:
            amp = 0.1
        elif severity < 0.12:
            amp = 0.2
        else:
            amp = 0.3
        penalty_tx = clamp(1.0 - ((0.6 + amp * tx_share) * resid_local + (0.4 - amp * tx_share) * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - ((0.6 + amp * rx_share) * resid_local + (0.4 - amp * rx_share) * resid_remote), 0.5, 1.0)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if max(rrx, peer_rtx) >= 10.0 and diff_rx <= 0.005:
                floor_rx = 0.99
            elif diff_rx <= th_rx:
                floor_rx = 0.98 if max(rrx, peer_rtx) >= 10.0 else 0.97
            else:
                floor_rx = 0.0
=======
            if max(rrx, peer_rtx) >= 10.0 and diff_rx <= 0.005:
                floor_rx = 0.99
            elif diff_rx <= th_rx:
                floor_rx = 0.98 if max(rrx, peer_rtx) >= 10.0 else 0.97
            else:
                floor_rx = 0.0
            # Ultra-agreement floor when both directions are extremely tight and routers are balanced
            if max(resid_local, resid_remote) <= 0.02 and diff_tx <= 0.003 and diff_rx <= 0.003:
                if max(rtx, peer_rrx) >= 10.0 and max(rrx, peer_rtx) >= 10.0:
                    floor_tx = max(floor_tx, 0.995)
                    floor_rx = max(floor_rx, 0.995)
>>>>>>> REPLACE
</DIFF>