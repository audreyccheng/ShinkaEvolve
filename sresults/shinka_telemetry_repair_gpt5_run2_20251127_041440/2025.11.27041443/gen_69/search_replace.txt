<NAME>
residual_tilt_and_share_aware_confidence
</NAME>

<DESCRIPTION>
I propose two conservative, topology-aware improvements to increase counter repair accuracy and confidence calibration:

1) Residual-tilted pair consensus: compute signed router residuals from original telemetry and, when repairing a link direction, slightly tilt the consensus center away from the local side if the link’s mismatch aligns with the router’s imbalance. This bounded tilt (γ ≤ 0.08) nudges repairs to also reduce router flow imbalance, retaining all existing guards and partial averaging behavior.

2) Share-aware, direction-coupled residual penalties in confidence: when scaling TX/RX confidences, weight local vs remote residuals by the interface’s directional share on the respective router (for TX use local Σtx; for RX use remote Σtx). This aligns penalties with each interface’s influence on conservation while keeping status scaling mild.

Both changes are magnitude-aware, bounded, and only affect adjustments beyond tolerance, preserving stability on already consistent telemetry.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Build unique undirected link pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
=======
    # Build unique undirected link pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # Precompute original router signed residuals using raw telemetry (for residual-tilted consensus)
    orig_router_sums: Dict[str, Tuple[float, float]] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            if iid in telemetry:
                s_tx += to_float(telemetry[iid].get('tx_rate', 0.0))
                s_rx += to_float(telemetry[iid].get('rx_rate', 0.0))
        orig_router_sums[router] = (s_tx, s_rx)
    orig_router_signed_frac: Dict[str, float] = {}
    for router, (s_tx, s_rx) in orig_router_sums.items():
        denom = max(s_tx, s_rx, 1.0)
        orig_router_signed_frac[router] = (s_tx - s_rx) / denom

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                conf_base = max(0.0, 1.0 - d_ab)
                # Penalize by applied change magnitude for calibration
                change_a = change_ratio(a_tx, rep_a_tx)
                change_b = change_ratio(b_rx, rep_b_rx)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
=======
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # Residual-tilted consensus: bias weighted center to reduce local router imbalance
                a_local_router = a.get('local_router')
                resid_frac_signed = orig_router_signed_frac.get(a_local_router, 0.0)
                tilt_same_sign = (a_tx - b_rx) * resid_frac_signed > 0.0
                gamma = min(0.08, 0.1 * abs(resid_frac_signed)) if tilt_same_sign else 0.0
                w_a = 0.5 - gamma
                w_a = 0.2 if w_a < 0.2 else (0.8 if w_a > 0.8 else w_a)
                w_b = 1.0 - w_a
                v = w_a * a_tx + w_b * b_rx

                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                conf_base = max(0.0, 1.0 - d_ab)
                # Penalize by applied change magnitude for calibration
                change_a = change_ratio(a_tx, rep_a_tx)
                change_b = change_ratio(b_rx, rep_b_rx)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                conf_base2 = max(0.0, 1.0 - d_ba)
                change_b2 = change_ratio(b_tx, rep_b_tx)
                change_a2 = change_ratio(a_rx, rep_a_rx)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
=======
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                # Residual-tilted consensus for B->A using B's local router residual
                b_local_router = b.get('local_router')
                resid_frac_signed_b = orig_router_signed_frac.get(b_local_router, 0.0)
                tilt_same_sign_b = (b_tx - a_rx) * resid_frac_signed_b > 0.0
                gamma_b = min(0.08, 0.1 * abs(resid_frac_signed_b)) if tilt_same_sign_b else 0.0
                w_b2 = 0.5 - gamma_b
                w_b2 = 0.2 if w_b2 < 0.2 else (0.8 if w_b2 > 0.8 else w_b2)
                w_a2 = 1.0 - w_b2
                v2 = w_b2 * b_tx + w_a2 * a_rx
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                conf_base2 = max(0.0, 1.0 - d_ba)
                change_b2 = change_ratio(b_tx, rep_b_tx)
                change_a2 = change_ratio(a_rx, rep_a_rx)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Compute router-level residuals after repairs for confidence penalties
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            if iid in per_if:
                s_tx += to_float(per_if[iid]['repaired_tx'])
                s_rx += to_float(per_if[iid]['repaired_rx'])
        router_residual[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
=======
    # Compute router-level residuals after repairs for confidence penalties
    router_residual: Dict[str, float] = {}
    router_sums_repaired: Dict[str, Tuple[float, float]] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            if iid in per_if:
                s_tx += to_float(per_if[iid]['repaired_tx'])
                s_rx += to_float(per_if[iid]['repaired_rx'])
        router_sums_repaired[router] = (s_tx, s_rx)
        router_residual[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Direction-aware penalties: TX depends more on local, RX more on remote
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)
=======
        # Share-aware, direction-coupled penalties: emphasize the router where this interface dominates
        sum_tx_local = router_sums_repaired.get(local_router, (0.0, 0.0))[0]
        sum_tx_remote = router_sums_repaired.get(remote_router, (0.0, 0.0))[0]

        # TX confidence depends more on local residual, scaled by this iface's TX share on local router
        share_tx_local = repaired_tx / max(1.0, sum_tx_local)
        w_local_tx = 0.6 + 0.2 * share_tx_local
        if w_local_tx < 0.0:
            w_local_tx = 0.0
        if w_local_tx > 1.0:
            w_local_tx = 1.0
        w_remote_tx = 1.0 - w_local_tx

        # RX confidence depends more on remote residual, scaled by this iface's RX share of remote's TX domain
        share_rx_remote = repaired_rx / max(1.0, sum_tx_remote)
        w_remote_rx = 0.6 + 0.2 * share_rx_remote
        if w_remote_rx < 0.0:
            w_remote_rx = 0.0
        if w_remote_rx > 1.0:
            w_remote_rx = 1.0
        w_local_rx = 1.0 - w_remote_rx

        penalty_tx = 1.0 - (w_local_tx * resid_local + w_remote_tx * resid_remote)
        penalty_rx = 1.0 - (w_remote_rx * resid_remote + w_local_rx * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        avg_penalty = min(penalty_tx, penalty_rx)
>>>>>>> REPLACE

</DIFF>