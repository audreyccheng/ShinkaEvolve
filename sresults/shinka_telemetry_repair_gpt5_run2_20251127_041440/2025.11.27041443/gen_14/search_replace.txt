<NAME>
pairwise_plus_router_balance
</NAME>

<DESCRIPTION>
I propose two targeted improvements that leverage redundancy and flow conservation to improve both repair accuracy and confidence calibration while preserving the strengths of the current implementation:

1) Confidence refinement by change magnitude: After pairwise link hardening, we downscale the per-counter confidence when the applied correction was large, using a simple normalized change metric. This reduces overconfidence on heavy edits and improves calibration without affecting repaired values.

2) Router-level balancing on dangling interfaces: After pairwise hardening, we use flow conservation (R1) to correct router imbalances by adjusting only interfaces that lack a known peer (dangling), thus not violating link symmetry. Corrections are distributed proportionally to existing traffic to minimize relative changes, and associated confidences are penalized based on the magnitude of the change. This adds dynamic checking and repair (not just penalization) at the router level, improving counter accuracy while maintaining good calibration.

These changes are consistent with the Hodor-inspired three-step approach: collect redundant signals (peer counters), harden them (pairwise averaging within threshold), and dynamically check and repair using router flow constraints. The edits are localized and preserve the rest of the program structure.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)
=======
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0) or 0.0) > EPS) or (float(d.get('tx_rate', 0.0) or 0.0) > EPS)

    def change_ratio(orig: float, rep: float) -> float:
        # magnitude of change normalized by the larger magnitude and 1.0 to avoid division by zero
        denom = max(abs(orig), abs(rep), 1.0)
        return abs(rep - orig) / denom
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    for _, (a_id, b_id) in pairs.items():
        a = telemetry[a_id]
        b = telemetry[b_id]

        a_status = a.get('interface_status', 'unknown')
        b_status = b.get('interface_status', 'unknown')

        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)

        # Decide pair status using interface consistency + traffic evidence
        a_has = has_traffic(a)
        b_has = has_traffic(b)

        if a_status == 'down' and b_status == 'down':
            pair_status = 'down'
        elif a_status == 'up' and b_status == 'up':
            pair_status = 'up'
        else:
            # Mismatch: if any traffic exists on either end, consider link up; otherwise down
            pair_status = 'up' if (a_has or b_has) else 'down'

        # Initialize with originals
        rep_a_tx, rep_b_rx = a_tx, b_rx
        rep_b_tx, rep_a_rx = b_tx, a_rx
        rx_conf_a = 1.0
        tx_conf_a = 1.0
        rx_conf_b = 1.0
        tx_conf_b = 1.0

        if pair_status == 'down':
            # No traffic on a down link
            rep_a_tx, rep_b_rx, rep_b_tx, rep_a_rx = 0.0, 0.0, 0.0, 0.0
            # Confidence is high if there was no traffic observed; otherwise moderate
            base_conf = 0.95 if not (a_has or b_has) else 0.7
            rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
        else:
            # Link is up: enforce link symmetry with hardening threshold
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba

        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        per_if_repair[a_id] = {
            'repaired_rx': rep_a_rx,
            'repaired_tx': rep_a_tx,
            'rx_conf': rx_conf_a,
            'tx_conf': tx_conf_a,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
        per_if_repair[b_id] = {
            'repaired_rx': rep_b_rx,
            'repaired_tx': rep_b_tx,
            'rx_conf': rx_conf_b,
            'tx_conf': tx_conf_b,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
=======
    for _, (a_id, b_id) in pairs.items():
        a = telemetry[a_id]
        b = telemetry[b_id]

        a_status = a.get('interface_status', 'unknown')
        b_status = b.get('interface_status', 'unknown')

        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)

        # Decide pair status using interface consistency + traffic evidence
        a_has = has_traffic(a)
        b_has = has_traffic(b)

        if a_status == 'down' and b_status == 'down':
            pair_status = 'down'
        elif a_status == 'up' and b_status == 'up':
            pair_status = 'up'
        else:
            # Mismatch: if any traffic exists on either end, consider link up; otherwise down
            pair_status = 'up' if (a_has or b_has) else 'down'

        # Initialize with originals
        rep_a_tx, rep_b_rx = a_tx, b_rx
        rep_b_tx, rep_a_rx = b_tx, a_rx
        rx_conf_a = 1.0
        tx_conf_a = 1.0
        rx_conf_b = 1.0
        tx_conf_b = 1.0

        if pair_status == 'down':
            # No traffic on a down link
            rep_a_tx, rep_b_rx, rep_b_tx, rep_a_rx = 0.0, 0.0, 0.0, 0.0
            # Confidence is high if there was no traffic observed; otherwise moderate
            base_conf = 0.95 if not (a_has or b_has) else 0.7
            rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
        else:
            # Link is up: enforce link symmetry with hardening threshold
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba

        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        # Confidence refinement: penalize by magnitude of applied change to improve calibration
        a_rx_change = change_ratio(a_rx, rep_a_rx)
        a_tx_change = change_ratio(a_tx, rep_a_tx)
        b_rx_change = change_ratio(b_rx, rep_b_rx)
        b_tx_change = change_ratio(b_tx, rep_b_tx)

        rx_conf_a = max(0.0, min(1.0, min(rx_conf_a, 1.0 - a_rx_change)))
        tx_conf_a = max(0.0, min(1.0, min(tx_conf_a, 1.0 - a_tx_change)))
        rx_conf_b = max(0.0, min(1.0, min(rx_conf_b, 1.0 - b_rx_change)))
        tx_conf_b = max(0.0, min(1.0, min(tx_conf_b, 1.0 - b_tx_change)))

        per_if_repair[a_id] = {
            'repaired_rx': rep_a_rx,
            'repaired_tx': rep_a_tx,
            'rx_conf': rx_conf_a,
            'tx_conf': tx_conf_a,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
        per_if_repair[b_id] = {
            'repaired_rx': rep_b_rx,
            'repaired_tx': rep_b_tx,
            'rx_conf': rx_conf_b,
            'tx_conf': tx_conf_b,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Second pass: compute router-level flow conservation residuals using repaired rates
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
=======
    # Router-level balancing using dangling interfaces to satisfy flow conservation (R1)
    # We only adjust interfaces without a known peer to avoid breaking link symmetry.
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        present = [iid for iid in if_list if iid in per_if_repair]
        if not present:
            continue
        for iid in present:
            rep = per_if_repair[iid]
            sum_tx += float(rep['repaired_tx'])
            sum_rx += float(rep['repaired_rx'])
        scale = max(sum_tx, sum_rx, 1.0)
        delta = sum_tx - sum_rx  # want delta -> 0

        # Skip tiny imbalances within tolerance
        if abs(delta) <= HARDENING_THRESHOLD * scale:
            continue

        # Candidate interfaces for adjustment: dangling and up
        dangling = [iid for iid in present
                    if (iid not in paired_ids) and (per_if_repair[iid].get('repaired_status', 'up') != 'down')]

        if not dangling:
            continue

        # Distribute correction proportionally to traffic magnitude to minimize relative change
        weights = []
        sum_w = 0.0
        for iid in dangling:
            rep = per_if_repair[iid]
            w = float(rep['repaired_tx']) + float(rep['repaired_rx']) + EPS
            weights.append((iid, w))
            sum_w += w
        if sum_w <= 0.0:
            sum_w = EPS * len(dangling)
            weights = [(iid, EPS) for iid in dangling]

        if delta > 0.0:
            # Too much TX; increase RX on dangling interfaces
            for iid, w in weights:
                inc = delta * (w / sum_w)
                new_rx = float(per_if_repair[iid]['repaired_rx']) + inc
                per_if_repair[iid]['repaired_rx'] = new_rx
                # Confidence: penalize by change magnitude from original observation
                rx_orig = float(telemetry.get(iid, {}).get('rx_rate', 0.0) or 0.0)
                cr = change_ratio(rx_orig, new_rx)
                per_if_repair[iid]['rx_conf'] = max(0.0, min(float(per_if_repair[iid].get('rx_conf', 0.6)), 1.0 - cr))
        else:
            # Too much RX; increase TX on dangling interfaces
            need = -delta
            for iid, w in weights:
                inc = need * (w / sum_w)
                new_tx = float(per_if_repair[iid]['repaired_tx']) + inc
                per_if_repair[iid]['repaired_tx'] = new_tx
                tx_orig = float(telemetry.get(iid, {}).get('tx_rate', 0.0) or 0.0)
                cr = change_ratio(tx_orig, new_tx)
                per_if_repair[iid]['tx_conf'] = max(0.0, min(float(per_if_repair[iid].get('tx_conf', 0.6)), 1.0 - cr))

    # Second pass: compute router-level flow conservation residuals using repaired rates
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
            else:
                # Interface not present in telemetry; ignore (no contribution)
                continue
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
>>>>>>> REPLACE

</DIFF>