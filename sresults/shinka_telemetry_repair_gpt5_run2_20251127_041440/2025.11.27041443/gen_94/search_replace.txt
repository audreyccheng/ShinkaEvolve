<NAME>
asym_prescale_and_safer_micro_adjust
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy while preserving strong confidence calibration:

1) Direction-aware asymmetric partial averaging with gentle prescale in pair consensus:
   - For each link direction (my_tx vs their_rx and my_rx vs their_tx), before computing consensus we apply a tiny, gated multiplicative prescale (±10%) only for the consensus and k calculation. This reduces ratio bias without committing prescaled values directly. We then replace the symmetric single-k partial averaging with asymmetric partial averaging so the louder side moves more toward the consensus. The k progression remains magnitude-aware and uses low/high-rate shaping. These changes are gated by the existing absolute guard and tolerance checks to avoid overcorrection on tiny flows.

2) Safer router micro-adjustments with benefit check:
   - For router-level flow-conservation fixes on dominating unpaired interfaces, we now simulate both candidate nudges (reduce loud/increase quiet in the beneficial direction), compute residual improvement, and only commit if the router residual improves by at least 10% and the interface’s internal skew does not worsen by more than 3%. This prevents harmful adjustments and aligns confidence reductions to the magnitude of the heuristic change.

These modifications implement Recommendations 2, 3, and 5 from the provided potential improvements. They should raise counter accuracy while maintaining or improving calibration by avoiding overconfident or detrimental repairs.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # a->b hardening
            if diff_ab > tol_ab:
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    if diff_ab <= 2 * tol_ab:
                        # Partial averaging near threshold to reduce overcorrection
                        k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            else:
                # Within tolerance: floor high confidence
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)

            # b->a hardening
            if diff_ba > tol_ba:
                if abs_ba > ABS_GUARD:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    if diff_ba <= 2 * tol_ba:
                        k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
=======
            # a->b hardening with gentle prescale and asymmetric partial averaging
            if diff_ab > tol_ab:
                if abs_ab > ABS_GUARD:
                    # Gentle prescale (only for consensus/k computation; do not commit prescaled values)
                    if max(a_tx, b_rx) >= 1.0:
                        s = sqrt(max(1e-9, b_rx) / max(1e-9, a_tx))
                        s = clamp(s, 0.90, 1.10)
                    else:
                        s = 1.0
                    a_tx_p = a_tx * s
                    b_rx_p = b_rx / s
                    diff_ab_p = rel_diff(a_tx_p, b_rx_p)

                    # Trust-weighted consensus on prescaled values
                    consensus_ab = w_a * a_tx_p + w_b * b_rx_p

                    # Low-rate–aware shaping
                    low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
                    full_mult_ab = 1.6 if low_band_ab else 2.0
                    exp_ab = 1.2 if low_band_ab else 1.0

                    if diff_ab_p <= full_mult_ab * tol_ab:
                        # Asymmetric partial averaging: move louder side more
                        k_raw = (diff_ab_p - tol_ab) / max(tol_ab, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ab))
                        loud = max(a_tx, b_rx)
                        quiet = min(a_tx, b_rx)
                        r = (loud - quiet) / max(1.0, loud)
                        if a_tx >= b_rx:
                            k_a = clamp(k_base * (1.0 + 0.5 * r))
                            k_b = clamp(k_base * (1.0 - 0.5 * r))
                        else:
                            k_b = clamp(k_base * (1.0 + 0.5 * r))
                            k_a = clamp(k_base * (1.0 - 0.5 * r))
                        new_a_tx = a_tx * (1.0 - k_a) + consensus_ab * k_a
                        new_b_rx = b_rx * (1.0 - k_b) + consensus_ab * k_b
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab

                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab_p)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            else:
                # Within tolerance: floor high confidence
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)

            # b->a hardening with gentle prescale and asymmetric partial averaging
            if diff_ba > tol_ba:
                if abs_ba > ABS_GUARD:
                    if max(b_tx, a_rx) >= 1.0:
                        s2 = sqrt(max(1e-9, a_rx) / max(1e-9, b_tx))
                        s2 = clamp(s2, 0.90, 1.10)
                    else:
                        s2 = 1.0
                    b_tx_p = b_tx * s2
                    a_rx_p = a_rx / s2
                    diff_ba_p = rel_diff(b_tx_p, a_rx_p)

                    consensus_ba = w_b * b_tx_p + w_a * a_rx_p

                    low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                    full_mult_ba = 1.6 if low_band_ba else 2.0
                    exp_ba = 1.2 if low_band_ba else 1.0

                    if diff_ba_p <= full_mult_ba * tol_ba:
                        k_raw = (diff_ba_p - tol_ba) / max(tol_ba, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ba))
                        loud = max(b_tx, a_rx)
                        quiet = min(b_tx, a_rx)
                        r = (loud - quiet) / max(1.0, loud)
                        if b_tx >= a_rx:
                            k_b = clamp(k_base * (1.0 + 0.5 * r))
                            k_a = clamp(k_base * (1.0 - 0.5 * r))
                        else:
                            k_a = clamp(k_base * (1.0 + 0.5 * r))
                            k_b = clamp(k_base * (1.0 - 0.5 * r))
                        new_b_tx = b_tx * (1.0 - k_b) + consensus_ba * k_b
                        new_a_rx = a_rx * (1.0 - k_a) + consensus_ba * k_a
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba

                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba_p)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces (recommendation 4)
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom

        # Identify unpaired, up interfaces
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if peer missing in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Adjust only the larger counter toward reducing the router imbalance
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        if imbalance > 0.0:
            # sum_tx > sum_rx: reduce tx or increase rx; nudge only larger counter
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                # reduce confidence to reflect heuristic adjustment
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_rx = rrx * (1.0 + alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        else:
            # sum_tx < sum_rx: reduce rx or increase tx; nudge only larger counter
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
            else:
                new_tx = rtx * (1.0 + alpha)
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
=======
    # Apply safer, benefit-checked micro-adjustments on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom
        if resid_frac < 0.03:
            continue

        # Identify unpaired, up interfaces with non-trivial traffic
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                if max(txv, rxv) < LOW_RATE_CUTOFF:
                    continue
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Helper to compute router residual for current snapshot
        def compute_router_resid_local(router_id: str) -> float:
            stx, srx = 0.0, 0.0
            for iid in router_ifaces.get(router_id, []):
                if iid in result:
                    stx += float(result[iid]['tx_rate'][1])
                    srx += float(result[iid]['rx_rate'][1])
            return abs(stx - srx) / max(1.0, stx, srx)

        # Snapshot current values and internal skew
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        pre_internal = abs(rtx - rrx) / max(1.0, max(rtx, rrx))
        resid_before = compute_router_resid_local(r)

        # Simulate both options and compute improvement
        def simulate(option: str):
            new_tx, new_rx = rtx, rrx
            if imbalance > 0.0:
                # tx excess: prefer reducing tx or increasing rx
                if option == 'tx':
                    new_tx = rtx * (1.0 - alpha)
                else:
                    new_rx = rrx * (1.0 + alpha)
            else:
                # rx excess: prefer reducing rx or increasing tx
                if option == 'rx':
                    new_rx = rrx * (1.0 - alpha)
                else:
                    new_tx = rtx * (1.0 + alpha)
            saved_tx = result[top_if]['tx_rate']
            saved_rx = result[top_if]['rx_rate']
            result[top_if]['tx_rate'] = (otx, new_tx, tc)
            result[top_if]['rx_rate'] = (orx, new_rx, rc)
            resid_tmp = compute_router_resid_local(r)
            post_internal_tmp = abs(new_tx - new_rx) / max(1.0, max(new_tx, new_rx))
            # Revert
            result[top_if]['tx_rate'] = saved_tx
            result[top_if]['rx_rate'] = saved_rx
            return resid_tmp, post_internal_tmp, new_tx, new_rx

        r_tx, post_tx_internal, cand_tx, cand_rx1 = simulate('tx')
        r_rx, post_rx_internal, cand_tx2, cand_rx2 = simulate('rx')

        # Pick option with larger residual improvement and guarded internal skew
        choice = None
        resid_after = resid_before
        new_tx = rtx
        new_rx = rrx
        if (r_tx <= r_rx) and (post_tx_internal <= pre_internal + 0.03):
            choice = 'tx'
            resid_after = r_tx
            new_tx, new_rx = cand_tx, cand_rx1
        elif (r_rx < r_tx) and (post_rx_internal <= pre_internal + 0.03):
            choice = 'rx'
            resid_after = r_rx
            new_tx, new_rx = cand_tx2, cand_rx2

        # Commit only if residual improves by at least 10%
        if choice is not None and resid_after <= (1.0 - 0.10) * resid_before:
            if choice == 'tx':
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        # else: no commit if guard fails or insufficient improvement
>>>>>>> REPLACE

</DIFF>