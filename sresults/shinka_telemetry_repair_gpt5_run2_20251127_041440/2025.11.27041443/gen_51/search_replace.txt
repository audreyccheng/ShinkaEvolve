<NAME>
asymmetric_partial_and_share_aware_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements to raise counter repair accuracy and improve confidence calibration:

1) Asymmetric partial averaging near threshold for pair repair:
   In the partial-averaging band (when violation is above τ but within 2τ), move the louder endpoint more than the quieter one when reconciling A.tx with B.rx (and symmetrically for B.tx vs A.rx). This follows the “asymmetric partial averaging” idea to better align towards the more credible side while still respecting link symmetry. The consensus value still uses residual‑tilted weighting, but the interpolation factors are asymmetric based on the magnitude difference, which can reduce residual errors without overcorrecting.

2) Interface-share–aware, direction-coupled router residual penalties for confidence:
   When scaling TX/RX confidences using router flow conservation residuals, modulate the local vs remote residual weights by the interface’s traffic share on its local router for that direction. Heavy-hitter interfaces receive slightly stronger local residual penalties, while lighter ones rely relatively more on the remote penalty. This improves confidence calibration by aligning penalties with each interface’s directional influence on its router.

Both changes are conservative: asymmetric averaging only applies in the near-threshold band, and confidence scaling remains bounded and well-clamped. No external dependencies added; we also store per-router TX/RX sums to compute traffic shares.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            if (diff_ab > tau_ab) and (abs_ab > ABS_GUARD):
                # Residual-tilted weighted consensus
                a_local = a.get('local_router')
                delta_local = router_orig_delta.get(a_local, 0.0)
                resid_local = router_orig_resid.get(a_local, 0.0)
                # Base equal weights
                w_a = 0.5
                w_b = 0.5
                # If moving A down (when A.tx > B.rx and router has TX surplus) helps, shrink w_a
                if (a_tx - b_rx) * delta_local > 0.0:
                    gamma = min(0.08, 0.1 * resid_local)
                    w_a = max(0.1, min(0.9, w_a - gamma))
                    w_b = 1.0 - w_a
                v_ab = w_a * a_tx + w_b * b_rx
                # Partial averaging near threshold
                if diff_ab <= 2.0 * tau_ab:
                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    k = max(0.0, min(1.0, k))
                    rep_a_tx = a_tx * (1.0 - k) + v_ab * k
                    rep_b_rx = b_rx * (1.0 - k) + v_ab * k
                else:
                    rep_a_tx = v_ab
                    rep_b_rx = v_ab
=======
            if (diff_ab > tau_ab) and (abs_ab > ABS_GUARD):
                # Residual-tilted weighted consensus
                a_local = a.get('local_router')
                delta_local = router_orig_delta.get(a_local, 0.0)
                resid_local = router_orig_resid.get(a_local, 0.0)
                # Base equal weights
                w_a = 0.5
                w_b = 0.5
                # If moving A down (when A.tx > B.rx and router has TX surplus) helps, shrink w_a
                if (a_tx - b_rx) * delta_local > 0.0:
                    gamma = min(0.08, 0.1 * resid_local)
                    w_a = max(0.1, min(0.9, w_a - gamma))
                    w_b = 1.0 - w_a
                v_ab = w_a * a_tx + w_b * b_rx
                # Partial averaging near threshold (asymmetric: move louder side more)
                if diff_ab <= 2.0 * tau_ab:
                    k_base = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    k_base = max(0.0, min(1.0, k_base))
                    max_ab = max(a_tx, b_rx)
                    min_ab = min(a_tx, b_rx)
                    loud_ratio = 0.0 if max_ab <= EPS else (max_ab - min_ab) / max(max_ab, EPS)
                    k_loud = max(0.0, min(1.0, k_base * (1.0 + 0.5 * loud_ratio)))
                    k_quiet = max(0.0, min(1.0, k_base * (1.0 - 0.5 * loud_ratio)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v_ab * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v_ab * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v_ab * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v_ab * k_loud
                else:
                    rep_a_tx = v_ab
                    rep_b_rx = v_ab
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (diff_ba > tau_ba) and (abs_ba > ABS_GUARD):
                b_local = b.get('local_router')
                delta_local_b = router_orig_delta.get(b_local, 0.0)
                resid_local_b = router_orig_resid.get(b_local, 0.0)
                w_b2 = 0.5
                w_a2 = 0.5
                if (b_tx - a_rx) * delta_local_b > 0.0:
                    gamma2 = min(0.08, 0.1 * resid_local_b)
                    w_b2 = max(0.1, min(0.9, w_b2 - gamma2))
                    w_a2 = 1.0 - w_b2
                v_ba = w_b2 * b_tx + w_a2 * a_rx
                if diff_ba <= 2.0 * tau_ba:
                    k2 = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
                    k2 = max(0.0, min(1.0, k2))
                    rep_b_tx = b_tx * (1.0 - k2) + v_ba * k2
                    rep_a_rx = a_rx * (1.0 - k2) + v_ba * k2
                else:
                    rep_b_tx = v_ba
                    rep_a_rx = v_ba
=======
            if (diff_ba > tau_ba) and (abs_ba > ABS_GUARD):
                b_local = b.get('local_router')
                delta_local_b = router_orig_delta.get(b_local, 0.0)
                resid_local_b = router_orig_resid.get(b_local, 0.0)
                w_b2 = 0.5
                w_a2 = 0.5
                if (b_tx - a_rx) * delta_local_b > 0.0:
                    gamma2 = min(0.08, 0.1 * resid_local_b)
                    w_b2 = max(0.1, min(0.9, w_b2 - gamma2))
                    w_a2 = 1.0 - w_b2
                v_ba = w_b2 * b_tx + w_a2 * a_rx
                if diff_ba <= 2.0 * tau_ba:
                    k2_base = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
                    k2_base = max(0.0, min(1.0, k2_base))
                    max_ba = max(b_tx, a_rx)
                    min_ba = min(b_tx, a_rx)
                    loud_ratio2 = 0.0 if max_ba <= EPS else (max_ba - min_ba) / max(max_ba, EPS)
                    k2_loud = max(0.0, min(1.0, k2_base * (1.0 + 0.5 * loud_ratio2)))
                    k2_quiet = max(0.0, min(1.0, k2_base * (1.0 - 0.5 * loud_ratio2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k2_loud) + v_ba * k2_loud
                        rep_a_rx = a_rx * (1.0 - k2_quiet) + v_ba * k2_quiet
                    else:
                        rep_b_tx = b_tx * (1.0 - k2_quiet) + v_ba * k2_quiet
                        rep_a_rx = a_rx * (1.0 - k2_loud) + v_ba * k2_loud
                else:
                    rep_b_tx = v_ba
                    rep_a_rx = v_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
            else:
                # Interface not present in telemetry; ignore (no contribution)
                continue
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
=======
    router_residual: Dict[str, float] = {}
    router_sums_tx: Dict[str, float] = {}
    router_sums_rx: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
        router_sums_tx[router] = sum_tx
        router_sums_rx[router] = sum_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Direction-aware penalties: TX trusts local more; RX trusts remote more
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        min_penalty = min(penalty_tx, penalty_rx)
=======
        # Direction-aware penalties with interface-share weighting
        sum_tx_local = router_sums_tx.get(local_router, 0.0)
        sum_rx_local = router_sums_rx.get(local_router, 0.0)
        # Interface traffic shares on local router (directional)
        iface_tx_share = 0.0 if sum_tx_local <= 0.0 else float(repaired_tx) / max(1.0, sum_tx_local)
        iface_rx_share = 0.0 if sum_rx_local <= 0.0 else float(repaired_rx) / max(1.0, sum_rx_local)
        iface_tx_share = max(0.0, min(1.0, iface_tx_share))
        iface_rx_share = max(0.0, min(1.0, iface_rx_share))
        # Share-aware direction-coupled penalties
        w_loc_tx = 0.6 + 0.2 * iface_tx_share
        w_rem_tx = 0.4 - 0.2 * iface_tx_share
        w_loc_rx = 0.4 - 0.2 * iface_rx_share
        w_rem_rx = 0.6 + 0.2 * iface_rx_share
        penalty_tx = 1.0 - (w_loc_tx * resid_local + w_rem_tx * resid_remote)
        penalty_rx = 1.0 - (w_rem_rx * resid_remote + w_loc_rx * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        min_penalty = min(penalty_tx, penalty_rx)
>>>>>>> REPLACE
</DIFF>