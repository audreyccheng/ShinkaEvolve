<NAME>
partial_averaging_and_directional_penalties
</NAME>

<DESCRIPTION>
I’m implementing three targeted improvements inspired by the provided recommendations to improve counter repair accuracy and confidence calibration:

1) Partial averaging just above the threshold (Recommendation 3): When the normalized difference exceeds τh but is ≤ 2τh, blend each endpoint toward the average with a factor k = (diff − τh)/τh instead of immediately snapping both to the full average. This reduces overcorrection near the boundary and should improve counter accuracy while maintaining calibration.

2) Direction-aware router residual penalties (Recommendation 2): In dynamic checking, scale tx confidence more by the local router residual and rx confidence more by the remote residual: tx_conf *= clamp(1 − (0.6 × resid_local + 0.4 × resid_remote)), rx_conf *= clamp(1 − (0.6 × resid_remote + 0.4 × resid_local)). Adjust status confidence mildly using 0.85 + 0.15 × min(pen_tx, pen_rx). This aligns confidence with traffic directionality and improves calibration.

3) Asymmetric confidence and harmonization (Recommendation 5):
   - If a link is “up” due to traffic but only one side shows traffic, downweight the silent side’s confidences by 0.88.
   - When both directions show very strong symmetry (≤ 0.5%), raise status confidence to 0.97–0.99 depending on magnitude and harmonize per-direction confidences via geometric means.

These changes leave the rest of the algorithm intact and continue to use topology. They aim to increase counter repair accuracy and keep confidence scores well-calibrated, improving the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from typing import Dict, Any, Tuple, List
=======
from typing import Dict, Any, Tuple, List
import math
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)
=======
        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)

        # Flags used later for status confidence boost on very strong agreement
        strong_agree_any = False
        strong_agree_high = False
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with hardening threshold (magnitude-aware)
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            tau_ab = dynamic_tau(a_tx, b_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)

            abs_ab = abs(a_tx - b_rx)
            abs_ba = abs(b_tx - a_rx)

            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
=======
        else:
            # Link is up: enforce link symmetry with hardening threshold (magnitude-aware)
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            tau_ab = dynamic_tau(a_tx, b_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)

            abs_ab = abs(a_tx - b_rx)
            abs_ba = abs(b_tx - a_rx)

            # Partial averaging just above threshold for A->B
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                if diff_ab <= 2.0 * tau_ab:
                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + avg_ab * k
                    rep_b_rx = b_rx * (1.0 - k) + avg_ab * k
                else:
                    rep_a_tx = avg_ab
                    rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            # Partial averaging just above threshold for B->A
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                if diff_ba <= 2.0 * tau_ba:
                    k = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k) + avg_ba * k
                    rep_a_rx = a_rx * (1.0 - k) + avg_ba * k
                else:
                    rep_b_tx = avg_ba
                    rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)

            # Track very strong agreement for later status boost and harmonization
            strong_agree_any = (diff_ab <= STRONG_AGREE_DIFF) and (diff_ba <= STRONG_AGREE_DIFF)
            strong_agree_high = strong_agree_any and (max(a_tx, b_rx, b_tx, a_rx) >= LOW_RATE_MAX)

            # Asymmetric confidence when only one side shows traffic
            if (a_has != b_has):
                if not a_has:
                    rx_conf_a *= 0.88
                    tx_conf_a *= 0.88
                if not b_has:
                    rx_conf_b *= 0.88
                    tx_conf_b *= 0.88

            # Harmonize pairwise confidences on very strong symmetry using geometric means
            if strong_agree_any:
                gm_ab = math.sqrt(max(0.0, tx_conf_a) * max(0.0, rx_conf_b))
                gm_ba = math.sqrt(max(0.0, tx_conf_b) * max(0.0, rx_conf_a))
                tx_conf_a = rx_conf_b = min(1.0, gm_ab)
                tx_conf_b = rx_conf_a = min(1.0, gm_ba)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8
=======
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8
            # Boost status confidence when both directions are in very strong agreement
            if strong_agree_high:
                status_conf = max(status_conf, 0.99)
            elif strong_agree_any:
                status_conf = max(status_conf, 0.97)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Symmetric dynamic checking penalty (from inspiration, best-calibrated variant)
        penalty = 1.0 - 0.5 * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling using the penalty
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty)))
=======
        # Direction-aware dynamic checking penalties
        def clamp01(x: float) -> float:
            return max(0.0, min(1.0, float(x)))

        pen_tx = clamp01(1.0 - (0.6 * resid_local + 0.4 * resid_remote))
        pen_rx = clamp01(1.0 - (0.6 * resid_remote + 0.4 * resid_local))

        rx_conf = clamp01(rx_conf * pen_rx)
        tx_conf = clamp01(tx_conf * pen_tx)
        # Status confidence: mild scaling using the weaker of the two directional penalties
        status_conf = clamp01(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
>>>>>>> REPLACE

</DIFF>