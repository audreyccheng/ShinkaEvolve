<NAME>
tri_axis_confidence_composition
</NAME>

<DESCRIPTION>
I propose to replace the final confidence scaling step with a tri-axis confidence composition that integrates:
- link symmetry fit after repair,
- correction magnitude (how much we changed the value),
- direction-aware router residual penalties.

The current implementation only multiplies earlier confidences by a router penalty, which tends to be overconfident on heavy corrections and under-differentiate cases with clear symmetry vs. poor symmetry after repair. This harms calibration.

The new step computes for each interface and direction:
- c_sym from the repaired counters vs the peerâ€™s repaired counters,
- c_delta from the magnitude of the change (original vs repaired),
- pen_tx/pen_rx (direction-aware router residuals).

It then composes confidence as: conf = clamp(0.45*pen + 0.35*c_sym + 0.20*c_delta), and applies magnitude-aware floors (0.99/0.98/0.97 when in tolerance) and asymmetric traffic-evidence scaling. Status confidence is also boosted when both directions show very strong agreement (0.99/0.97) and mildly aligned with the per-direction confidences as before.

This preserves the repair behavior while improving confidence calibration, addressing the observed low confidence_calibration metric without sacrificing counter repair accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Apply direction-aware penalties (recommendation 2) and mild status scaling
    for if_id, d in telemetry.items():
        if if_id not in result:
            continue
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        pen_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.0, 1.0)
        pen_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.0, 1.0)

        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']

        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * pen_tx))
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * pen_rx))
        # Mild status confidence scaling with penalties
        status_scale = 0.85 + 0.15 * min(pen_tx, pen_rx)
        result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
=======
    # Apply tri-axis confidence composition:
    # - direction-aware router penalties
    # - link symmetry fit after repair
    # - correction magnitude (original vs repaired)
    # with magnitude-aware floors and asymmetric traffic-evidence shaping.
    for if_id, d in telemetry.items():
        if if_id not in result:
            continue

        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        pen_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.0, 1.0)
        pen_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.0, 1.0)

        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']

        # If repaired status is down, keep zeros and current confidence (handled earlier)
        if rst == 'down':
            status_scale = 0.85 + 0.15 * min(pen_tx, pen_rx)
            result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
            result[if_id]['tx_rate'] = (otx, 0.0, tc)
            result[if_id]['rx_rate'] = (orx, 0.0, rc)
            continue

        # Peer-repaired values for symmetry; may be missing
        peer_id = d.get('connected_to')
        peer_exists = peer_id in result if peer_id else False
        if peer_exists:
            porx, prrx, prc = result[peer_id]['rx_rate']
            potx, prtx, ptc = result[peer_id]['tx_rate']
        else:
            prrx = None
            prtx = None

        # Helpers
        def rel_diff(a: float, b: float) -> float:
            return abs(a - b) / max(1.0, a, b)

        def dir_threshold(a: float, b: float) -> float:
            return LOW_RATE_THRESHOLD if max(a, b) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD

        # Compute symmetry fit on repaired values
        if peer_exists:
            diff_tx = rel_diff(rtx, prrx)  # my_tx vs their_rx
            diff_rx = rel_diff(rrx, prtx)  # my_rx vs their_tx
            c_sym_tx = clamp(1.0 - diff_tx)
            c_sym_rx = clamp(1.0 - diff_rx)
            # Magnitude-aware floors
            th_tx = dir_threshold(rtx, prrx)
            th_rx = dir_threshold(rrx, prtx)
            if max(rtx, prrx) >= 10.0 and diff_tx <= 0.005:
                floor_tx = 0.99
            elif diff_tx <= th_tx:
                floor_tx = 0.98 if max(rtx, prrx) >= 10.0 else 0.97
            else:
                floor_tx = 0.0
            if max(rrx, prtx) >= 10.0 and diff_rx <= 0.005:
                floor_rx = 0.99
            elif diff_rx <= th_rx:
                floor_rx = 0.98 if max(rrx, prtx) >= 10.0 else 0.97
            else:
                floor_rx = 0.0
        else:
            c_sym_tx = 0.9
            c_sym_rx = 0.9
            floor_tx = 0.0
            floor_rx = 0.0
            diff_tx = None
            diff_rx = None

        # Correction magnitude component (bigger changes => lower confidence)
        m_tx = abs(rtx - otx) / max(1.0, rtx, otx)
        m_rx = abs(rrx - orx) / max(1.0, rrx, orx)
        c_delta_tx = clamp(1.0 - min(1.0, 1.5 * m_tx))
        c_delta_rx = clamp(1.0 - min(1.0, 1.5 * m_rx))

        # Compose new confidences
        conf_tx_new = clamp(0.45 * pen_tx + 0.35 * c_sym_tx + 0.20 * c_delta_tx)
        conf_rx_new = clamp(0.45 * pen_rx + 0.35 * c_sym_rx + 0.20 * c_delta_rx)

        # Apply magnitude-aware floors
        conf_tx_new = max(conf_tx_new, floor_tx)
        conf_rx_new = max(conf_rx_new, floor_rx)

        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and prrx is not None:
            if rtx <= QUIET_EPS and prrx > QUIET_EPS:
                conf_tx_new = clamp(conf_tx_new * 0.88)
        if peer_exists and prtx is not None:
            if rrx <= QUIET_EPS and prtx > QUIET_EPS:
                conf_rx_new = clamp(conf_rx_new * 0.88)

        result[if_id]['tx_rate'] = (otx, rtx, conf_tx_new)
        result[if_id]['rx_rate'] = (orx, rrx, conf_rx_new)

        # Status confidence shaping:
        # - Boost when both directions show strong bilateral agreement
        # - Mildly align with per-direction confidences
        status_conf = sc
        if peer_exists and diff_tx is not None and diff_rx is not None:
            th_tx_cur = dir_threshold(rtx, prrx)
            th_rx_cur = dir_threshold(rrx, prtx)
            strong_tx = (max(rtx, prrx) >= 10.0 and diff_tx <= 0.005)
            strong_rx = (max(rrx, prtx) >= 10.0 and diff_rx <= 0.005)
            if strong_tx and strong_rx:
                status_conf = max(status_conf, 0.99)
            elif (diff_tx <= th_tx_cur and diff_rx <= th_rx_cur):
                status_conf = max(status_conf, 0.97)
        # Mild status confidence scaling with penalties and alignment
        status_scale = 0.85 + 0.15 * min(pen_tx, pen_rx)
        status_conf = clamp(status_conf * status_scale)
        status_conf = clamp(status_conf * (0.85 + 0.15 * min(conf_tx_new, conf_rx_new)))
        result[if_id]['interface_status'] = (ost, rst, status_conf)
>>>>>>> REPLACE

</DIFF>