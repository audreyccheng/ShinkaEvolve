<NAME>
magnitude_aware_and_directional_conf
</NAME>

<DESCRIPTION>
I propose two targeted improvements that preserve the successful pairwise hardening design while improving both counter repair accuracy and confidence calibration:

1) Magnitude-aware symmetry tolerance with absolute guard: Keep the 2% threshold but raise it to 5% when link rates are low (<10 Mbps) and require an absolute difference > 0.5 Mbps before averaging counters. This avoids over-correcting small flows where relative noise can look large and enhances calibration by setting stronger confidence floors on clear, high-rate agreements (0.99 when ≤0.5% diff at ≥10 Mbps, otherwise 0.98/0.97 within tolerance).

2) Direction-aware router residual penalties: Calibrate confidence by scaling TX using local-router residual more heavily and RX using remote-router residual more heavily. This aligns the dynamic checking with the traffic direction, improving confidence calibration without changing repaired values.

These changes should increase counter_repair_accuracy by avoiding unnecessary adjustments on low-rate links and improve confidence_calibration by aligning penalties with direction and agreement strength, while keeping status behavior unchanged (which already scores perfectly).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-6  # small absolute tolerance for "no traffic"

    def norm_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)
=======
    # Measurement timing tolerance (from Hodor research: ~2%). Magnitude-aware refinements below.
    HARDENING_THRESHOLD = 0.02  # default τh
    EPS = 1e-6  # small absolute tolerance for "no traffic"
    # Magnitude-aware parameters
    LOW_RATE_MAX = 10.0          # Mbps: below this, allow 5% tolerance
    ELEVATED_THRESHOLD = 0.05    # 5% tolerance for low-rate links
    ABS_DIFF_GUARD = 0.5         # Mbps: require abs diff > 0.5 to trigger averaging
    STRONG_AGREE_DIFF = 0.005    # 0.5%: strong agreement floor

    def norm_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    def dynamic_tau(a: float, b: float) -> float:
        # Raise tolerance for low-rate signals to avoid over-correcting noise
        return ELEVATED_THRESHOLD if max(a, b) < LOW_RATE_MAX else HARDENING_THRESHOLD

    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with hardening threshold
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
=======
        else:
            # Link is up: enforce link symmetry with hardening threshold (magnitude-aware)
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            tau_ab = dynamic_tau(a_tx, b_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)

            abs_ab = abs(a_tx - b_rx)
            abs_ba = abs(b_tx - a_rx)

            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        penalty = 1.0 - 0.5 * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty)))
=======
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        # Status confidence is less sensitive to flow residuals; apply mild scaling using average penalty
        penalty_avg = 0.5 * (penalty_rx + penalty_tx)
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty_avg)))
>>>>>>> REPLACE
</DIFF>