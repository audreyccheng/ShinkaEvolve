<NAME>
directional_partial_averaging_and_confidence_calibration
</NAME>

<DESCRIPTION>
I propose two targeted improvements to boost counter repair accuracy and confidence calibration while preserving perfect status repair:

1) Partial averaging near the symmetry threshold (magnitude-aware). Instead of fully averaging endpoints as soon as we exceed τh, we now use a linear interpolation toward consensus within [τh, 2τh]. This reduces over-correction for small violations while still fixing larger ones. It aligns with the Hodor hardening principle and has proven effective in prior generations.

2) Direction-aware router residual penalties and confidence calibration. We replace the symmetric router penalty with direction-aware penalties for TX and RX (TX penalized by local residual more than remote; RX the opposite). We also improve calibration by:
   - Penalizing confidence when only one endpoint shows traffic (asymmetric evidence).
   - Scaling confidence by the magnitude of the applied change to the counters.

These changes are minimal, consistent with the existing structure, and should improve both counter repair and calibration without risking status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # Link is up: enforce link symmetry with τh tolerance (magnitude-aware)
            # Direction A->B (A.tx vs B.rx)
            diff_ab = norm_diff(a_tx, b_rx)
            tau_ab = dynamic_tau(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)
=======
            # Link is up: enforce link symmetry with τh tolerance (magnitude-aware)
            # Direction A->B (A.tx vs B.rx)
            diff_ab = norm_diff(a_tx, b_rx)
            tau_ab = dynamic_tau(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                if diff_ab <= 2.0 * tau_ab:
                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + avg_ab * k
                    rep_b_rx = b_rx * (1.0 - k) + avg_ab * k
                else:
                    rep_a_tx = avg_ab
                    rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Direction B->A (B.tx vs A.rx)
            diff_ba = norm_diff(b_tx, a_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
=======
            # Direction B->A (B.tx vs A.rx)
            diff_ba = norm_diff(b_tx, a_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                if diff_ba <= 2.0 * tau_ba:
                    k2 = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + avg_ba * k2
                    rep_a_rx = a_rx * (1.0 - k2) + avg_ba * k2
                else:
                    rep_b_tx = avg_ba
                    rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # pair_status == 'up'
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                status_conf = 0.8  # up due to traffic evidence
=======
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # pair_status == 'up'
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                status_conf = 0.8  # up due to traffic evidence

        # Asymmetric confidence when only one side shows traffic
        if (a_has != b_has):
            if not a_has:
                rx_conf_a *= 0.88
                tx_conf_a *= 0.88
            if not b_has:
                rx_conf_b *= 0.88
                tx_conf_b *= 0.88

        # Calibrate confidences by magnitude of applied change (improves calibration)
        def change_ratio(orig: float, rep: float) -> float:
            denom = max(abs(orig), abs(rep), 1.0)
            return abs(rep - orig) / denom

        a_rx_change = change_ratio(a_rx, rep_a_rx)
        a_tx_change = change_ratio(a_tx, rep_a_tx)
        b_rx_change = change_ratio(b_rx, rep_b_rx)
        b_tx_change = change_ratio(b_tx, rep_b_tx)

        rx_conf_a = max(0.0, min(1.0, min(rx_conf_a, 1.0 - a_rx_change)))
        tx_conf_a = max(0.0, min(1.0, min(tx_conf_a, 1.0 - a_tx_change)))
        rx_conf_b = max(0.0, min(1.0, min(rx_conf_b, 1.0 - b_rx_change)))
        tx_conf_b = max(0.0, min(1.0, min(tx_conf_b, 1.0 - b_tx_change)))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        penalty = 1.0 - ROUTER_PENALTY_WEIGHT * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + STATUS_PENALTY_BLEND * penalty)))
=======
        def clamp01(x: float) -> float:
            return max(0.0, min(1.0, float(x)))

        pen_tx = clamp01(1.0 - (0.6 * resid_local + 0.4 * resid_remote))
        pen_rx = clamp01(1.0 - (0.6 * resid_remote + 0.4 * resid_local))

        rx_conf = clamp01(rx_conf * pen_rx)
        tx_conf = clamp01(tx_conf * pen_tx)
        # Status confidence is less sensitive to flow residuals; apply mild scaling using the weaker directional penalty
        status_conf = clamp01(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
>>>>>>> REPLACE

</DIFF>