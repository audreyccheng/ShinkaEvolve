<NAME>
magnitude_aware_symmetry_and_directional_confidence
</NAME>

<DESCRIPTION>
I propose three targeted improvements inspired by network telemetry validation principles to boost counter repair accuracy and confidence calibration without sacrificing status accuracy:

1) Magnitude-aware symmetry repair with absolute guard: Use elevated tolerance (5%) for low-rate links and a 0.5 Mbps absolute guard to avoid over-correcting tiny flows. Apply strong confidence floors (0.98/0.99) for high-rate agreements and maintain repairs only when differences exceed both relative and absolute thresholds. This reduces erroneous averaging on noise and preserves correct counters.

2) Change-aware confidence calibration: After any repair, reduce the confidence in proportion to the magnitude of change applied to each counter. This better aligns confidence with the expected repair accuracy, improving calibration and reducing overconfidence.

3) Direction-aware router residual penalties: Scale TX confidence based more on the local router residual and RX confidence based more on the remote router residual (0.6/0.4 split). This aligns with traffic directionality and flow conservation, improving both calibration and counter quality.

These changes are minimal and localized: we add a few constants and helper functions, update the pairwise repair logic within the existing loop, add a small calibration step, and refine the final confidence penalties. No changes to function inputs/outputs or external behavior are introduced beyond improved robustness and calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-6  # small absolute tolerance for "no traffic"

    def norm_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    def has_traffic(d: Dict[str, Any]) -> bool:
        return (d.get('rx_rate', 0.0) > EPS) or (d.get('tx_rate', 0.0) > EPS)
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    LOW_RATE_MAX = 10.0             # Mbps; below this, allow elevated tolerance
    ELEVATED_THRESHOLD = 0.05       # 5% τh for low-rate links
    ABS_DIFF_GUARD = 0.5            # Mbps; require abs diff > 0.5 to trigger averaging
    STRONG_AGREE_DIFF = 0.005       # 0.5% strong agreement floor for high-rate agreements
    EPS = 1e-6  # small absolute tolerance for "no traffic"

    # Direction-aware weights for router residual penalties
    LOCAL_WEIGHT_TX = 0.6
    REMOTE_WEIGHT_TX = 0.4
    LOCAL_WEIGHT_RX = 0.4
    REMOTE_WEIGHT_RX = 0.6

    def norm_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)

    def dynamic_tau(a: float, b: float) -> float:
        return ELEVATED_THRESHOLD if max(a, b) < LOW_RATE_MAX else HARDENING_THRESHOLD
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with hardening threshold
            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            # Confidence decreases with magnitude of violation; if unchanged, slightly boost
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
=======
        else:
            # Link is up: enforce link symmetry with magnitude-aware τh and absolute guard
            tau_ab = dynamic_tau(a_tx, b_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)
            abs_ab = abs(a_tx - b_rx)
            abs_ba = abs(b_tx - a_rx)

            # Direction A->B (A.tx vs B.rx)
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            # Confidence handling with strong floors when within tolerance
            conf_ab = max(0.0, 1.0 - diff_ab)
            if max(a_tx, b_rx) >= LOW_RATE_MAX and diff_ab <= STRONG_AGREE_DIFF:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            # Direction B->A (B.tx vs A.rx)
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if max(b_tx, a_rx) >= LOW_RATE_MAX and diff_ba <= STRONG_AGREE_DIFF:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        per_if_repair[a_id] = {
=======
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        # Confidence refinement: penalize by magnitude of applied change to improve calibration
        def _change_ratio(orig: float, rep: float) -> float:
            denom = max(abs(orig), abs(rep), 1.0)
            return abs(rep - orig) / denom

        a_rx_change = _change_ratio(a_rx, rep_a_rx)
        a_tx_change = _change_ratio(a_tx, rep_a_tx)
        b_rx_change = _change_ratio(b_rx, rep_b_rx)
        b_tx_change = _change_ratio(b_tx, rep_b_tx)

        rx_conf_a = max(0.0, min(1.0, min(rx_conf_a, 1.0 - 0.8 * a_rx_change)))
        tx_conf_a = max(0.0, min(1.0, min(tx_conf_a, 1.0 - 0.8 * a_tx_change)))
        rx_conf_b = max(0.0, min(1.0, min(rx_conf_b, 1.0 - 0.8 * b_rx_change)))
        tx_conf_b = max(0.0, min(1.0, min(tx_conf_b, 1.0 - 0.8 * b_tx_change)))

        per_if_repair[a_id] = {
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        penalty = 1.0 - 0.5 * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty)))
=======
        # Direction-aware penalties: TX depends more on local router, RX more on remote
        penalty_tx = 1.0 - (LOCAL_WEIGHT_TX * resid_local + REMOTE_WEIGHT_TX * resid_remote)
        penalty_rx = 1.0 - (LOCAL_WEIGHT_RX * resid_local + REMOTE_WEIGHT_RX * resid_remote)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        # Status confidence mildly scaled by average of direction penalties
        penalty_avg = 0.5 * (penalty_tx + penalty_rx)
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty_avg)))
>>>>>>> REPLACE
</DIFF>