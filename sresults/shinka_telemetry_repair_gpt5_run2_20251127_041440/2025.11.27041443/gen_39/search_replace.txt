<NAME>
weighted_consensus_and_router_residuals
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter_repair_accuracy while preserving good confidence calibration:

1) Replace simple averaging with trust-weighted directional consensus for link symmetry repairs. By weighting toward the endpoint with stronger activity (higher tx/rx magnitude), we better utilize redundancy and reduce bias from a noisier side. Partial averaging near the threshold is preserved to avoid overcorrection.

2) Add router-level flow conservation checks:
   - Perform tightly scoped micro-adjustments on dominating, unpaired interfaces to reduce per-router TX/RX imbalances, capped at 2% and only when a single interface accounts for the majority of the imbalance. This increases accuracy without broad, risky changes.
   - Apply direction-aware confidence penalties based on per-router residuals to calibrate confidences with conservation quality, using a gentle floor to avoid over-penalization.

These changes are consistent with the Hodor three-step approach (hardening and dynamic checking) and prior recommendations. They should improve the combined score by boosting counter accuracy while keeping (and even improving) confidence calibration alignment.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                avg_ab = 0.5 * (a_tx + b_rx)
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + avg_ab * k
                    new_b_rx = b_rx * (1.0 - k) + avg_ab * k
                else:
                    # Full averaging for clear violations
                    new_a_tx = avg_ab
                    new_b_rx = avg_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
=======
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                # Trust-weighted consensus using activity magnitude as reliability proxy
                act_a = max(a_tx, a_rx)
                act_b = max(b_tx, b_rx)
                denom_act = max(1e-9, act_a + act_b)
                w_a = act_a / denom_act
                w_b = act_b / denom_act
                consensus_ab = w_a * a_tx + w_b * b_rx
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                else:
                    # Clear violation: converge fully to consensus
                    new_a_tx = consensus_ab
                    new_b_rx = consensus_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                avg_ba = 0.5 * (b_tx + a_rx)
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + avg_ba * k
                    new_a_rx = a_rx * (1.0 - k) + avg_ba * k
                else:
                    new_b_tx = avg_ba
                    new_a_rx = avg_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
=======
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                # Trust-weighted consensus using activity magnitude as reliability proxy
                act_a = max(a_tx, a_rx)
                act_b = max(b_tx, b_rx)
                denom_act = max(1e-9, act_a + act_b)
                w_a = act_a / denom_act
                w_b = act_b / denom_act
                consensus_ba = w_b * b_tx + w_a * a_rx
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                else:
                    new_b_tx = consensus_ba
                    new_a_rx = consensus_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        result[interface_id] = repaired

    return result
=======
        result[interface_id] = repaired

    # Router-level flow conservation: micro-adjustments on dominating dangling interfaces
    # Build router->interfaces mapping using provided topology and telemetry hints
    router_ifaces: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        if lr:
            router_ifaces.setdefault(lr, [])
            if if_id not in router_ifaces[lr]:
                router_ifaces[lr].append(if_id)
        rr = d.get('remote_router')
        if rr and rr not in router_ifaces:
            router_ifaces[rr] = []

    # Compute initial per-router sums
    router_sums: Dict[str, Tuple[float, float]] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for iid in if_list:
            if iid in result:
                sum_tx += float(result[iid]['tx_rate'][1])
                sum_rx += float(result[iid]['rx_rate'][1])
        router_sums[r] = (sum_tx, sum_rx)

    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue  # already balanced

        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom

        candidates = []
        for iid in if_list:
            if iid not in result:
                continue
            status = result[iid]['interface_status'][1]
            if status != 'up':
                continue
            # Unpaired if peer missing in telemetry
            connected_to = result[iid].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            if not is_unpaired:
                continue
            txv = float(result[iid]['tx_rate'][1])
            rxv = float(result[iid]['rx_rate'][1])
            contrib = abs(txv - rxv)
            candidates.append((contrib, iid, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']

        if imbalance > 0.0:
            # sum_tx > sum_rx: decrease tx or increase rx; adjust only larger counter
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(tc))
            else:
                new_rx = rrx * (1.0 + alpha)
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(rc))
        else:
            # sum_tx < sum_rx: decrease rx or increase tx; adjust only larger counter
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(rc))
            else:
                new_tx = rtx * (1.0 + alpha)
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(tc))

    # Recompute per-router residual mismatch from possibly adjusted values
    router_resid: Dict[str, float] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for iid in if_list:
            if iid in result:
                sum_tx += float(result[iid]['tx_rate'][1])
                sum_rx += float(result[iid]['rx_rate'][1])
        denom = max(1.0, sum_tx, sum_rx)
        router_resid[r] = abs(sum_tx - sum_rx) / denom

    # Apply direction-aware confidence penalties with a gentle floor
    for iid, d in telemetry.items():
        if iid not in result:
            continue
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.7, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.7, 1.0)
        orx, rrx, rc = result[iid]['rx_rate']
        otx, rtx, tc = result[iid]['tx_rate']
        result[iid]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))
        result[iid]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))

    return result
>>>>>>> REPLACE
</DIFF>