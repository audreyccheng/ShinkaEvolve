<NAME>
asymmetric_partial_and_safer_micro
</NAME>

<DESCRIPTION>
I propose two targeted changes to improve counter repair accuracy and confidence calibration without hurting status accuracy:

1) Asymmetric partial averaging with dynamic absolute guards in pairwise consensus:
   - When link symmetry violations are modest (between τh and up to 2·τh, or 1.6·τh for low-rate links), move endpoints partially toward consensus instead of full averaging, and move the louder side more. For low-rate links, use a slightly more aggressive ramp (exponent 1.2) and a lower absolute guard (0.3 Mbps). This reduces over-correction on near-threshold and low-rate pairs, improving counter accuracy and confidence calibration.

2) Safer, benefit-checked micro-adjustments at the router level:
   - Replace distribution-based nudges with a dominant unpaired-interface-only micro-adjustment that reduces the dominant direction and commits only if it improves router residual by ≥8% and does not increase the interface’s internal |tx − rx| beyond 3% relative. Optionally perform a second small step when the first improved ≥20%. Also require residual ≥3% and sufficient interface magnitude to avoid nudging tiny flows. This reduces harmful adjustments that may degrade counter accuracy and overconfident outputs.

These changes are consistent with the Hodor principles, use topology, and preserve strong status handling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Thresholds and constants
    TH_REL_DEFAULT = 0.02   # 2% relative tolerance (τh)
    TH_REL_LOW = 0.05       # 5% when flows are small (<10 Mbps)
    TH_ABS_GUARD = 0.5      # require >0.5 Mbps absolute diff to trigger averaging
    EPS = 1e-6

    # Router micro-adjustment caps
    MICRO_DOMINANT_FRACTION = 0.20  # cap single dominant interface adjustment to ≤20% of its directional magnitude
    MICRO_DISTRIB_FRACTION = 0.10   # cap distributed adjustments to ≤10% of each interface's directional magnitude
=======
    # Thresholds and constants
    TH_REL_DEFAULT = 0.02   # 2% relative tolerance (τh)
    TH_REL_LOW = 0.05       # 5% when flows are small (<10 Mbps)
    TH_ABS_GUARD = 0.5      # require >0.5 Mbps absolute diff to trigger averaging
    ABS_GUARD_LOW = 0.3     # 0.3 Mbps absolute guard for low-rate links
    LOW_RATE_CUTOFF = 10.0  # Mbps threshold for low-rate behavior
    EPS = 1e-6

    # Router micro-adjustment guards (benefit-checked dominant-only)
    RESID_MIN = 0.03        # minimum router residual fraction to trigger micro-adjustments
    IMPROVE_REQ = 0.08      # require ≥8% residual improvement to commit
    SECOND_STEP_REQ = 0.20  # allow second mini-step if improvement ≥20%
    SECOND_STEP_MAX = 0.01  # second step cap (≤1% of router scale)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)

            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
                v = 0.5 * (a_tx + b_rx)
                rep_a_tx = v
                rep_b_rx = v
                conf_base = max(0.0, 1.0 - d_ab)
                # Penalize by applied change magnitude for calibration
                change_a = change_ratio(a_tx, v)
                change_b = change_ratio(b_rx, v)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)
=======
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < LOW_RATE_CUTOFF else TH_REL_DEFAULT
            guard_ab = ABS_GUARD_LOW if max_ab < LOW_RATE_CUTOFF else TH_ABS_GUARD
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            partial_upper = (1.6 * thr_rel_ab) if max_ab < LOW_RATE_CUTOFF else (2.0 * thr_rel_ab)

            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                conf_base = max(0.0, 1.0 - d_ab)
                # Penalize by applied change magnitude for calibration
                change_a = change_ratio(a_tx, rep_a_tx)
                change_b = change_ratio(b_rx, rep_b_rx)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= LOW_RATE_CUTOFF and d_ab <= 0.005:
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= LOW_RATE_CUTOFF else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)

            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
                v2 = 0.5 * (b_tx + a_rx)
                rep_b_tx = v2
                rep_a_rx = v2
                conf_base2 = max(0.0, 1.0 - d_ba)
                change_b2 = change_ratio(b_tx, v2)
                change_a2 = change_ratio(a_rx, v2)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
=======
            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < LOW_RATE_CUTOFF else TH_REL_DEFAULT
            guard_ba = ABS_GUARD_LOW if max_ba < LOW_RATE_CUTOFF else TH_ABS_GUARD
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            partial_upper_ba = (1.6 * thr_rel_ba) if max_ba < LOW_RATE_CUTOFF else (2.0 * thr_rel_ba)

            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                conf_base2 = max(0.0, 1.0 - d_ba)
                change_b2 = change_ratio(b_tx, rep_b_tx)
                change_a2 = change_ratio(a_rx, rep_a_rx)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= LOW_RATE_CUTOFF and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= LOW_RATE_CUTOFF else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Router-level micro-adjustments for flow conservation using only dangling, up interfaces
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        present = [iid for iid in if_list if iid in per_if]
        if not present:
            continue

        # Compute current sums
        sum_tx = sum(to_float(per_if[iid]['repaired_tx']) for iid in present)
        sum_rx = sum(to_float(per_if[iid]['repaired_rx']) for iid in present)
        delta = sum_tx - sum_rx  # want to drive toward zero
        scale = max(sum_tx, sum_rx, 1.0)
        # Skip tiny imbalances (use both relative τ and absolute guard)
        if abs(delta) <= max(TH_ABS_GUARD, TH_REL_DEFAULT * scale):
            continue

        # Candidates: dangling and up
        candidates = []
        for iid in present:
            if iid in paired_ids:
                continue
            if per_if[iid].get('repaired_status', 'up') == 'down':
                continue
            rep_tx = to_float(per_if[iid]['repaired_tx'])
            rep_rx = to_float(per_if[iid]['repaired_rx'])
            candidates.append((iid, rep_tx, rep_rx))

        if not candidates:
            continue

        # Direction to adjust: if delta > 0 (TX surplus), increase RX; if delta < 0 (RX surplus), increase TX
        # Weights by directional magnitude
        if delta > 0:
            weights = [(iid, tx) for (iid, tx, rx) in candidates]
        else:
            weights = [(iid, rx) for (iid, tx, rx) in candidates]

        sum_w = sum(max(w, 0.0) for _, w in weights)
        if sum_w <= EPS:
            continue

        # Dominant candidate logic: if a single interface has >50% of directional weight, micro-adjust only it
        weights_sorted = sorted(weights, key=lambda x: x[1], reverse=True)
        top_id, top_w = weights_sorted[0]
        if top_w / sum_w >= 0.5:
            # Micro-adjust cap by fraction of its directional magnitude
            max_adjust = MICRO_DOMINANT_FRACTION * max(top_w, 1.0)
            inc = min(abs(delta), max_adjust)
            if inc > 0.0:
                if delta > 0:
                    # Increase RX on top_id
                    orig = to_float(telemetry.get(top_id, {}).get('rx_rate', 0.0))
                    new_val = to_float(per_if[top_id]['repaired_rx']) + inc
                    per_if[top_id]['repaired_rx'] = new_val
                    cr = change_ratio(orig, new_val)
                    per_if[top_id]['rx_conf'] = max(0.0, min(float(per_if[top_id].get('rx_conf', 0.6)), 1.0 - 0.8 * cr))
                else:
                    # Increase TX on top_id
                    orig = to_float(telemetry.get(top_id, {}).get('tx_rate', 0.0))
                    new_val = to_float(per_if[top_id]['repaired_tx']) + inc
                    per_if[top_id]['repaired_tx'] = new_val
                    cr = change_ratio(orig, new_val)
                    per_if[top_id]['tx_conf'] = max(0.0, min(float(per_if[top_id].get('tx_conf', 0.6)), 1.0 - 0.8 * cr))
        else:
            # Distribute with per-interface cap for micro adjustments
            for iid, w in weights:
                share = (w / sum_w) if sum_w > 0 else 0.0
                inc = abs(delta) * share
                cap = MICRO_DISTRIB_FRACTION * max(w, 1.0)
                inc = min(inc, cap)
                if inc <= 0.0:
                    continue
                if delta > 0:
                    # Increase RX
                    orig = to_float(telemetry.get(iid, {}).get('rx_rate', 0.0))
                    new_val = to_float(per_if[iid]['repaired_rx']) + inc
                    per_if[iid]['repaired_rx'] = new_val
                    cr = change_ratio(orig, new_val)
                    per_if[iid]['rx_conf'] = max(0.0, min(float(per_if[iid].get('rx_conf', 0.6)), 1.0 - 0.7 * cr))
                else:
                    # Increase TX
                    orig = to_float(telemetry.get(iid, {}).get('tx_rate', 0.0))
                    new_val = to_float(per_if[iid]['repaired_tx']) + inc
                    per_if[iid]['repaired_tx'] = new_val
                    cr = change_ratio(orig, new_val)
                    per_if[iid]['tx_conf'] = max(0.0, min(float(per_if[iid].get('tx_conf', 0.6)), 1.0 - 0.7 * cr))
=======
    # Router-level micro-adjustments for flow conservation using only dangling, up interfaces (benefit-checked)
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        present = [iid for iid in if_list if iid in per_if]
        if not present:
            continue

        # Compute current sums
        sum_tx = sum(to_float(per_if[iid]['repaired_tx']) for iid in present)
        sum_rx = sum(to_float(per_if[iid]['repaired_rx']) for iid in present)
        delta = sum_tx - sum_rx  # want to drive toward zero
        scale = max(sum_tx, sum_rx, 1.0)
        resid = abs(delta) / scale

        # Trigger only on sufficiently large residuals
        if resid < RESID_MIN or abs(delta) <= EPS:
            continue

        # Candidates: dangling, up, sufficient magnitude, and aligned with imbalance
        candidates: List[Tuple[str, float, float, float]] = []
        for iid in present:
            if iid in paired_ids:
                continue
            if per_if[iid].get('repaired_status', 'up') == 'down':
                continue
            cur_tx = to_float(per_if[iid]['repaired_tx'])
            cur_rx = to_float(per_if[iid]['repaired_rx'])
            if max(cur_tx, cur_rx) < LOW_RATE_CUTOFF:
                continue
            contrib = cur_tx - cur_rx
            if (delta > 0 and contrib > 0) or (delta < 0 and contrib < 0):
                candidates.append((iid, contrib, cur_tx, cur_rx))

        if not candidates:
            continue

        total_same_dir = sum(abs(c[1]) for c in candidates) or EPS
        dom_iid, dom_contrib, cur_tx, cur_rx = max(candidates, key=lambda t: abs(t[1]))
        if abs(dom_contrib) / total_same_dir < 0.6:
            continue

        # Tentative nudge: reduce the dominant direction on the dominant interface
        alpha = min(0.02, 0.5 * resid)
        step = alpha * scale
        new_tx, new_rx = cur_tx, cur_rx
        if delta > 0 and dom_contrib > 0:
            # Too much TX globally; reduce TX on this interface
            new_tx = max(0.0, cur_tx - min(step, cur_tx))
        elif delta < 0 and dom_contrib < 0:
            # Too much RX globally; reduce RX on this interface
            new_rx = max(0.0, cur_rx - min(step, cur_rx))
        else:
            continue

        # Internal TX/RX skew guard (≤3%)
        old_int = abs(cur_tx - cur_rx) / max(1.0, max(cur_tx, cur_rx))
        new_int = abs(new_tx - new_rx) / max(1.0, max(new_tx, new_rx, 1.0))
        if new_int > 0.03 + 1e-9:
            continue

        # Commit only if router residual improves sufficiently
        sum_tx_new = sum_tx - cur_tx + new_tx
        sum_rx_new = sum_rx - cur_rx + new_rx
        resid_new = abs(sum_tx_new - sum_rx_new) / max(sum_tx_new, sum_rx_new, 1.0)
        if resid_new <= (1.0 - IMPROVE_REQ) * resid:
            # Commit change
            per_if[dom_iid]['repaired_tx'] = new_tx
            per_if[dom_iid]['repaired_rx'] = new_rx

            # Optional second mini-step if strong improvement and residual still meaningful
            if resid_new <= (1.0 - SECOND_STEP_REQ) * resid and resid_new >= 0.04:
                alpha2 = min(SECOND_STEP_MAX, 0.5 * resid_new)
                step2 = alpha2 * scale
                cur_tx2, cur_rx2 = new_tx, new_rx
                if delta > 0 and dom_contrib > 0:
                    cand_tx2 = max(0.0, cur_tx2 - min(step2, cur_tx2))
                    cand_rx2 = cur_rx2
                else:
                    cand_rx2 = max(0.0, cur_rx2 - min(step2, cur_rx2))
                    cand_tx2 = cur_tx2
                new_int2 = abs(cand_tx2 - cand_rx2) / max(1.0, max(cand_tx2, cand_rx2, 1.0))
                sum_tx_new2 = sum_tx - cur_tx + cand_tx2
                sum_rx_new2 = sum_rx - cur_rx + cand_rx2
                resid_new2 = abs(sum_tx_new2 - sum_rx_new2) / max(sum_tx_new2, sum_rx_new2, 1.0)
                if new_int2 <= 0.03 + 1e-9 and resid_new2 < resid_new:
                    per_if[dom_iid]['repaired_tx'] = cand_tx2
                    per_if[dom_iid]['repaired_rx'] = cand_rx2
                    resid_new = resid_new2

            # Confidence penalty proportional to applied change
            tx_orig = to_float(telemetry.get(dom_iid, {}).get('tx_rate', 0.0))
            rx_orig = to_float(telemetry.get(dom_iid, {}).get('rx_rate', 0.0))
            tx_change = change_ratio(tx_orig, to_float(per_if[dom_iid]['repaired_tx']))
            rx_change = change_ratio(rx_orig, to_float(per_if[dom_iid]['repaired_rx']))
            per_if[dom_iid]['tx_conf'] = max(0.0, min(float(per_if[dom_iid].get('tx_conf', 0.6)), 1.0 - 0.8 * tx_change))
            per_if[dom_iid]['rx_conf'] = max(0.0, min(float(per_if[dom_iid].get('rx_conf', 0.6)), 1.0 - 0.8 * rx_change))
>>>>>>> REPLACE