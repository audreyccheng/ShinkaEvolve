<NAME>
tri_axis_confidence_composition
</NAME>

<DESCRIPTION>
The current algorithm achieves strong counter repair accuracy but suffers from poor confidence calibration because it only scales confidences by router residual penalties at the end. This ignores two critical indicators of reliability: (1) how well a repaired value matches its peer after repair (link symmetry fit) and (2) how much the value was changed from the original (correction magnitude). To improve calibration without altering the repair values themselves, I replace the final confidence-scaling section with a tri-axis composition:
- Direction-aware router penalties (existing),
- Link symmetry fit after repair,
- Correction magnitude penalty.

I also add magnitude-aware floors for strong agreements and asymmetric traffic-evidence shaping (penalize silent side when peer shows traffic). Status confidence is also mildly aligned with these updated per-direction confidences while retaining residual-based scaling. This change is localized to the final pass and should significantly improve confidence calibration while keeping counter accuracy intact.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Apply direction-aware penalties with gentler floor and mild status scaling
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.5, 1.0)
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))
        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))
        status_scale = 0.85 + 0.15 * min(penalty_tx, penalty_rx)
        result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
=======
    # Apply tri-axis confidence composition:
    # - direction-aware router penalties,
    # - link symmetry fit after repair,
    # - correction magnitude; plus magnitude-aware floors and asymmetric traffic-evidence shaping.
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.5, 1.0)

        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']

        # If repaired status is down, keep zeros and only scale confidences by router penalties
        if rst == 'down':
            result[if_id]['rx_rate'] = (orx, 0.0, clamp(rc * penalty_rx))
            result[if_id]['tx_rate'] = (otx, 0.0, clamp(tc * penalty_tx))
            status_scale = 0.85 + 0.15 * min(penalty_tx, penalty_rx)
            result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
            continue

        # Peer repaired values for symmetry assessment
        peer_id = d.get('connected_to')
        peer_exists = (peer_id in result) if peer_id else False
        if peer_exists:
            _, peer_rrx, _ = result[peer_id]['rx_rate']
            _, peer_rtx, _ = result[peer_id]['tx_rate']
        else:
            peer_rrx = None
            peer_rtx = None

        # Symmetry fit after repair
        if peer_exists and peer_rrx is not None and peer_rtx is not None:
            diff_tx = rel_diff(rtx, peer_rrx)  # my_tx vs their_rx
            diff_rx = rel_diff(rrx, peer_rtx)  # my_rx vs their_tx
            c_sym_tx = clamp(1.0 - diff_tx)
            c_sym_rx = clamp(1.0 - diff_rx)

            # Magnitude-aware thresholds and floors
            th_tx = 0.05 if max(rtx, peer_rrx) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
            th_rx = 0.05 if max(rrx, peer_rtx) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
            if max(rtx, peer_rrx) >= 10.0 and diff_tx <= 0.005:
                floor_tx = 0.99
            elif diff_tx <= th_tx:
                floor_tx = 0.98 if max(rtx, peer_rrx) >= 10.0 else 0.97
            else:
                floor_tx = 0.0
            if max(rrx, peer_rtx) >= 10.0 and diff_rx <= 0.005:
                floor_rx = 0.99
            elif diff_rx <= th_rx:
                floor_rx = 0.98 if max(rrx, peer_rtx) >= 10.0 else 0.97
            else:
                floor_rx = 0.0
        else:
            # No redundancy; use conservative defaults
            c_sym_tx = 0.9
            c_sym_rx = 0.9
            floor_tx = 0.0
            floor_rx = 0.0

        # Correction magnitude component (bigger changes => lower confidence)
        m_tx = abs(rtx - otx) / max(1.0, rtx, otx)
        m_rx = abs(rrx - orx) / max(1.0, rrx, orx)
        c_delta_tx = clamp(1.0 - min(1.0, 1.5 * m_tx))
        c_delta_rx = clamp(1.0 - min(1.0, 1.5 * m_rx))

        # Compose final confidences
        conf_tx_new = clamp(0.45 * penalty_tx + 0.35 * c_sym_tx + 0.20 * c_delta_tx)
        conf_rx_new = clamp(0.45 * penalty_rx + 0.35 * c_sym_rx + 0.20 * c_delta_rx)

        # Apply magnitude-aware floors
        conf_tx_new = max(conf_tx_new, floor_tx)
        conf_rx_new = max(conf_rx_new, floor_rx)

        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and peer_rrx is not None and rtx <= QUIET_EPS and peer_rrx > QUIET_EPS:
            conf_tx_new = clamp(conf_tx_new * 0.88)
        if peer_exists and peer_rtx is not None and rrx <= QUIET_EPS and peer_rtx > QUIET_EPS:
            conf_rx_new = clamp(conf_rx_new * 0.88)

        result[if_id]['tx_rate'] = (otx, rtx, conf_tx_new)
        result[if_id]['rx_rate'] = (orx, rrx, conf_rx_new)

        # Status confidence shaping: residual-based scaling + mild alignment with per-direction confidences
        status_scale = 0.85 + 0.15 * min(penalty_tx, penalty_rx)
        status_conf_new = clamp(sc * status_scale)
        status_conf_new = clamp(status_conf_new * (0.85 + 0.15 * min(conf_tx_new, conf_rx_new)))
        result[if_id]['interface_status'] = (ost, rst, status_conf_new)
>>>>>>> REPLACE

</DIFF>