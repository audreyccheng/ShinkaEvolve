<NAME>
asym_partial_and_router_improvecheck
</NAME>

<DESCRIPTION>
I propose two targeted improvements to boost counter repair accuracy while preserving our already strong calibration:

1) Asymmetric, low-rate–aware partial averaging in pair consensus (Stage 1)
   - Replace the single symmetric k used when diff is near tolerance with asymmetric k_loud/k_quiet that moves the louder side more toward consensus, with low-rate acceleration and dynamic absolute guards. This reduces overcorrection on the quieter side and improves fit without harming high-rate accuracy.

2) Benefit-checked router-balanced reconciliation (Stage 2)
   - Convert the proportional router adjustments into a tentative application that is committed only if the router residual improves by at least 8%. Also avoid nudging extremely small flows (<1 Mbps). This prevents harmful adjustments that might degrade counter accuracy on balanced routers or in noisy low-rate conditions.

These changes should improve counter_repair_accuracy by better aligning pair symmetry with less bias and by preventing detrimental router-level adjustments, while maintaining our confidence calibration scheme unchanged.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    HARDENING_THRESHOLD = 0.02     # ~2% for normal rates
    LOW_RATE_CUTOFF = 10.0         # Mbps; use relaxed 5% when both sides are tiny
    LOW_RATE_THRESHOLD = 0.05      # 5% tolerance for low-rate flows
    ABS_GUARD = 0.5                # Mbps; absolute guard to avoid over-correcting tiny flows
    QUIET_EPS = 0.1                # Mbps; traffic "silence" threshold
    ROUTER_RESID_TRIGGER = 0.03    # Trigger router-balanced reconciliation at >=3% mismatch
    ROUTER_BUDGET_CAP = 0.015      # Cap router-wide adjustment budget to 1.5% of router traffic
=======
    HARDENING_THRESHOLD = 0.02     # ~2% for normal rates
    LOW_RATE_CUTOFF = 10.0         # Mbps; use relaxed 5% when both sides are tiny
    LOW_RATE_THRESHOLD = 0.05      # 5% tolerance for low-rate flows
    ABS_GUARD = 0.5                # Mbps; absolute guard to avoid over-correcting tiny flows
    QUIET_EPS = 0.1                # Mbps; traffic "silence" threshold
    ROUTER_RESID_TRIGGER = 0.03    # Trigger router-balanced reconciliation at >=3% mismatch
    ROUTER_BUDGET_CAP = 0.015      # Cap router-wide adjustment budget to 1.5% of router traffic
    SMALL_RATE_CUTOFF = 1.0        # Mbps; avoid router adjustments on extremely small flows
    IMPROVE_REQ = 0.08             # Require ≥8% residual improvement to commit router adjustments
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Direction a->b: a_tx vs b_rx
        abs_ab = abs(a_tx - b_rx)
        tol_ab = dir_threshold(a_tx, b_rx)
        diff_ab = abs_ab / max(1.0, a_tx, b_rx)

        if diff_ab > tol_ab and abs_ab > ABS_GUARD:
            # Activity-weighted consensus (bias to stronger magnitude)
            act_a = max(a_tx, a_rx)
            act_b = max(b_tx, b_rx)
            denom = max(1e-9, act_a + act_b)
            w_a = act_a / denom
            w_b = act_b / denom
            consensus_ab = w_a * a_tx + w_b * b_rx
            if diff_ab <= 2 * tol_ab:
                k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                vals[a_id]['tx'] = a_tx * (1.0 - k) + consensus_ab * k
                vals[b_id]['rx'] = b_rx * (1.0 - k) + consensus_ab * k
            else:
                vals[a_id]['tx'] = consensus_ab
                vals[b_id]['rx'] = consensus_ab
        # else within tolerance -> no change (confidence floors applied later)
=======
        # Direction a->b: a_tx vs b_rx
        abs_ab = abs(a_tx - b_rx)
        tol_ab = dir_threshold(a_tx, b_rx)
        diff_ab = abs_ab / max(1.0, a_tx, b_rx)
        # Low-rate–aware absolute guard and convergence shaping
        low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
        abs_guard_ab = 0.3 if low_band_ab else ABS_GUARD
        full_mult_ab = 1.6 if low_band_ab else 2.0
        exp_ab = 1.2 if low_band_ab else 1.0

        if diff_ab > tol_ab and abs_ab > abs_guard_ab:
            # Activity-weighted consensus (bias to stronger magnitude)
            act_a = max(a_tx, a_rx)
            act_b = max(b_tx, b_rx)
            denom = max(1e-9, act_a + act_b)
            w_a = act_a / denom
            w_b = act_b / denom
            consensus_ab = w_a * a_tx + w_b * b_rx
            if diff_ab <= full_mult_ab * tol_ab:
                # Asymmetric partial averaging: louder side moves more toward consensus
                k_raw = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                k_base = max(0.0, min(1.0, k_raw ** exp_ab))
                s = max(1e-9, a_tx + b_rx)
                a_share = a_tx / s
                b_share = b_rx / s
                if a_tx >= b_rx:
                    k_a = min(1.0, k_base * (1.0 + 0.5 * a_share))
                    k_b = min(1.0, k_base * (1.0 - 0.5 * b_share))
                else:
                    k_b = min(1.0, k_base * (1.0 + 0.5 * b_share))
                    k_a = min(1.0, k_base * (1.0 - 0.5 * a_share))
                vals[a_id]['tx'] = a_tx * (1.0 - k_a) + consensus_ab * k_a
                vals[b_id]['rx'] = b_rx * (1.0 - k_b) + consensus_ab * k_b
            else:
                vals[a_id]['tx'] = consensus_ab
                vals[b_id]['rx'] = consensus_ab
        # else within tolerance -> no change (confidence floors applied later)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Direction b->a: b_tx vs a_rx
        abs_ba = abs(b_tx - a_rx)
        tol_ba = dir_threshold(b_tx, a_rx)
        diff_ba = abs_ba / max(1.0, b_tx, a_rx)

        if diff_ba > tol_ba and abs_ba > ABS_GUARD:
            act_a = max(a_tx, a_rx)
            act_b = max(b_tx, b_rx)
            denom = max(1e-9, act_a + act_b)
            w_a = act_a / denom
            w_b = act_b / denom
            consensus_ba = w_b * b_tx + w_a * a_rx
            if diff_ba <= 2 * tol_ba:
                k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                vals[b_id]['tx'] = b_tx * (1.0 - k) + consensus_ba * k
                vals[a_id]['rx'] = a_rx * (1.0 - k) + consensus_ba * k
            else:
                vals[b_id]['tx'] = consensus_ba
                vals[a_id]['rx'] = consensus_ba
=======
        # Direction b->a: b_tx vs a_rx
        # Refresh values for this direction to reflect any prior adjustments
        b_tx = vals[b_id]['tx']
        a_rx = vals[a_id]['rx']
        abs_ba = abs(b_tx - a_rx)
        tol_ba = dir_threshold(b_tx, a_rx)
        diff_ba = abs_ba / max(1.0, b_tx, a_rx)
        low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
        abs_guard_ba = 0.3 if low_band_ba else ABS_GUARD
        full_mult_ba = 1.6 if low_band_ba else 2.0
        exp_ba = 1.2 if low_band_ba else 1.0

        if diff_ba > tol_ba and abs_ba > abs_guard_ba:
            act_a = max(a_tx, a_rx)
            act_b = max(b_tx, b_rx)
            denom = max(1e-9, act_a + act_b)
            w_a = act_a / denom
            w_b = act_b / denom
            consensus_ba = w_b * b_tx + w_a * a_rx
            if diff_ba <= full_mult_ba * tol_ba:
                k_raw = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                k_base = max(0.0, min(1.0, k_raw ** exp_ba))
                s2 = max(1e-9, b_tx + a_rx)
                b_share = b_tx / s2
                a_share = a_rx / s2
                if b_tx >= a_rx:
                    k_b = min(1.0, k_base * (1.0 + 0.5 * b_share))
                    k_a = min(1.0, k_base * (1.0 - 0.5 * a_share))
                else:
                    k_a = min(1.0, k_base * (1.0 + 0.5 * a_share))
                    k_b = min(1.0, k_base * (1.0 - 0.5 * b_share))
                vals[b_id]['tx'] = b_tx * (1.0 - k_b) + consensus_ba * k_b
                vals[a_id]['rx'] = a_rx * (1.0 - k_a) + consensus_ba * k_a
            else:
                vals[b_id]['tx'] = consensus_ba
                vals[a_id]['rx'] = consensus_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    router_sums = compute_router_sums(vals)
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        denom_r = max(1.0, sum_tx, sum_rx)
        delta = sum_tx - sum_rx
        resid = abs(delta) / denom_r
        if resid < ROUTER_RESID_TRIGGER or not if_list:
            continue

        # Determine whether to reduce the dominant side
        reduce_tx = delta > 0.0  # too much TX
        reduce_rx = delta < 0.0  # too much RX

        # Collect candidates and total mass for proportional distribution
        if reduce_tx:
            # Outgoing directions at router r => this router's tx counters
            outs = [iid for iid in if_list if status_orig.get(iid, 'unknown') != 'down' and peers.get(iid)]
            total_mass = sum(vals[iid]['tx'] for iid in outs) or 0.0
            if total_mass <= 0.0:
                continue
            budget = min(abs(delta), ROUTER_BUDGET_CAP * denom_r)
            for iid in outs:
                share = vals[iid]['tx'] / total_mass if total_mass > 0 else 0.0
                d_i = budget * share
                if d_i <= 0.0:
                    continue
                # Apply to local tx
                new_tx = max(0.0, vals[iid]['tx'] - d_i)
                vals[iid]['tx'] = new_tx
                # Mirror to peer's rx if peer exists and not explicitly down
                pid = peers.get(iid)
                if pid and status_orig.get(pid, 'unknown') != 'down':
                    vals[pid]['rx'] = max(0.0, vals[pid]['rx'] - d_i)
        elif reduce_rx:
            # Incoming directions at router r => this router's rx counters
            ins = [iid for iid in if_list if status_orig.get(iid, 'unknown') != 'down' and peers.get(iid)]
            total_mass = sum(vals[iid]['rx'] for iid in ins) or 0.0
            if total_mass <= 0.0:
                continue
            budget = min(abs(delta), ROUTER_BUDGET_CAP * denom_r)
            for iid in ins:
                share = vals[iid]['rx'] / total_mass if total_mass > 0 else 0.0
                d_i = budget * share
                if d_i <= 0.0:
                    continue
                # Apply to local rx
                new_rx = max(0.0, vals[iid]['rx'] - d_i)
                vals[iid]['rx'] = new_rx
                # Mirror to peer's tx if peer exists and not explicitly down
                pid = peers.get(iid)
                if pid and status_orig.get(pid, 'unknown') != 'down':
                    vals[pid]['tx'] = max(0.0, vals[pid]['tx'] - d_i)
=======
    router_sums = compute_router_sums(vals)

    # Helper to compute residual for a single router on current vals
    def compute_router_resid_local(router_id: str) -> float:
        s_tx, s_rx = 0.0, 0.0
        for iid in router_ifaces.get(router_id, []):
            if iid in vals:
                s_tx += float(vals[iid]['tx'])
                s_rx += float(vals[iid]['rx'])
        return abs(s_tx - s_rx) / max(1.0, s_tx, s_rx)

    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        denom_r = max(1.0, sum_tx, sum_rx)
        delta = sum_tx - sum_rx
        resid = abs(delta) / denom_r
        if resid < ROUTER_RESID_TRIGGER or not if_list:
            continue

        # Determine whether to reduce the dominant side
        reduce_tx = delta > 0.0  # too much TX
        reduce_rx = delta < 0.0  # too much RX

        # Collect candidates and total mass for proportional distribution
        if reduce_tx:
            # Outgoing directions at router r => this router's tx counters
            outs = [iid for iid in if_list
                    if status_orig.get(iid, 'unknown') != 'down' and peers.get(iid) and vals[iid]['tx'] >= SMALL_RATE_CUTOFF]
            total_mass = sum(vals[iid]['tx'] for iid in outs) or 0.0
            if total_mass <= 0.0:
                continue
            budget = min(abs(delta), ROUTER_BUDGET_CAP * denom_r)
            # Tentatively apply and track changes
            changes: List[Tuple[str, str, float]] = []
            for iid in outs:
                share = vals[iid]['tx'] / total_mass if total_mass > 0 else 0.0
                d_i = budget * share
                if d_i <= 0.0:
                    continue
                # Apply to local tx (tentative)
                old_tx = vals[iid]['tx']
                new_tx = max(0.0, old_tx - d_i)
                vals[iid]['tx'] = new_tx
                changes.append(('tx', iid, old_tx))
                # Mirror to peer's rx if peer exists and not explicitly down
                pid = peers.get(iid)
                if pid and status_orig.get(pid, 'unknown') != 'down':
                    old_prx = vals[pid]['rx']
                    vals[pid]['rx'] = max(0.0, old_prx - d_i)
                    changes.append(('rx', pid, old_prx))
            # Check improvement; revert if insufficient
            resid_after = compute_router_resid_local(r)
            if resid_after > (1.0 - IMPROVE_REQ) * resid:
                for kind, iid, old_val in changes:
                    vals[iid][kind] = old_val
        elif reduce_rx:
            # Incoming directions at router r => this router's rx counters
            ins = [iid for iid in if_list
                   if status_orig.get(iid, 'unknown') != 'down' and peers.get(iid) and vals[iid]['rx'] >= SMALL_RATE_CUTOFF]
            total_mass = sum(vals[iid]['rx'] for iid in ins) or 0.0
            if total_mass <= 0.0:
                continue
            budget = min(abs(delta), ROUTER_BUDGET_CAP * denom_r)
            changes: List[Tuple[str, str, float]] = []
            for iid in ins:
                share = vals[iid]['rx'] / total_mass if total_mass > 0 else 0.0
                d_i = budget * share
                if d_i <= 0.0:
                    continue
                # Apply to local rx (tentative)
                old_rx = vals[iid]['rx']
                new_rx = max(0.0, old_rx - d_i)
                vals[iid]['rx'] = new_rx
                changes.append(('rx', iid, old_rx))
                # Mirror to peer's tx if peer exists and not explicitly down
                pid = peers.get(iid)
                if pid and status_orig.get(pid, 'unknown') != 'down':
                    old_ptx = vals[pid]['tx']
                    vals[pid]['tx'] = max(0.0, old_ptx - d_i)
                    changes.append(('tx', pid, old_ptx))
            resid_after = compute_router_resid_local(r)
            if resid_after > (1.0 - IMPROVE_REQ) * resid:
                for kind, iid, old_val in changes:
                    vals[iid][kind] = old_val
>>>>>>> REPLACE
</DIFF>