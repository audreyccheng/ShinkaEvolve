<NAME>
change_based_confidence_refinement
</NAME>

<DESCRIPTION>
I propose a targeted improvement to confidence calibration without altering the repaired counter values. After pairwise link symmetry hardening, we now adjust the per-rate confidence using the magnitude of the change applied to each counter. Intuitively, if we significantly modify a counter (e.g., due to a large inconsistency), our confidence in that repair should be lower; if we leave it nearly unchanged, confidence should remain high. This refinement leverages the normalized change ratio between original and repaired values and clamps the resulting confidence within [0,1]. This change aims to improve confidence calibration (20% of the combined score) while keeping counter repair behavior unchanged, thereby preserving the strong counter accuracy we already have and the perfect status accuracy.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        per_if_repair[a_id] = {
=======
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        # Confidence refinement: penalize by magnitude of applied change
        # This improves calibration by lowering confidence when we make large adjustments.
        def change_ratio(orig: float, rep: float) -> float:
            denom = max(abs(orig), abs(rep), 1.0)
            return abs(rep - orig) / denom

        a_rx_change = change_ratio(a_rx, rep_a_rx)
        a_tx_change = change_ratio(a_tx, rep_a_tx)
        b_rx_change = change_ratio(b_rx, rep_b_rx)
        b_tx_change = change_ratio(b_tx, rep_b_tx)

        rx_conf_a = max(0.0, min(1.0, min(rx_conf_a, 1.0 - a_rx_change)))
        tx_conf_a = max(0.0, min(1.0, min(tx_conf_a, 1.0 - a_tx_change)))
        rx_conf_b = max(0.0, min(1.0, min(rx_conf_b, 1.0 - b_rx_change)))
        tx_conf_b = max(0.0, min(1.0, min(tx_conf_b, 1.0 - b_tx_change)))

        per_if_repair[a_id] = {
>>>>>>> REPLACE

</DIFF>