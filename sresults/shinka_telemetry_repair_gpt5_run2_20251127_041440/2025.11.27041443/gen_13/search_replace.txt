<NAME>
router_guided_link_choice
</NAME>

<DESCRIPTION>
I propose enhancing the pairwise link hardening step by incorporating router-level flow conservation as a guide to choose which side of a mismatched link to trust. Instead of always averaging A.tx and B.rx when they differ beyond the hardening threshold, we evaluate three candidates for the repaired directional flow: keep A.tx, keep B.rx, or average. We select the candidate that minimizes the combined residuals at the two adjacent routers (A’s local router for TX and B’s local router for RX), using a running estimate of per-router TX/RX sums updated as repairs are applied. This greedy, router-guided choice helps favor the side that better matches redundant router-level signals, improving counter accuracy without sacrificing calibration. Confidence for the chosen direction is gently boosted proportional to the reduction in router residual, preserving calibration by scaling the boost modestly.

This change is localized to the link hardening loop and adds a small per-router sums precomputation. Topology is still used for final router residual confidence scaling as before. The modification aims to increase counter_repair_accuracy while maintaining our strong confidence calibration performance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # First pass: pairwise hardening and status harmonization using link symmetry
    per_if_repair = {}  # interface_id -> interim repaired values and base confidences

    for _, (a_id, b_id) in pairs.items():
        a = telemetry[a_id]
        b = telemetry[b_id]

        a_status = a.get('interface_status', 'unknown')
        b_status = b.get('interface_status', 'unknown')

        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)

        # Decide pair status using interface consistency + traffic evidence
        a_has = has_traffic(a)
        b_has = has_traffic(b)

        if a_status == 'down' and b_status == 'down':
            pair_status = 'down'
        elif a_status == 'up' and b_status == 'up':
            pair_status = 'up'
        else:
            # Mismatch: if any traffic exists on either end, consider link up; otherwise down
            pair_status = 'up' if (a_has or b_has) else 'down'

        # Initialize with originals
        rep_a_tx, rep_b_rx = a_tx, b_rx
        rep_b_tx, rep_a_rx = b_tx, a_rx
        rx_conf_a = 1.0
        tx_conf_a = 1.0
        rx_conf_b = 1.0
        tx_conf_b = 1.0

        if pair_status == 'down':
            # No traffic on a down link
            rep_a_tx, rep_b_rx, rep_b_tx, rep_a_rx = 0.0, 0.0, 0.0, 0.0
            # Confidence is high if there was no traffic observed; otherwise moderate
            base_conf = 0.95 if not (a_has or b_has) else 0.7
            rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
        else:
            # Link is up: enforce link symmetry with hardening threshold
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba

        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        per_if_repair[a_id] = {
            'repaired_rx': rep_a_rx,
            'repaired_tx': rep_a_tx,
            'rx_conf': rx_conf_a,
            'tx_conf': tx_conf_a,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
        per_if_repair[b_id] = {
            'repaired_rx': rep_b_rx,
            'repaired_tx': rep_b_tx,
            'rx_conf': rx_conf_b,
            'tx_conf': tx_conf_b,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
=======
    # First pass: pairwise hardening and status harmonization using link symmetry
    per_if_repair = {}  # interface_id -> interim repaired values and base confidences

    # Precompute per-router TX/RX sums from observations (will be adjusted as we repair)
    curr_sum_tx: Dict[Any, float] = {}
    curr_sum_rx: Dict[Any, float] = {}
    for iid, d in telemetry.items():
        r = d.get('local_router')
        if r is None:
            continue
        curr_sum_tx[r] = curr_sum_tx.get(r, 0.0) + float(d.get('tx_rate', 0.0) or 0.0)
        curr_sum_rx[r] = curr_sum_rx.get(r, 0.0) + float(d.get('rx_rate', 0.0) or 0.0)

    def router_resid_for(r: Any, tx_sum: float, rx_sum: float) -> float:
        return abs(tx_sum - rx_sum) / max(tx_sum, rx_sum, 1.0)

    for _, (a_id, b_id) in pairs.items():
        a = telemetry[a_id]
        b = telemetry[b_id]

        a_status = a.get('interface_status', 'unknown')
        b_status = b.get('interface_status', 'unknown')

        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)

        a_lr = a.get('local_router')
        b_lr = b.get('local_router')

        # Decide pair status using interface consistency + traffic evidence
        a_has = has_traffic(a)
        b_has = has_traffic(b)

        if a_status == 'down' and b_status == 'down':
            pair_status = 'down'
        elif a_status == 'up' and b_status == 'up':
            pair_status = 'up'
        else:
            # Mismatch: if any traffic exists on either end, consider link up; otherwise down
            pair_status = 'up' if (a_has or b_has) else 'down'

        # Initialize with originals
        rep_a_tx, rep_b_rx = a_tx, b_rx
        rep_b_tx, rep_a_rx = b_tx, a_rx
        rx_conf_a = 1.0
        tx_conf_a = 1.0
        rx_conf_b = 1.0
        tx_conf_b = 1.0

        if pair_status == 'down':
            # Update router sums to reflect zeroing this pair's contributions
            if a_lr is not None:
                curr_sum_tx[a_lr] = curr_sum_tx.get(a_lr, 0.0) - a_tx
                curr_sum_rx[a_lr] = curr_sum_rx.get(a_lr, 0.0) - a_rx
            if b_lr is not None:
                curr_sum_tx[b_lr] = curr_sum_tx.get(b_lr, 0.0) - b_tx
                curr_sum_rx[b_lr] = curr_sum_rx.get(b_lr, 0.0) - b_rx
            # No traffic on a down link
            rep_a_tx, rep_b_rx, rep_b_tx, rep_a_rx = 0.0, 0.0, 0.0, 0.0
            # Confidence is high if there was no traffic observed; otherwise moderate
            base_conf = 0.95 if not (a_has or b_has) else 0.7
            rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
        else:
            # Link is up: enforce link symmetry with hardening threshold
            # Direction A->B (A.tx vs B.rx)
            diff_ab = norm_diff(a_tx, b_rx)
            if diff_ab > HARDENING_THRESHOLD:
                candidates = [
                    (0.5 * (a_tx + b_rx), 'avg'),
                    (a_tx, 'keep_a_tx'),
                    (b_rx, 'keep_b_rx')
                ]
                # Current combined residuals for the two adjacent routers
                p_orig = 0.0
                if a_lr is not None:
                    p_orig += router_resid_for(a_lr, curr_sum_tx.get(a_lr, 0.0), curr_sum_rx.get(a_lr, 0.0))
                if b_lr is not None:
                    p_orig += router_resid_for(b_lr, curr_sum_tx.get(b_lr, 0.0), curr_sum_rx.get(b_lr, 0.0))

                best_v = candidates[0][0]
                best_p = float('inf')
                for v, _ in candidates:
                    p_new = 0.0
                    if a_lr is not None:
                        tx_sum_new = curr_sum_tx.get(a_lr, 0.0) + (v - a_tx)
                        p_new += router_resid_for(a_lr, tx_sum_new, curr_sum_rx.get(a_lr, 0.0))
                    if b_lr is not None:
                        rx_sum_new = curr_sum_rx.get(b_lr, 0.0) + (v - b_rx)
                        p_new += router_resid_for(b_lr, curr_sum_tx.get(b_lr, 0.0), rx_sum_new)
                    if p_new < best_p:
                        best_p = p_new
                        best_v = v

                # Apply chosen value and update running router sums
                if a_lr is not None:
                    curr_sum_tx[a_lr] = curr_sum_tx.get(a_lr, 0.0) + (best_v - a_tx)
                if b_lr is not None:
                    curr_sum_rx[b_lr] = curr_sum_rx.get(b_lr, 0.0) + (best_v - b_rx)

                rep_a_tx = best_v
                rep_b_rx = best_v

                # Confidence decreases with magnitude of violation; slight boost if router residual improves
                conf_ab = max(0.0, 1.0 - diff_ab)
                improvement = max(0.0, (p_orig - best_p))
                denom = p_orig if p_orig > 1e-6 else 1.0
                boost = 0.1 * (improvement / denom)
                conf_ab = min(1.0, max(conf_ab, 0.85 + boost))
            else:
                conf_ab = min(1.0, max(0.98, 1.0 - diff_ab))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            # Direction B->A (B.tx vs A.rx)
            diff_ba = norm_diff(b_tx, a_rx)
            if diff_ba > HARDENING_THRESHOLD:
                candidates = [
                    (0.5 * (b_tx + a_rx), 'avg'),
                    (b_tx, 'keep_b_tx'),
                    (a_rx, 'keep_a_rx')
                ]
                p_orig = 0.0
                if b_lr is not None:
                    p_orig += router_resid_for(b_lr, curr_sum_tx.get(b_lr, 0.0), curr_sum_rx.get(b_lr, 0.0))
                if a_lr is not None:
                    p_orig += router_resid_for(a_lr, curr_sum_tx.get(a_lr, 0.0), curr_sum_rx.get(a_lr, 0.0))

                best_v2 = candidates[0][0]
                best_p2 = float('inf')
                for v, _ in candidates:
                    p_new2 = 0.0
                    if b_lr is not None:
                        tx_sum_new = curr_sum_tx.get(b_lr, 0.0) + (v - b_tx)
                        p_new2 += router_resid_for(b_lr, tx_sum_new, curr_sum_rx.get(b_lr, 0.0))
                    if a_lr is not None:
                        rx_sum_new = curr_sum_rx.get(a_lr, 0.0) + (v - a_rx)
                        p_new2 += router_resid_for(a_lr, curr_sum_tx.get(a_lr, 0.0), rx_sum_new)
                    if p_new2 < best_p2:
                        best_p2 = p_new2
                        best_v2 = v

                if b_lr is not None:
                    curr_sum_tx[b_lr] = curr_sum_tx.get(b_lr, 0.0) + (best_v2 - b_tx)
                if a_lr is not None:
                    curr_sum_rx[a_lr] = curr_sum_rx.get(a_lr, 0.0) + (best_v2 - a_rx)

                rep_b_tx = best_v2
                rep_a_rx = best_v2

                conf_ba = max(0.0, 1.0 - diff_ba)
                improvement2 = max(0.0, (p_orig - best_p2))
                denom2 = p_orig if p_orig > 1e-6 else 1.0
                boost2 = 0.1 * (improvement2 / denom2)
                conf_ba = min(1.0, max(conf_ba, 0.85 + boost2))
            else:
                conf_ba = min(1.0, max(0.98, 1.0 - diff_ba))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba

        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:  # up
            if a_status == 'up' and b_status == 'up':
                status_conf = 0.95
            else:
                # we decided up due to traffic evidence
                status_conf = 0.8

        per_if_repair[a_id] = {
            'repaired_rx': rep_a_rx,
            'repaired_tx': rep_a_tx,
            'rx_conf': rx_conf_a,
            'tx_conf': tx_conf_a,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
        per_if_repair[b_id] = {
            'repaired_rx': rep_b_rx,
            'repaired_tx': rep_b_tx,
            'rx_conf': rx_conf_b,
            'tx_conf': tx_conf_b,
            'repaired_status': pair_status,
            'status_conf': status_conf
        }
>>>>>>> REPLACE

</DIFF>