<NAME>
router_balancing_dangling
</NAME>

<DESCRIPTION>
I propose two targeted improvements:

1) Fix has_traffic robustness: Cast telemetry values to float to avoid type issues and improve down/up decisions when fields are None or non-numeric. This makes link status harmonization more reliable.

2) Add a router-level balancing step that enforces flow conservation (R1) using only dangling interfaces (interfaces without a known peer). After pairwise link symmetry hardening, some routers can still show residual imbalance. We use topology to compute per-router TX/RX sums and, when imbalance exceeds the 2% hardening threshold, we distribute the correction across dangling up interfaces proportionally to their traffic volume. This preserves link symmetry (since paired interfaces are not touched) while leveraging flow conservation to improve counter accuracy. Confidence for the adjusted counters is calibrated by the magnitude of the change relative to the original observation to maintain good confidence calibration.

These changes should improve counter repair accuracy without harming status accuracy, and maintain or improve confidence calibration through conservative, topology-aware adjustments.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (d.get('rx_rate', 0.0) > EPS) or (d.get('tx_rate', 0.0) > EPS)
=======
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (float(d.get('rx_rate', 0.0) or 0.0) > EPS) or (float(d.get('tx_rate', 0.0) or 0.0) > EPS)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Second pass: compute router-level flow conservation residuals using repaired rates
=======
    # Router-level balancing using dangling interfaces to satisfy flow conservation (R1)
    # We only adjust interfaces without a known peer to avoid breaking link symmetry.
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        present = [iid for iid in if_list if iid in per_if_repair]
        if not present:
            continue
        for iid in present:
            rep = per_if_repair[iid]
            sum_tx += float(rep['repaired_tx'])
            sum_rx += float(rep['repaired_rx'])
        scale = max(sum_tx, sum_rx, 1.0)
        delta = sum_tx - sum_rx  # want delta -> 0

        if abs(delta) <= HARDENING_THRESHOLD * scale:
            continue

        # Candidate interfaces for adjustment: dangling and up
        dangling = [iid for iid in present
                    if (iid not in paired_ids) and (per_if_repair[iid].get('repaired_status', 'up') != 'down')]

        if not dangling:
            continue

        # Distribute correction proportionally to traffic magnitude to minimize relative change
        weights = []
        sum_w = 0.0
        for iid in dangling:
            rep = per_if_repair[iid]
            w = float(rep['repaired_tx']) + float(rep['repaired_rx']) + EPS
            weights.append((iid, w))
            sum_w += w
        if sum_w <= 0.0:
            sum_w = EPS * len(dangling)
            weights = [(iid, EPS) for iid in dangling]

        if delta > 0.0:
            # Too much TX; increase RX on dangling interfaces
            for iid, w in weights:
                inc = delta * (w / sum_w)
                new_rx = float(per_if_repair[iid]['repaired_rx']) + inc
                per_if_repair[iid]['repaired_rx'] = new_rx
                # Confidence: penalize by change magnitude from original observation
                rx_orig = float(telemetry.get(iid, {}).get('rx_rate', 0.0) or 0.0)
                denom = max(abs(rx_orig), abs(new_rx), 1.0)
                cr = abs(new_rx - rx_orig) / denom
                per_if_repair[iid]['rx_conf'] = max(0.0, min(float(per_if_repair[iid].get('rx_conf', 0.6)), 1.0 - cr))
        else:
            # Too much RX; increase TX on dangling interfaces
            need = -delta
            for iid, w in weights:
                inc = need * (w / sum_w)
                new_tx = float(per_if_repair[iid]['repaired_tx']) + inc
                per_if_repair[iid]['repaired_tx'] = new_tx
                tx_orig = float(telemetry.get(iid, {}).get('tx_rate', 0.0) or 0.0)
                denom = max(abs(tx_orig), abs(new_tx), 1.0)
                cr = abs(new_tx - tx_orig) / denom
                per_if_repair[iid]['tx_conf'] = max(0.0, min(float(per_if_repair[iid].get('tx_conf', 0.6)), 1.0 - cr))

    # Second pass: compute router-level flow conservation residuals using repaired rates
>>>>>>> REPLACE

</DIFF>