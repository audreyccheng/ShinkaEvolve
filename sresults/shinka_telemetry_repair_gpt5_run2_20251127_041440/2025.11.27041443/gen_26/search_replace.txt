<NAME>
magnitude_aware_symmetry_and_directional_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements grounded in the Hodor principles and the provided recommendations:

1) Magnitude-aware symmetry tolerance with an absolute guard:
- Retain the 2% hardening threshold, but when the max of the compared rates is below 10 Mbps, raise the tolerance to 5% and require an absolute difference > 0.5 Mbps before averaging. This prevents over-correction of low-rate noise.
- Confidence floors are sharpened: within tolerance, set a higher floor (0.99) when max magnitude ≥ 10 Mbps and normalized difference ≤ 0.5%; otherwise keep a 0.98 floor. This improves calibration on strong agreements.

2) Direction-aware router residual penalties:
- Scale tx_conf and rx_conf using different blends of local vs. remote router residuals, aligning with traffic direction: TX leaves local, RX arrives from remote. This better ties confidence to where inconsistencies are more likely to originate, improving calibration without changing repaired values.

These are minimal, surgical edits that preserve the successful parts of the algorithm while improving both repair stability on tiny flows and confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-6  # small absolute tolerance for "no traffic"
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-6  # small absolute tolerance for "no traffic"
    # Magnitude-aware symmetry tuning
    LOW_RATE_THRESH = 10.0   # Mbps: below this, raise tolerance to avoid over-correcting noise
    ABS_GUARD = 0.5          # Mbps: require absolute difference > 0.5 Mbps to trigger averaging
    STRONG_AGREE = 0.005     # 0.5%: very strong normalized agreement for high-confidence floor
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with hardening threshold
            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            # Confidence decreases with magnitude of violation; if unchanged, slightly boost
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
=======
        else:
            # Link is up: enforce link symmetry with magnitude-aware tolerance and absolute guard
            # Direction A->B (A.tx vs B.rx)
            max_mag_ab = max(a_tx, b_rx)
            abs_diff_ab = abs(a_tx - b_rx)
            tau_ab = HARDENING_THRESHOLD if max_mag_ab >= LOW_RATE_THRESH else max(HARDENING_THRESHOLD, 0.05)
            if (diff_ab > tau_ab) and (abs_diff_ab > ABS_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            # Confidence decreases with magnitude of violation; boost within tolerance
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= tau_ab:
                # Higher floor for strong agreements on healthy magnitudes
                if (max_mag_ab >= LOW_RATE_THRESH) and (diff_ab <= STRONG_AGREE):
                    conf_ab = max(conf_ab, 0.99)
                else:
                    conf_ab = max(conf_ab, 0.98)
                conf_ab = min(1.0, conf_ab)
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            # Direction B->A (B.tx vs A.rx)
            max_mag_ba = max(b_tx, a_rx)
            abs_diff_ba = abs(b_tx - a_rx)
            tau_ba = HARDENING_THRESHOLD if max_mag_ba >= LOW_RATE_THRESH else max(HARDENING_THRESHOLD, 0.05)
            if (diff_ba > tau_ba) and (abs_diff_ba > ABS_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= tau_ba:
                if (max_mag_ba >= LOW_RATE_THRESH) and (diff_ba <= STRONG_AGREE):
                    conf_ba = max(conf_ba, 0.99)
                else:
                    conf_ba = max(conf_ba, 0.98)
                conf_ba = min(1.0, conf_ba)
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        penalty = 1.0 - 0.5 * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty)))
=======
        # Direction-aware router residual confidence penalties
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        # Status confidence is less sensitive; use the mean directional penalty
        status_penalty = 0.5 * (penalty_tx + penalty_rx)
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * status_penalty)))
>>>>>>> REPLACE

</DIFF>