<NAME>
residual_tilt_and_share_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements grounded in Hodor principles to improve both counter accuracy and confidence calibration:

1) Residual‑tilted, asymmetric consensus weights during pair repair:
   - Before any repair, compute per‑router flow residuals and signed imbalances from the original telemetry. During pairwise hardening, when A.tx vs B.rx (and symmetrically B.tx vs A.rx), slightly tilt the consensus target toward the side that reduces the local router’s imbalance. Specifically, if (a_tx − b_rx) and the local router’s imbalance (Σtx − Σrx) have the same sign, shrink the local weight by γ = min(0.08, 0.1 × resid_local). This bounded, direction‑aware tilt helps resolve ambiguous pairs by using flow conservation without overcorrecting, improving counter repair accuracy.

2) Interface‑share–aware, direction‑coupled router residual penalties in confidence:
   - When scaling tx/rx confidences, modulate the local vs remote residual weights by the interface’s traffic share on its router to better reflect how much each interface influences conservation. For tx: pen_tx uses local weight 0.6 + 0.2·tx_share and remote 0.4 − 0.2·tx_share; for rx: pen_rx uses local 0.4 − 0.2·rx_share and remote 0.6 + 0.2·rx_share. This aligns penalties to directional influence, improving confidence calibration.

These changes are minimal, maintain existing magnitude-aware gating and partial averaging, and only introduce bounded adjustments and better-calibrated confidence penalties.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Build unique link pairs (undirected, canonicalized)
    pairs = {}  # key: tuple(sorted([if1, if2])) -> (ifA, ifB)
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)
=======
    # Build unique link pairs (undirected, canonicalized)
    pairs = {}  # key: tuple(sorted([if1, if2])) -> (ifA, ifB)
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # Precompute router residuals and imbalances from original telemetry (before repair)
    orig_router_resid: Dict[str, float] = {}
    orig_router_imbalance: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx0 = 0.0
        s_rx0 = 0.0
        for iid in if_list:
            d = telemetry.get(iid, {})
            s_tx0 += float(d.get('tx_rate', 0.0) or 0.0)
            s_rx0 += float(d.get('rx_rate', 0.0) or 0.0)
        orig_router_imbalance[router] = s_tx0 - s_rx0
        orig_router_resid[router] = abs(s_tx0 - s_rx0) / max(s_tx0, s_rx0, 1.0)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                if diff_ab <= 2.0 * tau_ab:
                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + avg_ab * k
                    rep_b_rx = b_rx * (1.0 - k) + avg_ab * k
                else:
                    rep_a_tx = avg_ab
                    rep_b_rx = avg_ab
=======
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                # Residual-tilted consensus: bias toward the side that reduces local router imbalance
                a_loc = a.get('local_router')
                resid_loc0 = orig_router_resid.get(a_loc, 0.0)
                imb_loc0 = orig_router_imbalance.get(a_loc, 0.0)
                gamma = min(0.08, 0.1 * resid_loc0)
                if (a_tx - b_rx) * imb_loc0 > 0:
                    w_a = max(0.1, min(0.9, 0.5 - gamma))
                else:
                    w_a = 0.5
                target_ab = w_a * a_tx + (1.0 - w_a) * b_rx
                if diff_ab <= 2.0 * tau_ab:
                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + target_ab * k
                    rep_b_rx = b_rx * (1.0 - k) + target_ab * k
                else:
                    rep_a_tx = target_ab
                    rep_b_rx = target_ab
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                if diff_ba <= 2.0 * tau_ba:
                    k2 = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + avg_ba * k2
                    rep_a_rx = a_rx * (1.0 - k2) + avg_ba * k2
                else:
                    rep_b_tx = avg_ba
                    rep_a_rx = avg_ba
=======
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                # Residual-tilted consensus for B->A direction
                b_loc = b.get('local_router')
                resid_loc0_b = orig_router_resid.get(b_loc, 0.0)
                imb_loc0_b = orig_router_imbalance.get(b_loc, 0.0)
                gamma2 = min(0.08, 0.1 * resid_loc0_b)
                if (b_tx - a_rx) * imb_loc0_b > 0:
                    w_b = max(0.1, min(0.9, 0.5 - gamma2))
                else:
                    w_b = 0.5
                target_ba = w_b * b_tx + (1.0 - w_b) * a_rx
                if diff_ba <= 2.0 * tau_ba:
                    k2 = (diff_ba - tau_ba) / max(tau_b, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + target_ba * k2
                    rep_a_rx = a_rx * (1.0 - k2) + target_ba * k2
                else:
                    rep_b_tx = target_ba
                    rep_a_rx = target_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
=======
    router_residual: Dict[str, float] = {}
    router_sums: Dict[str, Tuple[float, float]] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
        router_sums[router] = (sum_tx, sum_rx)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        def clamp01(x: float) -> float:
            return max(0.0, min(1.0, float(x)))

        pen_tx = clamp01(1.0 - (0.6 * resid_local + 0.4 * resid_remote))
        pen_rx = clamp01(1.0 - (0.6 * resid_remote + 0.4 * resid_local))

        rx_conf = clamp01(rx_conf * pen_rx)
        tx_conf = clamp01(tx_conf * pen_tx)
        # Status confidence is less sensitive to flow residuals; apply mild scaling using the weaker directional penalty
        status_conf = clamp01(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
=======
        def clamp01(x: float) -> float:
            return max(0.0, min(1.0, float(x)))

        # Interface-share–aware, direction-coupled residual penalties
        s_tx_local, s_rx_local = router_sums.get(local_router, (0.0, 0.0))
        tx_share = repaired_tx / max(1.0, s_tx_local)
        rx_share = repaired_rx / max(1.0, s_rx_local)
        # TX: emphasize local residual more when this iface dominates local TX
        wL_tx = clamp01(0.6 + 0.2 * tx_share)
        wR_tx = clamp01(0.4 - 0.2 * tx_share)
        # RX: emphasize remote residual more when this iface dominates local RX
        wL_rx = clamp01(0.4 - 0.2 * rx_share)
        wR_rx = clamp01(0.6 + 0.2 * rx_share)

        pen_tx = clamp01(1.0 - (wL_tx * resid_local + wR_tx * resid_remote))
        pen_rx = clamp01(1.0 - (wL_rx * resid_local + wR_rx * resid_remote))

        tx_conf = clamp01(tx_conf * pen_tx)
        rx_conf = clamp01(rx_conf * pen_rx)
        # Status confidence is less sensitive to flow residuals; apply mild scaling using the weaker directional penalty
        status_conf = clamp01(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
>>>>>>> REPLACE
</DIFF>