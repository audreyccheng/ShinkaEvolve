<NAME>
gentle_prescale_ultra_agreement_conf_and_lowrate_penalty
</NAME>

<DESCRIPTION>
I propose three targeted improvements that aim to lift counter repair accuracy without harming the strong calibration and status accuracy:

1) Gentle multiplicative pair-bias prescaling (calculation-only) before consensus:
   - For each link direction, we pre-scale the compared counters by a small factor s in [0.90, 1.10] to reduce ratio bias before computing the normalized disagreement and the partial averaging weight k. We keep the consensus target computed from the original values and never commit prescaled counters directly. We also add low-rate–aware guards (stricter absolute guard and accelerated partial averaging) to avoid over-correcting tiny flows.
   - This helps align directional counters more smoothly and reduces over/under-shoot in partial adjustments.

2) Ultra-agreement confidence floor:
   - When both directions agree extremely well after repair (diff ≤ 0.003) and both routers have small residual (≤ 0.02), we set a high confidence floor of 0.995. This rewards exceptional agreement and preserves the existing strong calibration.

3) Low-rate quiet-side confidence relaxation:
   - For asymmetric traffic cases on tiny flows, we relax the penalty from 0.88 to 0.92 when max(local, peer) < 10 Mbps and the active side ≤ 2 Mbps. This reduces over-penalization at very low rates and improves calibration without impacting counter values.

These changes are consistent with the Hodor-based validation/repair principles and previously successful variants, focusing on small, safe improvements that should boost the combined score predominantly through improved counter accuracy and preserved/strong calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # a->b hardening
            if diff_ab > tol_ab:
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    if diff_ab <= 2 * tol_ab:
                        # Partial averaging near threshold to reduce overcorrection
                        k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            else:
=======
            # a->b hardening with low-rate–aware guards and gentle prescaling for k computation
            low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
            abs_guard_ab = 0.3 if low_band_ab else ABS_GUARD
            full_mult_ab = 1.6 if low_band_ab else 2.0
            exp_ab = 1.2 if low_band_ab else 1.0

            if diff_ab > tol_ab:
                if abs_ab > abs_guard_ab:
                    # Trust-weighted consensus (computed on original values)
                    consensus_ab = w_a * a_tx + w_b * b_rx

                    # Gentle multiplicative pair-bias prescaling for k/diff computation only
                    if max(a_tx, b_rx) >= 1.0:
                        s = (max(1e-9, b_rx) / max(1e-9, a_tx)) ** 0.5
                        s = max(0.90, min(1.10, s))
                        a_tx_ps = a_tx * s
                        b_rx_ps = b_rx / s
                        diff_eff = abs(a_tx_ps - b_rx_ps) / max(1.0, a_tx_ps, b_rx_ps)
                    else:
                        diff_eff = diff_ab

                    if diff_eff <= full_mult_ab * tol_ab:
                        # Partial averaging near threshold; accelerate on low-rate links
                        k_raw = (diff_eff - tol_ab) / max(tol_ab, 1e-9)
                        k = max(0.0, min(1.0, k_raw ** exp_ab))
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            else:
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # b->a hardening
            if diff_ba > tol_ba:
                if abs_ba > ABS_GUARD:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    if diff_ba <= 2 * tol_ba:
                        k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
=======
            # b->a hardening with low-rate–aware guards and gentle prescaling for k computation
            if diff_ba > tol_ba:
                # Low-rate–aware absolute guard and shaping
                low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                abs_guard_ba = 0.3 if low_band_ba else ABS_GUARD
                full_mult_ba = 1.6 if low_band_ba else 2.0
                exp_ba = 1.2 if low_band_ba else 1.0

                if abs_ba > abs_guard_ba:
                    consensus_ba = w_b * b_tx + w_a * a_rx

                    # Gentle multiplicative prescaling for k/diff computation only
                    if max(b_tx, a_rx) >= 1.0:
                        s = (max(1e-9, a_rx) / max(1e-9, b_tx)) ** 0.5
                        s = max(0.90, min(1.10, s))
                        b_tx_ps = b_tx * s
                        a_rx_ps = a_rx / s
                        diff_eff = abs(b_tx_ps - a_rx_ps) / max(1.0, b_tx_ps, a_rx_ps)
                    else:
                        diff_eff = diff_ba

                    if diff_eff <= full_mult_ba * tol_ba:
                        k_raw = (diff_eff - tol_ba) / max(tol_ba, 1e-9)
                        k = max(0.0, min(1.0, k_raw ** exp_ba))
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Compose new confidences
        conf_tx_new = clamp(0.45 * pen_tx + 0.35 * c_sym_tx + 0.20 * c_delta_tx)
        conf_rx_new = clamp(0.45 * pen_rx + 0.35 * c_sym_rx + 0.20 * c_delta_rx)

        # Apply magnitude-aware floors
        conf_tx_new = max(conf_tx_new, floor_tx)
        conf_rx_new = max(conf_rx_new, floor_rx)

        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and prrx is not None:
            if rtx <= QUIET_EPS and prrx > QUIET_EPS:
                conf_tx_new = clamp(conf_tx_new * 0.88)
        if peer_exists and prtx is not None:
            if rrx <= QUIET_EPS and prtx > QUIET_EPS:
                conf_rx_new = clamp(conf_rx_new * 0.88)
=======
        # Compose new confidences
        conf_tx_new = clamp(0.45 * pen_tx + 0.35 * c_sym_tx + 0.20 * c_delta_tx)
        conf_rx_new = clamp(0.45 * pen_rx + 0.35 * c_sym_rx + 0.20 * c_delta_rx)

        # Apply magnitude-aware floors
        conf_tx_new = max(conf_tx_new, floor_tx)
        conf_rx_new = max(conf_rx_new, floor_rx)

        # Ultra-agreement confidence floor when both directions and both routers are very well aligned
        if peer_exists and diff_tx is not None and diff_rx is not None:
            if diff_tx <= 0.003 and diff_rx <= 0.003 and max(resid_local, resid_remote) <= 0.02:
                conf_tx_new = max(conf_tx_new, 0.995)
                conf_rx_new = max(conf_rx_new, 0.995)

        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and prrx is not None:
            if rtx <= QUIET_EPS and prrx > QUIET_EPS:
                factor = 0.92 if (max(rtx, prrx) < LOW_RATE_CUTOFF and prrx <= 2.0) else 0.88
                conf_tx_new = clamp(conf_tx_new * factor)
        if peer_exists and prtx is not None:
            if rrx <= QUIET_EPS and prtx > QUIET_EPS:
                factor = 0.92 if (max(rrx, prtx) < LOW_RATE_CUTOFF and prtx <= 2.0) else 0.88
                conf_rx_new = clamp(conf_rx_new * factor)
>>>>>>> REPLACE
</DIFF>