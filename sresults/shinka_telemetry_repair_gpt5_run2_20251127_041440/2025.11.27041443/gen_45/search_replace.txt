<NAME>
partial_averaging_and_asymmetric_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements to boost counter accuracy and confidence calibration without destabilizing current strengths:

1) Partial averaging near the hardening threshold: Instead of fully averaging endpoints whenever the per-direction symmetry diff exceeds τh, we apply a linear interpolation toward the average only when τh < diff ≤ 2τh, and fall back to full averaging for larger violations. This reduces over-correction around the threshold and improves calibration by aligning the magnitude of changes with the severity of the detected inconsistency. The absolute guard (0.5 Mbps) is preserved to avoid perturbing tiny flows.

2) Asymmetric confidence when "up" is decided by traffic evidence from only one side: When a link is marked up due to observed traffic but only one side carries traffic, we modestly downscale the silent side’s RX/TX confidences (×0.88). This aligns confidence with the reliability of the evidence and improves calibration. Additionally, we boost status confidence to 0.99 for very strong bilateral agreement at high rates (≤0.5% diff in both directions), which sharpens calibration on clear matches.

Finally, I adjust the status confidence penalty in the final assembly to use the weaker direction penalty (0.85 + 0.15 × min(pen_tx, pen_rx)), which better reflects directionality compared to averaging both penalties.

These changes implement recommendations 2, 3, and 5 from the potential enhancements and should improve both counter accuracy and confidence calibration while keeping the algorithm stable.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # Magnitude-aware thresholds
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)

            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
                # Repair by consensus average
                v = 0.5 * (a_tx + b_rx)
                rep_a_tx = v
                rep_b_rx = v
                # Confidence decreases with violation magnitude and change magnitude
                change_a = abs(v - a_tx) / max(abs(v), abs(a_tx), 1.0)
                change_b = abs(v - b_rx) / max(abs(v), abs(b_rx), 1.0)
                conf_base = max(0.0, 1.0 - d_ab)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)
=======
            # Magnitude-aware thresholds
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)

            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
                # Repair by consensus average with partial averaging near threshold
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= 2.0 * thr_rel_ab:
                    k = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + v * k
                    rep_b_rx = b_rx * (1.0 - k) + v * k
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                # Confidence decreases with violation magnitude and change magnitude
                change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                conf_base = max(0.0, 1.0 - d_ab)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)

            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
                v2 = 0.5 * (b_tx + a_rx)
                rep_b_tx = v2
                rep_a_rx = v2
                change_b2 = abs(v2 - b_tx) / max(abs(v2), abs(b_tx), 1.0)
                change_a2 = abs(v2 - a_rx) / max(abs(v2), abs(a_rx), 1.0)
                conf_base2 = max(0.0, 1.0 - d_ba)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
=======
            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)

            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= 2.0 * thr_rel_ba:
                    k2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + v2 * k2
                    rep_a_rx = a_rx * (1.0 - k2) + v2 * k2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                conf_base2 = max(0.0, 1.0 - d_ba)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Status confidence
        if pair_status == 'down':
            if a_stat == 'down' and b_stat == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:
            if a_stat == 'up' and b_stat == 'up':
                status_conf = 0.95
            else:
                status_conf = 0.8
=======
        # Status confidence
        if pair_status == 'down':
            if a_stat == 'down' and b_stat == 'down' and not (a_has or b_has):
                status_conf = 0.98
            else:
                status_conf = 0.7
        else:
            if a_stat == 'up' and b_stat == 'up':
                status_conf = 0.95
            else:
                status_conf = 0.8
                # Asymmetric confidence when "up" is evidence-driven and only one side has traffic
                if a_has != b_has:
                    if not a_has:
                        rx_conf_a *= 0.88
                        tx_conf_a *= 0.88
                    if not b_has:
                        rx_conf_b *= 0.88
                        tx_conf_b *= 0.88
            # Boost status confidence on strong bilateral agreement at high rates
            if (max(max_ab, max_ba) >= 10.0) and (d_ab <= 0.005) and (d_ba <= 0.005):
                status_conf = max(status_conf, 0.99)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * avg_penalty)))
=======
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)
        min_penalty = min(penalty_tx, penalty_rx)

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))
>>>>>>> REPLACE
</DIFF>