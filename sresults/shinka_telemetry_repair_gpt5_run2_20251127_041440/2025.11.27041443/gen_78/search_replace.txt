<NAME>
asym_partial_and_benefit_checked_microadjust
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy and confidence calibration:

1) Asymmetric partial averaging in pair consensus near the threshold. Instead of moving both sides equally toward the consensus when violations are modest, we move the louder side more and the quieter side less, with low-rate acceleration and capped shaping. This direction-aware asymmetry helps converge faster on the true value without overshooting, especially when one endpoint has stronger signal quality. It implements the "asymmetric partial averaging" idea while preserving existing guards and geometric-mean confidence floors.

2) Safer, benefit-checked router micro-adjustments. Replace the simple one-shot nudge with a conservative, two-option evaluation that simulates adjusting tx vs rx and commits only if router residual improves by at least 20% and internal skew remains guarded. Optionally allow a second very small step under stricter guards. This reduces risky nudges that hurt calibration and keeps changes aligned with flow conservation.

Additionally, I slightly refine quiet-side confidence shaping in the final composition: when rates are very low and the peer shows only small activity (≤2 Mbps), use gentler damping (0.92 instead of 0.88). This improves calibration on tiny flows.

These changes are localized, leverage topology and router residuals, and should boost both repair accuracy and confidence calibration without altering external behavior or interfaces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                    if diff_ab <= 2 * tol_ab:
                        # Partial averaging near threshold to reduce overcorrection
                        k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
=======
                    # Low-rate–aware shaping parameters
                    low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
                    full_mult_ab = 1.6 if low_band_ab else 2.0
                    exp_ab = 1.2 if low_band_ab else 1.0
                    if diff_ab <= full_mult_ab * tol_ab:
                        # Asymmetric partial averaging: move the louder side more
                        k_raw = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ab))
                        loud = max(a_tx, b_rx)
                        quiet = min(a_tx, b_rx)
                        r = (loud - quiet) / max(1.0, loud)
                        if a_tx >= b_rx:
                            k_a = clamp(k_base * (1.0 + 0.5 * r))
                            k_b = clamp(k_base * (1.0 - 0.5 * r))
                        else:
                            k_b = clamp(k_base * (1.0 + 0.5 * r))
                            k_a = clamp(k_base * (1.0 - 0.5 * r))
                        new_a_tx = a_tx * (1.0 - k_a) + consensus_ab * k_a
                        new_b_rx = b_rx * (1.0 - k_b) + consensus_ab * k_b
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                    if diff_ba <= 2 * tol_ba:
                        k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
=======
                    # Low-rate–aware shaping parameters
                    low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
                    full_mult_ba = 1.6 if low_band_ba else 2.0
                    exp_ba = 1.2 if low_band_ba else 1.0
                    if diff_ba <= full_mult_ba * tol_ba:
                        # Asymmetric partial averaging: move the louder side more
                        k_raw = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        k_base = max(0.0, min(1.0, k_raw ** exp_ba))
                        loud = max(b_tx, a_rx)
                        quiet = min(b_tx, a_rx)
                        r = (loud - quiet) / max(1.0, loud)
                        if b_tx >= a_rx:
                            k_b = clamp(k_base * (1.0 + 0.5 * r))
                            k_a = clamp(k_base * (1.0 - 0.5 * r))
                        else:
                            k_a = clamp(k_base * (1.0 + 0.5 * r))
                            k_b = clamp(k_base * (1.0 - 0.5 * r))
                        new_b_tx = b_tx * (1.0 - k_b) + consensus_ba * k_b
                        new_a_rx = a_rx * (1.0 - k_a) + consensus_ba * k_a
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces (recommendation 4)
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom

        # Identify unpaired, up interfaces
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if peer missing in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Adjust only the larger counter toward reducing the router imbalance
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        if imbalance > 0.0:
            # sum_tx > sum_rx: reduce tx or increase rx; nudge only larger counter
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                # reduce confidence to reflect heuristic adjustment
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_rx = rrx * (1.0 + alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        else:
            # sum_tx < sum_rx: reduce rx or increase tx; nudge only larger counter
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
            else:
                new_tx = rtx * (1.0 + alpha)
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
=======
    # Apply safer, benefit-checked micro-adjustments only on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue
        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom
        # Require sufficient residual to attempt micro-adjustments
        if resid_frac < 0.03:
            continue

        # Identify unpaired, up interfaces with non-trivial traffic
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                if max(txv, rxv) < LOW_RATE_CUTOFF:
                    continue  # avoid nudging tiny flows
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Helper to compute router residual for a single router from current result snapshot
        def compute_router_resid_local(router_id: str) -> float:
            stx, srx = 0.0, 0.0
            for iid in router_ifaces.get(router_id, []):
                if iid in result:
                    stx += float(result[iid]['tx_rate'][1])
                    srx += float(result[iid]['rx_rate'][1])
            return abs(stx - srx) / max(1.0, stx, srx)

        # Current values and internal skew
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        pre_internal = abs(rtx - rrx) / max(1.0, max(rtx, rrx))
        resid_before = compute_router_resid_local(r)

        # Simulate two options and choose the better improvement
        def simulate(option: str):
            new_tx, new_rx = rtx, rrx
            if imbalance > 0.0:
                if option == 'tx':
                    new_tx = rtx * (1.0 - alpha)
                else:
                    new_rx = rrx * (1.0 + alpha)
            else:
                if option == 'rx':
                    new_rx = rrx * (1.0 - alpha)
                else:
                    new_tx = rtx * (1.0 + alpha)
            # Apply temporarily
            saved_tx = result[top_if]['tx_rate']
            saved_rx = result[top_if]['rx_rate']
            result[top_if]['tx_rate'] = (otx, new_tx, tc)
            result[top_if]['rx_rate'] = (orx, new_rx, rc)
            resid_tmp = compute_router_resid_local(r)
            post_internal_tmp = abs(new_tx - new_rx) / max(1.0, max(new_tx, new_rx))
            # Revert
            result[top_if]['tx_rate'] = saved_tx
            result[top_if]['rx_rate'] = saved_rx
            return resid_tmp, post_internal_tmp, new_tx, new_rx

        r_tx, post_tx_internal, tx1, rx1 = simulate('tx')
        r_rx, post_rx_internal, tx2, rx2 = simulate('rx')

        # Pick option with larger residual improvement subject to internal-skew guard
        choice = None
        resid_after = resid_before
        new_tx = rtx
        new_rx = rrx
        if (r_tx <= r_rx) and (post_tx_internal <= pre_internal + 0.03):
            choice = 'tx'
            resid_after = r_tx
            new_tx, new_rx = tx1, rx1
        elif (r_rx < r_tx) and (post_rx_internal <= pre_internal + 0.03):
            choice = 'rx'
            resid_after = r_rx
            new_tx, new_rx = tx2, rx2

        # Commit only if improves residual by at least 20%
        if choice is not None and resid_after <= (1.0 - 0.20) * resid_before:
            if choice == 'tx':
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))

            # Optional second mini-step if residual remains sizable
            resid_after_first = compute_router_resid_local(r)
            if resid_after_first >= 0.04:
                alpha2 = min(0.01, 0.5 * resid_after_first)
                # simulate second step on the same direction
                if choice == 'tx':
                    tx_second = new_tx * (1.0 - alpha2) if imbalance > 0.0 else new_tx * (1.0 + alpha2)
                    saved = result[top_if]['tx_rate']
                    result[top_if]['tx_rate'] = (otx, tx_second, clamp(new_conf))
                    resid_second = compute_router_resid_local(r)
                    post_internal2 = abs(tx_second - new_rx) / max(1.0, max(tx_second, new_rx))
                    if resid_second <= (1.0 - 0.20) * resid_after_first and post_internal2 <= pre_internal + 0.03:
                        new_conf2 = min(new_conf, 0.6 + 0.2 * (alpha2 / 0.01))
                        result[top_if]['tx_rate'] = (otx, tx_second, clamp(new_conf2))
                    else:
                        result[top_if]['tx_rate'] = saved
                else:
                    rx_second = new_rx * (1.0 + alpha2) if imbalance > 0.0 else new_rx * (1.0 - alpha2)
                    saved = result[top_if]['rx_rate']
                    result[top_if]['rx_rate'] = (orx, rx_second, clamp(new_conf))
                    resid_second = compute_router_resid_local(r)
                    post_internal2 = abs(new_tx - rx_second) / max(1.0, max(new_tx, rx_second))
                    if resid_second <= (1.0 - 0.20) * resid_after_first and post_internal2 <= pre_internal + 0.03:
                        new_conf2 = min(new_conf, 0.6 + 0.2 * (alpha2 / 0.01))
                        result[top_if]['rx_rate'] = (orx, rx_second, clamp(new_conf2))
                    else:
                        result[top_if]['rx_rate'] = saved
        # else: no commit if guard fails or insufficient improvement
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and peer_rrx is not None and rtx <= QUIET_EPS and peer_rrx > QUIET_EPS:
            conf_tx_new = clamp(conf_tx_new * 0.88)
        if peer_exists and peer_rtx is not None and rrx <= QUIET_EPS and peer_rtx > QUIET_EPS:
            conf_rx_new = clamp(conf_rx_new * 0.88)
=======
        # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
        if peer_exists and peer_rrx is not None and rtx <= QUIET_EPS and peer_rrx > QUIET_EPS:
            # Gentler damping on tiny flows
            factor = 0.92 if (max(rtx, peer_rrx) < LOW_RATE_CUTOFF and peer_rrx <= 2.0) else 0.88
            conf_tx_new = clamp(conf_tx_new * factor)
        if peer_exists and peer_rtx is not None and rrx <= QUIET_EPS and peer_rtx > QUIET_EPS:
            factor = 0.92 if (max(rrx, peer_rtx) < LOW_RATE_CUTOFF and peer_rtx <= 2.0) else 0.88
            conf_rx_new = clamp(conf_rx_new * factor)
>>>>>>> REPLACE
</DIFF>