--- a/original.py
+++ b/original.py
@@ -1,389 +1,525 @@
 # EVOLVE-BLOCK-START
 """
-Direction-aware consensus repair with magnitude-aware thresholds and
-router-level micro-adjustments for flow conservation.
-
-Principles:
+Tilted asymmetric consensus with share-weighted confidence and guarded router micro-fixes.
+
+Principles implemented:
 - Link Symmetry (R3): my_tx ≈ their_rx and my_rx ≈ their_tx (pairwise hardening)
-- Flow Conservation (R1): Σ incoming = Σ outgoing per router (used for micro-fixes/confidence)
+- Flow Conservation (R1): Σ incoming = Σ outgoing per router (used for tilts, micro-fixes, and confidence)
 - Interface Consistency: paired statuses aligned; down links carry no traffic
 
-Enhancements:
-- Magnitude-aware tolerance and absolute guard (0.5 Mbps) to avoid over-correction on tiny flows.
-- Strong agreement confidence floors (≥0.99 on clear high-rate agreement).
-- Direction-aware router residual penalties for RX/TX confidences.
-- Targeted micro-adjustments on dangling interfaces that dominate a router’s imbalance; otherwise, capped proportional distribution.
+Novel elements:
+- Residual-tilted, direction-aware asymmetric convergence in the partial band.
+- More decisive low-rate convergence with dynamic absolute guard and aggressive ramp.
+- Safer, benefit-checked micro-adjustments for dominant dangling interfaces only.
+- Interface-share–aware, direction-coupled router residual penalties in confidence.
 """
 from typing import Dict, Any, Tuple, List
+import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
-    # Thresholds and constants
-    TH_REL_DEFAULT = 0.02   # 2% relative tolerance (τh)
-    TH_REL_LOW = 0.05       # 5% when flows are small (<10 Mbps)
-    TH_ABS_GUARD = 0.5      # require >0.5 Mbps absolute diff to trigger averaging
+    # Base thresholds
+    TH_REL_DEFAULT = 0.02           # 2% relative tolerance (τh)
+    TH_REL_LOW = 0.05               # 5% when flows are small (< LOW_RATE_CUTOFF)
+    LOW_RATE_CUTOFF = 10.0          # Mbps
+    ABS_GUARD_HIGH = 0.5            # Mbps absolute guard, normal
+    ABS_GUARD_LOW = 0.3             # Mbps absolute guard, low-rate
+    STRONG_AGREE_DIFF = 0.005       # 0.5% strong agreement for high-rate
     EPS = 1e-6
 
-    # Router micro-adjustment caps
-    MICRO_DOMINANT_FRACTION = 0.20  # cap single dominant interface adjustment to ≤20% of its directional magnitude
-    MICRO_DISTRIB_FRACTION = 0.10   # cap distributed adjustments to ≤10% of each interface's directional magnitude
+    # Micro-adjustment controls (router-level conservation nudges)
+    MIN_RESID_FRAC_FOR_MICRO = 0.03
+    DOMINANT_PICK_MIN_RATE = LOW_RATE_CUTOFF  # avoid nudging tiny flows
+    ALPHA_BASE = 0.02                         # max base fraction for first step
+    ALPHA_EXTRA = 0.01                        # optional second mini-step
+    REQUIRED_IMPROVEMENT_FIRST = 0.08         # ≥8% improvement to commit first step
+    REQUIRED_IMPROVEMENT_SECOND = 0.20        # ≥20% improvement to allow a second step
+    INTERNAL_SKEW_LIMIT = 0.03                # do not worsen |tx - rx| beyond 3% relative
 
     def to_float(x: Any) -> float:
         try:
             return float(x)
         except Exception:
             return 0.0
 
     def has_traffic(d: Dict[str, Any]) -> bool:
         return (to_float(d.get('rx_rate', 0.0)) > EPS) or (to_float(d.get('tx_rate', 0.0)) > EPS)
 
     def rel_diff(a: float, b: float) -> float:
         return abs(a - b) / max(a, b, 1.0)
+
+    def sign(x: float) -> int:
+        return 1 if x > 0 else (-1 if x < 0 else 0)
+
+    def clamp01(x: float) -> float:
+        return max(0.0, min(1.0, x))
 
     def change_ratio(orig: float, rep: float) -> float:
         denom = max(abs(orig), abs(rep), 1.0)
         return abs(rep - orig) / denom
 
     # Build unique undirected link pairs
     pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
     for if_id, data in telemetry.items():
         peer = data.get('connected_to')
         if peer and peer in telemetry:
             key = tuple(sorted([if_id, peer]))
             if key not in pairs:
                 pairs[key] = (if_id, peer)
 
+    # Precompute router signed residuals from original telemetry (for tilt)
+    router_delta_raw: Dict[str, float] = {}
+    router_sum_tx_raw: Dict[str, float] = {}
+    router_sum_rx_raw: Dict[str, float] = {}
+    for router, if_list in topology.items():
+        s_tx = 0.0
+        s_rx = 0.0
+        for iid in if_list:
+            if iid in telemetry:
+                s_tx += to_float(telemetry[iid].get('tx_rate', 0.0))
+                s_rx += to_float(telemetry[iid].get('rx_rate', 0.0))
+        router_sum_tx_raw[router] = s_tx
+        router_sum_rx_raw[router] = s_rx
+        router_delta_raw[router] = s_tx - s_rx  # signed (positive => TX surplus)
+
     # First pass: pairwise consensus hardening and status harmonization
     per_if: Dict[str, Dict[str, Any]] = {}
 
     for _, (a_id, b_id) in pairs.items():
         a = telemetry[a_id]
         b = telemetry[b_id]
 
         a_stat = a.get('interface_status', 'unknown')
         b_stat = b.get('interface_status', 'unknown')
 
         a_rx, a_tx = to_float(a.get('rx_rate', 0.0)), to_float(a.get('tx_rate', 0.0))
         b_rx, b_tx = to_float(b.get('rx_rate', 0.0)), to_float(b.get('tx_rate', 0.0))
 
         a_has = has_traffic(a)
         b_has = has_traffic(b)
 
         # Decide pair status using interface consistency + traffic evidence
         if a_stat == 'down' and b_stat == 'down':
             pair_status = 'down'
         elif a_stat == 'up' and b_stat == 'up':
             pair_status = 'up'
         else:
             pair_status = 'up' if (a_has or b_has) else 'down'
 
         # Initialize repaired values with originals
         rep_a_tx, rep_b_rx = a_tx, b_rx
         rep_b_tx, rep_a_rx = b_tx, a_rx
         rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = 1.0
 
         if pair_status == 'down':
             # Enforce no traffic on a down link
             rep_a_tx = rep_b_rx = rep_b_tx = rep_a_rx = 0.0
             base_conf = 0.95 if not (a_has or b_has) else 0.7
             rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
         else:
-            # Direction A->B (A.tx vs B.rx)
-            max_ab = max(a_tx, b_rx)
-            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
-            d_ab = rel_diff(a_tx, b_rx)
-            abs_ab = abs(a_tx - b_rx)
-
-            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
-                v = 0.5 * (a_tx + b_rx)
-                rep_a_tx = v
-                rep_b_rx = v
-                conf_base = max(0.0, 1.0 - d_ab)
-                # Penalize by applied change magnitude for calibration
-                change_a = change_ratio(a_tx, v)
-                change_b = change_ratio(b_rx, v)
-                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
-                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
-            else:
-                # Within tolerance: keep values and set strong confidence floors
-                if max_ab >= 10.0 and d_ab <= 0.005:
-                    conf_floor = 0.99
+            # Helper to do one direction with asymmetric, residual-tilted repair
+            def directional_repair(x_local: float, y_remote: float,
+                                   local_router: str,
+                                   low_rate_cutoff: float = LOW_RATE_CUTOFF) -> Tuple[float, float, float]:
+                """
+                Repair a directional pair (x_local vs y_remote), return (new_local, new_remote, conf).
+                """
+                d = rel_diff(x_local, y_remote)
+                max_mag = max(x_local, y_remote)
+                tau = TH_REL_LOW if max_mag < low_rate_cutoff else TH_REL_DEFAULT
+                abs_guard = ABS_GUARD_LOW if max_mag < low_rate_cutoff else ABS_GUARD_HIGH
+
+                # Start with originals
+                new_local = x_local
+                new_remote = y_remote
+                conf = max(0.0, 1.0 - d)
+
+                if (d > tau) and (abs(x_local - y_remote) > abs_guard):
+                    # Consensus target (weighted later if large)
+                    mid = 0.5 * (x_local + y_remote)
+
+                    # Signed tilt by local router residual alignment
+                    delta_r = router_delta_raw.get(local_router, 0.0)
+                    same_sign = (sign(x_local - y_remote) == sign(delta_r)) and (sign(delta_r) != 0)
+                    gamma = min(0.08, 0.1 * (abs(delta_r) / max(router_sum_tx_raw.get(local_router, 0.0),
+                                                                 router_sum_rx_raw.get(local_router, 0.0), 1.0)))
+                    # Partial band and full band handling
+                    # Low-rate: more decisive, with ramp exponent
+                    if max_mag < low_rate_cutoff:
+                        full_factor = 1.6  # more decisive full-convergence trigger
+                        ramp_exp = 1.2
+                    else:
+                        full_factor = 2.0
+                        ramp_exp = 1.0
+
+                    if d <= full_factor * tau:
+                        # Asymmetric partial averaging: move louder side more
+                        loud_is_local = x_local >= y_remote
+                        loud = max(x_local, y_remote)
+                        quiet = min(x_local, y_remote)
+                        k_base = ((d - tau) / max(tau, 1e-9)) ** ramp_exp
+                        r = (loud - quiet) / max(1.0, loud)
+                        k_loud = max(0.0, min(1.0, k_base * (1 + 0.5 * r)))
+                        k_quiet = max(0.0, min(1.0, k_base * (1 - 0.5 * r)))
+
+                        # Residual tilt: move local more if imbalance aligns
+                        if same_sign:
+                            if loud_is_local:
+                                k_loud = max(0.0, min(1.0, k_loud + gamma))
+                            else:
+                                k_quiet = max(0.0, min(1.0, k_quiet + gamma))
+                        # Apply moves toward midpoint
+                        new_loud = loud * (1.0 - k_loud) + mid * k_loud
+                        new_quiet = quiet * (1.0 - k_quiet) + mid * k_quiet
+                        if loud_is_local:
+                            new_local, new_remote = new_loud, new_quiet
+                        else:
+                            new_local, new_remote = new_quiet, new_loud
+                    else:
+                        # Large disagreement: converge to weighted consensus with tilt
+                        w_local = 0.5
+                        if same_sign:
+                            w_local = max(0.2, min(0.8, w_local - gamma))
+                        w_remote = 1.0 - w_local
+                        target = w_local * x_local + w_remote * y_remote
+                        new_local = target
+                        new_remote = target
+
+                    # Confidence: penalize by violation magnitude and change magnitude
+                    ch_loc = change_ratio(x_local, new_local)
+                    ch_rem = change_ratio(y_remote, new_remote)
+                    conf = min(conf, 1.0 - 0.8 * max(ch_loc, ch_rem))
                 else:
-                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
-                tx_conf_a = max(tx_conf_a, conf_floor)
-                rx_conf_b = max(rx_conf_b, conf_floor)
-
-            # Direction B->A (B.tx vs A.rx)
-            max_ba = max(b_tx, a_rx)
-            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
-            d_ba = rel_diff(b_tx, a_rx)
-            abs_ba = abs(b_tx - a_rx)
-
-            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
-                v2 = 0.5 * (b_tx + a_rx)
-                rep_b_tx = v2
-                rep_a_rx = v2
-                conf_base2 = max(0.0, 1.0 - d_ba)
-                change_b2 = change_ratio(b_tx, v2)
-                change_a2 = change_ratio(a_rx, v2)
-                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
-                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
-            else:
-                if max_ba >= 10.0 and d_ba <= 0.005:
-                    conf_floor2 = 0.99
-                else:
-                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
-                tx_conf_b = max(tx_conf_b, conf_floor2)
-                rx_conf_a = max(rx_conf_a, conf_floor2)
+                    # Within tolerance: strong floors
+                    if (max_mag >= low_rate_cutoff) and (d <= STRONG_AGREE_DIFF):
+                        conf = max(conf, 0.99)
+                    else:
+                        conf = max(conf, 0.98 if max_mag >= low_rate_cutoff else 0.97)
+                return new_local, new_remote, clamp01(conf)
+
+            # A->B: A.tx vs B.rx, tilt w.r.t A.local router
+            a_local_router = a.get('local_router')
+            b_local_router = b.get('local_router')
+
+            rep_a_tx, rep_b_rx, conf_ab = directional_repair(a_tx, b_rx, a_local_router)
+            rep_b_tx, rep_a_rx, conf_ba = directional_repair(b_tx, a_rx, b_local_router)
+
+            # Assign directional confidences
+            tx_conf_a = conf_ab
+            rx_conf_b = conf_ab
+            tx_conf_b = conf_ba
+            rx_conf_a = conf_ba
+
+            # Asymmetric confidence when only one side shows traffic
+            if (a_has != b_has):
+                if not a_has:
+                    rx_conf_a *= 0.90
+                    tx_conf_a *= 0.90
+                if not b_has:
+                    rx_conf_b *= 0.90
+                    tx_conf_b *= 0.90
 
         # Status confidence based on agreement and evidence
         if pair_status == 'down':
             status_conf = 0.98 if (a_stat == 'down' and b_stat == 'down' and not (a_has or b_has)) else 0.7
         else:
             status_conf = 0.95 if (a_stat == 'up' and b_stat == 'up') else 0.8
 
         per_if[a_id] = {
-            'repaired_rx': rep_a_rx,
-            'repaired_tx': rep_a_tx,
+            'repaired_rx': float(rep_a_rx),
+            'repaired_tx': float(rep_a_tx),
             'rx_conf': float(rx_conf_a),
             'tx_conf': float(tx_conf_a),
             'repaired_status': pair_status,
-            'status_conf': status_conf
+            'status_conf': float(status_conf)
         }
         per_if[b_id] = {
-            'repaired_rx': rep_b_rx,
-            'repaired_tx': rep_b_tx,
+            'repaired_rx': float(rep_b_rx),
+            'repaired_tx': float(rep_b_tx),
             'rx_conf': float(rx_conf_b),
             'tx_conf': float(tx_conf_b),
             'repaired_status': pair_status,
-            'status_conf': status_conf
+            'status_conf': float(status_conf)
         }
 
     # Handle dangling interfaces (no valid peer in telemetry)
     for if_id, data in telemetry.items():
         if if_id in per_if:
             continue
         status = data.get('interface_status', 'unknown')
         rx = to_float(data.get('rx_rate', 0.0))
         tx = to_float(data.get('tx_rate', 0.0))
         if status == 'down':
             per_if[if_id] = {
                 'repaired_rx': 0.0,
                 'repaired_tx': 0.0,
                 'rx_conf': 0.9,
                 'tx_conf': 0.9,
                 'repaired_status': 'down',
                 'status_conf': 0.95
             }
         else:
             per_if[if_id] = {
                 'repaired_rx': rx,
                 'repaired_tx': tx,
                 'rx_conf': 0.6,
                 'tx_conf': 0.6,
                 'repaired_status': status if status in ('up', 'down') else 'up',
                 'status_conf': 0.6
             }
 
-    # Router-level micro-adjustments for flow conservation using only dangling, up interfaces
+    # Router-level safer micro-adjustments on dominant unpaired interfaces only
     paired_ids = set()
     for _, (aid, bid) in pairs.items():
         paired_ids.add(aid)
         paired_ids.add(bid)
 
+    # Precompute router-level sums/residuals before micro-fixes
+    def compute_router_sums(per_if_map: Dict[str, Dict[str, Any]]) -> Tuple[Dict[str, float], Dict[str, float], Dict[str, float]]:
+        sum_tx_map: Dict[str, float] = {}
+        sum_rx_map: Dict[str, float] = {}
+        resid_frac_map: Dict[str, float] = {}
+        for router, if_list in topology.items():
+            s_tx = 0.0
+            s_rx = 0.0
+            for iid in if_list:
+                if iid in per_if_map:
+                    s_tx += to_float(per_if_map[iid]['repaired_tx'])
+                    s_rx += to_float(per_if_map[iid]['repaired_rx'])
+            sum_tx_map[router] = s_tx
+            sum_rx_map[router] = s_rx
+            resid_frac_map[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
+        return sum_tx_map, sum_rx_map, resid_frac_map
+
+    sum_tx_before, sum_rx_before, resid_frac_before = compute_router_sums(per_if)
+
     for router, if_list in topology.items():
         present = [iid for iid in if_list if iid in per_if]
         if not present:
             continue
 
-        # Compute current sums
-        sum_tx = sum(to_float(per_if[iid]['repaired_tx']) for iid in present)
-        sum_rx = sum(to_float(per_if[iid]['repaired_rx']) for iid in present)
-        delta = sum_tx - sum_rx  # want to drive toward zero
-        scale = max(sum_tx, sum_rx, 1.0)
-        # Skip tiny imbalances (use both relative τ and absolute guard)
-        if abs(delta) <= max(TH_ABS_GUARD, TH_REL_DEFAULT * scale):
+        s_tx = sum_tx_before.get(router, 0.0)
+        s_rx = sum_rx_before.get(router, 0.0)
+        delta = s_tx - s_rx
+        resid_frac = resid_frac_before.get(router, 0.0)
+
+        # Skip small imbalances
+        if abs(delta) <= max(ABS_GUARD_HIGH, TH_REL_DEFAULT * max(s_tx, s_rx, 1.0)):
+            continue
+        if resid_frac < MIN_RESID_FRAC_FOR_MICRO:
             continue
 
         # Candidates: dangling and up
         candidates = []
         for iid in present:
             if iid in paired_ids:
                 continue
             if per_if[iid].get('repaired_status', 'up') == 'down':
                 continue
             rep_tx = to_float(per_if[iid]['repaired_tx'])
             rep_rx = to_float(per_if[iid]['repaired_rx'])
             candidates.append((iid, rep_tx, rep_rx))
-
         if not candidates:
             continue
 
-        # Direction to adjust: if delta > 0 (TX surplus), increase RX; if delta < 0 (RX surplus), increase TX
-        # Weights by directional magnitude
-        if delta > 0:
+        # Direction for adjustment
+        dir_tx_surplus = delta > 0  # TX surplus => increase RX to compensate
+        # Pick dominant by directional magnitude
+        if dir_tx_surplus:
             weights = [(iid, tx) for (iid, tx, rx) in candidates]
         else:
             weights = [(iid, rx) for (iid, tx, rx) in candidates]
 
-        sum_w = sum(max(w, 0.0) for _, w in weights)
-        if sum_w <= EPS:
-            continue
-
-        # Dominant candidate logic: if a single interface has >50% of directional weight, micro-adjust only it
-        weights_sorted = sorted(weights, key=lambda x: x[1], reverse=True)
-        top_id, top_w = weights_sorted[0]
-        if top_w / sum_w >= 0.5:
-            # Micro-adjust cap by fraction of its directional magnitude
-            max_adjust = MICRO_DOMINANT_FRACTION * max(top_w, 1.0)
-            inc = min(abs(delta), max_adjust)
-            if inc > 0.0:
-                if delta > 0:
-                    # Increase RX on top_id
-                    orig = to_float(telemetry.get(top_id, {}).get('rx_rate', 0.0))
-                    new_val = to_float(per_if[top_id]['repaired_rx']) + inc
-                    per_if[top_id]['repaired_rx'] = new_val
-                    cr = change_ratio(orig, new_val)
-                    per_if[top_id]['rx_conf'] = max(0.0, min(float(per_if[top_id].get('rx_conf', 0.6)), 1.0 - 0.8 * cr))
+        weights.sort(key=lambda x: x[1], reverse=True)
+        top_id, top_w = weights[0]
+
+        if (top_w >= DOMINANT_PICK_MIN_RATE) and (top_w > 0):
+            # Compute tentative nudge size
+            alpha = min(ALPHA_BASE, 0.5 * resid_frac)
+            inc = alpha * top_w
+            inc = min(inc, abs(delta))  # don't overshoot
+            if inc > 0:
+                # Simulate and check benefits
+                before_skew = abs(to_float(per_if[top_id]['repaired_tx']) - to_float(per_if[top_id]['repaired_rx']))
+                # Apply tentative
+                if dir_tx_surplus:
+                    per_if[top_id]['repaired_rx'] = to_float(per_if[top_id]['repaired_rx']) + inc
                 else:
-                    # Increase TX on top_id
-                    orig = to_float(telemetry.get(top_id, {}).get('tx_rate', 0.0))
-                    new_val = to_float(per_if[top_id]['repaired_tx']) + inc
-                    per_if[top_id]['repaired_tx'] = new_val
-                    cr = change_ratio(orig, new_val)
-                    per_if[top_id]['tx_conf'] = max(0.0, min(float(per_if[top_id].get('tx_conf', 0.6)), 1.0 - 0.8 * cr))
-        else:
-            # Distribute with per-interface cap for micro adjustments
-            for iid, w in weights:
-                share = (w / sum_w) if sum_w > 0 else 0.0
-                inc = abs(delta) * share
-                cap = MICRO_DISTRIB_FRACTION * max(w, 1.0)
-                inc = min(inc, cap)
-                if inc <= 0.0:
-                    continue
-                if delta > 0:
-                    # Increase RX
-                    orig = to_float(telemetry.get(iid, {}).get('rx_rate', 0.0))
-                    new_val = to_float(per_if[iid]['repaired_rx']) + inc
-                    per_if[iid]['repaired_rx'] = new_val
-                    cr = change_ratio(orig, new_val)
-                    per_if[iid]['rx_conf'] = max(0.0, min(float(per_if[iid].get('rx_conf', 0.6)), 1.0 - 0.7 * cr))
+                    per_if[top_id]['repaired_tx'] = to_float(per_if[top_id]['repaired_tx']) + inc
+
+                # Recompute router residual
+                sum_tx_after, sum_rx_after, resid_frac_after = compute_router_sums(per_if)
+                new_resid = resid_frac_after.get(router, resid_frac)
+                improved = (resid_frac - new_resid) / max(resid_frac, 1e-9)
+
+                # Check internal skew constraint
+                after_skew = abs(to_float(per_if[top_id]['repaired_tx']) - to_float(per_if[top_id]['repaired_rx']))
+                skew_denom = max(before_skew, to_float(per_if[top_id]['repaired_tx']), to_float(per_if[top_id]['repaired_rx']), 1.0)
+                skew_increase_ok = (after_skew - before_skew) / skew_denom <= INTERNAL_SKEW_LIMIT
+
+                if (improved >= REQUIRED_IMPROVEMENT_FIRST) and skew_increase_ok:
+                    # Commit with confidence penalty proportional to change
+                    if dir_tx_surplus:
+                        orig = to_float(telemetry.get(top_id, {}).get('rx_rate', 0.0))
+                        cr = change_ratio(orig, to_float(per_if[top_id]['repaired_rx']))
+                        per_if[top_id]['rx_conf'] = max(0.0, min(float(per_if[top_id].get('rx_conf', 0.6)), 1.0 - 0.8 * cr))
+                    else:
+                        orig = to_float(telemetry.get(top_id, {}).get('tx_rate', 0.0))
+                        cr = change_ratio(orig, to_float(per_if[top_id]['repaired_tx']))
+                        per_if[top_id]['tx_conf'] = max(0.0, min(float(per_if[top_id].get('tx_conf', 0.6)), 1.0 - 0.8 * cr))
+
+                    # Optional second mini-step if big improvement and residual still large
+                    resid_frac_now = new_resid
+                    if improved >= REQUIRED_IMPROVEMENT_SECOND and resid_frac_now >= (MIN_RESID_FRAC_FOR_MICRO + 0.01):
+                        inc2 = min(ALPHA_EXTRA * top_w, abs(sum_tx_after.get(router, 0.0) - sum_rx_after.get(router, 0.0)))
+                        if inc2 > 0:
+                            if dir_tx_surplus:
+                                per_if[top_id]['repaired_rx'] = to_float(per_if[top_id]['repaired_rx']) + inc2
+                                orig2 = to_float(telemetry.get(top_id, {}).get('rx_rate', 0.0))
+                                cr2 = change_ratio(orig2, to_float(per_if[top_id]['repaired_rx']))
+                                per_if[top_id]['rx_conf'] = max(0.0, min(float(per_if[top_id].get('rx_conf', 0.6)), 1.0 - 0.8 * cr2))
+                            else:
+                                per_if[top_id]['repaired_tx'] = to_float(per_if[top_id]['repaired_tx']) + inc2
+                                orig2 = to_float(telemetry.get(top_id, {}).get('tx_rate', 0.0))
+                                cr2 = change_ratio(orig2, to_float(per_if[top_id]['repaired_tx']))
+                                per_if[top_id]['tx_conf'] = max(0.0, min(float(per_if[top_id].get('tx_conf', 0.6)), 1.0 - 0.8 * cr2))
                 else:
-                    # Increase TX
-                    orig = to_float(telemetry.get(iid, {}).get('tx_rate', 0.0))
-                    new_val = to_float(per_if[iid]['repaired_tx']) + inc
-                    per_if[iid]['repaired_tx'] = new_val
-                    cr = change_ratio(orig, new_val)
-                    per_if[iid]['tx_conf'] = max(0.0, min(float(per_if[iid].get('tx_conf', 0.6)), 1.0 - 0.7 * cr))
-
-    # Compute router-level residuals after repairs for confidence penalties
+                    # Revert the tentative change if not beneficial
+                    if dir_tx_surplus:
+                        per_if[top_id]['repaired_rx'] = to_float(per_if[top_id]['repaired_rx']) - inc
+                    else:
+                        per_if[top_id]['repaired_tx'] = to_float(per_if[top_id]['repaired_tx']) - inc
+
+    # Compute router-level residuals after repairs
+    router_sum_tx: Dict[str, float] = {}
+    router_sum_rx: Dict[str, float] = {}
     router_residual: Dict[str, float] = {}
     for router, if_list in topology.items():
         s_tx = 0.0
         s_rx = 0.0
         for iid in if_list:
             if iid in per_if:
                 s_tx += to_float(per_if[iid]['repaired_tx'])
                 s_rx += to_float(per_if[iid]['repaired_rx'])
+        router_sum_tx[router] = s_tx
+        router_sum_rx[router] = s_rx
         router_residual[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
 
-    # Final assembly with direction-aware confidence scaling
+    # Final assembly with interface-share–aware, direction-coupled penalties
     result: Dict[str, Dict[str, Tuple]] = {}
     for if_id, data in telemetry.items():
         rep = per_if.get(if_id, {})
         repaired_rx = to_float(rep.get('repaired_rx', data.get('rx_rate', 0.0)))
         repaired_tx = to_float(rep.get('repaired_tx', data.get('tx_rate', 0.0)))
         repaired_status = rep.get('repaired_status', data.get('interface_status', 'unknown'))
 
         rx_conf = float(rep.get('rx_conf', 0.6))
         tx_conf = float(rep.get('tx_conf', 0.6))
         status_conf = float(rep.get('status_conf', 0.6))
 
         local_router = data.get('local_router')
         remote_router = data.get('remote_router')
         resid_local = router_residual.get(local_router, 0.0)
         resid_remote = router_residual.get(remote_router, 0.0)
 
-        # Direction-aware penalties: TX depends more on local, RX more on remote
-        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
-        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
-        penalty_tx = max(0.0, min(1.0, penalty_tx))
-        penalty_rx = max(0.0, min(1.0, penalty_rx))
+        # Compute local sums for share weighting
+        sum_tx_local = router_sum_tx.get(local_router, 0.0)
+        sum_rx_local = router_sum_rx.get(local_router, 0.0)
+
+        # Directional shares on local router
+        tx_share = repaired_tx / max(1.0, sum_tx_local)
+        rx_share = repaired_rx / max(1.0, sum_rx_local)
+
+        # TX: emphasize local residual by the interface's TX share
+        wL_tx = 0.6 + 0.2 * tx_share
+        wR_tx = 0.4 - 0.2 * tx_share
+        wL_tx = clamp01(wL_tx)
+        wR_tx = clamp01(wR_tx)
+        # RX: invert roles to emphasize remote side
+        wL_rx = 0.4 - 0.2 * rx_share
+        wR_rx = 0.6 + 0.2 * rx_share
+        wL_rx = clamp01(wL_rx)
+        wR_rx = clamp01(wR_rx)
+
+        penalty_tx = 1.0 - (wL_tx * resid_local + wR_tx * resid_remote)
+        penalty_rx = 1.0 - (wL_rx * resid_local + wR_rx * resid_remote)
+        penalty_tx = clamp01(penalty_tx)
+        penalty_rx = clamp01(penalty_rx)
         avg_penalty = 0.5 * (penalty_tx + penalty_rx)
 
-        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
-        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
+        tx_conf = clamp01(tx_conf * penalty_tx)
+        rx_conf = clamp01(rx_conf * penalty_rx)
         # Status confidence mildly scaled by average penalty
-        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * avg_penalty)))
+        status_conf = clamp01(status_conf * (0.75 + 0.25 * avg_penalty))
 
         # Assemble result tuples
         rx_orig = to_float(data.get('rx_rate', 0.0))
         tx_orig = to_float(data.get('tx_rate', 0.0))
         status_orig = data.get('interface_status', 'unknown')
 
         out: Dict[str, Any] = {}
         out['rx_rate'] = (rx_orig, repaired_rx, rx_conf)
         out['tx_rate'] = (tx_orig, repaired_tx, tx_conf)
         out['interface_status'] = (status_orig, repaired_status, status_conf)
 
         # Copy metadata unchanged
         out['connected_to'] = data.get('connected_to')
         out['local_router'] = local_router
         out['remote_router'] = remote_router
 
         result[if_id] = out
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")