<NAME>
prescale_and_adaptive_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements to raise counter repair accuracy and tighten confidence calibration without destabilizing the current logic:

1) Gentle multiplicative pre-harmonization before averaging (pair-level):
   - For each direction that triggers repair (diff > tol and abs > guard), compute a bounded prescale factor s = clamp(sqrt(peer/local), 0.90, 1.10) when rates are ≥1 Mbps.
   - Use only the prescaled pair to compute the effective discrepancy used for the partial averaging gain k (and the partial/full boundary). Keep the consensus target v as currently computed (with residual-tilted weighting) in the original domain. This reduces ratio bias in k while preserving proven targets and guards.
   - Implemented symmetrically for A->B and B->A.

2) Severity-adaptive, direction-aware router penalties with share weighting (confidence):
   - Modulate the local/remote residual blending using severity amp ∈ {0.1, 0.2, 0.3} based on max residual, and bias the blend by the per-interface TX/RX shares. This preserves directionality (local weighs more for TX, remote more for RX) while adapting to how “talkative” each direction is, improving calibration under varying imbalance severities.
   - Additionally, reintroduce guarded quiet-side damping when the link is deemed up solely by traffic evidence on one side: strong damping 0.88 at higher rates, relaxed to 0.92 when flows are tiny (≤2 Mbps and low-rate link). This avoids overconfidence on the silent endpoint at low traffic.

These changes follow the research guidance: we still use redundancy to harden signals, respect link symmetry and flow conservation, and provide more accurate confidence scoring that correlates with repair quality.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
                # Residual-tilted, direction-aware consensus weight (A's router)
                resid_a = resid_signed.get(a.get('local_router'), 0.0)
                if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                    gamma = min(0.08, 0.1 * abs(resid_a))
                    w_a = clamp(0.5 - gamma, 0.2, 0.8)
                    w_b = 1.0 - w_a
                    v = w_a * a_tx + w_b * b_rx
                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
=======
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # Gentle multiplicative prescaling to reduce ratio bias (for k computation only)
                if max_ab >= 1.0:
                    s = (max(EPS, b_rx) / max(EPS, a_tx)) ** 0.5
                    s = clamp(s, 0.90, 1.10)
                    d_k = rel_diff(a_tx * s, b_rx / s)
                else:
                    d_k = d_ab

                v = 0.5 * (a_tx + b_rx)
                # Residual-tilted, direction-aware consensus weight (A's router)
                resid_a = resid_signed.get(a.get('local_router'), 0.0)
                if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                    gamma = min(0.08, 0.1 * abs(resid_a))
                    w_a = clamp(0.5 - gamma, 0.2, 0.8)
                    w_b = 1.0 - w_a
                    v = w_a * a_tx + w_b * b_rx

                # Use prescaled discrepancy for partial/full decision and gain
                if d_k <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_k - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                # Residual-tilted, direction-aware consensus weight (B's router)
                resid_b = resid_signed.get(b.get('local_router'), 0.0)
                if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                    gamma2 = min(0.08, 0.1 * abs(resid_b))
                    w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                    w_a2 = 1.0 - w_b2
                    v2 = w_b2 * b_tx + w_a2 * a_rx
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
=======
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                # Gentle multiplicative prescaling to reduce ratio bias (for k computation only)
                if max_ba >= 1.0:
                    s2 = (max(EPS, a_rx) / max(EPS, b_tx)) ** 0.5
                    s2 = clamp(s2, 0.90, 1.10)
                    d_k2 = rel_diff(b_tx * s2, a_rx / s2)
                else:
                    d_k2 = d_ba

                v2 = 0.5 * (b_tx + a_rx)
                # Residual-tilted, direction-aware consensus weight (B's router)
                resid_b = resid_signed.get(b.get('local_router'), 0.0)
                if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                    gamma2 = min(0.08, 0.1 * abs(resid_b))
                    w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                    w_a2 = 1.0 - w_b2
                    v2 = w_b2 * b_tx + w_a2 * a_rx

                # Use prescaled discrepancy for partial/full decision and gain
                if d_k2 <= partial_upper_ba:
                    k_base2 = (d_k2 - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            status_conf = 0.98 if (a_stat == 'down' and b_stat == 'down' and not (a_has or b_has)) else 0.7
        else:
            status_conf = 0.95 if (a_stat == 'up' and b_stat == 'up') else 0.8
=======
        # Status confidence based on agreement and evidence
        if pair_status == 'down':
            status_conf = 0.98 if (a_stat == 'down' and b_stat == 'down' and not (a_has or b_has)) else 0.7
        else:
            status_conf = 0.95 if (a_stat == 'up' and b_stat == 'up') else 0.8
            # Asymmetric confidence shaping when only one side has observable traffic
            if a_has != b_has:
                a_max = max(a_tx, a_rx)
                b_max = max(b_tx, b_rx)
                active_max = a_max if a_has else b_max
                # Stronger damping on high-rate links; relax on tiny flows to avoid over-penalizing quiet side
                damp = 0.88
                if max(a_max, b_max) < LOW_RATE_CUTOFF and active_max <= 2.0:
                    damp = 0.92
                if not a_has:
                    rx_conf_a *= damp
                    tx_conf_a *= damp
                if not b_has:
                    rx_conf_b *= damp
                    tx_conf_b *= damp
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Direction-aware penalties: TX depends more on local, RX more on remote
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        # Status confidence mildly scaled by average penalty
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * avg_penalty)))
=======
        # Severity-adaptive, direction-aware penalties with share weighting
        severity = max(resid_local, resid_remote)
        if severity < 0.03:
            amp = 0.1
        elif severity < 0.12:
            amp = 0.2
        else:
            amp = 0.3
        total_mag = max(repaired_tx + repaired_rx, 1e-9)
        tx_share = repaired_tx / total_mag
        rx_share = repaired_rx / total_mag
        penalty_tx = 1.0 - ((0.6 + amp * tx_share) * resid_local + (0.4 - amp * tx_share) * resid_remote)
        penalty_rx = 1.0 - ((0.6 + amp * rx_share) * resid_remote + (0.4 - amp * rx_share) * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        min_penalty = min(penalty_tx, penalty_rx)

        tx_conf = max(0.0, min(1.0, tx_conf * penalty_tx))
        rx_conf = max(0.0, min(1.0, rx_conf * penalty_rx))
        # Status confidence scaled conservatively by the weaker (min) penalty
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))
>>>>>>> REPLACE
</DIFF>