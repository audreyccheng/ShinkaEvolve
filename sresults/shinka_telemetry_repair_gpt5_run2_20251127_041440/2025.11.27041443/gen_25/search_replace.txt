<NAME>
router_dominant_dangling_nudge
</NAME>

<DESCRIPTION>
I add a conservative, topology-aware micro-adjustment step that improves flow conservation (R1) by nudging only dominant dangling interfaces when a router’s imbalance is significant. This targets counter accuracy without breaking proven link symmetry repairs.

Key points:
- Identify routers with high normalized imbalance after pairwise hardening.
- Among interfaces on that router, find an unpaired (dangling), up interface whose contribution dominates (>50%) the router’s imbalance.
- Nudge its larger counter in the direction that reduces the imbalance by a small fraction α, scaled by residual (α ≤ 0.3).
- Adjust confidence for the changed counter based on the relative change from the original measurement.
- Recompute router residuals after the adjustments and keep the existing direction-aware confidence penalties.

This aligns with Hodor’s flow conservation while keeping changes minimal and well-calibrated.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Second pass: compute router-level flow conservation residuals using repaired rates
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
=======
    # Router-level micro-adjustments: nudge dominant dangling interfaces to reduce imbalance (R1)
    # Build set of paired interfaces to avoid breaking symmetry on known links
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        # Compute current sums from repaired values
        present = [iid for iid in if_list if iid in per_if_repair]
        if not present:
            continue
        sum_tx = 0.0
        sum_rx = 0.0
        for iid in present:
            rep = per_if_repair[iid]
            sum_tx += float(rep['repaired_tx'])
            sum_rx += float(rep['repaired_rx'])
        delta = sum_tx - sum_rx
        scale = max(sum_tx, sum_rx, 1.0)
        resid = abs(delta) / scale

        # Only act on clearly imbalanced routers
        RESID_THRESHOLD = max(2.0 * HARDENING_THRESHOLD, 0.05)  # at least 5% or 2τh
        if resid < RESID_THRESHOLD or abs(delta) <= EPS:
            continue

        # Consider dangling, up interfaces and find the dominant contributor
        candidates = []
        for iid in present:
            if iid in paired_ids:
                continue
            rep = per_if_repair[iid]
            if rep.get('repaired_status', 'up') == 'down':
                continue
            contrib = float(rep['repaired_tx']) - float(rep['repaired_rx'])
            candidates.append((iid, contrib))

        if not candidates:
            continue

        # Pick interface with the largest absolute contribution
        dom_iid, dom_contrib = max(candidates, key=lambda t: abs(t[1]))
        if abs(dom_contrib) < 0.5 * abs(delta):
            # Not dominant enough; skip adjustments to avoid overfitting
            pass
        else:
            # Nudge magnitude scaled by residual, capped to remain conservative
            alpha = min(0.3, 0.5 * resid)
            step = alpha * abs(delta)

            rep = per_if_repair[dom_iid]
            cur_tx = float(rep['repaired_tx'])
            cur_rx = float(rep['repaired_rx'])

            # Adjust the larger counter in the direction that reduces delta
            if delta > 0.0 and dom_contrib > 0.0:
                # Too much TX at router and this iface contributes positive (tx>rx): reduce its TX
                dec = min(step, cur_tx)
                new_tx = cur_tx - dec
                per_if_repair[dom_iid]['repaired_tx'] = new_tx
                # Confidence penalty based on change from original observation
                tx_orig = float(telemetry.get(dom_iid, {}).get('tx_rate', 0.0) or 0.0)
                denom = max(abs(tx_orig), abs(new_tx), 1.0)
                cr = abs(new_tx - tx_orig) / denom
                per_if_repair[dom_iid]['tx_conf'] = max(0.0, min(float(per_if_repair[dom_iid].get('tx_conf', 0.6)), 1.0 - cr))
            elif delta < 0.0 and dom_contrib < 0.0:
                # Too much RX at router and this iface contributes negative (rx>tx): reduce its RX
                dec = min(step, cur_rx)
                new_rx = cur_rx - dec
                per_if_repair[dom_iid]['repaired_rx'] = new_rx
                rx_orig = float(telemetry.get(dom_iid, {}).get('rx_rate', 0.0) or 0.0)
                denom = max(abs(rx_orig), abs(new_rx), 1.0)
                cr = abs(new_rx - rx_orig) / denom
                per_if_repair[dom_iid]['rx_conf'] = max(0.0, min(float(per_if_repair[dom_iid].get('rx_conf', 0.6)), 1.0 - cr))
            # If signs don't align, we skip to avoid counterproductive changes

    # Second pass: compute router-level flow conservation residuals using repaired rates (post-nudge)
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in per_if_repair:
                rep = per_if_repair[if_id]
                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
                sum_tx += float(rep['repaired_tx'])
                sum_rx += float(rep['repaired_rx'])
        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
        router_residual[router] = resid
>>>>>>> REPLACE

</DIFF>