<NAME>
magnitude_aware_symmetry
</NAME>

<DESCRIPTION>
I propose to make the link-symmetry hardening magnitude-aware and guarded by an absolute difference. This reduces unnecessary averaging on tiny flows (where relative error is misleading) and improves confidence calibration by rewarding strong agreements on high-rate links. Specifically:
- Add LOW_RATE_MAX, ELEVATED_THRESHOLD, ABS_DIFF_GUARD, and STRONG_AGREE_DIFF parameters.
- Introduce dynamic_tau(a, b) to raise the symmetry tolerance from 2% to 5% when both sides are below 10 Mbps.
- Only perform pairwise averaging if both the normalized diff exceeds the magnitude-aware threshold and the absolute difference exceeds 0.5 Mbps.
- Apply higher confidence floors for very strong agreements on high-rate links and slightly lower floors on low-rate links.

These changes should improve counter repair accuracy by avoiding over-correction in low-traffic scenarios and refine confidence calibration by aligning higher confidence with strong, high-quality signals. The rest of the algorithm, including router-level penalties, remains unchanged to maintain stability.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Parameters
    HARDENING_THRESHOLD = 0.02  # τh: 2% tolerance
    EPS = 1e-6                  # numeric floor for zero traffic detection
    ROUTER_PENALTY_WEIGHT = 0.5
    STATUS_PENALTY_BLEND = 0.25
=======
    # Parameters
    HARDENING_THRESHOLD = 0.02  # τh: 2% tolerance
    EPS = 1e-6                  # numeric floor for zero traffic detection
    ROUTER_PENALTY_WEIGHT = 0.5
    STATUS_PENALTY_BLEND = 0.25
    # Magnitude-aware symmetry controls
    LOW_RATE_MAX = 10.0         # Mbps: below this, use elevated tolerance
    ELEVATED_THRESHOLD = 0.05   # 5% tolerance for low-rate links
    ABS_DIFF_GUARD = 0.5        # Mbps: require absolute diff > 0.5 to trigger averaging
    STRONG_AGREE_DIFF = 0.005   # 0.5%: strong agreement floor
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def has_traffic(d: Dict[str, Any]) -> bool:
        # Detect any traffic beyond EPS in either direction
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)

    # Build unique link pairs (undirected, canonicalized)
    pairs = {}  # key: tuple(sorted([if1, if2])) -> (ifA, ifB)
=======
    def has_traffic(d: Dict[str, Any]) -> bool:
        # Detect any traffic beyond EPS in either direction
        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)

    def dynamic_tau(a: float, b: float) -> float:
        """
        Magnitude-aware tolerance: for low-rate signals, increase τh to reduce
        over-correction due to sampling noise.
        """
        return ELEVATED_THRESHOLD if max(a, b) < LOW_RATE_MAX else HARDENING_THRESHOLD

    # Build unique link pairs (undirected, canonicalized)
    pairs = {}  # key: tuple(sorted([if1, if2])) -> (ifA, ifB)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with τh tolerance
            # Direction A->B (A.tx vs B.rx)
            diff_ab = norm_diff(a_tx, b_rx)
            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            # Direction B->A (B.tx vs A.rx)
            diff_ba = norm_diff(b_tx, a_rx)
            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
=======
        else:
            # Link is up: enforce link symmetry with τh tolerance (magnitude-aware)
            # Direction A->B (A.tx vs B.rx)
            diff_ab = norm_diff(a_tx, b_rx)
            tau_ab = dynamic_tau(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            # Confidence floors based on agreement strength and magnitude
            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                conf_ab = max(conf_ab, 0.99)
            elif diff_ab <= tau_ab:
                conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            # Direction B->A (B.tx vs A.rx)
            diff_ba = norm_diff(b_tx, a_rx)
            tau_ba = dynamic_tau(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                conf_ba = max(conf_ba, 0.99)
            elif diff_ba <= tau_ba:
                conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)
>>>>>>> REPLACE
</DIFF>