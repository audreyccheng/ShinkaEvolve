<NAME>
trust_weighted_consensus_asym_confidence
</NAME>

<DESCRIPTION>
To improve counter repair accuracy while keeping strong confidence calibration, I propose three targeted changes:

1) Trust-weighted directional consensus: Replace simple averaging with activity-weighted consensus when repairing mismatched link counters. The side with larger observed traffic (a proxy for signal reliability) is given higher weight. This generally improves repair accuracy over naive averaging when one endpoint is more reliable.

2) Asymmetric confidence shaping under one-sided traffic: When only one side of a link direction exhibits traffic (above a small QUIET_EPS), reduce the silent sideâ€™s confidence for the corresponding counter. This aligns confidence with evidence and further improves calibration without aggressive counter changes.

3) Minor cleanup and consolidation: Remove redundant confidence assignment lines and apply the asymmetric confidence scaling in the second pass.

These changes preserve the magnitude-aware gating (2%/5% thresholds and absolute guard), partial averaging near threshold, and direction-aware router residual penalties. They should improve counter_repair_accuracy without sacrificing the already strong confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    HARDENING_THRESHOLD = 0.02
    # Magnitude-aware tolerance and absolute guard to avoid over-correcting tiny flows
    LOW_RATE_CUTOFF = 10.0  # Mbps
    ABS_GUARD = 0.5         # Mbps; require this absolute delta to trigger a repair
=======
    HARDENING_THRESHOLD = 0.02
    # Magnitude-aware tolerance and absolute guard to avoid over-correcting tiny flows
    LOW_RATE_CUTOFF = 10.0  # Mbps
    ABS_GUARD = 0.5         # Mbps; require this absolute delta to trigger a repair
    QUIET_EPS = 0.1         # Mbps; consider as "no traffic" for asymmetry handling
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    field_conf_floor: Dict[Tuple[str, str], float] = {}
=======
    field_conf_floor: Dict[Tuple[str, str], float] = {}
    # multiplicative confidence scalers for asymmetric traffic evidence
    field_conf_scale: Dict[Tuple[str, str], float] = {}
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        a_tx = float(a_data.get('tx_rate', 0.0))
        a_rx = float(a_data.get('rx_rate', 0.0))
        b_tx = float(b_data.get('tx_rate', 0.0))
        b_rx = float(b_data.get('rx_rate', 0.0))
=======
        a_tx = float(a_data.get('tx_rate', 0.0))
        a_rx = float(a_data.get('rx_rate', 0.0))
        b_tx = float(b_data.get('tx_rate', 0.0))
        b_rx = float(b_data.get('rx_rate', 0.0))

        # Activity-based trust weights (bias consensus toward stronger signal)
        act_a = max(a_tx, a_rx)
        act_b = max(b_tx, b_rx)
        denom_act = max(1e-9, act_a + act_b)
        w_a = act_a / denom_act
        w_b = act_b / denom_act
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                avg_ab = 0.5 * (a_tx + b_rx)
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + avg_ab * k
                    new_b_rx = b_rx * (1.0 - k) + avg_ab * k
                else:
                    # Full averaging for clear violations
                    new_a_tx = avg_ab
                    new_b_rx = avg_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                # Confidence aligned with disagreement magnitude
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
=======
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                # Trust-weighted consensus using activity as reliability proxy
                consensus_ab = w_a * a_tx + w_b * b_rx
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                else:
                    # Clear violation: converge fully to consensus
                    new_a_tx = consensus_ab
                    new_b_rx = consensus_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                # Confidence aligned with disagreement magnitude
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                avg_ba = 0.5 * (b_tx + a_rx)
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + avg_ba * k
                    new_a_rx = a_rx * (1.0 - k) + avg_ba * k
                else:
                    new_b_tx = avg_ba
                    new_a_rx = avg_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
=======
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                consensus_ba = w_b * b_tx + w_a * a_rx
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                else:
                    new_b_tx = consensus_ba
                    new_a_rx = consensus_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)

            # Asymmetric confidence when only one side shows traffic (directional)
            if a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
                field_conf_scale[(b_id, 'rx')] = min(field_conf_scale.get((b_id, 'rx'), 1.0), 0.9)
            if b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
                field_conf_scale[(a_id, 'tx')] = min(field_conf_scale.get((a_id, 'tx'), 1.0), 0.9)
            if b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
                field_conf_scale[(a_id, 'rx')] = min(field_conf_scale.get((a_id, 'rx'), 1.0), 0.9)
            if a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
                field_conf_scale[(b_id, 'tx')] = min(field_conf_scale.get((b_id, 'tx'), 1.0), 0.9)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (interface_id, 'rx') in field_value_adjust:
                repaired_rx = float(field_value_adjust[(interface_id, 'rx')])
                rx_confidence = min(rx_confidence, field_conf_assign.get((interface_id, 'rx'), rx_confidence))
                rx_confidence = field_conf_assign.get((interface_id, 'rx'), rx_confidence)
            if (interface_id, 'tx') in field_value_adjust:
                repaired_tx = float(field_value_adjust[(interface_id, 'tx')])
                tx_confidence = min(tx_confidence, field_conf_assign.get((interface_id, 'tx'), tx_confidence))
                tx_confidence = field_conf_assign.get((interface_id, 'tx'), tx_confidence)
=======
            if (interface_id, 'rx') in field_value_adjust:
                repaired_rx = float(field_value_adjust[(interface_id, 'rx')])
                rx_confidence = field_conf_assign.get((interface_id, 'rx'), rx_confidence)
            if (interface_id, 'tx') in field_value_adjust:
                repaired_tx = float(field_value_adjust[(interface_id, 'tx')])
                tx_confidence = field_conf_assign.get((interface_id, 'tx'), tx_confidence)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if tx_floor is not None:
                tx_confidence = max(tx_confidence, tx_floor)
=======
            if tx_floor is not None:
                tx_confidence = max(tx_confidence, tx_floor)

            # Apply asymmetric confidence scaling if present
            if (interface_id, 'rx') in field_conf_scale:
                rx_confidence = clamp(rx_confidence * field_conf_scale[(interface_id, 'rx')])
            if (interface_id, 'tx') in field_conf_scale:
                tx_confidence = clamp(tx_confidence * field_conf_scale[(interface_id, 'tx')])
>>>>>>> REPLACE

</DIFF>