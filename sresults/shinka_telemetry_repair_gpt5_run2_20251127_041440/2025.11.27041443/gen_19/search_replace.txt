<NAME>
magnitude_aware_and_router_confidence
</NAME>

<DESCRIPTION>
I’m introducing two targeted improvements inspired by Hodor’s three-step approach to improve both counter repair accuracy and confidence calibration, while keeping changes minimal and consistent with the current design:

1) Magnitude-aware symmetry tolerance with absolute guard:
   - Keep the 2% threshold for typical flows but raise it to 5% for low-rate links (max < 10 Mbps) and require an absolute delta > 0.5 Mbps to trigger any repair. This avoids over-correcting low-traffic noise and results in fewer unnecessary changes, improving counter accuracy and calibration.

2) Direction-aware router-level confidence attenuation from flow conservation:
   - After link-level repairs, compute per-router residuals |Σtx − Σrx| / max(1, Σtx, Σrx). Attenuate confidences in a direction-aware manner: TX confidence is penalized more by the local router residual, RX confidence more by the remote router residual. This aligns confidence with likely inconsistencies while not changing repaired values, typically improving calibration without hurting accuracy.

Additionally, I enforce interface consistency across connected pairs:
   - If either side reports down, set both sides effectively down (rates to 0 for the local view), with higher confidence if both agree. This is consistent with the invariant that down interfaces cannot send/receive and improves robustness.

These changes preserve the current code’s structure (pairwise hardening remains) while making the trigger for repairs more robust and calibrating confidence via router-level flow conservation.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02

    result = {}

    # First pass: collect all measurements and check link symmetry
    link_symmetry_violations = {}
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Magnitude-aware tolerance and absolute guard to avoid over-correcting tiny flows
    LOW_RATE_CUTOFF = 10.0  # Mbps
    ABS_GUARD = 0.5         # Mbps, require this absolute delta to trigger a repair

    def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
        return max(lo, min(hi, x))

    result = {}

    # First pass: collect all measurements and check link symmetry
    link_symmetry_violations = {}
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Default: no repair, high confidence
        repaired_rx = rx_rate
        repaired_tx = tx_rate
        repaired_status = interface_status
        rx_confidence = 1.0
        tx_confidence = 1.0
        status_confidence = 1.0

        # Check for issues and attempt repair
        if interface_id in link_symmetry_violations:
            violations = link_symmetry_violations[interface_id]

            # Repair RX rate if link symmetry is violated
            if violations['rx_tx_diff'] > HARDENING_THRESHOLD:
                # Use peer's TX as more reliable signal
                repaired_rx = violations['peer_tx']
                # Confidence decreases with magnitude of violation
                rx_confidence = max(0.0, 1.0 - violations['rx_tx_diff'])

            # Repair TX rate if link symmetry is violated
            if violations['tx_rx_diff'] > HARDENING_THRESHOLD:
                # Use peer's RX as more reliable signal
                repaired_tx = violations['peer_rx']
                # Confidence decreases with magnitude of violation
                tx_confidence = max(0.0, 1.0 - violations['tx_rx_diff'])

        # Check status consistency
        if connected_to and connected_to in telemetry:
            peer_status = telemetry[connected_to].get('interface_status', 'unknown')
            # If statuses don't match, lower confidence
            if interface_status != peer_status:
                status_confidence = 0.5
                # If interface is down but has non-zero rates, that's suspicious
                if interface_status == 'down' and (rx_rate > 0 or tx_rate > 0):
                    repaired_rx = 0.0
                    repaired_tx = 0.0
                    rx_confidence = 0.3
                    tx_confidence = 0.3
=======
        # Default: no repair, high confidence
        repaired_rx = rx_rate
        repaired_tx = tx_rate
        repaired_status = interface_status
        rx_confidence = 1.0
        tx_confidence = 1.0
        status_confidence = 1.0

        # Peer hints (if any)
        peer_status = None
        peer_rx = None
        peer_tx = None
        if connected_to and connected_to in telemetry:
            peer = telemetry[connected_to]
            peer_status = peer.get('interface_status', 'unknown')
            peer_rx = float(peer.get('rx_rate', 0.0))
            peer_tx = float(peer.get('tx_rate', 0.0))

        # Enforce interface consistency: if either side is down, set effective down and zero rates
        if interface_status == 'down' or peer_status == 'down':
            both_down = (interface_status == 'down' and peer_status == 'down')
            repaired_status = 'down'
            repaired_rx = 0.0
            repaired_tx = 0.0
            status_confidence = 0.95 if both_down else 0.7
            rx_confidence = status_confidence
            tx_confidence = status_confidence
        else:
            # Use magnitude-aware symmetry check with absolute guard
            if connected_to and connected_to in telemetry:
                # RX should match peer's TX
                abs_diff_rx = abs(float(rx_rate) - float(peer_tx))
                max_pair_rx = max(1.0, float(rx_rate), float(peer_tx))
                rel_diff_rx = abs_diff_rx / max_pair_rx
                tol_rx = 0.05 if max_pair_rx < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
                if rel_diff_rx > tol_rx and abs_diff_rx > ABS_GUARD:
                    repaired_rx = float(peer_tx)
                    rx_confidence = clamp(1.0 - rel_diff_rx)

                # TX should match peer's RX
                abs_diff_tx = abs(float(tx_rate) - float(peer_rx))
                max_pair_tx = max(1.0, float(tx_rate), float(peer_rx))
                rel_diff_tx = abs_diff_tx / max_pair_tx
                tol_tx = 0.05 if max_pair_tx < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
                if rel_diff_tx > tol_tx and abs_diff_tx > ABS_GUARD:
                    repaired_tx = float(peer_rx)
                    tx_confidence = clamp(1.0 - rel_diff_tx)

            # If statuses differ (but neither side is down), reduce status confidence
            if peer_status is not None and interface_status != peer_status:
                status_confidence = 0.5
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        result[interface_id] = repaired_data

    return result
=======
        result[interface_id] = repaired_data

    # Router-level flow conservation: direction-aware confidence attenuation
    # Build router->interfaces mapping (prefer topology, augment with telemetry hints)
    router_ifaces: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        if lr:
            router_ifaces.setdefault(lr, [])
            if if_id not in router_ifaces[lr]:
                router_ifaces[lr].append(if_id)
        rr = d.get('remote_router')
        if rr and rr not in router_ifaces:
            router_ifaces[rr] = []
    # Compute per-router residual mismatch from repaired values
    router_resid: Dict[str, float] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in result:
                sum_tx += float(result[if_id]['tx_rate'][1])
                sum_rx += float(result[if_id]['rx_rate'][1])
        denom = max(1.0, sum_tx, sum_rx)
        router_resid[r] = abs(sum_tx - sum_rx) / denom
    # Apply direction-aware penalties
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote))
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local))
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))
        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))

    return result
>>>>>>> REPLACE

</DIFF>