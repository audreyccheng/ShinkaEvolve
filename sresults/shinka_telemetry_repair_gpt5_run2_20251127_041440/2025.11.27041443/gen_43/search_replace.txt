<NAME>
pair_bias_scaling_stage0
</NAME>

<DESCRIPTION>
I propose adding a new Stage 0 "pair bias scaling" step before the current Stage 1 consensus hardening. This stage detects multiplicative bias on one endpoint of a link by comparing the ratios their_rx/my_tx and their_tx/my_rx. When both ratios agree within 2% and deviate from 1.0 beyond tolerance, we partially scale the less reliable side (lower activity) so that both its tx and rx counters move coherently toward the peer-derived geometric mean ratio. This addresses systematic scaling errors that partial averaging cannot fully correct and should improve counter repair accuracy while preserving strong confidence calibration.

The scaling is magnitude-aware: it requires both directions to have non-quiet traffic, honors the absolute guard, uses 5% vs 2% thresholds for low vs normal rates, and applies a partial correction factor to avoid over-correction. Confidence computation remains unchanged; it already factors in correction magnitude, symmetry fit, and router residuals, so calibration should remain strong or even improve due to better symmetry and router balance.

This edit is targeted: it inserts the Stage 0 loop between the value initialization and the existing Stage 1 loop. No new external dependencies are introduced, and all referenced variables are already defined.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    for if_id, d in telemetry.items():
        tx = float(d.get('tx_rate', 0.0))
        rx = float(d.get('rx_rate', 0.0))
        vals[if_id] = {'tx': tx, 'rx': rx}
        orig[if_id] = {'tx': tx, 'rx': rx}
        status_orig[if_id] = d.get('interface_status', 'unknown')

    # Stage 1: Directional link consensus with magnitude-aware gating and partial averaging
    visited_pairs = set()
=======
    for if_id, d in telemetry.items():
        tx = float(d.get('tx_rate', 0.0))
        rx = float(d.get('rx_rate', 0.0))
        vals[if_id] = {'tx': tx, 'rx': rx}
        orig[if_id] = {'tx': tx, 'rx': rx}
        status_orig[if_id] = d.get('interface_status', 'unknown')

    # Stage 0: Pair bias scaling (multiplicative harmonization) before consensus averaging.
    # Detect when one endpoint's counters are consistently scaled vs its peer in both directions.
    # Apply a partial multiplicative correction to the lower-activity side to preserve calibration.
    visited_pairs_bias = set()
    for a_id, a_d in telemetry.items():
        b_id = peers.get(a_id)
        if not b_id:
            continue
        key = tuple(sorted((a_id, b_id)))
        if key in visited_pairs_bias:
            continue
        visited_pairs_bias.add(key)

        sa = status_orig.get(a_id, 'unknown')
        sb = status_orig.get(b_id, 'unknown')
        if sa == 'down' or sb == 'down':
            continue

        a_tx, a_rx = vals[a_id]['tx'], vals[a_id]['rx']
        b_tx, b_rx = vals[b_id]['tx'], vals[b_id]['rx']

        # Require active traffic in both directions to infer multiplicative bias
        if (a_tx <= QUIET_EPS or b_rx <= QUIET_EPS or a_rx <= QUIET_EPS or b_tx <= QUIET_EPS):
            continue

        # Ratios that should both approximate the same bias factor if one endpoint is scaled
        r1 = b_rx / max(a_tx, 1e-9)  # their_rx / my_tx
        r2 = b_tx / max(a_rx, 1e-9)  # their_tx / my_rx
        # Geometric mean ratio as consensus scale
        s = (r1 * r2) ** 0.5

        # Consistency check between ratios and magnitude-aware gating
        ratio_consistent = (abs(r1 - r2) / max(1.0, r1, r2)) <= 0.02
        hi = max(a_tx, a_rx, b_tx, b_rx)
        tol = LOW_RATE_THRESHOLD if hi < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
        abs_ab = abs(a_tx - b_rx)
        abs_ba = abs(a_rx - b_tx)

        if (not ratio_consistent) or (abs(s - 1.0) <= tol) or (abs_ab <= ABS_GUARD and abs_ba <= ABS_GUARD):
            continue

        # Adjust the lower-activity side toward the bias-corrected scale
        act_a = max(a_tx, a_rx)
        act_b = max(b_tx, b_rx)
        if act_a < act_b:
            target = a_id
            scale = s
        else:
            target = b_id
            scale = 1.0 / max(1e-9, s)

        # Partial application near threshold to avoid overcorrection
        k = (abs(s - 1.0) - tol) / max(tol, 1e-9)
        k = clamp(k, 0.0, 1.0)
        factor = 1.0 + k * (scale - 1.0)

        vals[target]['tx'] = max(0.0, vals[target]['tx'] * factor)
        vals[target]['rx'] = max(0.0, vals[target]['rx'] * factor)

    # Stage 1: Directional link consensus with magnitude-aware gating and partial averaging
    visited_pairs = set()
>>>>>>> REPLACE

</DIFF>