<NAME>
prescale_ultrafloor_quietrelax
</NAME>

<DESCRIPTION>
I propose three focused improvements to enhance counter repair accuracy while maintaining or slightly improving calibration:

1) Gentle multiplicative pair-bias prescaling in pair consensus:
   Before computing the consensus target and partial update fraction k, prescale the two sides of each direction by s = sqrt(peer/local), clamped to [0.90, 1.10]. Use the prescaled values only for v (the consensus target) and k calculations. This reduces ratio-induced bias and improves convergence in asymmetric pairs without over-correcting. Gating remains on raw diffs and absolute guard, so we retain robustness on low magnitudes and avoid new false triggers.

2) Ultra-agreement confidence floor:
   If both directions on a link are tightly aligned after repair (≤0.3% rel diff) and both routers have very low residuals (≤2%), elevate rx/tx/status confidences to at least 0.995. This rewards truly consistent states, tightening calibration in clear-good scenarios.

3) Low-rate quiet-side confidence relaxation:
   When we infer link-up based on traffic but only one side shows evidence, we currently damp the quiet side confidences by 0.88. Relax this to 0.92 in tiny-traffic cases (overall link <10 Mbps and the traffic side ≤2 Mbps) to avoid over-penalizing benign low-rate asymmetries, improving calibration on small flows.

These changes follow the research principles (R3 hardening, R1-informed confidence) and keep all existing guards and micro-adjustment logic intact.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    LOW_RATE_CUTOFF = 10.0  # Mbps threshold for low-rate behavior
    EPS = 1e-6
=======
    LOW_RATE_CUTOFF = 10.0  # Mbps threshold for low-rate behavior
    EPS = 1e-6
    # Gentle prescaling clamp for bias reduction in consensus calculations
    PRESCALE_MIN = 0.90
    PRESCALE_MAX = 1.10
    # Ultra-agreement confidence floor thresholds
    ULTRA_DIFF_FLOOR = 0.003       # 0.3% relative diff
    RESID_AGREE_THRESH = 0.02      # 2% router residual
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                else:
                    # Residual-tilted weighted consensus target
                    v_ab = 0.5 * (a_tx + b_rx)
                    resid_a = resid_signed.get(a.get('local_router'), 0.0)
                    if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                        gamma = min(0.08, 0.1 * abs(resid_a))
                        w_a = clamp(0.5 - gamma, 0.2, 0.8)
                        w_b = 1.0 - w_a
                        v_ab = w_a * a_tx + w_b * b_rx

                    if d_ab <= partial_upper_ab:
                        # Asymmetric partial averaging: move louder side more; low-rate slightly steeper ramp
                        k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                        k_base = clamp(k_base, 0.0, 1.0)
                        if max_ab < LOW_RATE_CUTOFF:
                            k_base = k_base ** 1.2
                        if a_tx >= b_rx:
                            loud, quiet, loud_is_a = a_tx, b_rx, True
                        else:
                            loud, quiet, loud_is_a = b_rx, a_tx, False
                        r = (loud - quiet) / max(1.0, loud)
                        k_loud = clamp(k_base * (1.0 + 0.5 * r), 0.0, 1.0)
                        k_quiet = clamp(k_base * (1.0 - 0.5 * r), 0.0, 1.0)
                        if loud_is_a:
                            rep_a_tx = a_tx * (1.0 - k_loud) + v_ab * k_loud
                            rep_b_rx = b_rx * (1.0 - k_quiet) + v_ab * k_quiet
                        else:
                            rep_a_tx = a_tx * (1.0 - k_quiet) + v_ab * k_quiet
                            rep_b_rx = b_rx * (1.0 - k_loud) + v_ab * k_loud
                    else:
                        rep_a_tx = v_ab
                        rep_b_rx = v_ab

                    # Confidence decreases with violation and applied change magnitude
                    change_a = change_ratio(a_tx, rep_a_tx)
                    change_b = change_ratio(b_rx, rep_b_rx)
                    conf_base = max(0.0, 1.0 - d_ab)
                    tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                    rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
=======
                else:
                    # Gentle prescaling to reduce ratio bias (used only for consensus/k calculations)
                    s_ab = (max(EPS, b_rx) / max(EPS, a_tx)) ** 0.5
                    s_ab = clamp(s_ab, PRESCALE_MIN, PRESCALE_MAX)
                    a_tx_s = a_tx * s_ab
                    b_rx_s = b_rx / s_ab
                    d_ab_s = rel_diff(a_tx_s, b_rx_s)

                    # Residual-tilted weighted consensus target computed on prescaled values
                    v_ab = 0.5 * (a_tx_s + b_rx_s)
                    resid_a = resid_signed.get(a.get('local_router'), 0.0)
                    if max_ab >= 1.0 and (a_tx_s - b_rx_s) != 0.0 and resid_a != 0.0 and (sgn(a_tx_s - b_rx_s) == sgn(resid_a)):
                        gamma = min(0.08, 0.1 * abs(resid_a))
                        w_a = clamp(0.5 - gamma, 0.2, 0.8)
                        w_b = 1.0 - w_a
                        v_ab = w_a * a_tx_s + w_b * b_rx_s

                    if d_ab_s <= partial_upper_ab:
                        # Asymmetric partial averaging: louder side moves more; low-rate slightly steeper ramp
                        k_base = (d_ab_s - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                        k_base = clamp(k_base, 0.0, 1.0)
                        if max_ab < LOW_RATE_CUTOFF:
                            k_base = k_base ** 1.2
                        if a_tx_s >= b_rx_s:
                            loud_s, quiet_s, loud_is_a = a_tx_s, b_rx_s, True
                        else:
                            loud_s, quiet_s, loud_is_a = b_rx_s, a_tx_s, False
                        r = (loud_s - quiet_s) / max(1.0, loud_s)
                        k_loud = clamp(k_base * (1.0 + 0.5 * r), 0.0, 1.0)
                        k_quiet = clamp(k_base * (1.0 - 0.5 * r), 0.0, 1.0)
                        if loud_is_a:
                            rep_a_tx = a_tx * (1.0 - k_loud) + v_ab * k_loud
                            rep_b_rx = b_rx * (1.0 - k_quiet) + v_ab * k_quiet
                        else:
                            rep_a_tx = a_tx * (1.0 - k_quiet) + v_ab * k_quiet
                            rep_b_rx = b_rx * (1.0 - k_loud) + v_ab * k_loud
                    else:
                        rep_a_tx = v_ab
                        rep_b_rx = v_ab

                    # Confidence decreases with violation and applied change magnitude (use raw d_ab for calibration)
                    change_a = change_ratio(a_tx, rep_a_tx)
                    change_b = change_ratio(b_rx, rep_b_rx)
                    conf_base = max(0.0, 1.0 - d_ab)
                    tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                    rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                else:
                    v_ba = 0.5 * (b_tx + a_rx)
                    resid_b = resid_signed.get(b.get('local_router'), 0.0)
                    if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                        gamma2 = min(0.08, 0.1 * abs(resid_b))
                        w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                        w_a2 = 1.0 - w_b2
                        v_ba = w_b2 * b_tx + w_a2 * a_rx

                    if d_ba <= partial_upper_ba:
                        k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                        k_base2 = clamp(k_base2, 0.0, 1.0)
                        if max_ba < LOW_RATE_CUTOFF:
                            k_base2 = k_base2 ** 1.2
                        if b_tx >= a_rx:
                            loud2, quiet2, loud_is_b = b_tx, a_rx, True
                        else:
                            loud2, quiet2, loud_is_b = a_rx, b_tx, False
                        r2 = (loud2 - quiet2) / max(1.0, loud2)
                        k_loud2 = clamp(k_base2 * (1.0 + 0.5 * r2), 0.0, 1.0)
                        k_quiet2 = clamp(k_base2 * (1.0 - 0.5 * r2), 0.0, 1.0)
                        if loud_is_b:
                            rep_b_tx = b_tx * (1.0 - k_loud2) + v_ba * k_loud2
                            rep_a_rx = a_rx * (1.0 - k_quiet2) + v_ba * k_quiet2
                        else:
                            rep_b_tx = b_tx * (1.0 - k_quiet2) + v_ba * k_quiet2
                            rep_a_rx = a_rx * (1.0 - k_loud2) + v_ba * k_loud2
                    else:
                        rep_b_tx = v_ba
                        rep_a_rx = v_ba

                    change_b2 = change_ratio(b_tx, rep_b_tx)
                    change_a2 = change_ratio(a_rx, rep_a_rx)
                    conf_base2 = max(0.0, 1.0 - d_ba)
                    tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                    rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
=======
                else:
                    # Prescaling for bias reduction (used only for consensus/k computations)
                    s_ba = (max(EPS, a_rx) / max(EPS, b_tx)) ** 0.5
                    s_ba = clamp(s_ba, PRESCALE_MIN, PRESCALE_MAX)
                    b_tx_s = b_tx * s_ba
                    a_rx_s = a_rx / s_ba
                    d_ba_s = rel_diff(b_tx_s, a_rx_s)

                    v_ba = 0.5 * (b_tx_s + a_rx_s)
                    resid_b = resid_signed.get(b.get('local_router'), 0.0)
                    if max_ba >= 1.0 and (b_tx_s - a_rx_s) != 0.0 and resid_b != 0.0 and (sgn(b_tx_s - a_rx_s) == sgn(resid_b)):
                        gamma2 = min(0.08, 0.1 * abs(resid_b))
                        w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                        w_a2 = 1.0 - w_b2
                        v_ba = w_b2 * b_tx_s + w_a2 * a_rx_s

                    if d_ba_s <= partial_upper_ba:
                        k_base2 = (d_ba_s - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                        k_base2 = clamp(k_base2, 0.0, 1.0)
                        if max_ba < LOW_RATE_CUTOFF:
                            k_base2 = k_base2 ** 1.2
                        if b_tx_s >= a_rx_s:
                            loud2_s, quiet2_s, loud_is_b = b_tx_s, a_rx_s, True
                        else:
                            loud2_s, quiet2_s, loud_is_b = a_rx_s, b_tx_s, False
                        r2 = (loud2_s - quiet2_s) / max(1.0, loud2_s)
                        k_loud2 = clamp(k_base2 * (1.0 + 0.5 * r2), 0.0, 1.0)
                        k_quiet2 = clamp(k_base2 * (1.0 - 0.5 * r2), 0.0, 1.0)
                        if loud_is_b:
                            rep_b_tx = b_tx * (1.0 - k_loud2) + v_ba * k_loud2
                            rep_a_rx = a_rx * (1.0 - k_quiet2) + v_ba * k_quiet2
                        else:
                            rep_b_tx = b_tx * (1.0 - k_quiet2) + v_ba * k_quiet2
                            rep_a_rx = a_rx * (1.0 - k_loud2) + v_ba * k_loud2
                    else:
                        rep_b_tx = v_ba
                        rep_a_rx = v_ba

                    change_b2 = change_ratio(b_tx, rep_b_tx)
                    change_a2 = change_ratio(a_rx, rep_a_rx)
                    conf_base2 = max(0.0, 1.0 - d_ba)
                    tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                    rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # Asymmetric confidence when "up" is evidence-driven and only one side has traffic
                if a_has != b_has:
                    if not a_has:
                        rx_conf_a *= 0.88
                        tx_conf_a *= 0.88
                    if not b_has:
                        rx_conf_b *= 0.88
                        tx_conf_b *= 0.88
=======
                # Asymmetric confidence when "up" is evidence-driven and only one side has traffic
                if a_has != b_has:
                    # Relax damping for tiny flows: when overall link is low-rate and the traffic side ≤2 Mbps
                    overall_max = max(a_tx, a_rx, b_tx, b_rx)
                    if a_has and not b_has:
                        traffic_side = max(a_tx, a_rx)
                        damp = 0.92 if (overall_max < LOW_RATE_CUTOFF and traffic_side <= 2.0) else 0.88
                        rx_conf_b *= damp
                        tx_conf_b *= damp
                    elif b_has and not a_has:
                        traffic_side = max(b_tx, b_rx)
                        damp = 0.92 if (overall_max < LOW_RATE_CUTOFF and traffic_side <= 2.0) else 0.88
                        rx_conf_a *= damp
                        tx_conf_a *= damp
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))
=======
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))

        # Ultra-agreement floors: if both link directions tightly align and both routers have low residuals
        peer_id = data.get('connected_to')
        if peer_id and (peer_id in per_if) and (if_id in per_if):
            try:
                rep_tx_local = to_float(per_if[if_id]['repaired_tx'])
                rep_rx_local = to_float(per_if[if_id]['repaired_rx'])
                rep_rx_peer = to_float(per_if[peer_id]['repaired_rx'])
                rep_tx_peer = to_float(per_if[peer_id]['repaired_tx'])
                d1 = rel_diff(rep_tx_local, rep_rx_peer)
                d2 = rel_diff(rep_tx_peer, rep_rx_local)
                if (d1 <= ULTRA_DIFF_FLOOR) and (d2 <= ULTRA_DIFF_FLOOR) and (resid_local <= RESID_AGREE_THRESH) and (resid_remote <= RESID_AGREE_THRESH):
                    tx_conf = max(tx_conf, 0.995)
                    rx_conf = max(rx_conf, 0.995)
                    status_conf = max(status_conf, 0.995)
            except Exception:
                pass
>>>>>>> REPLACE
</DIFF>