<NAME>
calibrated_confidence_penalties_and_magnitude_floors
</NAME>

<DESCRIPTION>
I propose three targeted adjustments to improve confidence calibration without harming the strong counter repair accuracy:

1) Magnitude-aware confidence floors on in-tolerance link symmetry agreements:
   - For small flows (max < 10 Mbps), reduce floors from 0.98 to 0.97 to avoid overconfidence.
   - Keep strong-agreement floors at 0.99 for high-rate links with â‰¤0.5% normalized diff.
   - Add geometric-mean harmonization for very strong agreements to keep paired directions consistent.

2) Better handling of asymmetric traffic and unpaired interfaces:
   - Reduce confidence for the silent side in asymmetric evidence from 0.90 to 0.88.
   - Lower base confidence on unpaired interfaces to 0.92 to reflect lack of redundancy.

3) Direction-aware router residual penalties:
   - Allow penalties to go down to 0.5 (instead of 0.7 floor) to reflect high router-level imbalance.
   - Mildly scale status confidence based on the same penalties to keep calibration consistent.

These changes primarily refine confidence scoring to be less overconfident when evidence is weaker or inconsistent, improving confidence calibration while keeping the counter repair behavior unchanged.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            else:
                # Within tolerance: set strong confidence floors
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)
=======
            else:
                # Within tolerance: set magnitude-aware confidence floors
                if max(a_tx, b_rx) >= 10.0:
                    floor = 0.99 if diff_ab <= 0.005 else 0.98
                else:
                    floor = 0.97
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)
                # Harmonize very strong agreements with geometric-mean floor
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    fa = field_conf_floor.get((a_id, 'tx'), floor)
                    fb = field_conf_floor.get((b_id, 'rx'), floor)
                    gm = (max(1e-9, fa) * max(1e-9, fb)) ** 0.5
                    field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), gm)
                    field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), gm)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
=======
            else:
                if max(b_tx, a_rx) >= 10.0:
                    floor = 0.99 if diff_ba <= 0.005 else 0.98
                else:
                    floor = 0.97
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
                # Harmonize very strong agreements with geometric-mean floor
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    fb = field_conf_floor.get((b_id, 'tx'), floor)
                    fa = field_conf_floor.get((a_id, 'rx'), floor)
                    gm = (max(1e-9, fa) * max(1e-9, fb)) ** 0.5
                    field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), gm)
                    field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), gm)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Asymmetric confidence when only one side shows traffic (directional)
            if a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
                field_conf_scale[(b_id, 'rx')] = min(field_conf_scale.get((b_id, 'rx'), 1.0), 0.9)
            if b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
                field_conf_scale[(a_id, 'tx')] = min(field_conf_scale.get((a_id, 'tx'), 1.0), 0.9)
            if b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
                field_conf_scale[(a_id, 'rx')] = min(field_conf_scale.get((a_id, 'rx'), 1.0), 0.9)
            if a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
                field_conf_scale[(b_id, 'tx')] = min(field_conf_scale.get((b_id, 'tx'), 1.0), 0.9)
=======
            # Asymmetric confidence when only one side shows traffic (directional)
            if a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
                field_conf_scale[(b_id, 'rx')] = min(field_conf_scale.get((b_id, 'rx'), 1.0), 0.88)
            if b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
                field_conf_scale[(a_id, 'tx')] = min(field_conf_scale.get((a_id, 'tx'), 1.0), 0.88)
            if b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
                field_conf_scale[(a_id, 'rx')] = min(field_conf_scale.get((a_id, 'rx'), 1.0), 0.88)
            if a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
                field_conf_scale[(b_id, 'tx')] = min(field_conf_scale.get((b_id, 'tx'), 1.0), 0.88)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Apply pairwise planned adjustments if available
            if (interface_id, 'rx') in field_value_adjust:
                repaired_rx = float(field_value_adjust[(interface_id, 'rx')])
                rx_confidence = field_conf_assign.get((interface_id, 'rx'), rx_confidence)
            if (interface_id, 'tx') in field_value_adjust:
                repaired_tx = float(field_value_adjust[(interface_id, 'tx')])
                tx_confidence = field_conf_assign.get((interface_id, 'tx'), tx_confidence)

            # If statuses differ (but neither side is down), reduce status confidence moderately
            if connected_to and connected_to in telemetry:
                peer_status = telemetry[connected_to].get('interface_status', 'unknown')
                if interface_status != peer_status:
                    status_confidence = 0.6
=======
        else:
            # Apply pairwise planned adjustments if available
            if (interface_id, 'rx') in field_value_adjust:
                repaired_rx = float(field_value_adjust[(interface_id, 'rx')])
                rx_confidence = field_conf_assign.get((interface_id, 'rx'), rx_confidence)
            if (interface_id, 'tx') in field_value_adjust:
                repaired_tx = float(field_value_adjust[(interface_id, 'tx')])
                tx_confidence = field_conf_assign.get((interface_id, 'tx'), tx_confidence)

            # If no peer redundancy, slightly lower confidence to reflect uncertainty
            if not connected_to or connected_to not in telemetry:
                rx_confidence = min(rx_confidence, 0.92)
                tx_confidence = min(tx_confidence, 0.92)

            # If statuses differ (but neither side is down), reduce status confidence moderately
            if connected_to and connected_to in telemetry:
                peer_status = telemetry[connected_to].get('interface_status', 'unknown')
                if interface_status != peer_status:
                    status_confidence = 0.6
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Apply direction-aware penalties with gentle floor
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.7, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.7, 1.0)
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))
        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))
=======
    # Apply direction-aware penalties with gentler floor and mild status scaling
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.5, 1.0)
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))
        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))
        status_scale = 0.85 + 0.15 * min(penalty_tx, penalty_rx)
        result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
>>>>>>> REPLACE
</DIFF>