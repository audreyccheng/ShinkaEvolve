<NAME>
prescale_and_one_sided_with_ultra_floor
</NAME>

<DESCRIPTION>
I propose three targeted improvements to raise counter repair accuracy and maintain calibrated confidences:

1) Add gentle multiplicative pair-bias prescaling and one-sided trust to the pairwise consensus:
   - Prescale the pair by s = sqrt(peer/local) clamped to [0.90, 1.10] for consensus calculations only. This reduces ratio bias and improves symmetry (R3) without over-correcting.
   - Add one-sided trust when one side is near-zero and the peer is large; copy the larger value instead of averaging. This covers highly asymmetric corruptions and aligns with no-loss assumptions.

2) Add a consistent LOW_RATE_CUTOFF constant and related knobs:
   - Introduce LOW_RATE_CUTOFF and prescaling/one-sided constants at the top.

3) Add an ultra-agreement confidence floor:
   - If both directions tightly align post-repair (≤0.3% rel diff) and both routers have low residuals (≤2%), raise RX/TX/status confidences to 0.995, aligning confidence with high-likelihood correctness.

These changes are minimal diffs and leverage redundancy and router residuals per Hodor principles to improve counter accuracy and confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Base thresholds
    TH_REL_DEFAULT = 0.02   # 2%
    TH_REL_LOW = 0.05       # 5% for low-rate links
    TH_ABS_GUARD = 0.5      # 0.5 Mbps absolute guard
    ABS_GUARD_LOW = 0.3     # 0.3 Mbps absolute guard for low-rate links
    EPS = 1e-6
=======
    # Base thresholds
    TH_REL_DEFAULT = 0.02   # 2%
    TH_REL_LOW = 0.05       # 5% for low-rate links
    TH_ABS_GUARD = 0.5      # 0.5 Mbps absolute guard
    ABS_GUARD_LOW = 0.3     # 0.3 Mbps absolute guard for low-rate links
    LOW_RATE_CUTOFF = 10.0  # Mbps threshold for low-rate behavior
    # One-sided trust (when one side ~0 and peer is high)
    ONE_SIDED_FRAC = 0.05      # near-zero if smaller side <= 5% of larger
    ONE_SIDED_ABS_MULT = 2.0   # require abs diff > 2x guard to trust peer
    # Gentle prescaling clamp for bias reduction (used only for consensus/k computations)
    PRESCALE_MIN = 0.90
    PRESCALE_MAX = 1.10
    # Ultra-agreement confidence floor thresholds
    ULTRA_DIFF_FLOOR = 0.003       # 0.3% relative diff
    RESID_AGREE_THRESH = 0.02      # 2% router residual
    EPS = 1e-6
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Magnitude-aware thresholds with residual-tilted consensus and asymmetric partial averaging
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            guard_ab = ABS_GUARD_LOW if max_ab < 10.0 else TH_ABS_GUARD
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            partial_upper_ab = (1.6 * thr_rel_ab) if max_ab < 10.0 else (2.0 * thr_rel_ab)

            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # Residual-tilted weighted consensus target
                v = 0.5 * (a_tx + b_rx)
                resid_a = resid_signed.get(a.get('local_router'), 0.0)
                if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                    gamma = min(0.08, 0.1 * abs(resid_a))
                    w_a = clamp(0.5 - gamma, 0.2, 0.8)
                    w_b = 1.0 - w_a
                    v = w_a * a_tx + w_b * b_rx

                if d_ab <= partial_upper_ab:
                    # Asymmetric partial averaging: louder side moves more
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < 10.0:
                        k_base = k_base ** 1.2
                    if a_tx >= b_rx:
                        loud = a_tx; quiet = b_rx
                    else:
                        loud = b_rx; quiet = a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                # Confidence decreases with violation magnitude and change magnitude
                change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                conf_base = max(0.0, 1.0 - d_ab)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)

            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            guard_ba = ABS_GUARD_LOW if max_ba < 10.0 else TH_ABS_GUARD
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            partial_upper_ba = (1.6 * thr_rel_ba) if max_ba < 10.0 else (2.0 * thr_rel_ba)

            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                resid_b = resid_signed.get(b.get('local_router'), 0.0)
                if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                    gamma2 = min(0.08, 0.1 * abs(resid_b))
                    w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                    w_a2 = 1.0 - w_b2
                    v2 = w_b2 * b_tx + w_a2 * a_rx

                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < 10.0:
                        k_base2 = k_base2 ** 1.2
                    if b_tx >= a_rx:
                        loud2 = b_tx; quiet2 = a_rx
                    else:
                        loud2 = a_rx; quiet2 = b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                conf_base2 = max(0.0, 1.0 - d_ba)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
=======
        else:
            # Magnitude-aware thresholds with prescaling, one-sided trust, residual-tilted consensus,
            # and asymmetric partial averaging
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < LOW_RATE_CUTOFF else TH_REL_DEFAULT
            guard_ab = ABS_GUARD_LOW if max_ab < LOW_RATE_CUTOFF else TH_ABS_GUARD
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            partial_upper_ab = (1.6 * thr_rel_ab) if max_ab < LOW_RATE_CUTOFF else (2.0 * thr_rel_ab)

            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # One-sided trust: when one side is near-zero and peer is high (avoid averaging)
                min_ab = min(a_tx, b_rx)
                if (max_ab >= LOW_RATE_CUTOFF and
                    min_ab <= ONE_SIDED_FRAC * max_ab and
                    abs_ab > ONE_SIDED_ABS_MULT * guard_ab):
                    v_ab = max(a_tx, b_rx)
                    rep_a_tx = v_ab
                    rep_b_rx = v_ab
                    conf_base = max(0.0, 1.0 - 0.5 * d_ab)
                    change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                    change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                    tx_conf_a = min(0.95, max(0.65, conf_base, 1.0 - 0.8 * change_a))
                    rx_conf_b = min(0.95, max(0.65, conf_base, 1.0 - 0.8 * change_b))
                else:
                    # Gentle prescaling to reduce ratio bias (used only for consensus/k calculations)
                    s_ab = (max(EPS, b_rx) / max(EPS, a_tx)) ** 0.5
                    s_ab = clamp(s_ab, PRESCALE_MIN, PRESCALE_MAX)
                    a_tx_s = a_tx * s_ab
                    b_rx_s = b_rx / s_ab
                    d_ab_s = rel_diff(a_tx_s, b_rx_s)

                    # Residual-tilted weighted consensus target computed on prescaled values
                    v = 0.5 * (a_tx_s + b_rx_s)
                    resid_a = resid_signed.get(a.get('local_router'), 0.0)
                    if max_ab >= 1.0 and (a_tx_s - b_rx_s) != 0.0 and resid_a != 0.0 and (sgn(a_tx_s - b_rx_s) == sgn(resid_a)):
                        gamma = min(0.08, 0.1 * abs(resid_a))
                        w_a = clamp(0.5 - gamma, 0.2, 0.8)
                        w_b = 1.0 - w_a
                        v = w_a * a_tx_s + w_b * b_rx_s

                    if d_ab_s <= partial_upper_ab:
                        # Asymmetric partial averaging: louder side moves more; low-rate slightly steeper ramp
                        k_base = (d_ab_s - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                        k_base = min(1.0, max(0.0, k_base))
                        if max_ab < LOW_RATE_CUTOFF:
                            k_base = k_base ** 1.2
                        if a_tx_s >= b_rx_s:
                            loud_s, quiet_s, loud_is_a = a_tx_s, b_rx_s, True
                        else:
                            loud_s, quiet_s, loud_is_a = b_rx_s, a_tx_s, False
                        r = (loud_s - quiet_s) / max(1.0, loud_s)
                        k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                        k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                        if loud_is_a:
                            rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                            rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                        else:
                            rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                            rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                    else:
                        rep_a_tx = v
                        rep_b_rx = v

                    # Confidence decreases with raw violation magnitude and applied change
                    change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                    change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                    conf_base = max(0.0, 1.0 - d_ab)
                    tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                    rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors (using raw diff)
                if max_ab >= LOW_RATE_CUTOFF and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= LOW_RATE_CUTOFF else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)

            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < LOW_RATE_CUTOFF else TH_REL_DEFAULT
            guard_ba = ABS_GUARD_LOW if max_ba < LOW_RATE_CUTOFF else TH_ABS_GUARD
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            partial_upper_ba = (1.6 * thr_rel_ba) if max_ba < LOW_RATE_CUTOFF else (2.0 * thr_rel_ba)

            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                min_ba = min(b_tx, a_rx)
                if (max_ba >= LOW_RATE_CUTOFF and
                    min_ba <= ONE_SIDED_FRAC * max_ba and
                    abs_ba > ONE_SIDED_ABS_MULT * guard_ba):
                    v_ba = max(b_tx, a_rx)
                    rep_b_tx = v_ba
                    rep_a_rx = v_ba
                    conf_base2 = max(0.0, 1.0 - 0.5 * d_ba)
                    change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                    change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                    tx_conf_b = min(0.95, max(0.65, conf_base2, 1.0 - 0.8 * change_b2))
                    rx_conf_a = min(0.95, max(0.65, conf_base2, 1.0 - 0.8 * change_a2))
                else:
                    # Prescaling (used only for consensus/k calculations)
                    s_ba = (max(EPS, a_rx) / max(EPS, b_tx)) ** 0.5
                    s_ba = clamp(s_ba, PRESCALE_MIN, PRESCALE_MAX)
                    b_tx_s = b_tx * s_ba
                    a_rx_s = a_rx / s_ba
                    d_ba_s = rel_diff(b_tx_s, a_rx_s)

                    v2 = 0.5 * (b_tx_s + a_rx_s)
                    resid_b = resid_signed.get(b.get('local_router'), 0.0)
                    if max_ba >= 1.0 and (b_tx_s - a_rx_s) != 0.0 and resid_b != 0.0 and (sgn(b_tx_s - a_rx_s) == sgn(resid_b)):
                        gamma2 = min(0.08, 0.1 * abs(resid_b))
                        w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                        w_a2 = 1.0 - w_b2
                        v2 = w_b2 * b_tx_s + w_a2 * a_rx_s

                    if d_ba_s <= partial_upper_ba:
                        k_base2 = (d_ba_s - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                        k_base2 = min(1.0, max(0.0, k_base2))
                        if max_ba < LOW_RATE_CUTOFF:
                            k_base2 = k_base2 ** 1.2
                        if b_tx_s >= a_rx_s:
                            loud2_s, quiet2_s, loud_is_b = b_tx_s, a_rx_s, True
                        else:
                            loud2_s, quiet2_s, loud_is_b = a_rx_s, b_tx_s, False
                        r2 = (loud2_s - quiet2_s) / max(1.0, loud2_s)
                        k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                        k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                        if loud_is_b:
                            rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                            rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                        else:
                            rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                            rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                    else:
                        rep_b_tx = v2
                        rep_a_rx = v2

                    change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                    change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                    conf_base2 = max(0.0, 1.0 - d_ba)
                    tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                    rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= LOW_RATE_CUTOFF and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= LOW_RATE_CUTOFF else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))

        # Assemble output tuples with original, repaired, confidence
=======
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min_penalty)))

        # Ultra-agreement floor: if both directions on this link are tightly aligned post-repair
        # and both routers have very low residuals, raise confidences to at least 0.995.
        peer_id = data.get('connected_to')
        if peer_id and (peer_id in per_if) and (if_id in per_if):
            try:
                rep_tx_local = repaired_tx
                rep_rx_local = repaired_rx
                rep_rx_peer = float(per_if[peer_id]['repaired_rx'])
                rep_tx_peer = float(per_if[peer_id]['repaired_tx'])
                d1 = rel_diff(rep_tx_local, rep_rx_peer)
                d2 = rel_diff(rep_tx_peer, rep_rx_local)
                if (d1 <= ULTRA_DIFF_FLOOR) and (d2 <= ULTRA_DIFF_FLOOR) and (resid_local <= RESID_AGREE_THRESH) and (resid_remote <= RESID_AGREE_THRESH):
                    tx_conf = max(tx_conf, 0.995)
                    rx_conf = max(rx_conf, 0.995)
                    status_conf = max(status_conf, 0.995)
            except Exception:
                pass

        # Assemble output tuples with original, repaired, confidence
>>>>>>> REPLACE
</DIFF>