<NAME>
calibrated_confidence_guards
</NAME>

<DESCRIPTION>
The current algorithm achieves strong counter repair accuracy but exhibits overconfidence, especially in scenarios where we skip repairs due to the absolute guard, use heuristic micro-adjustments, or face asymmetric traffic evidence. This harms the confidence calibration metric.

I propose targeted changes to improve calibration while preserving counter accuracy:
1) Guard-blocked discrepancy handling: When normalized diff exceeds tolerance but we skip repair due to the absolute guard, do not apply high-confidence floors. Instead, downscale the confidence multiplicatively for the affected direction(s). This avoids overconfidence on unresolved mismatches at low magnitudes.
2) Reduce confidence on heuristic micro-adjustments: Replace the previous confidence increase (max with ~0.8) with a conservative cap (min to ≤0.8) to reflect the uncertainty of these nudges.
3) Strong-agreement status confidence floor: When both directions strongly agree (≤0.5% and ≥10 Mbps), raise status confidence via a floor. This leverages redundant agreement to improve calibration for status confidence without risking overconfidence elsewhere.
4) Asymmetric traffic evidence penalties: Increase asymmetry downscaling from 0.9 to 0.85 for the silent direction, aligning with recommendation 5.
5) Unpaired interfaces baseline: Slightly lower base confidence for unpaired interfaces (no redundancy), avoiding high confidence where we lack corroborating signals.

These adjustments should lift confidence calibration with minimal effect on counter accuracy and keep status accuracy perfect.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    field_conf_scale: Dict[Tuple[str, str], float] = {}     # multiplicative confidence scalers (asymmetry)

    visited_pairs = set()
=======
    field_conf_scale: Dict[Tuple[str, str], float] = {}     # multiplicative confidence scalers (asymmetry)
    status_conf_floor: Dict[str, float] = {}                # status confidence floors under strong bilateral agreement

    visited_pairs = set()
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                # Trust-weighted consensus
                consensus_ab = w_a * a_tx + w_b * b_rx
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold to reduce overcorrection
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                else:
                    # Clear violation: converge fully to consensus
                    new_a_tx = consensus_ab
                    new_b_rx = consensus_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
            else:
                # Within tolerance: floor high confidence
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)
=======
            if diff_ab > tol_ab:
                if abs_ab > ABS_GUARD:
                    # Trust-weighted consensus
                    consensus_ab = w_a * a_tx + w_b * b_rx
                    if diff_ab <= 2 * tol_ab:
                        # Partial averaging near threshold to reduce overcorrection
                        k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                        new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                        new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                    else:
                        # Clear violation: converge fully to consensus
                        new_a_tx = consensus_ab
                        new_b_rx = consensus_ab
                    field_value_adjust[(a_id, 'tx')] = new_a_tx
                    field_value_adjust[(b_id, 'rx')] = new_b_rx
                    conf_ab = clamp(1.0 - diff_ab)
                    field_conf_assign[(a_id, 'tx')] = conf_ab
                    field_conf_assign[(b_id, 'rx')] = conf_ab
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
                    field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            else:
                # Within tolerance: floor high confidence
                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                consensus_ba = w_b * b_tx + w_a * a_rx
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                else:
                    new_b_tx = consensus_ba
                    new_a_rx = consensus_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
=======
            if diff_ba > tol_ba:
                if abs_ba > ABS_GUARD:
                    consensus_ba = w_b * b_tx + w_a * a_rx
                    if diff_ba <= 2 * tol_ba:
                        k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                        new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                        new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                    else:
                        new_b_tx = consensus_ba
                        new_a_rx = consensus_ba
                    field_value_adjust[(b_id, 'tx')] = new_b_tx
                    field_value_adjust[(a_id, 'rx')] = new_a_rx
                    conf_ba = clamp(1.0 - diff_ba)
                    field_conf_assign[(b_id, 'tx')] = conf_ba
                    field_conf_assign[(a_id, 'rx')] = conf_ba
                else:
                    # Guard-blocked discrepancy: do not set high floors; downscale confidence instead
                    field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
                    field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            else:
                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
                    floor = 0.99
                else:
                    floor = 0.98
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Asymmetric confidence when only one side shows traffic (traffic-evidence asymmetry)
            pair_up = True
            # Direction a->b
            if pair_up and a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
                field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
            if pair_up and b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
                field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
            # Direction b->a
            if pair_up and b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
                field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
            if pair_up and a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
                field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
=======
            # Asymmetric confidence when only one side shows traffic (traffic-evidence asymmetry)
            pair_up = True
            # Direction a->b
            if pair_up and a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
                field_conf_scale[(b_id, 'rx')] = min(0.85, field_conf_scale.get((b_id, 'rx'), 1.0))
            if pair_up and b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
                field_conf_scale[(a_id, 'tx')] = min(0.85, field_conf_scale.get((a_id, 'tx'), 1.0))
            # Direction b->a
            if pair_up and b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
                field_conf_scale[(a_id, 'rx')] = min(0.85, field_conf_scale.get((a_id, 'rx'), 1.0))
            if pair_up and a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
                field_conf_scale[(b_id, 'tx')] = min(0.85, field_conf_scale.get((b_id, 'tx'), 1.0))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Harmonize very strong agreements via geometric-mean floors
            strong_ab = (max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005)
            strong_ba = (max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005)
            if strong_ab:
                # Geometric mean harmonization for link-direction confidences
                fa = field_conf_floor.get((a_id, 'tx'), 0.98)
                fb = field_conf_floor.get((b_id, 'rx'), 0.98)
                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), gm)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), gm)
            if strong_ba:
                fb = field_conf_floor.get((b_id, 'tx'), 0.98)
                fa = field_conf_floor.get((a_id, 'rx'), 0.98)
                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), gm)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), gm)
=======
            # Harmonize very strong agreements via geometric-mean floors
            strong_ab = (max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005)
            strong_ba = (max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005)
            if strong_ab:
                # Geometric mean harmonization for link-direction confidences
                fa = field_conf_floor.get((a_id, 'tx'), 0.98)
                fb = field_conf_floor.get((b_id, 'rx'), 0.98)
                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), gm)
                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), gm)
            if strong_ba:
                fb = field_conf_floor.get((b_id, 'tx'), 0.98)
                fa = field_conf_floor.get((a_id, 'rx'), 0.98)
                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), gm)
                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), gm)
            # If both directions are strongly consistent, raise status confidence floor
            if strong_ab and strong_ba:
                status_conf_floor[a_id] = max(status_conf_floor.get(a_id, 0.0), 0.99)
                status_conf_floor[b_id] = max(status_conf_floor.get(b_id, 0.0), 0.99)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            # Apply confidence floors for in-tolerance agreements
            rx_floor = field_conf_floor.get((interface_id, 'rx'))
            tx_floor = field_conf_floor.get((interface_id, 'tx'))
            if rx_floor is not None:
                rx_conf = max(rx_conf, rx_floor)
            if tx_floor is not None:
                tx_conf = max(tx_conf, tx_floor)

            # Apply asymmetric scaling if applicable
            if (interface_id, 'rx') in field_conf_scale:
                rx_conf = clamp(rx_conf * field_conf_scale[(interface_id, 'rx')])
            if (interface_id, 'tx') in field_conf_scale:
                tx_conf = clamp(tx_conf * field_conf_scale[(interface_id, 'tx')])
=======
            # For unpaired interfaces (no redundancy), use a slightly lower baseline confidence
            if not connected_to or connected_to not in telemetry:
                rx_conf = min(rx_conf, 0.9)
                tx_conf = min(tx_conf, 0.9)

            # Apply confidence floors for in-tolerance agreements
            rx_floor = field_conf_floor.get((interface_id, 'rx'))
            tx_floor = field_conf_floor.get((interface_id, 'tx'))
            if rx_floor is not None:
                rx_conf = max(rx_conf, rx_floor)
            if tx_floor is not None:
                tx_conf = max(tx_conf, tx_floor)

            # Apply asymmetric scaling if applicable
            if (interface_id, 'rx') in field_conf_scale:
                rx_conf = clamp(rx_conf * field_conf_scale[(interface_id, 'rx')])
            if (interface_id, 'tx') in field_conf_scale:
                tx_conf = clamp(tx_conf * field_conf_scale[(interface_id, 'tx')])

            # Apply status confidence floor when strong bilateral agreement detected
            sfloor = status_conf_floor.get(interface_id)
            if sfloor is not None:
                status_conf = max(status_conf, sfloor)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                # modest confidence increase reflecting conservation alignment
                new_conf = max(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_rx = rrx * (1.0 + alpha)
                new_conf = max(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
=======
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                # reduce confidence to reflect heuristic adjustment
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_rx = rrx * (1.0 + alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_conf = max(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
            else:
                new_tx = rtx * (1.0 + alpha)
                new_conf = max(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
=======
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
            else:
                new_tx = rtx * (1.0 + alpha)
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
>>>>>>> REPLACE

</DIFF>