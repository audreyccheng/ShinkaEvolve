<NAME>
residual_tilt_and_share_weighted_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy while preserving calibration:

1) Residual‑tilted, direction‑aware pair consensus: During pairwise hardening, when a direction violates tolerance, we bias the consensus target away from the local router’s imbalance by tilting the averaging weights based on the signed flow conservation residual computed from the original telemetry. If a_tx > b_rx and the local router has a positive residual (too much TX), we reduce the weight on A so the consensus moves more toward B. The tilt γ is bounded (≤0.08) and proportional to the router residual magnitude, and is only applied when both relative and absolute triggers fire. This should reduce systematic errors and improve counter accuracy without destabilizing tiny flows.

2) Interface‑share–aware, direction‑coupled confidence penalties: In the final confidence scaling, we modulate the local vs remote residual weights by the interface’s directional share on its router. An interface that dominates a router’s TX (or RX) should have its TX (or RX) confidence more sensitive to the corresponding router’s residual. This maintains the strong tri-axis confidence logic while aligning penalties to each interface’s influence, improving calibration.

Implementation details:
- Compute signed router residual fractions from original telemetry before pairwise repairs.
- Use those signed residuals to tilt pair consensus targets in both directions.
- Track router TX/RX sums after repairs and use them to compute per-interface shares for confidence scaling.
- Keep all existing guards, magnitude-aware thresholds, and micro-adjustment logic intact.

These changes are minimal, consistent, and should improve both counter accuracy and confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def change_ratio(orig: float, rep: float) -> float:
        denom = max(abs(orig), abs(rep), 1.0)
        return abs(rep - orig) / denom
=======
    def change_ratio(orig: float, rep: float) -> float:
        denom = max(abs(orig), abs(rep), 1.0)
        return abs(rep - orig) / denom

    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
=======
    # Compute signed router residuals from original telemetry (for residual-tilted consensus)
    router_signed_resid_orig: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx_o = 0.0
        s_rx_o = 0.0
        for iid in if_list:
            d = telemetry.get(iid)
            if not d:
                continue
            s_tx_o += to_float(d.get('tx_rate', 0.0))
            s_rx_o += to_float(d.get('rx_rate', 0.0))
        denom_o = max(s_tx_o, s_rx_o, 1.0)
        router_signed_resid_orig[router] = (s_tx_o - s_rx_o) / denom_o

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
=======
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # Residual-tilted consensus: bias toward reducing local router's signed imbalance
                sign_diff_ab = 1.0 if a_tx > b_rx else (-1.0 if a_tx < b_rx else 0.0)
                resid_local_a = router_signed_resid_orig.get(a.get('local_router'), 0.0)
                gamma = min(0.08, 0.1 * abs(resid_local_a)) if (sign_diff_ab * resid_local_a) > 0 else 0.0
                w_a = clamp(0.5 - gamma, 0.2, 0.8)
                w_b = 1.0 - w_a
                v = w_a * a_tx + w_b * b_rx
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
=======
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                # Residual-tilted consensus for B->A using B's local router residual
                sign_diff_ba = 1.0 if b_tx > a_rx else (-1.0 if b_tx < a_rx else 0.0)
                resid_local_b = router_signed_resid_orig.get(b.get('local_router'), 0.0)
                gamma2 = min(0.08, 0.1 * abs(resid_local_b)) if (sign_diff_ba * resid_local_b) > 0 else 0.0
                w_ba = clamp(0.5 - gamma2, 0.2, 0.8)
                w_ar = 1.0 - w_ba
                v2 = w_ba * b_tx + w_ar * a_rx
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Compute router-level residuals after repairs for confidence penalties
    router_residual: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            if iid in per_if:
                s_tx += to_float(per_if[iid]['repaired_tx'])
                s_rx += to_float(per_if[iid]['repaired_rx'])
        router_residual[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
=======
    # Compute router-level residuals after repairs for confidence penalties
    router_residual: Dict[str, float] = {}
    router_sums_tx: Dict[str, float] = {}
    router_sums_rx: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            if iid in per_if:
                s_tx += to_float(per_if[iid]['repaired_tx'])
                s_rx += to_float(per_if[iid]['repaired_rx'])
        router_sums_tx[router] = s_tx
        router_sums_rx[router] = s_rx
        router_residual[router] = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        # Direction-aware penalties: TX depends more on local, RX more on remote
        penalty_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        penalty_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)
=======
        # Share-aware, direction-coupled penalties: scale local/remote weights by interface's directional share
        sum_tx_local = router_sums_tx.get(local_router, 0.0)
        sum_rx_local = router_sums_rx.get(local_router, 0.0)
        iface_tx_share = repaired_tx / max(1.0, sum_tx_local)
        iface_rx_share = repaired_rx / max(1.0, sum_rx_local)
        iface_tx_share = max(0.0, min(1.0, iface_tx_share))
        iface_rx_share = max(0.0, min(1.0, iface_rx_share))
        w_tx_local = 0.6 + 0.2 * iface_tx_share
        w_tx_remote = 0.4 - 0.2 * iface_tx_share
        w_rx_remote = 0.6 + 0.2 * iface_rx_share
        w_rx_local = 0.4 - 0.2 * iface_rx_share
        penalty_tx = 1.0 - (w_tx_local * resid_local + w_tx_remote * resid_remote)
        penalty_rx = 1.0 - (w_rx_remote * resid_remote + w_rx_local * resid_local)
        penalty_tx = max(0.0, min(1.0, penalty_tx))
        penalty_rx = max(0.0, min(1.0, penalty_rx))
        avg_penalty = 0.5 * (penalty_tx + penalty_rx)
>>>>>>> REPLACE

</DIFF>