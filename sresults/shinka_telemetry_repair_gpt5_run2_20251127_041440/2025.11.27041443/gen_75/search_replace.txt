<NAME>
residual_tilted_pair_consensus
</NAME>

<DESCRIPTION>
I add a residual-tilted, direction-aware consensus weighting to the pairwise repair step, guided by router-level signed flow residuals computed from the original telemetry. This biases the consensus slightly against the local endpoint on links where the direction of pair asymmetry aligns with the router’s signed imbalance, thereby nudging repairs to simultaneously reduce per-router flow conservation residuals (R1) while enforcing link symmetry (R3). The tilt is small (≤8% shift in weight), magnitude-aware, and only applied when symmetry violations exceed both relative and absolute guards and the rate is not tiny.

Concretely:
- Compute per-router signed residuals from the original telemetry (respecting down interfaces as zero).
- In each direction (A→B uses A’s router; B→A uses B’s router), if the sign of the pair delta matches the router’s residual sign, use v = w_local·local + (1−w_local)·peer with w_local = clamp(0.5 − γ, 0.2, 0.8), γ = min(0.08, 0.1·|resid_local|).
- Keep existing magnitude-aware thresholds, partial averaging, and confidence calibration; only substitute the consensus point v with the tilted one when applicable.

This should improve counter repair accuracy by reducing router imbalances without harming confidence calibration.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def change_ratio(orig: float, rep: float) -> float:
        denom = max(abs(orig), abs(rep), 1.0)
        return abs(rep - orig) / denom
=======
    def change_ratio(orig: float, rep: float) -> float:
        denom = max(abs(orig), abs(rep), 1.0)
        return abs(rep - orig) / denom

    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def sgn(x: float) -> int:
        return 1 if x > 0 else (-1 if x < 0 else 0)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Build unique undirected link pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
=======
    # Build unique undirected link pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # Compute signed router residuals (original telemetry; down interfaces contribute zero)
    resid_signed: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            d = telemetry.get(iid)
            if not d:
                continue
            status = d.get('interface_status', 'unknown')
            tx = to_float(d.get('tx_rate', 0.0))
            rx = to_float(d.get('rx_rate', 0.0))
            if status == 'down':
                tx = 0.0
                rx = 0.0
            s_tx += tx
            s_rx += rx
        scale = max(s_tx, s_rx, 1.0)
        resid_signed[router] = (s_tx - s_rx) / scale if scale > 0 else 0.0

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
=======
            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                v = 0.5 * (a_tx + b_rx)
                # Residual-tilted, direction-aware consensus weight (A's router)
                resid_a = resid_signed.get(a.get('local_router'), 0.0)
                if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                    gamma = min(0.08, 0.1 * abs(resid_a))
                    w_a = clamp(0.5 - gamma, 0.2, 0.8)
                    w_b = 1.0 - w_a
                    v = w_a * a_tx + w_b * b_rx
                if d_ab <= partial_upper:
                    # Asymmetric partial averaging: louder side moves more; low-rate uses slightly steeper ramp
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < LOW_RATE_CUTOFF:
                        k_base = k_base ** 1.2
                    loud = a_tx if a_tx >= b_rx else b_rx
                    quiet = b_rx if a_tx >= b_rx else a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
=======
            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                # Residual-tilted, direction-aware consensus weight (B's router)
                resid_b = resid_signed.get(b.get('local_router'), 0.0)
                if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                    gamma2 = min(0.08, 0.1 * abs(resid_b))
                    w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                    w_a2 = 1.0 - w_b2
                    v2 = w_b2 * b_tx + w_a2 * a_rx
                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < LOW_RATE_CUTOFF:
                        k_base2 = k_base2 ** 1.2
                    loud2 = b_tx if b_tx >= a_rx else a_rx
                    quiet2 = a_rx if b_tx >= a_rx else b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
>>>>>>> REPLACE

</DIFF>