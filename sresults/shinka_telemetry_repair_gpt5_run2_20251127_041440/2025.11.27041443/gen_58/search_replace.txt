<NAME>
pair_bias_prescaling
</NAME>

<DESCRIPTION>
I propose adding a targeted Stage 0 “pair‑bias multiplicative harmonization” step before the current residual‑tilted consensus. It detects when one end of a link is consistently multiplicatively scaled versus its peer across both directions (a_tx vs b_rx and a_rx vs b_tx). When both ratios agree within 2% and the bias magnitude exceeds magnitude‑aware thresholds, we partially correct the lower‑activity endpoint using a bounded factor. This pre‑scales obviously miscalibrated pairs so that the subsequent residual‑tilted asymmetric consensus has a better starting point, improving counter repairs without hurting calibration. The step is magnitude‑aware, guarded by absolute thresholds, and only engages on active links, so it remains conservative and calibration‑friendly. No other logic is changed.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Stage 1: Residual-tilted, trust-weighted link consensus with asymmetric partial averaging
=======
    # Stage 0: Pair-bias multiplicative harmonization (pre-consensus)
    visited_pairs_bias = set()
    for a_id, a_d in telemetry.items():
        b_id = peers.get(a_id)
        if not b_id:
            continue
        key = tuple(sorted((a_id, b_id)))
        if key in visited_pairs_bias:
            continue
        visited_pairs_bias.add(key)

        sa = status_orig.get(a_id, 'unknown')
        sb = status_orig.get(b_id, 'unknown')
        if sa == 'down' or sb == 'down':
            continue

        a_tx, a_rx = vals[a_id]['tx'], vals[a_id]['rx']
        b_tx, b_rx = vals[b_id]['tx'], vals[b_id]['rx']

        # Require active traffic in both directions to infer multiplicative bias
        if (a_tx <= QUIET_EPS or a_rx <= QUIET_EPS or b_tx <= QUIET_EPS or b_rx <= QUIET_EPS):
            continue

        # Ratios that should both approximate the same bias factor if one endpoint is scaled
        r1 = b_rx / max(a_tx, 1e-9)  # their_rx / my_tx
        r2 = b_tx / max(a_rx, 1e-9)  # their_tx / my_rx
        s = sqrt(max(1e-18, r1 * r2))  # geometric mean ratio

        # Consistency check between ratios and magnitude-aware gating
        ratio_consistent = (abs(r1 - r2) / max(1.0, r1, r2)) <= 0.02
        hi = max(a_tx, a_rx, b_tx, b_rx)
        tol = LOW_RATE_THRESHOLD if hi < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
        abs_ab = abs(a_tx - b_rx)
        abs_ba = abs(b_tx - a_rx)

        if (not ratio_consistent) or (abs(s - 1.0) <= tol) or (abs_ab <= ABS_GUARD and abs_ba <= ABS_GUARD):
            continue

        # Adjust the lower-activity side toward the bias-corrected scale (partial application)
        act_a = max(a_tx, a_rx)
        act_b = max(b_tx, b_rx)
        if act_a < act_b:
            target = a_id
            scale = s
        else:
            target = b_id
            scale = 1.0 / max(1e-9, s)

        k = (abs(s - 1.0) - tol) / max(tol, 1e-9)
        k = clamp(k, 0.0, 1.0)
        factor = 1.0 + k * (scale - 1.0)

        vals[target]['tx'] = max(0.0, vals[target]['tx'] * factor)
        vals[target]['rx'] = max(0.0, vals[target]['rx'] * factor)

    # Stage 1: Residual-tilted, trust-weighted link consensus with asymmetric partial averaging
>>>>>>> REPLACE

</DIFF>