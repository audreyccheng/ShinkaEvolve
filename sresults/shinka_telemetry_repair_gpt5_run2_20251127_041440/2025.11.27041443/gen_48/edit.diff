--- a/original.py
+++ b/original.py
@@ -1,440 +1,488 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
-This version implements a consensus-and-residual fusion approach:
-- Trust-weighted directional consensus with partial averaging near threshold
-- Magnitude-aware gating with absolute guard and sharp agreement floors
-- Asymmetric confidence shaping when only one side shows traffic
-- Router-level micro-adjustments for dominating dangling interfaces
-- Direction-aware confidence penalties informed by flow-conservation residuals
+This version implements "tilted_asym_consensus_v2":
+- Residual-tilted, trust-weighted directional consensus with asymmetric partial averaging
+- Magnitude-aware gating with absolute guard and strong agreement floors
+- Improvement-checked router micro-adjustments for dominating unpaired interfaces
+- Tri-axis confidence with interface-share–aware, direction-coupled router penalties,
+  symmetry fit after repair, and correction magnitude; plus asymmetric traffic-evidence shaping
 """
 from typing import Dict, Any, Tuple, List
 from math import sqrt
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
-    Core invariants used:
-    1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
-    2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
-    3. Interface Consistency: Status should be consistent across connected pairs
-
-    Args:
-        telemetry: Dictionary where key is interface_id and value contains:
-            - interface_status: "up" or "down"
-            - rx_rate: receive rate in Mbps
-            - tx_rate: transmit rate in Mbps
-            - connected_to: interface_id this interface connects to
-            - local_router: router_id this interface belongs to
-            - remote_router: router_id on the other side
-        topology: Dictionary where key is router_id and value contains a list of interface_ids
-
-    Returns:
-        Dictionary with same structure but telemetry values become tuples of:
-        (original_value, repaired_value, confidence_score)
-        where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
+    Invariants:
+    - Link Symmetry (R3): my_tx ≈ peer_rx, my_rx ≈ peer_tx
+    - Flow Conservation (R1): Sum(tx) ≈ Sum(rx) at each router
+    - Interface Consistency: Down on one side => both down with zero rates
     """
-    # Hardened tolerances (Hodor guidance)
-    HARDENING_THRESHOLD = 0.02   # 2% for normal rates
-    LOW_RATE_CUTOFF = 10.0       # Mbps threshold for tiny flows
-    LOW_RATE_THRESHOLD = 0.05    # 5% tolerance when small
-    ABS_GUARD = 0.5              # Mbps; absolute guard to avoid over-correcting tiny flows
-    QUIET_EPS = 0.1              # Mbps; traffic "silence" threshold for asymmetry handling
+
+    # Thresholds and guards
+    HARDENING_THRESHOLD = 0.02       # τh ≈ 2% (normal rates)
+    LOW_RATE_CUTOFF = 10.0           # Mbps (small flows use relaxed tolerance)
+    LOW_RATE_THRESHOLD = 0.05        # 5% for low rates
+    ABS_GUARD = 0.5                  # Mbps absolute guard for tiny discrepancies
+    QUIET_EPS = 0.1                  # Mbps silence threshold
+
+    # Residual-tilt parameters (Recommendation 1)
+    TILT_GAMMA_MAX = 0.08            # max absolute tilt on local weight
+    TILT_GAMMA_SCALE = 0.10          # scale by residual fraction (γ = min(0.08, 0.1 * resid_local))
+
+    # Micro-adjuster parameters (Recommendation 2)
+    ROUTER_RESID_TRIGGER = 0.03      # trigger micro-adjust when residual ≥ 3%
+    DOMINANCE_SHARE = 0.60           # candidate must contribute ≥60% of same-direction mass
+    MI_ALPHA_CAP = 0.02              # cap nudge at 2%
+    IMPROVE_REQ = 0.10               # require ≥10% residual improvement to commit
 
     def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
         return max(lo, min(hi, x))
 
-    result: Dict[str, Dict[str, Tuple]] = {}
-
-    # Build peer mapping for quick, validated lookup
-    peers: Dict[str, str] = {}
-    for if_id, data in telemetry.items():
-        peer_id = data.get('connected_to')
-        peers[if_id] = peer_id if peer_id in telemetry else None
-
-    # Plan pairwise consensus adjustments so both ends change consistently
-    field_value_adjust: Dict[Tuple[str, str], float] = {}   # (iface, 'tx'|'rx') -> new_value
-    field_conf_assign: Dict[Tuple[str, str], float] = {}    # set confidence when adjusted
-    field_conf_floor: Dict[Tuple[str, str], float] = {}     # high floors when in strong agreement
-    field_conf_scale: Dict[Tuple[str, str], float] = {}     # multiplicative confidence scalers (asymmetry)
-
-    visited_pairs = set()
-
-    # Utility for normalized difference
     def rel_diff(a: float, b: float) -> float:
         return abs(a - b) / max(1.0, a, b)
 
-    # Pairwise consensus-and-hardening
-    for a_id, a_data in telemetry.items():
-        b_id = peers.get(a_id)
-        if not b_id:
-            continue
-        key = tuple(sorted([a_id, b_id]))
-        if key in visited_pairs:
-            continue
-        visited_pairs.add(key)
-
-        a_status = a_data.get('interface_status', 'unknown')
-        b_status = telemetry[b_id].get('interface_status', 'unknown')
-
-        a_tx = float(a_data.get('tx_rate', 0.0))
-        a_rx = float(a_data.get('rx_rate', 0.0))
-        b_tx = float(telemetry[b_id].get('tx_rate', 0.0))
-        b_rx = float(telemetry[b_id].get('rx_rate', 0.0))
-
-        # Only attempt counter fusion if neither side is explicitly down; down logic handled later
-        if a_status != 'down' and b_status != 'down':
-            # Direction a->b: compare a_tx with b_rx
-            abs_ab = abs(a_tx - b_rx)
-            max_ab = max(1.0, a_tx, b_rx)
-            diff_ab = abs_ab / max_ab
-            tol_ab = LOW_RATE_THRESHOLD if max(a_tx, b_rx) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
-
-            # Direction b->a: compare b_tx with a_rx
-            abs_ba = abs(b_tx - a_rx)
-            max_ba = max(1.0, b_tx, a_rx)
-            diff_ba = abs_ba / max_ba
-            tol_ba = LOW_RATE_THRESHOLD if max(b_tx, a_rx) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
-
-            # Activity-based trust for consensus weighting (novel bias)
-            # Bias toward the side that exhibits stronger traffic magnitude (more reliable signal)
-            act_a = max(a_tx, a_rx)
-            act_b = max(b_tx, b_rx)
-            denom_act = max(1e-9, act_a + act_b)
-            w_a = act_a / denom_act
-            w_b = act_b / denom_act
-
-            # a->b hardening
-            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
-                # Trust-weighted consensus
-                consensus_ab = w_a * a_tx + w_b * b_rx
-                if diff_ab <= 2 * tol_ab:
-                    # Partial averaging near threshold to reduce overcorrection
-                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
-                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
-                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
-                else:
-                    # Clear violation: converge fully to consensus
-                    new_a_tx = consensus_ab
-                    new_b_rx = consensus_ab
-                field_value_adjust[(a_id, 'tx')] = new_a_tx
-                field_value_adjust[(b_id, 'rx')] = new_b_rx
-                conf_ab = clamp(1.0 - diff_ab)
-                field_conf_assign[(a_id, 'tx')] = conf_ab
-                field_conf_assign[(b_id, 'rx')] = conf_ab
-            else:
-                # Within tolerance: floor high confidence
-                if max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005:
-                    floor = 0.99
-                else:
-                    floor = 0.98
-                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), floor)
-                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), floor)
-
-            # b->a hardening
-            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
-                consensus_ba = w_b * b_tx + w_a * a_rx
-                if diff_ba <= 2 * tol_ba:
-                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
-                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
-                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
-                else:
-                    new_b_tx = consensus_ba
-                    new_a_rx = consensus_ba
-                field_value_adjust[(b_id, 'tx')] = new_b_tx
-                field_value_adjust[(a_id, 'rx')] = new_a_rx
-                conf_ba = clamp(1.0 - diff_ba)
-                field_conf_assign[(b_id, 'tx')] = conf_ba
-                field_conf_assign[(a_id, 'rx')] = conf_ba
-            else:
-                if max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005:
-                    floor = 0.99
-                else:
-                    floor = 0.98
-                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), floor)
-                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), floor)
-
-            # Asymmetric confidence when only one side shows traffic (traffic-evidence asymmetry)
-            pair_up = True
-            # Direction a->b
-            if pair_up and a_tx > QUIET_EPS and b_rx <= QUIET_EPS:
-                field_conf_scale[(b_id, 'rx')] = min(0.9, field_conf_scale.get((b_id, 'rx'), 1.0))
-            if pair_up and b_rx > QUIET_EPS and a_tx <= QUIET_EPS:
-                field_conf_scale[(a_id, 'tx')] = min(0.9, field_conf_scale.get((a_id, 'tx'), 1.0))
-            # Direction b->a
-            if pair_up and b_tx > QUIET_EPS and a_rx <= QUIET_EPS:
-                field_conf_scale[(a_id, 'rx')] = min(0.9, field_conf_scale.get((a_id, 'rx'), 1.0))
-            if pair_up and a_rx > QUIET_EPS and b_tx <= QUIET_EPS:
-                field_conf_scale[(b_id, 'tx')] = min(0.9, field_conf_scale.get((b_id, 'tx'), 1.0))
-
-            # Harmonize very strong agreements via geometric-mean floors
-            strong_ab = (max(a_tx, b_rx) >= 10.0 and diff_ab <= 0.005)
-            strong_ba = (max(b_tx, a_rx) >= 10.0 and diff_ba <= 0.005)
-            if strong_ab:
-                # Geometric mean harmonization for link-direction confidences
-                fa = field_conf_floor.get((a_id, 'tx'), 0.98)
-                fb = field_conf_floor.get((b_id, 'rx'), 0.98)
-                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
-                field_conf_floor[(a_id, 'tx')] = max(field_conf_floor.get((a_id, 'tx'), 0.0), gm)
-                field_conf_floor[(b_id, 'rx')] = max(field_conf_floor.get((b_id, 'rx'), 0.0), gm)
-            if strong_ba:
-                fb = field_conf_floor.get((b_id, 'tx'), 0.98)
-                fa = field_conf_floor.get((a_id, 'rx'), 0.98)
-                gm = sqrt(max(1e-9, fa) * max(1e-9, fb))
-                field_conf_floor[(b_id, 'tx')] = max(field_conf_floor.get((b_id, 'tx'), 0.0), gm)
-                field_conf_floor[(a_id, 'rx')] = max(field_conf_floor.get((a_id, 'rx'), 0.0), gm)
-
-    # Second pass: apply planned adjustments and assign calibrated confidences
-    for interface_id, data in telemetry.items():
-        repaired = {}
-
-        interface_status = data.get('interface_status', 'unknown')
-        rx_rate = float(data.get('rx_rate', 0.0))
-        tx_rate = float(data.get('tx_rate', 0.0))
-        connected_to = data.get('connected_to')
-
-        # Defaults: identity with conservative base
-        repaired_rx = rx_rate
-        repaired_tx = tx_rate
-        repaired_status = interface_status
-        rx_conf = 0.95
-        tx_conf = 0.95
-        status_conf = 0.95
-
-        # Peer snapshot
-        peer_status = None
-        if connected_to and connected_to in telemetry:
-            peer_status = telemetry[connected_to].get('interface_status', 'unknown')
-
-        # Enforce interface consistency: if either side is down, set both down with zero rates
-        if interface_status == 'down' or (peer_status == 'down' if peer_status is not None else False):
-            both_down = (interface_status == 'down' and (peer_status == 'down' if peer_status is not None else False))
-            repaired_status = 'down'
-            repaired_rx = 0.0
-            repaired_tx = 0.0
-            status_conf = 0.95 if both_down else 0.7
-            rx_conf = status_conf
-            tx_conf = status_conf
-        else:
-            # Apply pairwise counter adjustments
-            if (interface_id, 'rx') in field_value_adjust:
-                repaired_rx = float(field_value_adjust[(interface_id, 'rx')])
-                rx_conf = field_conf_assign.get((interface_id, 'rx'), rx_conf)
-            if (interface_id, 'tx') in field_value_adjust:
-                repaired_tx = float(field_value_adjust[(interface_id, 'tx')])
-                tx_conf = field_conf_assign.get((interface_id, 'tx'), tx_conf)
-
-            # Status mismatch (neither side down) reduces status confidence
-            if connected_to and connected_to in telemetry:
-                if interface_status != peer_status:
-                    status_conf = min(status_conf, 0.6)
-
-            # Apply confidence floors for in-tolerance agreements
-            rx_floor = field_conf_floor.get((interface_id, 'rx'))
-            tx_floor = field_conf_floor.get((interface_id, 'tx'))
-            if rx_floor is not None:
-                rx_conf = max(rx_conf, rx_floor)
-            if tx_floor is not None:
-                tx_conf = max(tx_conf, tx_floor)
-
-            # Apply asymmetric scaling if applicable
-            if (interface_id, 'rx') in field_conf_scale:
-                rx_conf = clamp(rx_conf * field_conf_scale[(interface_id, 'rx')])
-            if (interface_id, 'tx') in field_conf_scale:
-                tx_conf = clamp(tx_conf * field_conf_scale[(interface_id, 'tx')])
-
-        # Store
-        repaired['rx_rate'] = (rx_rate, repaired_rx, clamp(rx_conf))
-        repaired['tx_rate'] = (tx_rate, repaired_tx, clamp(tx_conf))
-        repaired['interface_status'] = (interface_status, repaired_status, clamp(status_conf))
-        repaired['connected_to'] = connected_to
-        repaired['local_router'] = data.get('local_router')
-        repaired['remote_router'] = data.get('remote_router')
-        result[interface_id] = repaired
-
-    # Router-level flow conservation: micro-adjustments on dominating dangling interfaces
-    # Build router->interfaces mapping using provided topology and telemetry fallbacks
+    def dir_threshold(a: float, b: float) -> float:
+        return LOW_RATE_THRESHOLD if max(a, b) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
+
+    # Build peer mapping and collect originals
+    peers: Dict[str, str] = {}
+    vals: Dict[str, Dict[str, float]] = {}
+    orig: Dict[str, Dict[str, float]] = {}
+    status_orig: Dict[str, str] = {}
+    for if_id, d in telemetry.items():
+        p = d.get('connected_to')
+        peers[if_id] = p if p in telemetry else None
+        tx = float(d.get('tx_rate', 0.0))
+        rx = float(d.get('rx_rate', 0.0))
+        vals[if_id] = {'tx': tx, 'rx': rx}
+        orig[if_id] = {'tx': tx, 'rx': rx}
+        status_orig[if_id] = d.get('interface_status', 'unknown')
+
+    # Build router->interfaces mapping (prefer topology, augment with telemetry hints)
     router_ifaces: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
     for if_id, d in telemetry.items():
         lr = d.get('local_router')
         if lr:
             router_ifaces.setdefault(lr, [])
             if if_id not in router_ifaces[lr]:
                 router_ifaces[lr].append(if_id)
         rr = d.get('remote_router')
         if rr and rr not in router_ifaces:
             router_ifaces[rr] = []
 
-    # Compute per-router sums
-    router_sums: Dict[str, Tuple[float, float]] = {}
-    for r, if_list in router_ifaces.items():
-        sum_tx = 0.0
-        sum_rx = 0.0
-        for if_id in if_list:
-            if if_id in result:
-                sum_tx += float(result[if_id]['tx_rate'][1])
-                sum_rx += float(result[if_id]['rx_rate'][1])
-        router_sums[r] = (sum_tx, sum_rx)
-
-    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces (recommendation 4)
+    # Helper to compute per-router sums from provided values
+    def compute_router_sums(current_vals: Dict[str, Dict[str, float]]) -> Dict[str, Tuple[float, float]]:
+        sums: Dict[str, Tuple[float, float]] = {}
+        for r, if_list in router_ifaces.items():
+            s_tx = 0.0
+            s_rx = 0.0
+            for iid in if_list:
+                if iid in current_vals:
+                    s_tx += float(current_vals[iid]['tx'])
+                    s_rx += float(current_vals[iid]['rx'])
+            sums[r] = (s_tx, s_rx)
+        return sums
+
+    # Compute original router residuals for tilt computation
+    router_sums_orig = compute_router_sums(orig)
+    router_delta_orig: Dict[str, float] = {}   # delta = sum_tx - sum_rx
+    router_resid_frac_orig: Dict[str, float] = {}
+    for r, (s_tx, s_rx) in router_sums_orig.items():
+        router_delta_orig[r] = s_tx - s_rx
+        denom = max(1.0, s_tx, s_rx)
+        router_resid_frac_orig[r] = abs(s_tx - s_rx) / denom
+
+    # Stage 1: Residual-tilted, trust-weighted link consensus with asymmetric partial averaging
+    visited_pairs = set()
+    for a_id, a_d in telemetry.items():
+        b_id = peers.get(a_id)
+        if not b_id:
+            continue
+        key = tuple(sorted((a_id, b_id)))
+        if key in visited_pairs:
+            continue
+        visited_pairs.add(key)
+
+        sa = status_orig.get(a_id, 'unknown')
+        sb = status_orig.get(b_id, 'unknown')
+        if sa == 'down' or sb == 'down':
+            # Skip counter fusion; handled later by status enforcement
+            continue
+
+        a_tx, a_rx = vals[a_id]['tx'], vals[a_id]['rx']
+        b_tx, b_rx = vals[b_id]['tx'], vals[b_id]['rx']
+
+        # Activity-based base weights
+        act_a = max(a_tx, a_rx)
+        act_b = max(b_tx, b_rx)
+        denom_act = max(1e-9, act_a + act_b)
+        w_a_base = act_a / denom_act
+        w_b_base = act_b / denom_act
+
+        a_lr = telemetry[a_id].get('local_router')
+        b_lr = telemetry[b_id].get('local_router')
+
+        # Utility: asymmetric partial averaging update
+        def asym_partial(a_val: float, b_val: float, consensus: float, diff: float, tol: float) -> Tuple[float, float]:
+            k_base = (diff - tol) / max(tol, 1e-9)
+            # compute loudness share
+            s = max(1e-9, a_val + b_val)
+            a_share = a_val / s
+            b_share = b_val / s
+            # louder moves more
+            k_a = clamp(k_base * (1.0 + 0.5 * a_share), 0.0, 1.0)
+            k_b = clamp(k_base * (1.0 + 0.5 * b_share), 0.0, 1.0)
+            # but bias to move louder more: the quieter uses reduced factor
+            if a_val >= b_val:
+                k_b = clamp(k_base * (1.0 - 0.5 * b_share), 0.0, 1.0)
+            else:
+                k_a = clamp(k_base * (1.0 - 0.5 * a_share), 0.0, 1.0)
+            new_a = a_val * (1.0 - k_a) + consensus * k_a
+            new_b = b_val * (1.0 - k_b) + consensus * k_b
+            return new_a, new_b
+
+        # Direction a->b: compare a_tx with b_rx
+        abs_ab = abs(a_tx - b_rx)
+        tol_ab = dir_threshold(a_tx, b_rx)
+        diff_ab = abs_ab / max(1.0, a_tx, b_rx)
+        if diff_ab > tol_ab and abs_ab > ABS_GUARD:
+            # Residual-tilted weights based on a's local router residual and delta
+            if a_lr in router_resid_frac_orig:
+                resid_local = router_resid_frac_orig[a_lr]
+                delta_local = router_delta_orig.get(a_lr, 0.0)
+            else:
+                resid_local = 0.0
+                delta_local = 0.0
+            w_a, w_b = w_a_base, w_b_base
+            if resid_local > 0.0 and (a_tx - b_rx) * delta_local > 0.0:
+                gamma = min(TILT_GAMMA_MAX, TILT_GAMMA_SCALE * resid_local)
+                w_a = clamp(w_a_base - gamma, 0.1, 0.9)
+                w_b = 1.0 - w_a
+            consensus_ab = w_a * a_tx + w_b * b_rx
+            if diff_ab <= 2 * tol_ab:
+                new_a_tx, new_b_rx = asym_partial(a_tx, b_rx, consensus_ab, diff_ab, tol_ab)
+            else:
+                new_a_tx, new_b_rx = consensus_ab, consensus_ab
+            vals[a_id]['tx'], vals[b_id]['rx'] = new_a_tx, new_b_rx
+
+        # Direction b->a: compare b_tx with a_rx
+        abs_ba = abs(b_tx - a_rx)
+        tol_ba = dir_threshold(b_tx, a_rx)
+        diff_ba = abs_ba / max(1.0, b_tx, a_rx)
+        if diff_ba > tol_ba and abs_ba > ABS_GUARD:
+            if b_lr in router_resid_frac_orig:
+                resid_local = router_resid_frac_orig[b_lr]
+                delta_local = router_delta_orig.get(b_lr, 0.0)
+            else:
+                resid_local = 0.0
+                delta_local = 0.0
+            w_a2, w_b2 = w_a_base, w_b_base
+            # Note direction b->a: local side is b
+            if resid_local > 0.0 and (b_tx - a_rx) * delta_local > 0.0:
+                gamma = min(TILT_GAMMA_MAX, TILT_GAMMA_SCALE * resid_local)
+                # shrink b's weight; w_b2 is base weight for b
+                w_b2 = clamp(w_b_base - gamma, 0.1, 0.9)
+                w_a2 = 1.0 - w_b2
+            consensus_ba = w_b2 * b_tx + w_a2 * a_rx
+            if diff_ba <= 2 * tol_ba:
+                new_b_tx, new_a_rx = asym_partial(b_tx, a_rx, consensus_ba, diff_ba, tol_ba)
+            else:
+                new_b_tx, new_a_rx = consensus_ba, consensus_ba
+            vals[b_id]['tx'], vals[a_id]['rx'] = new_b_tx, new_a_rx
+
+    # Stage 2: Router-level micro-adjustments (improvement-checked, stronger triggers)
+    # Work on current vals; compute router sums and residuals
+    router_sums = compute_router_sums(vals)
+    router_resid_frac: Dict[str, float] = {}
+    for r, (s_tx, s_rx) in router_sums.items():
+        denom = max(1.0, s_tx, s_rx)
+        router_resid_frac[r] = abs(s_tx - s_rx) / denom
+
     for r, if_list in router_ifaces.items():
         sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
-        imbalance = sum_tx - sum_rx
-        abs_imb = abs(imbalance)
-        if abs_imb <= 0.0:
-            continue
-        denom = max(1.0, sum_tx, sum_rx)
-        resid_frac = abs_imb / denom
-
-        # Identify unpaired, up interfaces
+        delta = sum_tx - sum_rx
+        denom_r = max(1.0, sum_tx, sum_rx)
+        resid_frac = abs(delta) / denom_r
+        if resid_frac < ROUTER_RESID_TRIGGER:
+            continue
+        if not if_list:
+            continue
+
+        reduce_tx = delta > 0.0
+        reduce_rx = delta < 0.0
+
+        # Consider only unpaired, up interfaces (dangling)
         candidates = []
-        for if_id in if_list:
-            if if_id not in result:
+        total_mass = 0.0
+        for iid in if_list:
+            if iid not in vals:
                 continue
-            # unpaired if peer missing in telemetry
-            connected_to = result[if_id].get('connected_to')
-            is_unpaired = not connected_to or connected_to not in telemetry
-            status = result[if_id]['interface_status'][1]
-            if is_unpaired and status == 'up':
-                txv = float(result[if_id]['tx_rate'][1])
-                rxv = float(result[if_id]['rx_rate'][1])
-                contrib = abs(txv - rxv)
-                candidates.append((contrib, if_id, txv, rxv))
-
-        if not candidates:
-            continue
-
+            if status_orig.get(iid, 'unknown') != 'up':
+                continue
+            peer_id = peers.get(iid)
+            if peer_id is not None:
+                continue  # skip paired
+            vtx = float(vals[iid]['tx'])
+            vrx = float(vals[iid]['rx'])
+            if reduce_tx:
+                mass = vtx
+            elif reduce_rx:
+                mass = vrx
+            else:
+                mass = 0.0
+            if mass > 0.0:
+                candidates.append((mass, iid, vtx, vrx))
+                total_mass += mass
+
+        if not candidates or total_mass <= 0.0:
+            continue
+
+        # Dominance test ≥ 60% of same-direction mass
         candidates.sort(reverse=True)
-        top_contrib, top_if, txv, rxv = candidates[0]
-        if top_contrib < 0.5 * abs_imb:
-            continue  # not dominating enough
-
-        alpha = min(0.02, 0.5 * resid_frac)
+        top_mass, top_if, top_tx, top_rx = candidates[0]
+        if top_mass < DOMINANCE_SHARE * total_mass:
+            continue
+
+        # Tentative nudge
+        alpha = min(MI_ALPHA_CAP, 0.5 * resid_frac)
         if alpha <= 0.0:
             continue
 
-        # Adjust only the larger counter toward reducing the router imbalance
-        orx, rrx, rc = result[top_if]['rx_rate']
-        otx, rtx, tc = result[top_if]['tx_rate']
-        if imbalance > 0.0:
-            # sum_tx > sum_rx: reduce tx or increase rx; nudge only larger counter
-            if rtx >= rrx:
-                new_tx = rtx * (1.0 - alpha)
-                # modest confidence increase reflecting conservation alignment
-                new_conf = max(tc, 0.6 + 0.2 * (alpha / 0.02))
-                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
-            else:
-                new_rx = rrx * (1.0 + alpha)
-                new_conf = max(rc, 0.6 + 0.2 * (alpha / 0.02))
-                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
+        def compute_router_resid_if(vals_mut: Dict[str, Dict[str, float]], router: str) -> float:
+            stx, srx = 0.0, 0.0
+            for iid in router_ifaces.get(router, []):
+                if iid in vals_mut:
+                    stx += float(vals_mut[iid]['tx'])
+                    srx += float(vals_mut[iid]['rx'])
+            return abs(stx - srx) / max(1.0, stx, srx)
+
+        # Clone local changes for tentative application
+        old_tx, old_rx = vals[top_if]['tx'], vals[top_if]['rx']
+        # Adjust only the larger counter in the direction that reduces imbalance
+        if reduce_tx:
+            if old_tx >= old_rx:
+                new_tx = old_tx * (1.0 - alpha)
+                new_rx = old_rx
+            else:
+                new_tx = old_tx
+                new_rx = old_rx * (1.0 + alpha)
+        else:  # reduce_rx
+            if old_rx >= old_tx:
+                new_rx = old_rx * (1.0 - alpha)
+                new_tx = old_tx
+            else:
+                new_rx = old_rx
+                new_tx = old_tx * (1.0 + alpha)
+
+        # Apply tentatively
+        vals[top_if]['tx'], vals[top_if]['rx'] = new_tx, new_rx
+        resid_after = compute_router_resid_if(vals, r)
+        resid_before = resid_frac
+        # Commit only if improves by at least 10%
+        if resid_after <= (1.0 - IMPROVE_REQ) * resid_before:
+            # Commit already applied
+            # Update router_sums for this router
+            router_sums[r] = (sum_tx - old_tx + new_tx, sum_rx - old_rx + new_rx)
         else:
-            # sum_tx < sum_rx: reduce rx or increase tx; nudge only larger counter
-            if rrx >= rtx:
-                new_rx = rrx * (1.0 - alpha)
-                new_conf = max(rc, 0.6 + 0.2 * (alpha / 0.02))
-                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
-            else:
-                new_tx = rtx * (1.0 + alpha)
-                new_conf = max(tc, 0.6 + 0.2 * (alpha / 0.02))
-                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
-
-    # Recompute residuals after micro-adjustments
-    router_resid: Dict[str, float] = {}
-    for r, if_list in router_ifaces.items():
-        sum_tx = 0.0
-        sum_rx = 0.0
-        for if_id in if_list:
-            if if_id in result:
-                sum_tx += float(result[if_id]['tx_rate'][1])
-                sum_rx += float(result[if_id]['rx_rate'][1])
-        denom = max(1.0, sum_tx, sum_rx)
-        router_resid[r] = abs(sum_tx - sum_rx) / denom
-
-    # Apply direction-aware penalties (recommendation 2) and mild status scaling
+            # Revert change
+            vals[top_if]['tx'], vals[top_if]['rx'] = old_tx, old_rx
+
+    # Stage 3: Recompute residuals after micro-adjustments
+    router_sums2 = compute_router_sums(vals)
+    router_resid2: Dict[str, float] = {}
+    for r, (s_tx, s_rx) in router_sums2.items():
+        router_resid2[r] = abs(s_tx - s_rx) / max(1.0, s_tx, s_rx)
+
+    # Stage 4: Final assembly with calibrated confidences (tri-axis + share-aware penalties)
+    result: Dict[str, Dict[str, Tuple]] = {}
+    # Precompute per-router directional sums for share calculation
+    router_sum_tx: Dict[str, float] = {r: stx for r, (stx, srx) in router_sums2.items()}
+    router_sum_rx: Dict[str, float] = {r: srx for r, (stx, srx) in router_sums2.items()}
+
     for if_id, d in telemetry.items():
-        if if_id not in result:
-            continue
         lr = d.get('local_router')
         rr = d.get('remote_router')
-        resid_local = router_resid.get(lr, 0.0)
-        resid_remote = router_resid.get(rr, 0.0)
-        pen_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.0, 1.0)
-        pen_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.0, 1.0)
-
-        orx, rrx, rc = result[if_id]['rx_rate']
-        otx, rtx, tc = result[if_id]['tx_rate']
-        ost, rst, sc = result[if_id]['interface_status']
-
-        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * pen_tx))
-        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * pen_rx))
-        # Mild status confidence scaling with penalties
-        status_scale = 0.85 + 0.15 * min(pen_tx, pen_rx)
-        result[if_id]['interface_status'] = (ost, rst, clamp(sc * status_scale))
-
-    # Ensure zero rates if repaired status is down (idempotent safety)
+        peer_id = peers.get(if_id)
+        peer_exists = peer_id is not None
+
+        orig_tx = orig[if_id]['tx']
+        orig_rx = orig[if_id]['rx']
+        rep_tx = vals[if_id]['tx']
+        rep_rx = vals[if_id]['rx']
+
+        status = status_orig.get(if_id, 'unknown')
+        peer_status = status_orig.get(peer_id, 'unknown') if peer_exists else None
+
+        # Enforce interface consistency: if either side is down, set both down with zero rates
+        force_down = (status == 'down') or (peer_exists and peer_status == 'down')
+        if force_down:
+            repaired_status = 'down'
+            both_report_down = (status == 'down' and (peer_exists and peer_status == 'down'))
+            status_conf = 0.95 if both_report_down else 0.7
+            rep_tx = 0.0
+            rep_rx = 0.0
+            tx_conf = status_conf
+            rx_conf = status_conf
+        else:
+            repaired_status = status
+
+            # Directional shares for confidence penalties
+            sum_tx_local = router_sum_tx.get(lr, 0.0)
+            sum_rx_local = router_sum_rx.get(lr, 0.0)
+            iface_tx_share = rep_tx / max(1.0, sum_tx_local)
+            iface_rx_share = rep_rx / max(1.0, sum_rx_local)
+
+            resid_local = router_resid2.get(lr, 0.0)
+            resid_remote = router_resid2.get(rr, 0.0)
+
+            # Share-aware, direction-coupled penalties (Recommendation 3)
+            pen_tx = clamp(1.0 - ((0.6 + 0.2 * iface_tx_share) * resid_local +
+                                  (0.4 - 0.2 * iface_tx_share) * resid_remote), 0.0, 1.0)
+            pen_rx = clamp(1.0 - ((0.6 + 0.2 * iface_rx_share) * resid_local +
+                                  (0.4 - 0.2 * iface_rx_share) * resid_remote), 0.0, 1.0)
+
+            # Link symmetry fit on repaired values
+            if peer_exists:
+                peer_rep_tx = vals[peer_id]['tx']
+                peer_rep_rx = vals[peer_id]['rx']
+                diff_tx = rel_diff(rep_tx, peer_rep_rx)  # my_tx vs their_rx
+                diff_rx = rel_diff(rep_rx, peer_rep_tx)  # my_rx vs their_tx
+                c_sym_tx = clamp(1.0 - diff_tx)
+                c_sym_rx = clamp(1.0 - diff_rx)
+                # Magnitude-aware floors for strong agreement
+                floor_tx = 0.0
+                floor_rx = 0.0
+                th_tx = dir_threshold(rep_tx, peer_rep_rx)
+                th_rx = dir_threshold(rep_rx, peer_rep_tx)
+                if max(rep_tx, peer_rep_rx) >= 10.0 and diff_tx <= 0.005:
+                    floor_tx = 0.99
+                elif diff_tx <= th_tx:
+                    floor_tx = 0.98 if max(rep_tx, peer_rep_rx) >= 10.0 else 0.97
+                if max(rep_rx, peer_rep_tx) >= 10.0 and diff_rx <= 0.005:
+                    floor_rx = 0.99
+                elif diff_rx <= th_rx:
+                    floor_rx = 0.98 if max(rep_rx, peer_rep_tx) >= 10.0 else 0.97
+            else:
+                peer_rep_tx = None
+                peer_rep_rx = None
+                c_sym_tx = 0.9
+                c_sym_rx = 0.9
+                floor_tx = 0.0
+                floor_rx = 0.0
+
+            # Correction magnitude component
+            m_tx = abs(rep_tx - orig_tx) / max(1.0, rep_tx, orig_tx)
+            m_rx = abs(rep_rx - orig_rx) / max(1.0, rep_rx, orig_rx)
+            c_delta_tx = clamp(1.0 - min(1.0, 1.5 * m_tx))
+            c_delta_rx = clamp(1.0 - min(1.0, 1.5 * m_rx))
+
+            # Compose confidences (tri-axis)
+            tx_conf = clamp(0.45 * pen_tx + 0.35 * c_sym_tx + 0.20 * c_delta_tx)
+            rx_conf = clamp(0.45 * pen_rx + 0.35 * c_sym_rx + 0.20 * c_delta_rx)
+
+            # Apply magnitude-aware floors
+            tx_conf = max(tx_conf, floor_tx)
+            rx_conf = max(rx_conf, floor_rx)
+
+            # Asymmetric traffic-evidence shaping: penalize silent side if peer shows traffic
+            if peer_exists and peer_rep_rx is not None:
+                if rep_tx <= QUIET_EPS and peer_rep_rx > QUIET_EPS:
+                    tx_conf = clamp(tx_conf * 0.88)
+            if peer_exists and peer_rep_tx is not None:
+                if rep_rx <= QUIET_EPS and peer_rep_tx > QUIET_EPS:
+                    rx_conf = clamp(rx_conf * 0.88)
+
+            # Status confidence shaping
+            status_conf = 0.95
+            if peer_exists and repaired_status != peer_status and peer_status != 'down':
+                status_conf = min(status_conf, 0.6)
+            # Strong bilateral agreement boosts status confidence
+            if peer_exists:
+                if (max(rep_tx, peer_rep_rx) >= 10.0 and rel_diff(rep_tx, peer_rep_rx) <= 0.005 and
+                        max(rep_rx, peer_rep_tx) >= 10.0 and rel_diff(rep_rx, peer_rep_tx) <= 0.005):
+                    status_conf = max(status_conf, 0.99)
+                elif (rel_diff(rep_tx, peer_rep_rx) <= dir_threshold(rep_tx, peer_rep_rx) and
+                      rel_diff(rep_rx, peer_rep_tx) <= dir_threshold(rep_rx, peer_rep_tx)):
+                    status_conf = max(status_conf, 0.97)
+            # Align mildly with per-direction confidences and penalties
+            status_conf = clamp(status_conf * (0.85 + 0.15 * min(tx_conf, rx_conf)))
+            status_conf = clamp(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
+
+        # Assemble output
+        out: Dict[str, Tuple] = {}
+        out['rx_rate'] = (orig_rx, rep_rx, clamp(rx_conf))
+        out['tx_rate'] = (orig_tx, rep_tx, clamp(tx_conf))
+        out['interface_status'] = (status_orig[if_id], repaired_status, clamp(status_conf))
+        out['connected_to'] = d.get('connected_to')
+        out['local_router'] = d.get('local_router')
+        out['remote_router'] = d.get('remote_router')
+        result[if_id] = out
+
+    # Safety: ensure zero rates if repaired status is down
     for if_id, d in result.items():
-        status = d['interface_status'][1]
-        if status == 'down':
+        if d['interface_status'][1] == 'down':
             orx, _, rc = d['rx_rate']
             otx, _, tc = d['tx_rate']
             d['rx_rate'] = (orx, 0.0, rc)
             d['tx_rate'] = (otx, 0.0, tc)
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")
