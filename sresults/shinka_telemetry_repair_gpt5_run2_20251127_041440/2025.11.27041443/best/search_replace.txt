<NAME>
lowrate_dynamic_guard_shareaware_conf_and_safe_micro
</NAME>

<DESCRIPTION>
I propose three targeted enhancements inspired by the research recommendations to improve counter repair accuracy and confidence calibration without destabilizing the algorithm:

1) Dynamic absolute guard and low-rate–aware partial convergence in pairwise consensus (Rec. 3):
   - For low-rate links, reduce the absolute guard (0.3 Mbps), trigger full convergence earlier (1.6×tol instead of 2×tol), and use a slightly aggressive ramp with exponent 1.2. This improves convergence on low-rate pairs that previously under-corrected, while preserving stability for high-rate flows.

2) Safer, benefit-checked router micro-adjustments on unpaired dominating interfaces (Rec. 5):
   - Require router residual ≥3% and candidate flow ≥ LOW_RATE_CUTOFF; tentatively apply a small nudge and commit only if it improves router residual by ≥8% and does not worsen the interface’s internal rx/tx imbalance by more than 3% relative. Also, reduce confidence on heuristic adjustments (rather than previously boosting it). This protects counter accuracy and improves calibration.

3) Interface-share–aware, direction-coupled router penalties in confidence (Rec. 4):
   - Weight router penalties by the interface’s share of local tx/rx before composing the confidence (0.6+0.2·share on local, 0.4−0.2·share on remote). This aligns confidence with the interface’s influence on conservation and yields better calibration without changing repaired values.

These changes keep the strong aspects of the current method and focus on improving low-rate repairs, preventing harmful nudges, and aligning confidence with influence and residuals.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            if diff_ab > tol_ab and abs_ab > ABS_GUARD:
                # Trust-weighted consensus using activity as reliability proxy
                consensus_ab = w_a * a_tx + w_b * b_rx
                if diff_ab <= 2 * tol_ab:
                    # Partial averaging near threshold
                    k = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                else:
                    # Clear violation: converge fully to consensus
                    new_a_tx = consensus_ab
                    new_b_rx = consensus_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                # Confidence aligned with disagreement magnitude
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
=======
            # Low-rate–aware guards and convergence shaping
            low_band_ab = max(a_tx, b_rx) < LOW_RATE_CUTOFF
            abs_guard_ab = 0.3 if low_band_ab else ABS_GUARD
            full_mult_ab = 1.6 if low_band_ab else 2.0
            exp_ab = 1.2 if low_band_ab else 1.0

            if diff_ab > tol_ab and abs_ab > abs_guard_ab:
                # Trust-weighted consensus using activity as reliability proxy
                consensus_ab = w_a * a_tx + w_b * b_rx
                if diff_ab <= full_mult_ab * tol_ab:
                    # Partial averaging near threshold, accelerated on low-rate links
                    k_raw = (diff_ab - tol_ab) / max(tol_ab, 1e-9)
                    k = max(0.0, min(1.0, k_raw ** exp_ab))
                    new_a_tx = a_tx * (1.0 - k) + consensus_ab * k
                    new_b_rx = b_rx * (1.0 - k) + consensus_ab * k
                else:
                    # Clear violation: converge fully to consensus
                    new_a_tx = consensus_ab
                    new_b_rx = consensus_ab
                field_value_adjust[(a_id, 'tx')] = new_a_tx
                field_value_adjust[(b_id, 'rx')] = new_b_rx
                # Confidence aligned with disagreement magnitude
                conf_ab = clamp(1.0 - diff_ab)
                field_conf_assign[(a_id, 'tx')] = conf_ab
                field_conf_assign[(b_id, 'rx')] = conf_ab
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            if diff_ba > tol_ba and abs_ba > ABS_GUARD:
                consensus_ba = w_b * b_tx + w_a * a_rx
                if diff_ba <= 2 * tol_ba:
                    k = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                else:
                    new_b_tx = consensus_ba
                    new_a_rx = consensus_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
=======
            # Low-rate–aware guards and convergence shaping
            low_band_ba = max(b_tx, a_rx) < LOW_RATE_CUTOFF
            abs_guard_ba = 0.3 if low_band_ba else ABS_GUARD
            full_mult_ba = 1.6 if low_band_ba else 2.0
            exp_ba = 1.2 if low_band_ba else 1.0

            if diff_ba > tol_ba and abs_ba > abs_guard_ba:
                consensus_ba = w_b * b_tx + w_a * a_rx
                if diff_ba <= full_mult_ba * tol_ba:
                    k_raw = (diff_ba - tol_ba) / max(tol_ba, 1e-9)
                    k = max(0.0, min(1.0, k_raw ** exp_ba))
                    new_b_tx = b_tx * (1.0 - k) + consensus_ba * k
                    new_a_rx = a_rx * (1.0 - k) + consensus_ba * k
                else:
                    new_b_tx = consensus_ba
                    new_a_rx = consensus_ba
                field_value_adjust[(b_id, 'tx')] = new_b_tx
                field_value_adjust[(a_id, 'rx')] = new_a_rx
                conf_ba = clamp(1.0 - diff_ba)
                field_conf_assign[(b_id, 'tx')] = conf_ba
                field_conf_assign[(a_id, 'rx')] = conf_ba
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue  # already balanced

        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom
        # Candidate interfaces: unpaired and up
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if connected_to missing or not in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        # Pick dominating candidate
        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        # Compute nudge magnitude capped at 2%
        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Adjust only the larger counter toward reducing router imbalance
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']

        if imbalance > 0:
            # sum_tx > sum_rx: decrease tx or increase rx
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(tc + 0.05 * (alpha / 0.02)))
            else:
                new_rx = rrx * (1.0 + alpha)
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(rc + 0.05 * (alpha / 0.02)))
        else:
            # sum_tx < sum_rx: decrease rx or increase tx
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(rc + 0.05 * (alpha / 0.02)))
            else:
                new_tx = rtx * (1.0 + alpha)
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(tc + 0.05 * (alpha / 0.02)))
=======
    # Apply tightly scoped micro-adjustments only on dominating dangling interfaces
    for r, if_list in router_ifaces.items():
        sum_tx, sum_rx = router_sums.get(r, (0.0, 0.0))
        imbalance = sum_tx - sum_rx
        abs_imb = abs(imbalance)
        if abs_imb <= 0.0:
            continue  # already balanced

        denom = max(1.0, sum_tx, sum_rx)
        resid_frac = abs_imb / denom
        # Require sufficient residual to attempt micro-adjustments
        if resid_frac < 0.03:
            continue

        # Candidate interfaces: unpaired, up, with non-trivial traffic
        candidates = []
        for if_id in if_list:
            if if_id not in result:
                continue
            # unpaired if connected_to missing or not in telemetry
            connected_to = result[if_id].get('connected_to')
            is_unpaired = not connected_to or connected_to not in telemetry
            status = result[if_id]['interface_status'][1]
            if is_unpaired and status == 'up':
                txv = float(result[if_id]['tx_rate'][1])
                rxv = float(result[if_id]['rx_rate'][1])
                if max(txv, rxv) < LOW_RATE_CUTOFF:
                    continue  # avoid nudging tiny flows
                contrib = abs(txv - rxv)
                candidates.append((contrib, if_id, txv, rxv))

        if not candidates:
            continue

        # Pick dominating candidate
        candidates.sort(reverse=True)
        top_contrib, top_if, txv, rxv = candidates[0]
        if top_contrib < 0.5 * abs_imb:
            continue  # not dominating enough

        # Compute nudge magnitude capped at 2%
        alpha = min(0.02, 0.5 * resid_frac)
        if alpha <= 0.0:
            continue

        # Helper to compute router residual for a single router from current result snapshot
        def compute_router_resid_local(router_id: str) -> float:
            stx, srx = 0.0, 0.0
            for iid in router_ifaces.get(router_id, []):
                if iid in result:
                    stx += float(result[iid]['tx_rate'][1])
                    srx += float(result[iid]['rx_rate'][1])
            return abs(stx - srx) / max(1.0, stx, srx)

        # Adjust only the larger counter toward reducing router imbalance, tentatively
        orx, rrx, rc = result[top_if]['rx_rate']
        otx, rtx, tc = result[top_if]['tx_rate']
        pre_internal = abs(rtx - rrx) / max(1.0, max(rtx, rrx))

        if imbalance > 0:
            # sum_tx > sum_rx: decrease tx or increase rx
            if rtx >= rrx:
                new_tx = rtx * (1.0 - alpha)
                new_rx = rrx
                adjust_kind = 'tx'
            else:
                new_rx = rrx * (1.0 + alpha)
                new_tx = rtx
                adjust_kind = 'rx'
        else:
            # sum_tx < sum_rx: decrease rx or increase tx
            if rrx >= rtx:
                new_rx = rrx * (1.0 - alpha)
                new_tx = rtx
                adjust_kind = 'rx'
            else:
                new_tx = rtx * (1.0 + alpha)
                new_rx = rrx
                adjust_kind = 'tx'

        # Apply tentatively
        if adjust_kind == 'tx':
            result[top_if]['tx_rate'] = (otx, new_tx, tc)
        else:
            result[top_if]['rx_rate'] = (orx, new_rx, rc)

        resid_after = compute_router_resid_local(r)
        post_internal = abs(new_tx - new_rx) / max(1.0, max(new_tx, new_rx))

        # Commit only if improves residual >=8% and internal imbalance doesn't worsen by >3% relative
        if resid_after <= (1.0 - 0.08) * resid_frac and post_internal <= pre_internal + 0.03:
            # Reduce confidence to reflect heuristic adjustment
            if adjust_kind == 'tx':
                new_conf = min(tc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['tx_rate'] = (otx, new_tx, clamp(new_conf))
            else:
                new_conf = min(rc, 0.6 + 0.2 * (alpha / 0.02))
                result[top_if]['rx_rate'] = (orx, new_rx, clamp(new_conf))
        else:
            # Revert
            result[top_if]['tx_rate'] = (otx, rtx, tc)
            result[top_if]['rx_rate'] = (orx, rrx, rc)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Recompute per-router residual mismatch from possibly adjusted values
    router_resid: Dict[str, float] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in result:
                sum_tx += float(result[if_id]['tx_rate'][1])
                sum_rx += float(result[if_id]['rx_rate'][1])
        denom = max(1.0, sum_tx, sum_rx)
        router_resid[r] = abs(sum_tx - sum_rx) / denom
=======
    # Recompute per-router residual mismatch from possibly adjusted values
    router_resid: Dict[str, float] = {}
    router_sum_tx: Dict[str, float] = {}
    router_sum_rx: Dict[str, float] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in result:
                sum_tx += float(result[if_id]['tx_rate'][1])
                sum_rx += float(result[if_id]['rx_rate'][1])
        denom = max(1.0, sum_tx, sum_rx)
        router_resid[r] = abs(sum_tx - sum_rx) / denom
        router_sum_tx[r] = sum_tx
        router_sum_rx[r] = sum_rx
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.5, 1.0)

        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']
=======
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        ost, rst, sc = result[if_id]['interface_status']

        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        # Share-aware, direction-coupled penalties
        sum_tx_local = router_sum_tx.get(lr, 0.0)
        sum_rx_local = router_sum_rx.get(lr, 0.0)
        tx_share = rtx / max(1.0, sum_tx_local)
        rx_share = rrx / max(1.0, sum_rx_local)
        penalty_tx = clamp(1.0 - ((0.6 + 0.2 * tx_share) * resid_local + (0.4 - 0.2 * tx_share) * resid_remote), 0.5, 1.0)
        penalty_rx = clamp(1.0 - ((0.6 + 0.2 * rx_share) * resid_local + (0.4 - 0.2 * rx_share) * resid_remote), 0.5, 1.0)
>>>>>>> REPLACE
</DIFF>