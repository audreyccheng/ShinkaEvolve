--- a/original.py
+++ b/original.py
@@ -1,371 +1,448 @@
 # EVOLVE-BLOCK-START
 """
-Network telemetry repair algorithm that detects and corrects inconsistencies
-in network interface telemetry data using topology relationships.
-
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
+Staged consensus repair for network telemetry with magnitude-aware symmetry,
+partial averaging, direction-aware confidence, and micro-adjustments for
+dominating dangling interfaces.
+
+Stages:
+  1) Signal collection and pair indexing
+  2) Pairwise hardening (R3 + status harmonization)
+  3) Dangling interface handling
+  4) Router residual computation (R1)
+  5) Micro-adjustments on dominating dangling interfaces
+  6) Final confidence calibration and assembly
 """
 from typing import Dict, Any, Tuple, List
 import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
-    """
-    Repair network interface telemetry by detecting and correcting inconsistencies.
-
-    Core principle: Use network invariants to validate and repair telemetry:
-    1. Link Symmetry (R3): my_tx_rate ≈ their_rx_rate for connected interfaces
-    2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
-    3. Interface Consistency: Status should be consistent across connected pairs
-
-    Args:
-        telemetry: Dictionary where key is interface_id and value contains:
-            - interface_status: "up" or "down"
-            - rx_rate: receive rate in Mbps
-            - tx_rate: transmit rate in Mbps
-            - connected_to: interface_id this interface connects to
-            - local_router: router_id this interface belongs to
-            - remote_router: router_id on the other side
-        topology: Dictionary where key is router_id and value contains a list of interface_ids
-
-    Returns:
-        Dictionary with same structure but telemetry values become tuples of:
-        (original_value, repaired_value, confidence_score)
-        where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
-    """
-    # Measurement timing tolerance (from Hodor research: ~2%). Magnitude-aware refinements below.
-    HARDENING_THRESHOLD = 0.02  # default τh
-    EPS = 1e-6  # small absolute tolerance for "no traffic"
-    # Magnitude-aware parameters
-    LOW_RATE_MAX = 10.0          # Mbps: below this, allow 5% tolerance
-    ELEVATED_THRESHOLD = 0.05    # 5% tolerance for low-rate links
-    ABS_DIFF_GUARD = 0.5         # Mbps: require abs diff > 0.5 to trigger averaging
-    STRONG_AGREE_DIFF = 0.005    # 0.5%: strong agreement floor
-
-    def norm_diff(a: float, b: float) -> float:
+    # ---------------------------
+    # Configuration parameters
+    # ---------------------------
+    # Symmetry hardening thresholds
+    TH_REL_DEFAULT = 0.02      # 2% default
+    TH_REL_LOW = 0.05          # 5% for low-rate links
+    LOW_RATE_MAX = 10.0        # Mbps threshold for "low" rate
+    STRONG_AGREE_DIFF = 0.005  # 0.5% strong agreement floor
+    ABS_DIFF_GUARD = 0.5       # Mbps absolute minimum to trigger averaging
+    EPS = 1e-6                 # for "no traffic" detection and numeric safety
+
+    # Router residual penalties (direction-aware)
+    TX_LOCAL_W = 0.6
+    TX_REMOTE_W = 0.4
+    RX_LOCAL_W = 0.4
+    RX_REMOTE_W = 0.6
+
+    # Micro-adjustments for dominating dangling interfaces
+    RESIDUAL_ACTIVATE = TH_REL_DEFAULT  # activate nudges when residual > 2%
+    MICRO_MAX_CHANGE = 0.02             # cap change at 2% of the adjusted counter
+    MICRO_SCALE = 0.5                   # α = min(0.02, 0.5 * resid)
+    MICRO_SHARE_GUARD = 0.5             # candidate's counter must be ≥ 50% of absolute imbalance
+
+    # ---------------------------
+    # Helper functions
+    # ---------------------------
+    def to_float(x: Any) -> float:
+        try:
+            return float(x)
+        except Exception:
+            return 0.0
+
+    def clamp01(x: float) -> float:
+        return max(0.0, min(1.0, float(x)))
+
+    def has_traffic(d: Dict[str, Any]) -> bool:
+        return (to_float(d.get('rx_rate', 0.0)) > EPS) or (to_float(d.get('tx_rate', 0.0)) > EPS)
+
+    def rel_diff(a: float, b: float) -> float:
         return abs(a - b) / max(a, b, 1.0)
 
     def dynamic_tau(a: float, b: float) -> float:
-        # Raise tolerance for low-rate signals to avoid over-correcting noise
-        return ELEVATED_THRESHOLD if max(a, b) < LOW_RATE_MAX else HARDENING_THRESHOLD
-
-    def has_traffic(d: Dict[str, Any]) -> bool:
-        return (float(d.get('rx_rate', 0.0)) > EPS) or (float(d.get('tx_rate', 0.0)) > EPS)
-
-    # Build link pairs (unique, undirected)
-    pairs = {}  # key: tuple(sorted(if1, if2)) -> (if1_id, if2_id)
+        return TH_REL_LOW if max(a, b) < LOW_RATE_MAX else TH_REL_DEFAULT
+
+    # ---------------------------
+    # Stage 1: Build link pairs
+    # ---------------------------
+    # Create unique undirected pairs keyed by sorted tuple; maintain set of paired members
+    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
+    paired_members: set = set()
     for if_id, data in telemetry.items():
         peer = data.get('connected_to')
         if peer and peer in telemetry:
             key = tuple(sorted([if_id, peer]))
             if key not in pairs:
                 pairs[key] = (if_id, peer)
-
-    # First pass: pairwise hardening and status harmonization using link symmetry
-    per_if_repair = {}  # interface_id -> interim repaired values and base confidences
+                paired_members.add(if_id)
+                paired_members.add(peer)
+
+    # ---------------------------
+    # Stage 2: Pairwise hardening
+    # ---------------------------
+    per_if: Dict[str, Dict[str, Any]] = {}
 
     for _, (a_id, b_id) in pairs.items():
         a = telemetry[a_id]
         b = telemetry[b_id]
 
-        a_status = a.get('interface_status', 'unknown')
-        b_status = b.get('interface_status', 'unknown')
-
-        a_rx, a_tx = float(a.get('rx_rate', 0.0) or 0.0), float(a.get('tx_rate', 0.0) or 0.0)
-        b_rx, b_tx = float(b.get('rx_rate', 0.0) or 0.0), float(b.get('tx_rate', 0.0) or 0.0)
-
-        # Flags used later for status confidence boost on very strong agreement
+        a_stat = a.get('interface_status', 'unknown')
+        b_stat = b.get('interface_status', 'unknown')
+
+        a_rx, a_tx = to_float(a.get('rx_rate', 0.0)), to_float(a.get('tx_rate', 0.0))
+        b_rx, b_tx = to_float(b.get('rx_rate', 0.0)), to_float(b.get('tx_rate', 0.0))
+
+        a_has = has_traffic(a)
+        b_has = has_traffic(b)
+
+        # Pair status via consistency + traffic evidence
+        if a_stat == 'down' and b_stat == 'down':
+            pair_status = 'down'
+        elif a_stat == 'up' and b_stat == 'up':
+            pair_status = 'up'
+        else:
+            pair_status = 'up' if (a_has or b_has) else 'down'
+
+        # Initialize repaired values with originals
+        rep_a_rx, rep_a_tx = a_rx, a_tx
+        rep_b_rx, rep_b_tx = b_rx, b_tx
+        rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = 1.0
+
         strong_agree_any = False
         strong_agree_high = False
 
-        # Decide pair status using interface consistency + traffic evidence
-        a_has = has_traffic(a)
-        b_has = has_traffic(b)
-
-        if a_status == 'down' and b_status == 'down':
-            pair_status = 'down'
-        elif a_status == 'up' and b_status == 'up':
-            pair_status = 'up'
-        else:
-            # Mismatch: if any traffic exists on either end, consider link up; otherwise down
-            pair_status = 'up' if (a_has or b_has) else 'down'
-
-        # Initialize with originals
-        rep_a_tx, rep_b_rx = a_tx, b_rx
-        rep_b_tx, rep_a_rx = b_tx, a_rx
-        rx_conf_a = 1.0
-        tx_conf_a = 1.0
-        rx_conf_b = 1.0
-        tx_conf_b = 1.0
-
         if pair_status == 'down':
-            # No traffic on a down link
-            rep_a_tx, rep_b_rx, rep_b_tx, rep_a_rx = 0.0, 0.0, 0.0, 0.0
-            # Confidence is high if there was no traffic observed; otherwise moderate
+            # Enforce no traffic
+            rep_a_rx = rep_a_tx = rep_b_rx = rep_b_tx = 0.0
             base_conf = 0.95 if not (a_has or b_has) else 0.7
             rx_conf_a = tx_conf_a = rx_conf_b = tx_conf_b = base_conf
         else:
-            # Link is up: enforce link symmetry with hardening threshold (magnitude-aware)
-            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
-            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx
-
+            # Direction A->B: A.tx vs B.rx
+            d_ab = rel_diff(a_tx, b_rx)
             tau_ab = dynamic_tau(a_tx, b_rx)
-            tau_ba = dynamic_tau(b_tx, a_rx)
-
             abs_ab = abs(a_tx - b_rx)
-            abs_ba = abs(b_tx - a_rx)
-
-            # Partial averaging just above threshold for A->B
-            if (diff_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
+            if (d_ab > tau_ab) and (abs_ab > ABS_DIFF_GUARD):
                 avg_ab = 0.5 * (a_tx + b_rx)
-                if diff_ab <= 2.0 * tau_ab:
-                    k = (diff_ab - tau_ab) / max(tau_ab, 1e-9)
+                if d_ab <= 2.0 * tau_ab:
+                    k = (d_ab - tau_ab) / max(tau_ab, 1e-9)
                     rep_a_tx = a_tx * (1.0 - k) + avg_ab * k
                     rep_b_rx = b_rx * (1.0 - k) + avg_ab * k
                 else:
-                    rep_a_tx = avg_ab
-                    rep_b_rx = avg_ab
-            conf_ab = max(0.0, 1.0 - diff_ab)
-            # Confidence floors based on agreement strength and magnitude
-            if diff_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
+                    rep_a_tx = rep_b_rx = avg_ab
+            conf_ab = max(0.0, 1.0 - d_ab)
+            # In-tolerance floors
+            if d_ab <= STRONG_AGREE_DIFF and max(a_tx, b_rx) >= LOW_RATE_MAX:
                 conf_ab = max(conf_ab, 0.99)
-            elif diff_ab <= tau_ab:
+            elif d_ab <= tau_ab:
                 conf_ab = max(conf_ab, 0.98 if max(a_tx, b_rx) >= LOW_RATE_MAX else 0.97)
-            tx_conf_a = min(1.0, conf_ab)
-            rx_conf_b = min(1.0, conf_ab)
-
-            # Partial averaging just above threshold for B->A
-            if (diff_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
+            tx_conf_a = min(tx_conf_a, conf_ab)
+            rx_conf_b = min(rx_conf_b, conf_ab)
+
+            # Direction B->A: B.tx vs A.rx
+            d_ba = rel_diff(b_tx, a_rx)
+            tau_ba = dynamic_tau(b_tx, a_rx)
+            abs_ba = abs(b_tx - a_rx)
+            if (d_ba > tau_ba) and (abs_ba > ABS_DIFF_GUARD):
                 avg_ba = 0.5 * (b_tx + a_rx)
-                if diff_ba <= 2.0 * tau_ba:
-                    k = (diff_ba - tau_ba) / max(tau_ba, 1e-9)
-                    rep_b_tx = b_tx * (1.0 - k) + avg_ba * k
-                    rep_a_rx = a_rx * (1.0 - k) + avg_ba * k
+                if d_ba <= 2.0 * tau_ba:
+                    k2 = (d_ba - tau_ba) / max(tau_ba, 1e-9)
+                    rep_b_tx = b_tx * (1.0 - k2) + avg_ba * k2
+                    rep_a_rx = a_rx * (1.0 - k2) + avg_ba * k2
                 else:
-                    rep_b_tx = avg_ba
-                    rep_a_rx = avg_ba
-            conf_ba = max(0.0, 1.0 - diff_ba)
-            if diff_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
+                    rep_b_tx = rep_a_rx = avg_ba
+            conf_ba = max(0.0, 1.0 - d_ba)
+            if d_ba <= STRONG_AGREE_DIFF and max(b_tx, a_rx) >= LOW_RATE_MAX:
                 conf_ba = max(conf_ba, 0.99)
-            elif diff_ba <= tau_ba:
+            elif d_ba <= tau_ba:
                 conf_ba = max(conf_ba, 0.98 if max(b_tx, a_rx) >= LOW_RATE_MAX else 0.97)
-            tx_conf_b = min(1.0, conf_ba)
-            rx_conf_a = min(1.0, conf_ba)
-
-            # Track very strong agreement for later status boost and harmonization
-            strong_agree_any = (diff_ab <= STRONG_AGREE_DIFF) and (diff_ba <= STRONG_AGREE_DIFF)
+            tx_conf_b = min(tx_conf_b, conf_ba)
+            rx_conf_a = min(rx_conf_a, conf_ba)
+
+            strong_agree_any = (d_ab <= STRONG_AGREE_DIFF) and (d_ba <= STRONG_AGREE_DIFF)
             strong_agree_high = strong_agree_any and (max(a_tx, b_rx, b_tx, a_rx) >= LOW_RATE_MAX)
 
-            # Asymmetric confidence when only one side shows traffic
-            if (a_has != b_has):
+            # Asymmetric assignment when "up" is evidence-driven and only one side has traffic
+            if a_has != b_has:
                 if not a_has:
                     rx_conf_a *= 0.88
                     tx_conf_a *= 0.88
                 if not b_has:
                     rx_conf_b *= 0.88
                     tx_conf_b *= 0.88
 
-            # Harmonize pairwise confidences on very strong symmetry using geometric means
+            # Harmonize confidences on very strong agreement via geometric means
             if strong_agree_any:
-                gm_ab = math.sqrt(max(0.0, tx_conf_a) * max(0.0, rx_conf_b))
-                gm_ba = math.sqrt(max(0.0, tx_conf_b) * max(0.0, rx_conf_a))
+                gm_ab = math.sqrt(clamp01(tx_conf_a) * clamp01(rx_conf_b))
+                gm_ba = math.sqrt(clamp01(tx_conf_b) * clamp01(rx_conf_a))
                 tx_conf_a = rx_conf_b = min(1.0, gm_ab)
                 tx_conf_b = rx_conf_a = min(1.0, gm_ba)
 
-        # Status confidence based on agreement and evidence
+        # Status confidence
         if pair_status == 'down':
-            if a_status == 'down' and b_status == 'down' and not (a_has or b_has):
+            if a_stat == 'down' and b_stat == 'down' and not (a_has or b_has):
                 status_conf = 0.98
             else:
                 status_conf = 0.7
-        else:  # up
-            if a_status == 'up' and b_status == 'up':
+        else:
+            if a_stat == 'up' and b_stat == 'up':
                 status_conf = 0.95
             else:
-                # we decided up due to traffic evidence
                 status_conf = 0.8
-            # Boost status confidence when both directions are in very strong agreement
             if strong_agree_high:
                 status_conf = max(status_conf, 0.99)
             elif strong_agree_any:
                 status_conf = max(status_conf, 0.97)
 
-        # Confidence refinement: penalize by magnitude of applied change
-        # This improves calibration by lowering confidence when we make large adjustments.
+        # Calibration refinement: penalize by own change magnitude
         def change_ratio(orig: float, rep: float) -> float:
             denom = max(abs(orig), abs(rep), 1.0)
             return abs(rep - orig) / denom
 
         a_rx_change = change_ratio(a_rx, rep_a_rx)
         a_tx_change = change_ratio(a_tx, rep_a_tx)
         b_rx_change = change_ratio(b_rx, rep_b_rx)
         b_tx_change = change_ratio(b_tx, rep_b_tx)
 
-        rx_conf_a = max(0.0, min(1.0, min(rx_conf_a, 1.0 - a_rx_change)))
-        tx_conf_a = max(0.0, min(1.0, min(tx_conf_a, 1.0 - a_tx_change)))
-        rx_conf_b = max(0.0, min(1.0, min(rx_conf_b, 1.0 - b_rx_change)))
-        tx_conf_b = max(0.0, min(1.0, min(tx_conf_b, 1.0 - b_tx_change)))
-
-        per_if_repair[a_id] = {
+        rx_conf_a = clamp01(min(rx_conf_a, 1.0 - a_rx_change))
+        tx_conf_a = clamp01(min(tx_conf_a, 1.0 - a_tx_change))
+        rx_conf_b = clamp01(min(rx_conf_b, 1.0 - b_rx_change))
+        tx_conf_b = clamp01(min(tx_conf_b, 1.0 - b_tx_change))
+
+        per_if[a_id] = {
             'repaired_rx': rep_a_rx,
             'repaired_tx': rep_a_tx,
             'rx_conf': rx_conf_a,
             'tx_conf': tx_conf_a,
             'repaired_status': pair_status,
             'status_conf': status_conf
         }
-        per_if_repair[b_id] = {
+        per_if[b_id] = {
             'repaired_rx': rep_b_rx,
             'repaired_tx': rep_b_tx,
             'rx_conf': rx_conf_b,
             'tx_conf': tx_conf_b,
             'repaired_status': pair_status,
             'status_conf': status_conf
         }
 
-    # Handle interfaces without a valid peer (dangling or missing peer data)
+    # ---------------------------
+    # Stage 3: Dangling interfaces
+    # ---------------------------
     for if_id, data in telemetry.items():
-        if if_id in per_if_repair:
+        if if_id in per_if:
             continue
         status = data.get('interface_status', 'unknown')
-        rx = float(data.get('rx_rate', 0.0) or 0.0)
-        tx = float(data.get('tx_rate', 0.0) or 0.0)
+        rx = to_float(data.get('rx_rate', 0.0))
+        tx = to_float(data.get('tx_rate', 0.0))
         if status == 'down':
             # Enforce no traffic on down interfaces
-            per_if_repair[if_id] = {
+            per_if[if_id] = {
                 'repaired_rx': 0.0,
                 'repaired_tx': 0.0,
                 'rx_conf': 0.9,
                 'tx_conf': 0.9,
                 'repaired_status': 'down',
                 'status_conf': 0.95
             }
         else:
-            # No peer to cross-check; keep values but lower confidence slightly.
-            per_if_repair[if_id] = {
+            # No redundant peer; keep values with moderate confidence
+            per_if[if_id] = {
                 'repaired_rx': rx,
                 'repaired_tx': tx,
                 'rx_conf': 0.6,
                 'tx_conf': 0.6,
                 'repaired_status': status if status in ('up', 'down') else 'up',
                 'status_conf': 0.6
             }
 
-    # Second pass: compute router-level flow conservation residuals using repaired rates
+    # ---------------------------
+    # Stage 4: Router residuals
+    # ---------------------------
     router_residual: Dict[str, float] = {}
+    router_sums: Dict[str, Tuple[float, float]] = {}
     for router, if_list in topology.items():
-        sum_tx = 0.0
-        sum_rx = 0.0
-        for if_id in if_list:
-            if if_id in per_if_repair:
-                rep = per_if_repair[if_id]
-                # Include all interfaces; down interfaces contribute 0 traffic (already enforced)
-                sum_tx += float(rep['repaired_tx'])
-                sum_rx += float(rep['repaired_rx'])
-        resid = abs(sum_tx - sum_rx) / max(sum_tx, sum_rx, 1.0)
+        s_tx = 0.0
+        s_rx = 0.0
+        for iid in if_list:
+            if iid in per_if:
+                rep = per_if[iid]
+                s_tx += to_float(rep['repaired_tx'])
+                s_rx += to_float(rep['repaired_rx'])
+        resid = abs(s_tx - s_rx) / max(s_tx, s_rx, 1.0)
         router_residual[router] = resid
-
-    # Final assembly: scale confidences by router residuals (dynamic checking)
+        router_sums[router] = (s_tx, s_rx)
+
+    # ---------------------------
+    # Stage 5: Micro-adjustments on dominating dangling interfaces
+    # ---------------------------
+    # Only adjust if residual is non-trivial and one dangling interface dominates imbalance.
+    for router, if_list in topology.items():
+        resid = router_residual.get(router, 0.0)
+        if resid <= RESIDUAL_ACTIVATE:
+            continue
+        s_tx, s_rx = router_sums.get(router, (0.0, 0.0))
+        imbalance = s_tx - s_rx
+        if abs(imbalance) < EPS:
+            continue
+        # Candidate set: unpaired, up interfaces on this router
+        candidates: List[str] = []
+        for iid in if_list:
+            if iid in per_if:
+                if iid not in paired_members and per_if[iid].get('repaired_status', 'up') == 'up':
+                    candidates.append(iid)
+        if not candidates:
+            continue
+
+        # Direction of imbalance
+        tx_excess = imbalance > 0.0  # True if Σtx > Σrx (need to reduce tx or increase rx)
+        # Pick candidate with largest relevant counter
+        best_iid = None
+        best_val = -1.0
+        for iid in candidates:
+            rep = per_if[iid]
+            val = to_float(rep['repaired_tx']) if tx_excess else to_float(rep['repaired_rx'])
+            if val > best_val:
+                best_val = val
+                best_iid = iid
+
+        if best_iid is None or best_val <= 0.0:
+            continue
+
+        # Require candidate to account for at least 50% of the absolute imbalance
+        if best_val < MICRO_SHARE_GUARD * abs(imbalance):
+            continue
+
+        # Compute nudge factor α
+        alpha = min(MICRO_MAX_CHANGE, MICRO_SCALE * resid)
+        if alpha <= 0.0:
+            continue
+
+        # Apply micro-adjustment to only the larger counter on the candidate toward reducing imbalance
+        rep = per_if[best_iid]
+        rx_v = to_float(rep['repaired_rx'])
+        tx_v = to_float(rep['repaired_tx'])
+        # Choose the larger counter to adjust
+        if tx_v >= rx_v:
+            # Larger is tx
+            if tx_excess:
+                # Reduce tx to reduce imbalance
+                new_tx = tx_v * (1.0 - alpha)
+                rep['repaired_tx'] = new_tx
+                # modest confidence improvement for this direction
+                rep['tx_conf'] = clamp01(rep.get('tx_conf', 0.6) + 0.2 * (alpha / MICRO_MAX_CHANGE))
+            else:
+                # Imbalance is rx excess; reduce rx even though tx is larger to respect rule "only larger counter"
+                new_rx = rx_v * (1.0 - alpha)
+                rep['repaired_rx'] = new_rx
+                rep['rx_conf'] = clamp01(rep.get('rx_conf', 0.6) + 0.2 * (alpha / MICRO_MAX_CHANGE))
+        else:
+            # Larger is rx
+            if not tx_excess:
+                # Reduce rx to reduce imbalance
+                new_rx = rx_v * (1.0 - alpha)
+                rep['repaired_rx'] = new_rx
+                rep['rx_conf'] = clamp01(rep.get('rx_conf', 0.6) + 0.2 * (alpha / MICRO_MAX_CHANGE))
+            else:
+                # Imbalance is tx excess; reduce tx even though rx is larger to respect rule "only larger counter"
+                new_tx = tx_v * (1.0 - alpha)
+                rep['repaired_tx'] = new_tx
+                rep['tx_conf'] = clamp01(rep.get('tx_conf', 0.6) + 0.2 * (alpha / MICRO_MAX_CHANGE))
+
+        per_if[best_iid] = rep  # write back
+
+    # ---------------------------
+    # Stage 6: Final assembly with direction-aware penalties
+    # ---------------------------
     result: Dict[str, Dict[str, Tuple]] = {}
     for if_id, data in telemetry.items():
-        repaired = per_if_repair.get(if_id, {})
-        repaired_rx = repaired.get('repaired_rx', float(data.get('rx_rate', 0.0) or 0.0))
-        repaired_tx = repaired.get('repaired_tx', float(data.get('tx_rate', 0.0) or 0.0))
-        repaired_status = repaired.get('repaired_status', data.get('interface_status', 'unknown'))
-
-        # Base confidences from link hardening
-        rx_conf = float(repaired.get('rx_conf', 0.6))
-        tx_conf = float(repaired.get('tx_conf', 0.6))
-        status_conf = float(repaired.get('status_conf', 0.6))
-
-        # Apply router-based penalty using both local and remote routers when available
+        rep = per_if.get(if_id, {})
+        repaired_rx = to_float(rep.get('repaired_rx', data.get('rx_rate', 0.0)))
+        repaired_tx = to_float(rep.get('repaired_tx', data.get('tx_rate', 0.0)))
+        repaired_status = rep.get('repaired_status', data.get('interface_status', 'unknown'))
+
+        rx_conf = float(rep.get('rx_conf', 0.6))
+        tx_conf = float(rep.get('tx_conf', 0.6))
+        status_conf = float(rep.get('status_conf', 0.6))
+
         local_router = data.get('local_router')
         remote_router = data.get('remote_router')
-
         resid_local = router_residual.get(local_router, 0.0)
         resid_remote = router_residual.get(remote_router, 0.0)
 
-        # Direction-aware dynamic checking penalties
-        def clamp01(x: float) -> float:
-            return max(0.0, min(1.0, float(x)))
-
-        pen_tx = clamp01(1.0 - (0.6 * resid_local + 0.4 * resid_remote))
-        pen_rx = clamp01(1.0 - (0.6 * resid_remote + 0.4 * resid_local))
-
+        # Direction-aware penalties
+        pen_tx = clamp01(1.0 - (TX_LOCAL_W * resid_local + TX_REMOTE_W * resid_remote))
+        pen_rx = clamp01(1.0 - (RX_LOCAL_W * resid_local + RX_REMOTE_W * resid_remote))
+        tx_conf = clamp01(tx_conf * pen_tx)
         rx_conf = clamp01(rx_conf * pen_rx)
-        tx_conf = clamp01(tx_conf * pen_tx)
-        # Status confidence: mild scaling using the weaker of the two directional penalties
+        # Status mild scaling using the weaker direction penalty
         status_conf = clamp01(status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx)))
 
-        repaired_data: Dict[str, Any] = {}
-        # Store repaired values with confidence scores
-        rx_orig = float(data.get('rx_rate', 0.0) or 0.0)
-        tx_orig = float(data.get('tx_rate', 0.0) or 0.0)
+        out: Dict[str, Any] = {}
+        rx_orig = to_float(data.get('rx_rate', 0.0))
+        tx_orig = to_float(data.get('tx_rate', 0.0))
         status_orig = data.get('interface_status', 'unknown')
 
-        repaired_data['rx_rate'] = (rx_orig, repaired_rx, rx_conf)
-        repaired_data['tx_rate'] = (tx_orig, repaired_tx, tx_conf)
-        repaired_data['interface_status'] = (status_orig, repaired_status, status_conf)
+        out['rx_rate'] = (rx_orig, repaired_rx, rx_conf)
+        out['tx_rate'] = (tx_orig, repaired_tx, tx_conf)
+        out['interface_status'] = (status_orig, repaired_status, status_conf)
 
         # Copy metadata unchanged
-        repaired_data['connected_to'] = data.get('connected_to')
-        repaired_data['local_router'] = local_router
-        repaired_data['remote_router'] = remote_router
-
-        result[if_id] = repaired_data
+        out['connected_to'] = data.get('connected_to')
+        out['local_router'] = local_router
+        out['remote_router'] = remote_router
+
+        result[if_id] = out
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")