<NAME>
magnitude_aware_pair_and_safe_router_microadjust
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy while preserving status accuracy and improving confidence calibration:

1) Magnitude-aware pair repair with absolute guard and partial averaging:
   - Replace the fixed 2% threshold with magnitude-aware thresholds (2% for ≥10 Mbps, 5% for <10 Mbps) and a 0.5 Mbps absolute guard.
   - Use partial averaging when just beyond threshold (T < diff ≤ 2T) to avoid over-correction.
   - Apply stronger confidence floors on clear high-rate agreement.
   This reduces unnecessary changes on low-rate links and improves accuracy on high-rate links.

2) Improvement-checked micro-adjustments for router flow conservation:
   - Replace the proportional distribution across all dangling interfaces with a single, dominance-tested, small nudge (≤2% of router scale).
   - Only adjust when router residual ≥3% and the dominant dangling interface contributes >60% of dangling traffic.
   - Commit only if the router residual improves by at least 10% relative; otherwise skip.
   This avoids harmful over-corrections and improves calibration by tying changes to measurable residual improvements.

3) Direction-aware dynamic confidence penalties:
   - Replace the symmetric final confidence penalty with direction-aware penalties (TX penalized by local residual more, RX by remote residual more), and scale status by the weaker direction.
   This better aligns confidence with directional conservation quality.

These changes focus on leaving good telemetry untouched, making bounded repairs where justified, and emitting calibrated confidences.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    EPS = 1e-6  # small absolute tolerance for "no traffic"
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02  # base 2% timing tolerance
    # Magnitude-aware tolerances and guards to avoid over-correcting tiny flows
    TH_REL_DEFAULT = 0.02   # 2% for normal/high-rate links
    TH_REL_LOW = 0.05       # 5% for low-rate links (<10 Mbps)
    TH_ABS_GUARD = 0.5      # 0.5 Mbps absolute guard before averaging
    LOW_RATE_MAX = 10.0     # threshold between low/high-rate
    STRONG_AGREE_DIFF = 0.005  # 0.5% strong agreement floor
    EPS = 1e-6  # small absolute tolerance for "no traffic"
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        else:
            # Link is up: enforce link symmetry with hardening threshold
            diff_ab = norm_diff(a_tx, b_rx)  # A.tx vs B.rx
            diff_ba = norm_diff(b_tx, a_rx)  # B.tx vs A.rx

            if diff_ab > HARDENING_THRESHOLD:
                avg_ab = 0.5 * (a_tx + b_rx)
                rep_a_tx = avg_ab
                rep_b_rx = avg_ab
            conf_ab = max(0.0, 1.0 - diff_ab)
            if diff_ab <= HARDENING_THRESHOLD:
                conf_ab = min(1.0, max(conf_ab, 0.98))
            tx_conf_a = conf_ab
            rx_conf_b = conf_ab

            if diff_ba > HARDENING_THRESHOLD:
                avg_ba = 0.5 * (b_tx + a_rx)
                rep_b_tx = avg_ba
                rep_a_rx = avg_ba
            conf_ba = max(0.0, 1.0 - diff_ba)
            if diff_ba <= HARDENING_THRESHOLD:
                conf_ba = min(1.0, max(conf_ba, 0.98))
            tx_conf_b = conf_ba
            rx_conf_a = conf_ba
=======
        else:
            # Link is up: enforce link symmetry with magnitude-aware thresholds and absolute guard
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < LOW_RATE_MAX else TH_REL_DEFAULT
            d_ab = norm_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)

            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
                # Repair by consensus average with partial averaging near threshold
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= 2.0 * thr_rel_ab:
                    k = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + v * k
                    rep_b_rx = b_rx * (1.0 - k) + v * k
                else:
                    rep_a_tx = v
                    rep_b_rx = v
            # Confidence floors and violation-based reduction
            conf_ab = max(0.0, 1.0 - d_ab)
            if max_ab >= LOW_RATE_MAX and d_ab <= STRONG_AGREE_DIFF:
                conf_ab = max(conf_ab, 0.99)
            elif d_ab <= thr_rel_ab:
                conf_ab = max(conf_ab, 0.98 if max_ab >= LOW_RATE_MAX else 0.97)
            tx_conf_a = min(1.0, conf_ab)
            rx_conf_b = min(1.0, conf_ab)

            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < LOW_RATE_MAX else TH_REL_DEFAULT
            d_ba = norm_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)

            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= 2.0 * thr_rel_ba:
                    k2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + v2 * k2
                    rep_a_rx = a_rx * (1.0 - k2) + v2 * k2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
            conf_ba = max(0.0, 1.0 - d_ba)
            if max_ba >= LOW_RATE_MAX and d_ba <= STRONG_AGREE_DIFF:
                conf_ba = max(conf_ba, 0.99)
            elif d_ba <= thr_rel_ba:
                conf_ba = max(conf_ba, 0.98 if max_ba >= LOW_RATE_MAX else 0.97)
            tx_conf_b = min(1.0, conf_ba)
            rx_conf_a = min(1.0, conf_ba)

            # Asymmetric confidence reduction when only one side has traffic evidence
            if a_has != b_has:
                if not a_has:
                    rx_conf_a *= 0.88
                    tx_conf_a *= 0.88
                if not b_has:
                    rx_conf_b *= 0.88
                    tx_conf_b *= 0.88
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    # Router-level balancing using dangling interfaces to satisfy flow conservation (R1)
    # We only adjust interfaces without a known peer to avoid breaking link symmetry.
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        sum_tx = 0.0
        sum_rx = 0.0
        present = [iid for iid in if_list if iid in per_if_repair]
        if not present:
            continue
        for iid in present:
            rep = per_if_repair[iid]
            sum_tx += float(rep['repaired_tx'])
            sum_rx += float(rep['repaired_rx'])
        scale = max(sum_tx, sum_rx, 1.0)
        delta = sum_tx - sum_rx  # want delta -> 0

        # Skip tiny imbalances within tolerance
        if abs(delta) <= HARDENING_THRESHOLD * scale:
            continue

        # Candidate interfaces for adjustment: dangling and up
        dangling = [iid for iid in present
                    if (iid not in paired_ids) and (per_if_repair[iid].get('repaired_status', 'up') != 'down')]

        if not dangling:
            continue

        # Distribute correction proportionally to traffic magnitude to minimize relative change
        weights = []
        sum_w = 0.0
        for iid in dangling:
            rep = per_if_repair[iid]
            w = float(rep['repaired_tx']) + float(rep['repaired_rx']) + EPS
            weights.append((iid, w))
            sum_w += w
        if sum_w <= 0.0:
            sum_w = EPS * len(dangling)
            weights = [(iid, EPS) for iid in dangling]

        if delta > 0.0:
            # Too much TX; increase RX on dangling interfaces
            for iid, w in weights:
                inc = delta * (w / sum_w)
                new_rx = float(per_if_repair[iid]['repaired_rx']) + inc
                per_if_repair[iid]['repaired_rx'] = new_rx
                # Confidence: penalize by change magnitude from original observation
                rx_orig = float(telemetry.get(iid, {}).get('rx_rate', 0.0) or 0.0)
                cr = change_ratio(rx_orig, new_rx)
                per_if_repair[iid]['rx_conf'] = max(0.0, min(float(per_if_repair[iid].get('rx_conf', 0.6)), 1.0 - cr))
        else:
            # Too much RX; increase TX on dangling interfaces
            need = -delta
            for iid, w in weights:
                inc = need * (w / sum_w)
                new_tx = float(per_if_repair[iid]['repaired_tx']) + inc
                per_if_repair[iid]['repaired_tx'] = new_tx
                tx_orig = float(telemetry.get(iid, {}).get('tx_rate', 0.0) or 0.0)
                cr = change_ratio(tx_orig, new_tx)
                per_if_repair[iid]['tx_conf'] = max(0.0, min(float(per_if_repair[iid].get('tx_conf', 0.6)), 1.0 - cr))
=======
    # Router-level balancing using dangling interfaces to satisfy flow conservation (R1)
    # We only adjust interfaces without a known peer to avoid breaking link symmetry.
    paired_ids = set()
    for _, (aid, bid) in pairs.items():
        paired_ids.add(aid)
        paired_ids.add(bid)

    for router, if_list in topology.items():
        # Compute current router totals
        sum_tx = 0.0
        sum_rx = 0.0
        present = [iid for iid in if_list if iid in per_if_repair]
        if not present:
            continue
        for iid in present:
            rep = per_if_repair[iid]
            sum_tx += float(rep['repaired_tx'])
            sum_rx += float(rep['repaired_rx'])
        scale = max(sum_tx, sum_rx, 1.0)
        delta = sum_tx - sum_rx  # want delta -> 0
        resid_frac = abs(delta) / scale

        # Stronger trigger: only attempt micro-adjustment for noticeable imbalance (≥3%)
        if resid_frac < 0.03:
            continue

        # Candidate interfaces for adjustment: dangling and up
        dangling = [iid for iid in present
                    if (iid not in paired_ids) and (per_if_repair[iid].get('repaired_status', 'up') != 'down')]

        if not dangling:
            continue

        # Determine dominance among dangling interfaces
        weights = []
        sum_w = 0.0
        for iid in dangling:
            rep = per_if_repair[iid]
            w = float(rep['repaired_tx']) + float(rep['repaired_rx']) + EPS
            weights.append((iid, w))
            sum_w += w
        if sum_w <= 0.0:
            continue  # nothing meaningful to adjust

        # Pick dominant interface and require >60% share among dangling traffic
        dom_iid, dom_w = max(weights, key=lambda x: x[1])
        dom_share = dom_w / max(sum_w, EPS)
        if dom_share <= 0.6:
            continue

        # Tentative nudge capped at 2% of router scale
        alpha = min(0.02 * scale, abs(delta))

        # Compute tentative new residual after the nudge
        if delta > 0.0:
            # Too much TX; increase RX on dominant dangling interface
            new_sum_rx = sum_rx + alpha
            new_sum_tx = sum_tx
            new_delta = new_sum_tx - new_sum_rx
        else:
            # Too much RX; increase TX on dominant dangling interface
            new_sum_tx = sum_tx + alpha
            new_sum_rx = sum_rx
            new_delta = new_sum_tx - new_sum_rx

        new_scale = max(new_sum_tx, new_sum_rx, 1.0)
        new_resid_frac = abs(new_delta) / new_scale

        # Commit only if residual improves by at least 10% relative
        if new_resid_frac <= 0.9 * resid_frac:
            if delta > 0.0:
                new_rx = float(per_if_repair[dom_iid]['repaired_rx']) + alpha
                per_if_repair[dom_iid]['repaired_rx'] = new_rx
                # Confidence: penalize by change magnitude from original observation
                rx_orig = float(telemetry.get(dom_iid, {}).get('rx_rate', 0.0) or 0.0)
                cr = change_ratio(rx_orig, new_rx)
                per_if_repair[dom_iid]['rx_conf'] = max(0.0, min(float(per_if_repair[dom_iid].get('rx_conf', 0.6)), 1.0 - cr))
            else:
                new_tx = float(per_if_repair[dom_iid]['repaired_tx']) + alpha
                per_if_repair[dom_iid]['repaired_tx'] = new_tx
                tx_orig = float(telemetry.get(dom_iid, {}).get('tx_rate', 0.0) or 0.0)
                cr = change_ratio(tx_orig, new_tx)
                per_if_repair[dom_iid]['tx_conf'] = max(0.0, min(float(per_if_repair[dom_iid].get('tx_conf', 0.6)), 1.0 - cr))
        # else: skip adjustment to avoid degrading counters on noise
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        penalty = 1.0 - 0.5 * (resid_local + resid_remote)
        penalty = max(0.0, min(1.0, penalty))

        rx_conf = max(0.0, min(1.0, rx_conf * penalty))
        tx_conf = max(0.0, min(1.0, tx_conf * penalty))
        # Status confidence is less sensitive to flow residuals; apply mild scaling
        status_conf = max(0.0, min(1.0, status_conf * (0.75 + 0.25 * penalty)))
=======
        # Direction-aware dynamic checking penalties: TX weighted by local residual, RX by remote
        pen_tx = 1.0 - (0.6 * resid_local + 0.4 * resid_remote)
        pen_rx = 1.0 - (0.6 * resid_remote + 0.4 * resid_local)
        pen_tx = max(0.0, min(1.0, pen_tx))
        pen_rx = max(0.0, min(1.0, pen_rx))

        rx_conf = max(0.0, min(1.0, rx_conf * pen_rx))
        tx_conf = max(0.0, min(1.0, tx_conf * pen_tx))
        # Status confidence is less sensitive to flow residuals; apply mild scaling using weaker direction
        status_conf = max(0.0, min(1.0, status_conf * (0.85 + 0.15 * min(pen_tx, pen_rx))))
>>>>>>> REPLACE

</DIFF>