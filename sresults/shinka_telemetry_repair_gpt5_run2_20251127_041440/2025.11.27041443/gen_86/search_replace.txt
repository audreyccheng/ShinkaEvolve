<NAME>
residual_tilt_and_asymmetric_pair_averaging
</NAME>

<DESCRIPTION>
I propose improving counter repair accuracy and confidence calibration by enhancing the pairwise hardening step with two mechanisms inspired by the Hodor validation principles and prior program variants:

1) Residual-tilted weighted consensus per direction: When a router’s signed residual suggests a consistent bias (sum_tx − sum_rx), we slightly tilt the pairwise averaging towards the value that reduces the local router's imbalance. This uses redundant router-level information to guide corrections and improves accuracy without overcorrecting.

2) Asymmetric partial averaging: In the partial correction band, move the louder side more than the quieter side, which better reflects realistic measurement bias. At low rates, use slightly steeper ramps and a smaller absolute guard to avoid noise-driven changes.

I also add a low-rate absolute guard (0.3 Mbps) and compute signed router residuals from original telemetry (down interfaces contribute zero) to support residual-tilting. The final confidence penalties remain direction-aware and unchanged, preserving strong calibration.

These changes are targeted: they only affect the pairwise repair step and do not introduce global micro-adjustments, minimizing risk while aiming to raise counter_repair_accuracy and maintain confidence calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Base thresholds
    TH_REL_DEFAULT = 0.02   # 2%
    TH_REL_LOW = 0.05       # 5% for low-rate links
    TH_ABS_GUARD = 0.5      # 0.5 Mbps absolute guard
    EPS = 1e-6
=======
    # Base thresholds
    TH_REL_DEFAULT = 0.02   # 2%
    TH_REL_LOW = 0.05       # 5% for low-rate links
    TH_ABS_GUARD = 0.5      # 0.5 Mbps absolute guard
    ABS_GUARD_LOW = 0.3     # 0.3 Mbps absolute guard for low-rate links
    EPS = 1e-6
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (to_float(d.get('rx_rate', 0.0)) > EPS) or (to_float(d.get('tx_rate', 0.0)) > EPS)

    def rel_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    # Build unique undirected pairs
=======
    def has_traffic(d: Dict[str, Any]) -> bool:
        return (to_float(d.get('rx_rate', 0.0)) > EPS) or (to_float(d.get('tx_rate', 0.0)) > EPS)

    def rel_diff(a: float, b: float) -> float:
        return abs(a - b) / max(a, b, 1.0)

    def clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def sgn(x: float) -> int:
        return 1 if x > 0 else (-1 if x < 0 else 0)

    # Build unique undirected pairs
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Build unique undirected pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
=======
    # Build unique undirected pairs
    pairs: Dict[Tuple[str, str], Tuple[str, str]] = {}
    for if_id, data in telemetry.items():
        peer = data.get('connected_to')
        if peer and peer in telemetry:
            key = tuple(sorted([if_id, peer]))
            if key not in pairs:
                pairs[key] = (if_id, peer)

    # Compute signed router residuals from original telemetry (down links contribute zero)
    resid_signed: Dict[str, float] = {}
    for router, if_list in topology.items():
        s_tx = 0.0
        s_rx = 0.0
        for iid in if_list:
            d = telemetry.get(iid)
            if not d:
                continue
            status = d.get('interface_status', 'unknown')
            tx = to_float(d.get('tx_rate', 0.0))
            rx = to_float(d.get('rx_rate', 0.0))
            if status == 'down':
                tx = 0.0
                rx = 0.0
            s_tx += tx
            s_rx += rx
        scale = max(s_tx, s_rx, 1.0)
        resid_signed[router] = (s_tx - s_rx) / scale if scale > 0 else 0.0

    # First pass: pairwise consensus hardening and status harmonization
    per_if: Dict[str, Dict[str, Any]] = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        else:
            # Magnitude-aware thresholds
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)

            if (d_ab > thr_rel_ab) and (abs_ab > TH_ABS_GUARD):
                # Repair by consensus average with partial averaging near threshold
                v = 0.5 * (a_tx + b_rx)
                if d_ab <= 2.0 * thr_rel_ab:
                    k = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    rep_a_tx = a_tx * (1.0 - k) + v * k
                    rep_b_rx = b_rx * (1.0 - k) + v * k
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                # Confidence decreases with violation magnitude and change magnitude
                change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                conf_base = max(0.0, 1.0 - d_ab)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)

            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)

            if (d_ba > thr_rel_ba) and (abs_ba > TH_ABS_GUARD):
                v2 = 0.5 * (b_tx + a_rx)
                if d_ba <= 2.0 * thr_rel_ba:
                    k2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    rep_b_tx = b_tx * (1.0 - k2) + v2 * k2
                    rep_a_rx = a_rx * (1.0 - k2) + v2 * k2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                conf_base2 = max(0.0, 1.0 - d_ba)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
=======
        else:
            # Magnitude-aware thresholds with residual-tilted consensus and asymmetric partial averaging
            # Direction A->B (A.tx vs B.rx)
            max_ab = max(a_tx, b_rx)
            thr_rel_ab = TH_REL_LOW if max_ab < 10.0 else TH_REL_DEFAULT
            guard_ab = ABS_GUARD_LOW if max_ab < 10.0 else TH_ABS_GUARD
            d_ab = rel_diff(a_tx, b_rx)
            abs_ab = abs(a_tx - b_rx)
            partial_upper_ab = (1.6 * thr_rel_ab) if max_ab < 10.0 else (2.0 * thr_rel_ab)

            if (d_ab > thr_rel_ab) and (abs_ab > guard_ab):
                # Residual-tilted weighted consensus target
                v = 0.5 * (a_tx + b_rx)
                resid_a = resid_signed.get(a.get('local_router'), 0.0)
                if max_ab >= 1.0 and (a_tx - b_rx) != 0.0 and resid_a != 0.0 and (sgn(a_tx - b_rx) == sgn(resid_a)):
                    gamma = min(0.08, 0.1 * abs(resid_a))
                    w_a = clamp(0.5 - gamma, 0.2, 0.8)
                    w_b = 1.0 - w_a
                    v = w_a * a_tx + w_b * b_rx

                if d_ab <= partial_upper_ab:
                    # Asymmetric partial averaging: louder side moves more
                    k_base = (d_ab - thr_rel_ab) / max(thr_rel_ab, 1e-9)
                    k_base = min(1.0, max(0.0, k_base))
                    if max_ab < 10.0:
                        k_base = k_base ** 1.2
                    if a_tx >= b_rx:
                        loud = a_tx; quiet = b_rx
                    else:
                        loud = b_rx; quiet = a_tx
                    r = (loud - quiet) / max(1.0, loud)
                    k_loud = min(1.0, max(0.0, k_base * (1.0 + 0.5 * r)))
                    k_quiet = min(1.0, max(0.0, k_base * (1.0 - 0.5 * r)))
                    if a_tx >= b_rx:
                        rep_a_tx = a_tx * (1.0 - k_loud) + v * k_loud
                        rep_b_rx = b_rx * (1.0 - k_quiet) + v * k_quiet
                    else:
                        rep_a_tx = a_tx * (1.0 - k_quiet) + v * k_quiet
                        rep_b_rx = b_rx * (1.0 - k_loud) + v * k_loud
                else:
                    rep_a_tx = v
                    rep_b_rx = v
                # Confidence decreases with violation magnitude and change magnitude
                change_a = abs(rep_a_tx - a_tx) / max(abs(rep_a_tx), abs(a_tx), 1.0)
                change_b = abs(rep_b_rx - b_rx) / max(abs(rep_b_rx), abs(b_rx), 1.0)
                conf_base = max(0.0, 1.0 - d_ab)
                tx_conf_a = min(conf_base, 1.0 - 0.8 * change_a)
                rx_conf_b = min(conf_base, 1.0 - 0.8 * change_b)
            else:
                # Within tolerance: keep values and set strong confidence floors
                if max_ab >= 10.0 and d_ab <= 0.005:  # 0.5%
                    conf_floor = 0.99
                else:
                    conf_floor = 0.98 if max_ab >= 10.0 else 0.97
                tx_conf_a = max(tx_conf_a, conf_floor)
                rx_conf_b = max(rx_conf_b, conf_floor)

            # Direction B->A (B.tx vs A.rx)
            max_ba = max(b_tx, a_rx)
            thr_rel_ba = TH_REL_LOW if max_ba < 10.0 else TH_REL_DEFAULT
            guard_ba = ABS_GUARD_LOW if max_ba < 10.0 else TH_ABS_GUARD
            d_ba = rel_diff(b_tx, a_rx)
            abs_ba = abs(b_tx - a_rx)
            partial_upper_ba = (1.6 * thr_rel_ba) if max_ba < 10.0 else (2.0 * thr_rel_ba)

            if (d_ba > thr_rel_ba) and (abs_ba > guard_ba):
                v2 = 0.5 * (b_tx + a_rx)
                resid_b = resid_signed.get(b.get('local_router'), 0.0)
                if max_ba >= 1.0 and (b_tx - a_rx) != 0.0 and resid_b != 0.0 and (sgn(b_tx - a_rx) == sgn(resid_b)):
                    gamma2 = min(0.08, 0.1 * abs(resid_b))
                    w_b2 = clamp(0.5 - gamma2, 0.2, 0.8)
                    w_a2 = 1.0 - w_b2
                    v2 = w_b2 * b_tx + w_a2 * a_rx

                if d_ba <= partial_upper_ba:
                    k_base2 = (d_ba - thr_rel_ba) / max(thr_rel_ba, 1e-9)
                    k_base2 = min(1.0, max(0.0, k_base2))
                    if max_ba < 10.0:
                        k_base2 = k_base2 ** 1.2
                    if b_tx >= a_rx:
                        loud2 = b_tx; quiet2 = a_rx
                    else:
                        loud2 = a_rx; quiet2 = b_tx
                    r2 = (loud2 - quiet2) / max(1.0, loud2)
                    k_loud2 = min(1.0, max(0.0, k_base2 * (1.0 + 0.5 * r2)))
                    k_quiet2 = min(1.0, max(0.0, k_base2 * (1.0 - 0.5 * r2)))
                    if b_tx >= a_rx:
                        rep_b_tx = b_tx * (1.0 - k_loud2) + v2 * k_loud2
                        rep_a_rx = a_rx * (1.0 - k_quiet2) + v2 * k_quiet2
                    else:
                        rep_b_tx = b_tx * (1.0 - k_quiet2) + v2 * k_quiet2
                        rep_a_rx = a_rx * (1.0 - k_loud2) + v2 * k_loud2
                else:
                    rep_b_tx = v2
                    rep_a_rx = v2
                change_b2 = abs(rep_b_tx - b_tx) / max(abs(rep_b_tx), abs(b_tx), 1.0)
                change_a2 = abs(rep_a_rx - a_rx) / max(abs(rep_a_rx), abs(a_rx), 1.0)
                conf_base2 = max(0.0, 1.0 - d_ba)
                tx_conf_b = min(conf_base2, 1.0 - 0.8 * change_b2)
                rx_conf_a = min(conf_base2, 1.0 - 0.8 * change_a2)
            else:
                if max_ba >= 10.0 and d_ba <= 0.005:
                    conf_floor2 = 0.99
                else:
                    conf_floor2 = 0.98 if max_ba >= 10.0 else 0.97
                tx_conf_b = max(tx_conf_b, conf_floor2)
                rx_conf_a = max(rx_conf_a, conf_floor2)
>>>>>>> REPLACE
</DIFF>