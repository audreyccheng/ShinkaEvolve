<NAME>
magnitude_aware_and_router_confidence
</NAME>

<DESCRIPTION>
I propose two targeted improvements to increase counter repair accuracy while preserving strong confidence calibration:

1) Magnitude-aware symmetry threshold with absolute guard:
   - Keep the 2% hardening tolerance but relax it to 5% for flows under 10 Mbps and require an absolute delta > 0.5 Mbps to trigger a repair. This reduces over-corrections on tiny flows and helps align with the research’s Hodor tolerance, improving counter accuracy without harming calibration.

2) Direction-aware router-level confidence attenuation:
   - After repairing via link symmetry, compute per-router flow conservation residuals and apply direction-aware penalties to rx/tx confidences. This does not change values, only confidence, making confidence more faithful when router-level imbalances exist, improving calibration robustness.

Additionally, I propagate down status across a link: if either side reports down, zero both sides’ rates with calibrated confidence (higher if both sides agree). This enforces interface consistency and ensures counters are consistent with status.

These are minimal, surgical changes to the existing function and leverage the provided topology for the router-level confidence attenuation step.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02

    result = {}

    # First pass: collect all measurements and check link symmetry
    link_symmetry_violations = {}
=======
    # Measurement timing tolerance (from Hodor research: ~2%)
    HARDENING_THRESHOLD = 0.02
    # Magnitude-aware tolerance and absolute guard to avoid over-correcting tiny flows
    LOW_RATE_CUTOFF = 10.0  # Mbps
    ABS_GUARD = 0.5         # Mbps; require this absolute delta to trigger a repair

    def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
        return max(lo, min(hi, x))

    result = {}

    # First pass: collect all measurements and check link symmetry
    link_symmetry_violations = {}
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Second pass: repair using redundant signals
    for interface_id, data in telemetry.items():
        repaired_data = {}

        interface_status = data.get('interface_status', 'unknown')
        rx_rate = data.get('rx_rate', 0.0)
        tx_rate = data.get('tx_rate', 0.0)
        connected_to = data.get('connected_to')

        # Default: no repair, high confidence
        repaired_rx = rx_rate
        repaired_tx = tx_rate
        repaired_status = interface_status
        rx_confidence = 1.0
        tx_confidence = 1.0
        status_confidence = 1.0

        # Check for issues and attempt repair
        if interface_id in link_symmetry_violations:
            violations = link_symmetry_violations[interface_id]

            # Repair RX rate if link symmetry is violated
            if violations['rx_tx_diff'] > HARDENING_THRESHOLD:
                # Use peer's TX as more reliable signal
                repaired_rx = violations['peer_tx']
                # Confidence decreases with magnitude of violation
                rx_confidence = max(0.0, 1.0 - violations['rx_tx_diff'])

            # Repair TX rate if link symmetry is violated
            if violations['tx_rx_diff'] > HARDENING_THRESHOLD:
                # Use peer's RX as more reliable signal
                repaired_tx = violations['peer_rx']
                # Confidence decreases with magnitude of violation
                tx_confidence = max(0.0, 1.0 - violations['tx_rx_diff'])

        # Check status consistency
        if connected_to and connected_to in telemetry:
            peer_status = telemetry[connected_to].get('interface_status', 'unknown')
            # If statuses don't match, lower confidence
            if interface_status != peer_status:
                status_confidence = 0.5
                # If interface is down but has non-zero rates, that's suspicious
                if interface_status == 'down' and (rx_rate > 0 or tx_rate > 0):
                    repaired_rx = 0.0
                    repaired_tx = 0.0
                    rx_confidence = 0.3
                    tx_confidence = 0.3

        # Store repaired values with confidence scores
        repaired_data['rx_rate'] = (rx_rate, repaired_rx, rx_confidence)
        repaired_data['tx_rate'] = (tx_rate, repaired_tx, tx_confidence)
        repaired_data['interface_status'] = (interface_status, repaired_status, status_confidence)

        # Copy metadata unchanged
        repaired_data['connected_to'] = connected_to
        repaired_data['local_router'] = data.get('local_router')
        repaired_data['remote_router'] = data.get('remote_router')

        result[interface_id] = repaired_data
=======
    # Second pass: repair using redundant signals
    for interface_id, data in telemetry.items():
        repaired_data = {}

        interface_status = data.get('interface_status', 'unknown')
        rx_rate = data.get('rx_rate', 0.0)
        tx_rate = data.get('tx_rate', 0.0)
        connected_to = data.get('connected_to')

        # Default: no repair, high confidence
        repaired_rx = rx_rate
        repaired_tx = tx_rate
        repaired_status = interface_status
        rx_confidence = 1.0
        tx_confidence = 1.0
        status_confidence = 1.0

        # Peer snapshot for redundancy use
        peer_status = None
        peer_rx = None
        peer_tx = None
        if connected_to and connected_to in telemetry:
            peer = telemetry[connected_to]
            peer_status = peer.get('interface_status', 'unknown')
            peer_rx = peer.get('rx_rate', 0.0)
            peer_tx = peer.get('tx_rate', 0.0)

        # Enforce interface consistency: if either side is down, set effective down and zero rates
        if interface_status == 'down' or (peer_status == 'down' if peer_status is not None else False):
            both_down = (interface_status == 'down' and (peer_status == 'down' if peer_status is not None else False))
            repaired_status = 'down'
            repaired_rx = 0.0
            repaired_tx = 0.0
            status_confidence = 0.95 if both_down else 0.7
            rx_confidence = status_confidence
            tx_confidence = status_confidence
        else:
            # Use magnitude-aware symmetry check with absolute guard
            if connected_to and connected_to in telemetry:
                # RX should match peer's TX
                abs_diff_rx = abs(float(rx_rate) - float(peer_tx))
                max_pair_rx = max(1.0, float(rx_rate), float(peer_tx))
                rel_diff_rx = abs_diff_rx / max_pair_rx
                tol_rx = 0.05 if max(float(rx_rate), float(peer_tx)) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
                if rel_diff_rx > tol_rx and abs_diff_rx > ABS_GUARD:
                    repaired_rx = float(peer_tx)
                    rx_confidence = max(0.0, 1.0 - rel_diff_rx)
                # TX should match peer's RX
                abs_diff_tx = abs(float(tx_rate) - float(peer_rx))
                max_pair_tx = max(1.0, float(tx_rate), float(peer_rx))
                rel_diff_tx = abs_diff_tx / max_pair_tx
                tol_tx = 0.05 if max(float(tx_rate), float(peer_rx)) < LOW_RATE_CUTOFF else HARDENING_THRESHOLD
                if rel_diff_tx > tol_tx and abs_diff_tx > ABS_GUARD:
                    repaired_tx = float(peer_rx)
                    tx_confidence = max(0.0, 1.0 - rel_diff_tx)
                # If statuses differ (but neither side is down), reduce status confidence
                if interface_status != peer_status:
                    status_confidence = 0.6
            else:
                # No redundancy: keep values but slightly lower confidence
                rx_confidence = min(rx_confidence, 0.95)
                tx_confidence = min(tx_confidence, 0.95)

        # Store repaired values with confidence scores
        repaired_data['rx_rate'] = (rx_rate, repaired_rx, rx_confidence)
        repaired_data['tx_rate'] = (tx_rate, repaired_tx, tx_confidence)
        repaired_data['interface_status'] = (interface_status, repaired_status, status_confidence)

        # Copy metadata unchanged
        repaired_data['connected_to'] = connected_to
        repaired_data['local_router'] = data.get('local_router')
        repaired_data['remote_router'] = data.get('remote_router')

        result[interface_id] = repaired_data
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        result[interface_id] = repaired_data

    return result
=======
        result[interface_id] = repaired_data

    # Router-level flow conservation: direction-aware confidence attenuation
    # Build router->interfaces mapping (prefer topology, augment with telemetry hints)
    router_ifaces: Dict[str, List[str]] = {r: list(if_list) for r, if_list in topology.items()}
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        if lr:
            router_ifaces.setdefault(lr, [])
            if if_id not in router_ifaces[lr]:
                router_ifaces[lr].append(if_id)
        rr = d.get('remote_router')
        if rr and rr not in router_ifaces:
            router_ifaces[rr] = []
    # Compute per-router residual mismatch from repaired values
    router_resid: Dict[str, float] = {}
    for r, if_list in router_ifaces.items():
        sum_tx = 0.0
        sum_rx = 0.0
        for if_id in if_list:
            if if_id in result:
                sum_tx += float(result[if_id]['tx_rate'][1])
                sum_rx += float(result[if_id]['rx_rate'][1])
        denom = max(1.0, sum_tx, sum_rx)
        router_resid[r] = abs(sum_tx - sum_rx) / denom
    # Apply direction-aware penalties with gentle floor
    for if_id, d in telemetry.items():
        lr = d.get('local_router')
        rr = d.get('remote_router')
        resid_local = router_resid.get(lr, 0.0)
        resid_remote = router_resid.get(rr, 0.0)
        penalty_tx = clamp(1.0 - (0.6 * resid_local + 0.4 * resid_remote), 0.7, 1.0)
        penalty_rx = clamp(1.0 - (0.6 * resid_remote + 0.4 * resid_local), 0.7, 1.0)
        orx, rrx, rc = result[if_id]['rx_rate']
        otx, rtx, tc = result[if_id]['tx_rate']
        result[if_id]['rx_rate'] = (orx, rrx, clamp(rc * penalty_rx))
        result[if_id]['tx_rate'] = (otx, rtx, clamp(tc * penalty_tx))

    return result
>>>>>>> REPLACE
</DIFF>