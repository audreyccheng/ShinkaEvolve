{
  "unprocessed_programs": [],
  "meta_summary": "**Program Name: Stochastic Greedy Sampling Scheduler**\n- **Implementation**: Uses a constructive greedy algorithm that samples 10 random candidates at each step, selecting the transaction that minimizes the cumulative cost of the current sequence.\n- **Performance**: Achieved a combined score of 2.83 while processing 300 total transactions across three workloads.\n- **Feedback**: The randomized lookahead strategy provides a balance between computational efficiency and schedule quality, though the implementation only generates a single schedule sequence rather than exploring multiple paths.\n**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True\n\n**Program Name: Multi-Start Randomized Greedy with Heuristic Bias**\n- **Implementation**: The algorithm utilizes a multi-start greedy strategy that constructs schedules by iteratively selecting the best candidate from a mix of random samples and high-cost \"heavy\" items. It executes 10 restarts, switching from broad random sampling to a heuristic-biased approach that prioritizes long-duration transactions to optimize placement.\n- **Performance**: Achieved a strong combined score of 2.87, demonstrating effective minimization of total makespan across all three workloads.\n- **Feedback**: The hybrid approach of combining random exploration with a \"heaviest-first\" heuristic bias proved highly effective for schedule optimization. The multi-start mechanism ensures robustness against local optima, while the cost-based bias helps resolve bottlenecks early in the construction process.\n**Program Identifier:** Generation 1 - Patch Name iterative_heuristic_greedy_scheduling - Correct Program: True\n\n**Program Name: Genetic Algorithm with Caching for Transaction Scheduling**\n- **Implementation:** Uses a Genetic Algorithm with Order Crossover (OX1), shift mutation, and tournament selection, enhanced by a dictionary cache to memoize expensive fitness calculations.\n- **Performance:** Achieved a combined score of 2.23, successfully optimizing makespans across complex and simple workloads.\n- **Feedback:** The caching mechanism effectively reduces computational overhead, while the specific crossover and mutation strategies maintain valid permutation structures for robust schedule optimization.\n**Program Identifier:** Generation 2 - Patch Name genetic_txn_scheduler - Correct Program: True\n\n**Program Name: Sampled Greedy Construction with Random Restarts**\n- **Implementation**: The algorithm constructs schedules by iteratively appending the transaction that minimizes the current makespan from a random sample of 15 remaining candidates. This stochastic greedy process is repeated 10 times to identify the lowest cost sequence.\n- **Performance**: It achieved a combined maximization score of 3.06 with correct validation across all workloads.\n- **Feedback**: The sampling strategy significantly speeds up execution compared to exhaustive greedy search, balancing solution quality with runtime efficiency, though the limited sample size may miss the optimal local choice.\n**Program Identifier:** Generation 3 - Patch Name implement_greedy_restarts - Correct Program: True\n\n**Program Name: Hybrid Greedy LPT with Shift-Based Local Search**\n- **Implementation**: The algorithm employs a multi-start greedy construction biased by transaction costs (LPT), followed by a hill-climbing local search that refines the schedule using random shift operations.\n- **Performance**: It achieved a combined score of 3.06, correctly scheduling all 300 transactions across the workloads.\n- **Feedback**: The use of cost-biased sampling during construction provides high-quality starting points, while the shift-based refinement effectively minimizes gaps in the schedule to optimize the total makespan.\n**Program Identifier:** Generation 4 - Patch Name greedy_with_local_search - Correct Program: True\n\n**Program Name: Beam Search with Diversity Constraints and Duration Tie-Breaking**\n- **Implementation**: The solution implements a beam search with stochastic sampling (16 candidates) and a diversity mechanism (limiting parents to 3 children) to maintain varied search paths. It prioritizes candidates based on lowest current makespan, using a Longest Processing Time (LPT) heuristic as a secondary tie-breaker.\n- **Performance**: The algorithm achieved a combined score of 3.44, successfully generating valid schedules across all three workloads.\n- **Feedback**: The diversity constraint effectively prevents the beam from converging too early on local optima, while the duration-based tie-breaking improves schedule packing efficiency by placing expensive transactions earlier when costs are equal.\n**Program Identifier:** Generation 5 - Patch Name beam_search_scheduler - Correct Program: True\n\n**Program Name: Adaptive Greedy Construction with Hybrid Local Search**\n- **Implementation**: Generates candidate schedules using a greedy strategy that samples high-cost transactions and switches to exhaustive search for the final 15 items, followed by refinement using random swap and shift operators.\n- **Performance**: Achieved a combined score of 3.08, successfully minimizing total makespan across diverse transaction workloads.\n- **Feedback**: The adaptive switch to exhaustive search for the schedule tail effectively prevents suboptimal gaps often left by greedy approaches, while the heuristic bias ensures \"heavy\" transactions are scheduled early to avoid bottlenecks.\n**Program Identifier:** Generation 6 - Patch Name adaptive_greedy_hybrid_ls - Correct Program: True\n\n**Program Name: Beam Search with Diversity and Local Refinement**\n- **Implementation**: Implements beam search with diversity constraints to limit children per parent and random sampling, concluding with a local search pass of adjacent swaps.\n- **Performance**: Achieved a combined score of 3.32 with valid schedules for all workloads.\n- **Feedback**: The diversity mechanism effectively maintains population variety during the greedy construction, while the final swap pass offers a low-cost method to fix minor ordering inefficiencies.\n**Program Identifier:** Generation 7 - Patch Name beam_search_with_local_refinement - Correct Program: True\n\n**Program Name: Heuristic Beam Search with Diversity and Local Refinement**\n- **Implementation**: This solution implements a Beam Search algorithm utilizing heuristic sampling (LPT/SPT) and diversity constraints to prune the search space, followed by a stochastic local search to refine the final schedule.\n- **Performance**: The algorithm achieved a combined score of 3.24, demonstrating effective optimization of transaction schedules while maintaining efficient execution time.\n- **Feedback**: The integration of heuristic sampling significantly reduces computational overhead by targeting likely high-quality candidates, while diversity constraints prevent the beam from converging prematurely. The final local search step proves valuable for escaping local optima inherent in the constructive phase.\n**Program Identifier:** Generation 8 - Patch Name beam_search_plus_local_refine - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with Windowed Local Refinement**\n- **Implementation**: The algorithm utilizes a beam search with random sampling and state deduplication based on remaining transaction sets to ensure path diversity, prioritizing longer transactions during tie-breaking. A post-processing windowed local search (size 4) iteratively swaps nearby transactions to refine the final schedule.\n- **Performance**: The solution achieved a combined score of 3.39, successfully generating valid schedules with reasonable makespans.\n- **Feedback**: The state deduplication strategy is highly effective for preventing the beam from converging on identical permutations, while the local swap refinement helps correct greedy ordering errors inherent to beam search.\n**Program Identifier:** Generation 9 - Patch Name deduplicated_beam_search - Correct Program: True\n\n**Program Name: Adaptive Greedy with Tail Search and Hybrid Local Search**\n- **Implementation**: Constructs schedules using an adaptive greedy approach with heavy-item bias, tail-end exhaustive search, and duration-based tie-breaking, followed by local search using weighted shift and swap operators.\n- **Performance**: Achieved a competitive combined score of 3.17, successfully passing all validation tests.\n- **Feedback**: The combination of heuristic bias and exhaustive tail search effectively constructs high-quality initial solutions, while duration-based tie-breaking helps fill scheduling gaps before refinement.\n**Program Identifier:** Generation 10 - Patch Name adaptive_greedy_tiebreak_swap - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with LPT Sampling and Local Refinement**\n- **Implementation**: The algorithm employs beam search with state deduplication based on remaining transaction sets, utilizing a hybrid sampling strategy that prioritizes Longest Processing Time (LPT) candidates alongside random selection. A post-processing phase applies adjacent swaps to locally refine the best schedule found.\n- **Performance**: Achieved a combined score of 3.41, demonstrating effective optimization of transaction ordering within limited execution time.\n- **Feedback**: Deduplication logic is highly effective here, preventing the beam from saturating with permutations of the same task subset. The hybrid sampling strategy successfully balances greedy optimization (via LPT) with sufficient diversity to avoid local optima.\n**Program Identifier:** Generation 11 - Patch Name deduplicated_lpt_beam_search - Correct Program: True\n\n**Program Name: Weighted Greedy with Exhaustive Tail and Biased Local Search**\n- **Implementation**: The algorithm combines duration-weighted greedy construction with an exhaustive search for the final 20 items and uses a shift-heavy local search to refine the schedule.\n- **Performance**: Achieved a high combined score of 3.22, effectively minimizing total makespan across workloads.\n- **Feedback**: The adaptive switch to exhaustive search for the sequence tail and the Longest Processing Time (LPT) tie-breaking strategy significantly enhanced packing efficiency.\n**Program Identifier:** Generation 12 - Patch Name weighted_greedy_lpt_search - Correct Program: True\n\n**Program Name: Hybrid Deduplicated Beam Search with Weighted Sampling**\n- **Implementation**: Implements a beam search initialized with mixed LPT/random seeds, utilizing weighted sampling and state deduplication based on remaining transaction sets to prune redundant paths. The schedule is further improved via a multi-pass windowed insertion refinement phase.\n- **Performance**: Achieved a strong combined score of 3.41, demonstrating effective makespan minimization.\n- **Feedback**: The state deduplication strategy significantly improves search efficiency by preventing the beam from saturating with identical subsets, while the windowed insertion refinement successfully corrects local ordering inefficiencies left by the greedy construction.\n**Program Identifier:** Generation 13 - Patch Name hybrid_dedup_beam - Correct Program: True\n\n**Program Name: Adaptive Beam Search with Hybrid Sampling and Local Refinement**\n- **Implementation**: Uses an adaptive beam width and hybrid sampling (prioritizing longest remaining transactions mixed with random selection) to construct schedules, utilizing state deduplication to prune redundant paths based on remaining transaction sets. A final windowed local search performs swaps to refine the ordering.\n- **Performance**: Achieved a strong combined score of 3.36, indicating effective makespan minimization across all workloads.\n- **Feedback**: The combination of LPT-driven sampling and state deduplication efficiently navigates the search space by targeting critical path transactions early, while the adaptive beam width and local search refinement successfully balance global exploration with local optimization.\n**Program Identifier:** Generation 14 - Patch Name adaptive_dedup_beam_search - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with LPT Sampling and Local Search**\n- **Implementation**: The algorithm uses beam search with state deduplication to discard redundant remaining sets, selecting next-step candidates via a mix of Longest Processing Time (LPT) heuristics and random sampling. A post-search local refinement phase applies adjacent swaps to optimize the final sequence.\n- **Performance**: Achieved a combined score of 3.46, generating valid, optimized schedules across all workloads.\n- **Feedback**: State deduplication is highly effective here, preventing the beam from filling with permutations of the same subset and ensuring diversity. The hybrid LPT/random sampling strategy successfully mitigates greedy traps while prioritizing bottleneck transactions.\n**Program Identifier:** Generation 15 - Patch Name deduplicated_beam_search_with_lpt_sampling - Correct Program: True\n\n**Program Name: Diverse Deduplicated Beam Search with Local Refinement**\n- **Implementation**: Utilizes beam search with hybrid LPT/random sampling, state deduplication, and parent diversity constraints, followed by a windowed swap-based local search.\n- **Performance**: Achieved a combined score of 3.48, effectively optimizing makespan across varying workload complexities.\n- **Feedback**: The integration of state deduplication and diversity limits prevented beam stagnation, while the post-processing local search successfully corrected minor greedy sequencing errors.\n**Program Identifier:** Generation 16 - Patch Name diverse_dedup_beam_search - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with Ends-Out Sampling and Local Search**\n- **Implementation**: This approach employs beam search with state deduplication and an \"ends-out\" sampling strategy that explicitly selects the longest and shortest transactions during expansion, followed by adjacent swap and windowed insertion refinement.\n- **Performance**: The algorithm achieved a strong combined score of 3.44, demonstrating effective optimization within the execution time limits.\n- **Feedback**: The \"ends-out\" sampling effectively balances bottleneck management (LPT) with gap filling (SPT), while state deduplication significantly improves search efficiency by preventing the exploration of redundant subsets.\n**Program Identifier:** Generation 17 - Patch Name ends_out_sampling_beam_search - Correct Program: True\n\n**Program Name: Diverse Deduplicated Beam Search with Local Refinement**\n- **Implementation**: Utilizes a beam search with state deduplication, parent diversity constraints, and hybrid LPT/random sampling, followed by a windowed swap local search for refinement.\n- **Performance**: Achieved a strong combined score of 3.57, indicating highly effective makespan optimization.\n- **Feedback**: The combination of state-based deduplication and diversity limits effectively maintained search breadth without exploding computational cost, while the local search resolved minor ordering inefficiencies.\n**Program Identifier:** Generation 18 - Patch Name parallelism_heuristic_and_weighted_sampling - Correct Program: True\n\n**Program Name: Stochastic Beam Search with LPT Sampling and Local Refinement**\n- **Implementation**: Constructs schedules using beam search with duration-weighted sampling to favor long transactions and exhaustive tail search, followed by hill climbing using shift and swap operators.\n- **Performance**: Achieved a combined score of 3.30, successfully optimizing makespan across all three workloads.\n- **Feedback**: The weighted sampling effectively incorporates Longest-Processing-Time heuristics into the construction phase, while the subsequent local search refines the packing density of the final schedule.\n**Program Identifier:** Generation 19 - Patch Name stochastic_beam_search_scheduler - Correct Program: True\n\n**Program Name: Work-Density Beam Search with Ends-Out Sampling**\n- **Implementation**: Utilizes a beam search guided by a work density heuristic and LPT/SPT sampling, refined by adjacent swaps and windowed insertions to optimize transaction ordering.\n- **Performance**: Achieved a combined score of 3.57, successfully scheduling 300 transactions across diverse workloads without errors.\n- **Feedback**: The density-based heuristic effectively targets packing efficiency, while state deduplication and hybrid local search ensure high-quality solutions by preventing premature convergence.\n**Program Identifier:** Generation 20 - Patch Name work_density_beam_search - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with Windowed Insertion Refinement**\n- **Implementation**: The algorithm utilizes a beam search seeded with Longest Processing Time (LPT) and random starts, employing state deduplication based on remaining items and an \"ends-out\" sampling strategy that mixes longest and shortest tasks. A post-processing phase applies windowed insertion local search to fine-tune the schedule sequence.\n- **Performance**: The solution validates successfully across all workloads, achieving a combined optimization score of 3.38.\n- **Feedback**: Deduplicating states by the set of remaining items prevents redundant search effort on permutations, while the windowed insertion refinement effectively addresses local ordering constraints that beam search might miss.\n**Program Identifier:** Generation 21 - Patch Name ends_out_beam_with_insertion_refinement - Correct Program: True\n\n**Program Name: Hybrid Dynamic Beam Search with Local Search Refinement**\n- **Implementation**: Constructs schedules using a linearly tapering beam search with weighted LPT sampling for candidate selection, followed by 800 iterations of shift-and-swap local search.\n- **Performance**: Achieved a combined maximization score of 3.12, successfully generating valid schedules across all three workloads.\n- **Feedback**: The dynamic beam width efficiently allocates resources to early critical decisions, while the LPT tie-breaking and aggressive local search effectively minimize schedule gaps.\n**Program Identifier:** Generation 22 - Patch Name dynamic_beam_search - Correct Program: True\n\n**Program Name: Conflict-Aware Tapered Beam Search with Sampled Insertion**\n- **Implementation**: Computes conflict weights to guide a tapered beam search that prioritizes high-contention transactions using secondary sorting metrics, followed by a local search refinement utilizing sampled insertion points.\n- **Performance**: Achieved a combined score of 3.26, successfully optimizing makespan across all workloads.\n- **Feedback**: The integration of domain-specific conflict heuristics into the beam search construction significantly improves initial schedule quality, which is then effectively fine-tuned by the targeted local search.\n**Program Identifier:** Generation 23 - Patch Name conflict_aware_beam_search - Correct Program: True\n\n**Program Name: Work-Density Beam Search with Windowed Local Search**\n- **Implementation**: This approach uses a beam search guided by a \"work density\" heuristic ($Cost - TotalDuration$) to prioritize parallelism, incorporating hybrid LPT sampling and state deduplication to maintain diversity. It further optimizes schedules using a two-phase local search strategy consisting of windowed swaps and targeted insertions.\n- **Performance**: The algorithm achieved a high combined score of 3.66, demonstrating effective makespan reduction across all workloads.\n- **Feedback**: The density-based heuristic effectively encourages parallel transaction packing, while the combination of beam diversity techniques and granular local search refinement ensures robust solution quality.\n**Program Identifier:** Generation 24 - Patch Name work_density_beam_search_plus_refinement - Correct Program: True\n\n**Program Name: Diverse Deduplicated Beam Search with Hybrid Sampling and Refinement**\n- **Implementation**: The algorithm employs beam search with state deduplication and parent diversity constraints, expanding via hybrid LPT/weighted sampling and refining with windowed insertion local search.\n- **Performance**: Achieved a high combined score of 3.61, demonstrating excellent optimization capabilities.\n- **Feedback**: State deduplication significantly improves search efficiency by merging identical remaining sets, while windowed insertion effectively optimizes local dependency ordering.\n**Program Identifier:** Generation 25 - Patch Name tapered_beam_insertion_refine - Correct Program: True\n\n**Program Name: Conflict-Aware Beam Search with Heavy-Item Refinement**\n- **Implementation**: Utilizes a beam search guided by a composite weight of transaction duration and conflict degree, followed by a specialized refinement phase that locally optimizes the positions of the longest transactions.\n- **Performance**: Achieved a maximization score of 3.31 with valid schedules for all workloads.\n- **Feedback**: The approach effectively identifies bottlenecks by prioritizing high-conflict items during construction, and the targeted refinement of \"heavy\" items provides significant gains by adjusting the critical path.\n**Program Identifier:** Generation 26 - Patch Name conflict_beam_heavy_refine - Correct Program: True\n\n**Program Name: Conflict-Aware Tapered Beam Search with Local Refinement**\n- **Implementation**: Uses pre-computed conflict weights to guide a tapered beam search prioritizing high-contention transactions, followed by local search refinement using shift and swap operators.\n- **Performance**: Achieved a combined score of 3.12, producing valid schedules for all workloads.\n- **Feedback**: The conflict-aware heuristic effectively targets critical bottlenecks early in the construction phase, while the tapered beam width optimizes the balance between search space exploration and execution time.\n**Program Identifier:** Generation 27 - Patch Name conflict_aware_tapered_beam_search - Correct Program: True\n\n**Program Name: Conflict-Aware Tapered Beam Search with Heavy-Item Refinement**\n- **Implementation**: Constructs schedules using a tapered beam search guided by a combined conflict-volume and duration heuristic, followed by targeted re-insertion of high-conflict transactions and stochastic hill climbing.\n- **Performance**: Achieved a strong combined score of 3.27, effectively minimizing total makespan across all workloads.\n- **Feedback**: The tapered beam width balances exploration with computational efficiency, while the specific re-insertion phase effectively targets and resolves bottlenecks caused by the most problematic transactions.\n**Program Identifier:** Generation 28 - Patch Name conflict_beam_search - Correct Program: True\n\n**Program Name: Hybrid Conflict-Aware Beam Search with Windowed Re-insertion**\n- **Implementation**: Uses beam search guided by conflict-weighted priorities and a zero-cost increase heuristic, followed by two passes of deterministic windowed re-insertion and adjacent swapping.\n- **Performance**: Achieved a strong combined score of 3.37 with valid, optimized schedules across all workloads.\n- **Feedback**: The multi-stage strategy effectively targets critical path transactions early while the windowed re-insertion fine-tunes local ordering, ensuring robust makespan reduction.\n**Program Identifier:** Generation 29 - Patch Name windowed_reinsertion_beam - Correct Program: True\n\n**Program Name: Conflict-Degree Aware Beam Search with Dual-Phase Refinement**\n- **Implementation**: The algorithm utilizes a tapered beam search prioritizing high-conflict, long-duration transactions, followed by a refinement phase that re-inserts critical items globally and performs windowed local search.\n- **Performance**: The solution achieved a strong combined maximization score of 3.39.\n- **Feedback**: The heuristic effectively addresses bottlenecks by scheduling high-conflict transactions early, while the dual-phase refinement robustly optimizes both macro-level placement of critical tasks and micro-level ordering.\n**Program Identifier:** Generation 30 - Patch Name conflict_degree_beam_refinement - Correct Program: True\n\n**Program Name: Parallelism-Guided Beam Search with Diversity Control and Local Search**\n- **Implementation**: Employed a beam search using a `Makespan - TotalDuration` heuristic to favor parallelism, incorporating diversity limits on descendants, hybrid LPT/random sampling, and post-processing with windowed swaps and insertions.\n- **Performance**: Achieved a combined score of 3.72, successfully optimizing schedules across varied workloads.\n- **Feedback**: The density-based heuristic effectively prioritizes concurrent execution, while diversity controls and multi-phase local search prevent convergence to suboptimal local minima.\n**Program Identifier:** Generation 31 - Patch Name density_guided_diverse_beam - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Utilizes an adaptive beam search with one-step lookahead based on conflict-volume priority, followed by iterated local search using windowed insertion and perturbation.\n- **Performance**: The algorithm achieved a combined score of 3.24, successfully optimizing makespan across multiple workloads.\n- **Feedback**: The hybrid approach effectively balances global structure building with local refinement, leveraging conflict analysis to guide the initial schedule construction.\n**Program Identifier:** Generation 32 - Patch Name conflict_aware_lookahead_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Combines beam search using a one-step LPT lookahead and weighted sampling with a \"perturb and repair\" Iterated Local Search refinement phase.\n- **Performance**: Achieved a combined score of 3.77, successfully balancing makespan optimization and runtime constraints.\n- **Feedback**: The lookahead heuristic effectively identifies heavy blocking transactions early, while the ILS post-processing significantly improves solution quality through targeted local moves.\n**Program Identifier:** Generation 33 - Patch Name lookahead_beam_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Utilizes a beam search with a 2-step lookahead metric that anticipates future blocking costs, followed by an Iterated Local Search employing random swaps and windowed insertion to refine the schedule.\n- **Performance**: Achieved a combined score of 3.42, effectively balancing makespan reduction with computational overhead.\n- **Feedback**: The lookahead mechanism successfully identifies and avoids greedy pitfalls, while the hybrid candidate selection and ILS ensure diverse exploration of the solution space.\n**Program Identifier:** Generation 34 - Patch Name lookahead_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Hybrid Sampling and ILS**\n- **Implementation**: The algorithm employs beam search with a one-step lookahead heuristic and hybrid sampling (deterministic LPT plus weighted random), followed by Iterated Local Search with window-based insertion refinement and perturbation.\n- **Performance**: It achieved a high combined maximization score of 3.72, indicating strong scheduling efficiency.\n- **Feedback**: The combination of lookahead logic during construction and post-construction local search effectively balances exploration and exploitation to minimize makespan.\n**Program Identifier:** Generation 35 - Patch Name stochastic_lookahead_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: This approach combines Beam Search with a one-step lookahead that tentatively schedules large transactions to assess future blocking, followed by an Iterated Local Search (ILS) refinement phase. Weighted random sampling and a density-based heuristic guide the beam to prioritize parallelism.\n- **Performance**: The solution achieved a superior combined score of 3.73, demonstrating highly effective makespan minimization.\n- **Feedback**: The lookahead mechanism provides a robust defense against greedy pitfalls by evaluating the impact on heavy transactions, while the ILS post-processing efficiently optimizes local adjacencies.\n**Program Identifier:** Generation 36 - Patch Name lookahead_ils_scheduling - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Precomputes a \"conflict volume\" urgency metric to guide a Lookahead Beam Search that evaluates 2-step costs, followed by Iterated Local Search (ILS) using swap perturbations and windowed descent.\n- **Performance**: Achieved a combined score of 3.32, demonstrating effective optimization across diverse transaction workloads.\n- **Feedback**: The lookahead mechanism successfully prevents shortsighted greedy decisions by anticipating future blocking, while the hybrid ILS refinement strategy effectively fine-tunes the schedule to escape local optima.\n**Program Identifier:** Generation 37 - Patch Name lookahead_beam_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Constructs schedules using beam search with 1-step lookahead and hybrid sampling, then refines results via Iterated Local Search with swap and insertion neighborhoods.\n- **Performance**: The algorithm achieved a high combined score of 3.76, demonstrating robust optimization capabilities across multiple workloads.\n- **Feedback**: The lookahead mechanism successfully mitigated greedy bias during construction, while the perturbation logic improved final solution quality by escaping local optima.\n**Program Identifier:** Generation 38 - Patch Name reintroduce_lookahead_and_ils - Correct Program: True\n\n**Program Name: Robust Lookahead Beam Search with Squared Sampling and ILS**\n- **Implementation**: Implements beam search using a pessimistic lookahead that penalizes blocking the top-2 longest remaining transactions, combined with squared-weighted sampling ($d^2$) to aggressively prioritize heavy items. The solution is refined via multi-start Iterated Local Search (ILS) utilizing random swap perturbations and windowed insertion repair.\n- **Performance**: Achieved a strong combined score of 3.73, demonstrating effective minimization of makespan across diverse workloads.\n- **Feedback**: The use of squared weights successfully biases selection toward critical path items, while the robust lookahead prevents local optima that would delay future heavy transactions. The multi-start ILS provides necessary post-processing refinement, though the extensive lookahead logic adds significant computational overhead per node.\n**Program Identifier:** Generation 39 - Patch Name robust_lookahead_ils - Correct Program: True\n\n**Program Name: Deep-Lookahead Beam Search with Hybrid ILS Refinement**\n- **Implementation**: Uses beam search with a \"pilot\" lookahead that simulates adding the next two urgent transactions to evaluate candidate costs, followed by Iterated Local Search using windowed insertion and hybrid perturbations (block shuffle/long swap).\n- **Performance**: Achieved a high combined score of 3.24, effectively minimizing total makespan across diverse workloads.\n- **Feedback**: The pilot lookahead prevents suboptimal greedy choices by anticipating future conflicts, while the hybrid perturbation strategy balances local reordering with global structural changes to escape local optima efficiently.\n**Program Identifier:** Generation 40 - Patch Name pilot_beam_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Utilizes beam search with 1-step lookahead and hybrid sampling (LPT/random) for schedule construction, followed by iterated local search with multi-swap perturbations for refinement.\n- **Performance**: Achieved a combined score of 3.76, effectively minimizing total makespan across diverse workloads.\n- **Feedback**: The lookahead strategy effectively prevents myopic greedy errors, while the hybrid sampling and post-processing local search ensure robust exploration and convergence to high-quality schedules.\n**Program Identifier:** Generation 41 - Patch Name robust_lookahead_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Conflict Urgency and ILS**\n- **Implementation**: Uses beam search with a 2-step lookahead evaluating conflict-volume urgency, followed by Iterated Local Search (ILS) utilizing block shuffling and windowed insertion.\n- **Performance**: Achieved a high combined score of 3.41, demonstrating effective schedule optimization.\n- **Feedback**: The lookahead strategy effectively mitigates shortsighted greedy decisions, while the mix of block shuffling and windowed repair in ILS robustly refines the schedule.\n**Program Identifier:** Generation 42 - Patch Name ILS_Refinements - Correct Program: True\n\n**Program Name: Volume-Weighted Beam Search with Windowed ILS**\n- **Implementation**: The solution utilizes a \"Conflict Volume\" metric to guide a weighted Beam Search for initial scheduling, followed by an Iterated Local Search that employs random swaps and windowed insertion descent.\n- **Performance**: Achieved a combined score of 3.37, effectively optimizing the makespan across three distinct workloads.\n- **Feedback**: The strategy of prioritizing transactions based on conflict duration during construction, coupled with a perturbation-repair cycle, effectively balances global structure with local refinement.\n**Program Identifier:** Generation 43 - Patch Name ils_conflict_volume_beam - Correct Program: True\n\n**Program Name: Conflict-Volume Lookahead Beam Search with ILS**\n- **Implementation**: Computes a \"conflict volume\" metric to guide a beam search with one-step simulation lookahead, followed by iterated local search using windowed re-insertion and swaps.\n- **Performance**: Score: 0.0 (Failed validation).\n- **Feedback**: The implementation relies on expensive simulation calls within both the lookahead construction and the iterative refinement phases, likely causing execution timeouts or errors during validation.\n**Program Identifier:** Generation 44 - Patch Name lookahead_ils_scheduling - Correct Program: False\n\n**Program Name: Lookahead Beam Search with Multi-Cycle Iterated Local Search**\n- **Implementation**: Utilizes a Beam Search with LPT-based one-step lookahead and diversity constraints to build a schedule, followed by a Multi-Cycle Iterated Local Search using window-based swaps and insertions.\n- **Performance**: Achieved a high combined score of 3.82, indicating effective minimization of makespan across all workloads.\n- **Feedback**: The one-step lookahead strategy significantly improves the beam search's decision-making by anticipating costs, while the subsequent ILS phase robustly refines the solution by escaping local optima.\n**Program Identifier:** Generation 45 - Patch Name multi_cycle_ils_beam - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Critical Re-insertion and ILS**\n- **Implementation**: Uses urgency-based beam search with a 1-step lookahead cost heuristic to build an initial schedule, followed by global re-insertion of critical transactions and Iterated Local Search with block moves.\n- **Performance**: Achieved a combined score of 3.31, successfully optimizing makespan across diverse workloads.\n- **Feedback**: The lookahead mechanism helps avoid early greedy mistakes, while critical path re-insertion specifically targets high-conflict transactions to minimize overall makespan.\n**Program Identifier:** Generation 46 - Patch Name hybrid_lookahead_ils_scheduler - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Iterated Local Search**\n- **Implementation**: Utilizes beam search with 1-step LPT lookahead and weighted sampling for construction, followed by Iterated Local Search (ILS) using perturbation and greedy repair.\n- **Performance**: Achieved a high combined score of 3.73, effectively minimizing makespan across all workloads.\n- **Feedback**: The integration of lookahead during construction minimizes greedy errors, while the \"perturb and repair\" strategy effectively refines schedules by escaping local optima.\n**Program Identifier:** Generation 47 - Patch Name multi_cycle_ils - Correct Program: True\n\n**Program Name: Squared-Weighted Beam Search with Multi-Cycle ILS**\n- **Implementation**: Combines beam search using squared-weighted sampling and 1-step lookahead with a multi-cycle Iterated Local Search that alternates swaps and insertions for refinement.\n- **Performance**: Achieved a combined score of 3.89, demonstrating strong optimization of makespan across mixed transaction workloads.\n- **Feedback**: The squared weighting strategy effectively targets bottleneck transactions, while the extensive local search with perturbations ensures robust escape from local optima.\n**Program Identifier:** Generation 48 - Patch Name robust_hybrid_beam_ils - Correct Program: True\n\n**Program Name: Deduplicated Beam Search with Iterated Local Search**\n- **Implementation**: Implements a beam search with state deduplication using frozensets and dynamic beam widths, prioritized by a hybrid LPT/random strategy. A post-processing Iterated Local Search (ILS) refines the schedule using windowed swaps and insertions.\n- **Performance**: Achieved a combined score of 3.73, indicating highly effective makespan minimization.\n- **Feedback**: Deduplicating states based on remaining transaction sets significantly enhances search efficiency by avoiding redundant permutations. The multi-stage approach (construction followed by aggressive local search) robustly optimizes complex workloads by balancing global structure and local conflict resolution.\n**Program Identifier:** Generation 49 - Patch Name tune_beam_parameters - Correct Program: True\n\n**Program Name: Adaptive Beam Search with Lookahead and Block-Move ILS**\n- **Implementation**: Utilizes an adaptive beam search with LPT-based lookahead and hybrid sampling, followed by Iterated Local Search (ILS) using block moves and greedy swaps.\n- **Performance**: Achieved a high combined score of 3.72, indicating excellent optimization balance.\n- **Feedback**: The lookahead strategy effectively prevents early greedy mistakes, while structural perturbations in ILS significantly refine the final schedule quality.\n**Program Identifier:** Generation 50 - Patch Name adaptive_beam_ils_block - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Variable Neighborhood Descent and ILS**\n- **Implementation**: Constructs schedules using a tapered beam search with lookahead based on conflict urgency, refined by Variable Neighborhood Descent (windowed insertions/swaps) and Iterated Local Search.\n- **Performance**: Achieved a combined optimization score of 3.39 with valid schedules across all workloads.\n- **Feedback**: The hybrid strategy effectively leverages specific conflict metrics for construction and stochastic search for refinement, though the lookahead mechanism adds computational overhead relative to simpler constructive heuristics.\n**Program Identifier:** Generation 51 - Patch Name vnd_beam_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Conflict Volume and Block-Move ILS**\n- **Implementation**: Combines conflict-volume-based urgency metrics, cubic sampling, and 1-step lookahead beam search with a structure-preserving block-move Iterated Local Search.\n- **Performance**: Achieved an exceptional combined score of 3.16, demonstrating significant makespan reduction across workloads.\n- **Feedback**: The lookahead mechanism effectively mitigates greedy blocking errors, while block-moves preserve internal parallelism during refinement, proving highly effective for handling heavy contention.\n**Program Identifier:** Generation 52 - Patch Name lookahead_beam_block_ils_v2 - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Cubic Sampling and Ruin-Recreate ILS**\n- **Implementation**: This approach combines Beam Search using cubic weighted sampling and deduplicated multi-target lookahead with an Iterated Local Search (ILS) phase that employs ruin-and-recreate perturbation for schedule refinement.\n- **Performance**: The algorithm achieved a strong combined score of 3.92, indicating effective makespan minimization across diverse workloads.\n- **Feedback**: Aggressive cubic weighting successfully prioritizes computationally expensive transactions early, while the multi-cycle ILS ensures the final schedule is robustly optimized against local minima.\n**Program Identifier:** Generation 53 - Patch Name tune_params - Correct Program: True\n\n**Program Name: Tapered Beam Search with Critical Reinsertion and Local Search**\n- **Implementation**: Utilizes urgency-based tapered beam search followed by global reinsertion of critical bottlenecks and iterated local search with windowed descent to refine the schedule.\n- **Performance**: Achieved a high combined score of 3.28, demonstrating strong optimization of transaction makespans across workloads.\n- **Feedback**: The critical reinsertion phase effectively corrects high-level structural flaws by repositioning bottlenecks, while windowed descent efficiently refines local ordering without excessive computational cost.\n**Program Identifier:** Generation 54 - Patch Name tapered_beam_ils_crossover - Correct Program: True\n\n**Program Name: Cubic-Weighted Beam Search with Lookahead and Block-Move ILS**\n- **Implementation**: This approach combines a beam search using cubic-weighted sampling and multi-target lookahead (simulating future high-urgency items) with an Iterated Local Search employing block moves and windowed descent.\n- **Performance**: The algorithm achieved a high combined score of 3.41, demonstrating effective optimization across diverse workloads.\n- **Feedback**: The multi-target lookahead prevents short-sighted greedy choices by validating compatibility with upcoming critical transactions, while block moves in the local search phase help preserve optimal subsequences during perturbation.\n**Program Identifier:** Generation 55 - Patch Name cubic_lookahead_beam_block_ils - Correct Program: True\n\n**Program Name: Cubic-Weighted Beam Search with Multi-Target Lookahead and ILS**\n- **Implementation**: This approach employs a beam search that selects candidates via cubic urgency weighting ($u^3$) and evaluates them using a lookahead against the top-3 remaining items. It refines the schedule using Iterated Local Search (ILS) featuring block-move perturbations and windowed insertion descent.\n- **Performance**: The solution achieved a combined score of 3.44, effectively balancing execution time with schedule quality.\n- **Feedback**: The cubic weighting strategy successfully promotes critical path items while maintaining diversity, and the block-move perturbation helps escape local optima by preserving efficient contiguous schedule segments.\n**Program Identifier:** Generation 56 - Patch Name cubic_beam_block_ils - Correct Program: True\n\n**Program Name: Adaptive Beam Search with Lookahead and Ruin-Recreate ILS**\n- **Implementation**: The solution implements an adaptive beam search that utilizes LPT-based lookahead scoring and cubic-weighted sampling to construct initial schedules, followed by an Iterated Local Search (ILS) employing ruin-recreate and block-move perturbations for refinement.\n- **Performance**: The algorithm achieved a high combined score of 3.80, demonstrating superior optimization of transaction makespans across all workloads.\n- **Feedback**: The integration of optimistic lookahead during beam search effectively anticipates high-cost transaction dependencies, while the aggressive ruin-recreate perturbation in the post-processing phase significantly improves solution quality by escaping local optima.\n**Program Identifier:** Generation 57 - Patch Name tune_config_params - Correct Program: True\n\n**Program Name: Cubic-Weighted Beam Search with Multi-Target Lookahead and Hybrid ILS**\n- **Implementation**: Implements beam search using conflict-volume urgency and cubic-weighted sampling, enhanced by a multi-target lookahead that checks compatibility with upcoming urgent tasks. The schedule is refined via hybrid Iterated Local Search combining block moves and ruin-and-recreate strategies.\n- **Performance**: Achieved a combined score of 3.55, indicating superior optimization of transaction makespan.\n- **Feedback**: The multi-target lookahead effectively mitigates short-sighted greedy placements, while the specific combination of block moves and LNS allows the algorithm to robustly reorganize parallel transaction clusters.\n**Program Identifier:** Generation 58 - Patch Name cubic_beam_lns - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Adaptive Stagnation-Based ILS**\n- **Implementation**: Utilizes an urgency-weighted beam search with a multi-target lookahead metric to build initial schedules, followed by an adaptive Iterated Local Search that escalates perturbation intensity (swaps, block moves, ruin-and-recreate) based on stagnation counters.\n- **Performance**: Achieved a combined score of 3.51, effectively optimizing makespan across diverse workloads.\n- **Feedback**: The lookahead metric prevents short-sighted greedy decisions by evaluating future compatibility of urgent tasks, while the adaptive perturbation robustly escapes local optima by varying disruption levels.\n**Program Identifier:** Generation 59 - Patch Name adaptive_ils_beam - Correct Program: True\n\n**Program Name: Hybrid Beam Search with Lookahead and Ruin-and-Recreate ILS**\n- **Implementation**: This approach combines Beam Search using cubic-weighted sampling and a 1-step lookahead for \"heavy\" transactions, followed by Iterated Local Search (ILS) with a ruin-and-recreate perturbation strategy.\n- **Performance**: The algorithm achieved a combined score of 4.02, demonstrating effective optimization through sophisticated lookahead heuristics and aggressive local refinement.\n- **Feedback**: The multi-target lookahead significantly improves the construction phase by anticipating critical transaction placements, while the ruin-and-recreate mechanic successfully prevents the scheduler from getting stuck in local optima.\n**Program Identifier:** Generation 60 - Patch Name cubic_weighted_beam_ruin_recreate - Correct Program: True\n\n**Program Name: Cubic-Weighted Beam Search with Stagnation-Based Adaptive ILS**\n- **Implementation**: This approach constructs schedules using a beam search with cubic-weighted sampling and multi-target lookahead to prioritize urgent tasks, followed by an adaptive Iterated Local Search that escalates perturbation intensity (from swaps to ruin-and-recreate) based on stagnation.\n- **Performance**: The algorithm achieved a strong combined score of 3.66, indicating high efficiency across diverse workloads.\n- **Feedback**: The cubic weighting effectively biases selection toward high-impact transactions while maintaining diversity, and the lookahead mechanism combined with adaptive perturbation helps the solver anticipate bottlenecks and escape local optima robustly.\n**Program Identifier:** Generation 61 - Patch Name adaptive_cubic_beam - Correct Program: True\n\n**Program Name: Prospector Beam Search with Scramble-Enhanced ILS**\n- **Implementation**: Uses a beam search with a \"prospector\" lookahead to test candidates against future high-urgency tasks, followed by Iterated Local Search employing block scrambling and windowed insertion.\n- **Performance**: Achieved a combined score of 3.56, successfully optimizing makespan across all workloads with valid schedules.\n- **Feedback**: The lookahead mechanism effectively prevents early scheduling of blocking transactions, while block-level perturbations allow the local search to escape local optima caused by dense conflict clusters.\n**Program Identifier:** Generation 62 - Patch Name prospector_schedule - Correct Program: True\n\n**Program Name: Quartic Beam Search with Deep Lookahead and Adaptive ILS**\n- **Implementation**: Uses beam search with $d^4$ urgency sampling and 5-step lookahead to build schedules, refined by an ILS that escalates perturbation intensity (from swaps to ruin-recreate) upon stagnation.\n- **Performance**: Achieved a high combined score of 3.51, demonstrating excellent optimization capability.\n- **Feedback**: The aggressive urgency-based sampling combined with adaptive perturbation mechanics effectively balances greedy exploitation of bottlenecks with robust mechanisms to escape local optima.\n**Program Identifier:** Generation 63 - Patch Name quartic_weighted_deep_lookahead - Correct Program: True\n\n**Program Name: Hybrid Beam Search with Quartic Sampling and Ruin-and-Recreate ILS**\n- **Implementation**: Combines Beam Search using quartic-weighted sampling and optimistic lookahead with a post-processing Ruin-and-Recreate Iterated Local Search (ILS) that strategically removes and reinserts transactions.\n- **Performance**: Achieved a combined score of 3.97.\n- **Feedback**: The heavy-tailed sampling prioritizes difficult transactions during construction, while the ILS phase effectively refines the schedule by escaping local optima through targeted perturbation and greedy re-insertion.\n**Program Identifier:** Generation 64 - Patch Name quartic_beam_ruin_recreate - Correct Program: True\n\n**Program Name: Average-Lookahead Beam Search with Chain-Ruin ILS**\n- **Implementation**: Implements Beam Search using a lookahead metric that weighs the minimum and average costs of subsequent urgent items, followed by an Iterated Local Search that removes and greedily reinserts contiguous blocks to fix dependency chains.\n- **Performance**: Achieved a combined maximization score of 3.69 across the validation workloads.\n- **Feedback**: The lookahead strategy effectively balances immediate makespan impact with future scheduling flexibility, while the block-based perturbation helps resolve suboptimal transaction ordering in dense dependency areas.\n**Program Identifier:** Generation 65 - Patch Name avg_lookahead_beam_chain_ils - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Stagnation-Adaptive ILS**\n- **Implementation**: Features a beam search using quartic probability weighting and multi-target lookahead, followed by an Iterated Local Search that escalates perturbation intensity (swap to ruin-and-recreate) based on search stagnation.\n- **Performance**: Achieved a strong combined score of 3.41, indicating high solution quality across workloads.\n- **Feedback**: The deep lookahead mechanism checking the top-6 urgent followers significantly improved the initial schedule, while the adaptive perturbation strategy effectively broke local optima without unnecessary computational overhead.\n**Program Identifier:** Generation 66 - Patch Name quartic_beam_deep_lookahead - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Ruin-and-Recreate ILS**\n- **Implementation**: Implements Beam Search with 1-step lookahead and quartic weighted sampling to construct initial schedules, followed by an Iterated Local Search using ruin-and-recreate perturbation with best-fit reinsertion.\n- **Performance**: Achieved a high combined score of 3.95, demonstrating robust optimization of transaction makespans.\n- **Feedback**: The integration of lookahead to prevent myopic greedy choices and a ruin-and-recreate strategy for escaping local optima proved highly effective, balancing exploration and exploitation well.\n**Program Identifier:** Generation 67 - Patch Name improved_scheduling_params_and_ils - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Deduplication and Block-Move ILS**\n- **Implementation**: Uses beam search with quartic-weighted sampling and set-based deduplication to construct schedules, refining them via an Iterated Local Search that employs \"Smart Block Moves\" and Ruin-and-Recreate strategies.\n- **Performance**: Achieved a strong combined score of 3.52 across three workloads.\n- **Feedback**: The combination of aggressive urgency weighting and lookahead validation ensures critical transactions are prioritized, while state deduplication prevents the beam search from converging too early on suboptimal paths.\n**Program Identifier:** Generation 68 - Patch Name quartic_dedup_beam_ils - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Ruin-and-Recreate ILS**\n- **Implementation**: It employs Beam Search with quartic-weighted sampling ($d^4$) and optimistic lookahead, followed by a Ruin-and-Recreate Iterated Local Search using swaps, block moves, and greedy re-insertion.\n- **Performance**: The solution achieved a combined score of 4.02, indicating highly efficient scheduling.\n- **Feedback**: The aggressive weighting strategy effectively prioritizes costly transactions, while the multi-operator local search and lookahead mechanism successfully navigate complex dependencies to minimize idle time.\n**Program Identifier:** Generation 69 - Patch Name ILS_BlockMoves_LargerRuin - Correct Program: True\n\n**Program Name: Quartic Beam Search with Optimistic Lookahead and Hybrid ILS**\n- **Implementation**: The algorithm employs a beam search using quartic-weighted sampling and optimistic multi-target lookahead to prioritize large transactions, followed by a hybrid Ruin-and-Recreate ILS that alternates between block and scatter perturbation strategies.\n- **Performance**: It achieved a high combined score of 3.94, demonstrating strong optimization capabilities across varying transaction workloads.\n- **Feedback**: The optimistic lookahead effectively balanced immediate packing efficiency with future compatibility for heavy items, while the dual-mode perturbation in the ILS phase successfully refined schedules by disrupting different types of local optima.\n**Program Identifier:** Generation 70 - Patch Name quartic_beam_multi_target_lookahead - Correct Program: True\n\n**Program Name: Cubic-Weighted Beam Search with Block-Move ILS**\n- **Implementation**: Constructs schedules using beam search with cubic-weighted sampling and optimistic lookahead, followed by an Iterated Local Search (ILS) that utilizes block insertions to relocate clusters of transactions.\n- **Performance**: Achieved a combined score of 3.91, indicating highly efficient makespan reduction.\n- **Feedback**: The block-move strategy effectively escapes local optima by preserving tight transaction clusters, while cubic weighting ensures a robust balance between greedy selection and exploration.\n**Program Identifier:** Generation 71 - Patch Name cubic_weights_and_block_moves - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Extended ILS**\n- **Implementation**: This approach uses beam search with aggressive quartic ($d^4$) weighted sampling and a multi-target lookahead, followed by Iterated Local Search featuring specific block moves and ruin-and-recreate perturbation.\n- **Performance**: The solution achieved a high combined score of 3.98, demonstrating strong optimization capabilities across complex mixed workloads.\n- **Feedback**: The aggressive sampling weights effectively prioritize heavy transactions, while the addition of small block moves in the local search phase helps resolve coupled dependencies that standard swaps miss.\n**Program Identifier:** Generation 72 - Patch Name quartic_beam_extended_ils - Correct Program: True\n\n**Program Name: Quartic-Anchored Beam Search with Threshold-Acceptance ILS**\n- **Implementation**: Combines beam search using quartic-weighted sampling and a hybrid lookahead metric with Iterated Local Search employing Ruin-and-Recreate and threshold acceptance.\n- **Performance**: Achieved a high combined score of 3.75, demonstrating superior optimization capability across workloads.\n- **Feedback**: The integration of deterministic \"anchor\" moves with aggressive sampling and a lookahead metric successfully balanced stability and exploration, while threshold acceptance robustly handled local optima escape.\n**Program Identifier:** Generation 73 - Patch Name quartic_anchored_threshold_ils - Correct Program: True\n\n**Program Name: Quartic Prospector Beam Search with Adaptive Ruin ILS**\n- **Implementation**: The algorithm employs a beam search utilizing aggressive quartic urgency weighting and lookahead validation, followed by an Iterated Local Search (ILS) that adaptively switches between block scrambling and ruin-and-recreate strategies.\n- **Performance**: It achieved a high combined score of 3.62, effectively minimizing makespan across diverse workloads.\n- **Feedback**: The combination of aggressive urgency-based sampling with lookahead successfully prioritized critical path tasks, while the adaptive perturbation mechanisms prevented stagnation in local optima.\n**Program Identifier:** Generation 74 - Patch Name quartic_prospector_adaptive_ils - Correct Program: True\n\n**Program Name: Quartic Beam Search with Lookahead and Threshold ILS**\n- **Implementation**: Combines beam search using quartic-weighted sampling and one-step lookahead with an Iterated Local Search employing ruin-recreate and threshold acceptance criteria.\n- **Performance**: Achieved a superior combined score of 3.95, demonstrating highly effective makespan reduction.\n- **Feedback**: The aggressive quartic weighting and lookahead successfully prioritize costly transactions early, while the threshold-based acceptance in ILS provides robust refinement against local optima.\n**Program Identifier:** Generation 75 - Patch Name threshold_ils_beam - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Threshold ILS**\n- **Implementation**: Implements a beam search using quartic-weighted sampling ($d^4$) and optimistic lookahead to prioritize heavy transactions, followed by a ruin-and-recreate Iterated Local Search (ILS) with threshold acceptance.\n- **Performance**: Achieved a strong combined score of 3.97, successfully optimizing makespan across all three workloads.\n- **Feedback**: The aggressive weighting towards long transactions combined with a sophisticated local search refinement phase effectively escaped local optima to find high-quality schedules.\n**Program Identifier:** Generation 76 - Patch Name improved_scheduling_algorithm - Correct Program: True\n\n**Program Name: Quartic Beam Search with Threshold-Acceptance ILS**\n- **Implementation**: Uses beam search with hybrid quartic/LPT sampling and multi-target lookahead, followed by Iterated Local Search employing threshold acceptance and specific ruin-recreate strategies.\n- **Performance**: Achieved a high combined score of 3.95, indicating effective minimization of transaction makespans.\n- **Feedback**: The combination of aggressive lookahead during construction and threshold-based acceptance during refinement effectively balances exploration and exploitation to escape local optima.\n**Program Identifier:** Generation 77 - Patch Name quartic_beam_threshold_ils - Correct Program: True\n\n**Program Name: Quartic-Anchored Beam Search with Threshold-Acceptance ILS**\n- **Implementation**: Constructs schedules using beam search that mixes deterministic top-k anchors with quartic-weighted sampling and a hybrid lookahead metric evaluating subsequent item compatibility. Refinement employs Iterated Local Search with aggressive ruin-and-recreate perturbations and a threshold acceptance mechanism to escape local optima.\n- **Performance**: Achieved a combined score of 3.72, indicating strong optimization performance.\n- **Feedback**: The blend of deterministic anchors and steep probability sampling during construction provides high-quality initial solutions, while the threshold acceptance criterion effectively allows the local search to navigate out of local minima without relying solely on random restarts.\n**Program Identifier:** Generation 78 - Patch Name quartic_anchored_threshold_ils - Correct Program: True\n\n**Program Name: Hybrid Beam Search with Quartic Sampling and Threshold ILS**\n- **Implementation**: Constructs schedules using beam search with optimistic lookahead and quartic-weighted sampling, followed by Iterated Local Search utilizing ruin-and-recreate with threshold acceptance.\n- **Performance**: Achieved a combined score of 3.95, indicating highly efficient makespan minimization.\n- **Feedback**: The integration of lookahead heuristics during construction and non-monotonic acceptance criteria during refinement enables the algorithm to effectively navigate the search space and escape local optima.\n**Program Identifier:** Generation 79 - Patch Name quartic_weighted_beam_and_threshold_ils - Correct Program: True\n\n**Program Name: Quintic-Anchored Beam Search with Deep-Optimistic Lookahead**\n- **Implementation**: Combines beam search using quintic probability weighting and top-5 lookahead scoring with an Iterated Local Search featuring threshold acceptance and flexible ruin-and-recreate perturbations.\n- **Performance**: Achieved a combined score of 3.48 across three workloads with valid execution.\n- **Feedback**: The heavy weighting on conflict volume and the optimistic lookahead metric effectively prioritize unblocking critical paths, while aggressive perturbation prevents stagnation in local optima.\n**Program Identifier:** Generation 80 - Patch Name quintic_beam_aggressive_ils - Correct Program: True\n\n**Program Name: Expanded-Anchor Beam Search with Threshold-Ruin ILS**\n- **Implementation**: The solution employs a beam search that prioritizes stability via top-4 deterministic anchors and quartic probability sampling, refining results with an Iterated Local Search using aggressive ruin-and-recreate and threshold acceptance.\n- **Performance**: It achieved a high combined score of 3.72, demonstrating strong optimization capabilities across varied workloads.\n- **Feedback**: The expansion of deterministic anchors stabilizes the critical path during construction, while the aggressive ruin strategy effectively disrupts local optima caused by dense transaction dependencies.\n**Program Identifier:** Generation 81 - Patch Name quartic_anchor_ils - Correct Program: True\n\n**Program Name: Quartic-Anchored Beam Search with Hybrid Chain-Ruin ILS**\n- **Implementation**: Utilizes a beam search with quartic-weighted sampling and top-4 compatibility lookahead, followed by an Iterated Local Search using chain ruin, scattered ruin, and block moves to refine the schedule.\n- **Performance**: Achieved a combined score of 3.65, successfully generating valid schedules with optimized makespans.\n- **Feedback**: The lookahead metric effectively balances immediate costs with future compatibility, while the hybrid perturbation strategies successfully break dependency chains to escape local optima.\n**Program Identifier:** Generation 82 - Patch Name hybrid_chain_quartic_ils - Correct Program: True\n\n**Program Name: Quartic-Anchored Beam Search with Threshold-Adaptive ILS**\n- **Implementation**: Utilizes beam search with quartic probability sampling and hybrid lookahead, followed by an adaptive Iterated Local Search employing threshold acceptance and variable perturbation strategies like ruin-and-recreate.\n- **Performance**: Achieved a combined optimization score of 3.58 across three workloads.\n- **Feedback**: The aggressive quartic weighting successfully prioritized critical paths, while the threshold-based acceptance criterion in the local search effectively managed escapes from local optima to refine the schedule.\n**Program Identifier:** Generation 83 - Patch Name quartic_beam_threshold_ils - Correct Program: True\n\n**Program Name: Quartic Beam Search with Adaptive ILS**\n- **Implementation**: Utilizes beam search with quartic ($d^4$) probability weighting and idle-time lookahead for construction, followed by an adaptive ILS with ruin-recreate and multi-stage local search (insertion, block moves, swap).\n- **Performance**: Achieved a combined score of 4.02, demonstrating strong optimization of makespan across workloads.\n- **Feedback**: The heavy bias towards long transactions combined with the specific \"idle time\" heuristic ($Cost - Duration$) allows for high-quality initial schedules that are further refined by aggressive local search.\n**Program Identifier:** Generation 84 - Patch Name quartic_beam_adaptive_ils - Correct Program: True\n\n**Program Name: Quad-Anchor Beam Search with Aggressive Ruin ILS**\n- **Implementation**: Implements a constructive beam search using urgency-based \"quad-anchors\" and weighted lookahead for initial sequencing, followed by an Iterated Local Search using aggressive scattered ruin and block moves with threshold acceptance.\n- **Performance**: Achieved a combined score of 3.58, demonstrating effective makespan minimization across complex workloads.\n- **Feedback**: The deterministic selection of highly conflicting \"anchor\" transactions stabilizes the critical path during construction, while the aggressive perturbation strategies effectively restructure the sequence to escape local optima.\n**Program Identifier:** Generation 85 - Patch Name quad_anchor_beam_aggressive_ruin_ils - Correct Program: True\n\n**Program Name: Lookahead Beam Search with Hybrid Sampling and ILS**\n- **Implementation**: The algorithm employs Beam Search with a 1-step lookahead and quartic weighted sampling to construct initial schedules, followed by an Iterated Local Search (ILS) using \"ruin and recreate\" perturbation with best-fit re-insertion.\n- **Performance**: It achieved a combined score of 4.12, demonstrating robust optimization capabilities across multiple workloads.\n- **Feedback**: The integration of lookahead logic mitigates myopic greedy errors during construction, while the specific LPT-prioritized ruin and recreate strategy effectively refines the schedule to escape local optima.\n**Program Identifier:** Generation 86 - Patch Name optimize_ils_and_beam_config - Correct Program: True\n\n**Program Name: Hybrid Beam Search with Quartic Sampling and Threshold ILS**\n- **Implementation**: Combines beam search using quartic-weighted ($d^4$) sampling and optimistic lookahead with an Iterated Local Search employing threshold acceptance and extensive neighborhood moves (swaps, insertions, block moves).\n- **Performance**: Achieved a combined score of 3.97, indicating strong optimization capabilities across varying transaction complexities.\n- **Feedback**: The aggressive prioritization of long transactions via quartic weights and lookahead effectively establishes a solid structure, while the threshold-based ILS robustly fine-tunes the schedule by allowing slight degradations to escape local optima.\n**Program Identifier:** Generation 87 - Patch Name quartic_beam_threshold_ils - Correct Program: True\n\n**Program Name: Hyper-Anchored Beam Search with Conflict-Biased Threshold ILS**\n- **Implementation**: Utilizes beam search with quartic sampling and a conflict-heavy urgency heuristic, refined by Threshold ILS using aggressive ruin-and-recreate and windowed local descent.\n- **Performance**: Achieved a combined maximization score of 3.57.\n- **Feedback**: The algorithm's heavy weighting (70%) on conflict volume effectively unblocks dependencies, while the hybrid lookahead metric balances immediate costs with future scheduling flexibility.\n**Program Identifier:** Generation 88 - Patch Name hyper_anchor_ils - Correct Program: True\n\n**Program Name: Quartic-Anchored Beam Search with Threshold ILS**\n- **Implementation**: Computes transaction urgency via conflict volume to drive a beam search with deterministic anchors and quartic sampling, followed by an ILS phase using threshold acceptance and large-neighborhood search.\n- **Performance**: Achieved a high combined score of 3.66, indicating robust scheduling efficiency across diverse workloads.\n- **Feedback**: The hybrid lookahead and aggressive perturbation strategies (ruin-recreate) effectively balance exploring the search space and exploiting critical transaction orderings to escape local optima.\n**Program Identifier:** Generation 89 - Patch Name improved_scheduling_quartic_anchored_beam_threshold_ils - Correct Program: True\n\n**Program Name: Hybrid Quartic Beam Search with Threshold ILS**\n- **Implementation**: The solution implements a beam search utilizing quartic-weighted sampling ($cost^4$) and optimistic lookahead for initial construction, followed by an Iterated Local Search (ILS) using ruin-and-recreate perturbation and threshold acceptance.\n- **Performance**: The algorithm achieved a high combined score of 4.10, indicating effective optimization across all workloads.\n- **Feedback**: The aggressive quartic weighting successfully prioritized costly transactions during construction, while the multi-operator ILS phase (swaps, block moves, insertions) effectively refined the schedule by escaping local optima.\n**Program Identifier:** Generation 90 - Patch Name hybrid_quartic_beam_ils - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Ruin-and-Recreate ILS**\n- **Implementation**: Combines beam search using optimistic lookahead and quartic weighting for heavy transactions with a hybrid ruin-and-recreate local search utilizing block and scatter perturbation.\n- **Performance**: Achieved a high combined score of 3.91, indicating excellent optimization of schedule makespans.\n- **Feedback**: The aggressive LPT-based weighting and multi-target lookahead effectively guide the global search, while the hybrid perturbation strategy ensures robust local refinement.\n**Program Identifier:** Generation 91 - Patch Name optimize_search_parameters - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Threshold ILS**\n- **Implementation**: Uses beam search with $d^4$ weighted sampling and lookahead for construction, followed by Iterated Local Search with aggressive ruin-recreate perturbation and threshold acceptance.\n- **Performance**: Achieved a combined score of 4.00, effectively minimizing total makespan across all workloads.\n- **Feedback**: The high-degree polynomial weighting in beam search effectively prioritized costly transactions, while the aggressive ruin-recreate phase in ILS successfully refined the schedule to escape local optima.\n**Program Identifier:** Generation 92 - Patch Name quartic_ils_scheduling - Correct Program: True\n\n**Program Name: Quartic-Weighted Beam Search with Threshold ILS**\n- **Implementation**: Utilizes beam search with quartic-weighted sampling ($d^4$) and multi-target optimistic lookahead for construction, followed by a ruin-and-recreate ILS using threshold acceptance.\n- **Performance**: Achieved a combined score of 4.05, demonstrating superior minimization of makespan across workloads.\n- **Feedback**: The aggressive weighting towards heavy transactions combined with lookahead produces strong initial solutions, while the threshold acceptance in ILS effectively refines the schedule by allowing controlled degradation to escape local optima.\n**Program Identifier:** Generation 93 - Patch Name tune_params_to_best_historical - Correct Program: True\n\n**Program Name: Tri-Anchor Beam Search with Tight-Threshold ILS**\n- **Implementation**: The algorithm utilizes a beam search blending three deterministic anchors with quartic-weighted sampling, followed by an Iterated Local Search (ILS) that applies aggressive ruin-and-recreate moves under a strict 0.2% acceptance threshold. Priority is assigned via a composite urgency score weighting transaction duration and conflict volume.\n- **Performance**: It achieved a combined optimization score of 3.56 across the three workloads.\n- **Feedback**: The strategy of mixing deterministic high-urgency anchors with heavy-tailed sampling effectively balances greedy exploitation with exploration, while the tight ILS threshold fine-tunes the result without disrupting the global structure.\n**Program Identifier:** Generation 94 - Patch Name tri_anchor_beam_tight_ils - Correct Program: True\n\n**Program Name: Quintic-Anchored Beam Search with Hybrid Lookahead and Threshold ILS**\n- **Implementation**: This approach utilizes a Beam Search with quintic ($d^5$) weighted sampling and deterministic anchors, evaluating candidates via a hybrid lookahead metric that mixes best and average next-step costs. It refines the schedule using Iterated Local Search (ILS) with aggressive Ruin-and-Recreate perturbations and a threshold acceptance criterion allowing 0.2% degradation to escape local optima.\n- **Performance**: The algorithm achieved a Combined Score of 3.85, indicating strong performance driven by the lookahead mechanism and robust local search.\n- **Feedback**: The hybrid lookahead metric effectively balances immediate gains with future schedule compatibility, while the threshold acceptance logic prevents the local search from stagnating. The aggressive weighting in the sampling strategy ensures the algorithm prioritizes critical path items heavily while maintaining sufficient diversity for optimization.\n**Program Identifier:** Generation 95 - Patch Name quintic_beam_weighting - Correct Program: True\n\n**Program Name: Quintic-Weighted Beam Search with Adaptive Ruin-and-Recreate ILS**\n- **Implementation**: Combines a beam search using quintic ($d^5$) weighting and multi-target lookahead to prioritize heavy transactions with an Iterated Local Search featuring aggressive ruin-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 4.05, indicating excellent optimization of transaction makespans.\n- **Feedback**: The aggressive polynomial weighting effectively forces early scheduling of costly transactions (\"big rocks\"), while the perturbation-based refinement phase successfully escapes local optima inherent in greedy construction.\n**Program Identifier:** Generation 96 - Patch Name quintic_beam_ils - Correct Program: True\n\n**Program Name: Quintic-Anchored Beam Search with Threshold-Acceptance ILS**\n- **Implementation**: Utilizes beam search with sextic ($d^6$) weighted sampling and hybrid lookahead to build schedules, refined by Iterated Local Search using Ruin-and-Recreate perturbations and linear threshold acceptance.\n- **Performance**: Achieved a combined score of 3.57, successfully generating valid schedules for all workloads.\n- **Feedback**: The aggressive heavy-tailed sampling combined with lookahead effectively prioritizes critical path items, while the threshold acceptance mechanism enables the local search to escape optima without the rigidity of strict hill-climbing.\n**Program Identifier:** Generation 97 - Patch Name sextic_beam_annealing_ils - Correct Program: True\n\n**Program Name: Quintic-Weighted Beam Search with Block-Move ILS**\n- **Implementation**: Features a beam search using quintic ($d^5$) weighted sampling and optimistic lookahead to prioritize long transactions, refined by an Iterated Local Search using swaps, block moves, and ruin-and-recreate.\n- **Performance**: Achieved a strong combined score of 4.03, demonstrating effective makespan reduction across workloads.\n- **Feedback**: The aggressive bias towards long transactions during construction and specific block-move operations during refinement were key implementation choices for efficiently handling complex transaction dependencies.\n**Program Identifier:** Generation 98 - Patch Name quintic_beam_ils - Correct Program: True\n\n**Program Name: Quintic-Expanded Beam Search with Threshold-Acceptance ILS**\n- **Implementation**: Constructs schedules using a beam search with urgency-based quintic sampling and a hybrid lookahead metric, followed by Iterated Local Search using ruin-and-recreate perturbations and threshold acceptance.\n- **Performance**: Achieved a high combined score of 3.79, demonstrating superior makespan optimization capabilities.\n- **Feedback**: The combination of stable deterministic anchors and aggressive sampling in the beam search provides a high-quality initial solution, which is further refined effectively by the threshold-based acceptance criterion.\n**Program Identifier:** Generation 99 - Patch Name quintic_expanded_beam - Correct Program: True",
  "meta_scratch_pad": "Based on the analysis of Generations 91-99, Previous Global Insights, and the Current Best Program (Generation 86), here are the specific optimization insights:\n\n## Successful Algorithmic Patterns\n*   **Polynomial Weighted Sampling ($d^4$ - $d^5$):** The highest-performing programs consistently used heavy-tailed probability weighting. Generation 86 ($d^4$, Score 4.12) and Generations 93 and 96 ($d^4$ and $d^5$ respectively, both Score 4.05) demonstrated that raising transaction duration to the 4th or 5th power provides the optimal balance of prioritizing \"big rocks\" while maintaining enough stochastic diversity to find better packing combinations than pure greedy sorts.\n*   **LPT-Sorted Repair in ILS:** A crucial differentiator for the Current Best Program (Gen 86) is its \"Recreate\" phase strategy. Unlike standard random re-insertion, it sorts the removed transactions by Longest Processing Time (LPT) before re-inserting them (`removed.sort(key=lambda t: txn_durations[t], reverse=True)`). This ensures that the local search prioritizes fitting the most difficult items first, leading to denser schedules.\n*   **Multi-Target Lookahead:** Programs that employed a specific \"Multi-Target\" lookahead (Gen 86, 93, 96)\u2014which explicitly evaluates the compatibility of the top 3-4 largest remaining transactions\u2014consistently outperformed those using generic \"average\" or \"hybrid\" lookahead metrics (Gen 95, 99). This targeted lookahead prevents the beam search from making choices that block the placement of specific high-cost items later.\n*   **Moderate Threshold Acceptance:** The most effective local search strategies (Gen 86, 93) utilized a moderate acceptance threshold (allowing ~0.5% degradation). This proved superior to \"Tight-Threshold\" approaches (Gen 94, 0.2% threshold), as it provides sufficient slack for the algorithm to traverse the rugged landscape of dependency conflicts without losing the global structure.\n\n## Ineffective Approaches\n*   **Over-Aggressive Sampling Bias ($d^6$):** Generation 97 increased the sampling weight to the sextic power ($d^6$) and saw a significant performance drop to 3.57. This indicates a ceiling for polynomial weighting; at $d^6$, the algorithm likely becomes too deterministic, mimicking a greedy heuristic that lacks the diversity required to solve complex conflict chains.\n*   **Restrictive Local Search Thresholds:** Generation 94 implemented a \"Tight-Threshold ILS\" allowing only 0.2% degradation and achieved a low score of 3.56. Compared to the 0.5% threshold in the best programs, this suggests that an overly strict acceptance criterion prevents the Ruin-and-Recreate phase from escaping local optima effectively.\n*   **Rigid Anchoring Strategies:** Generation 94's \"Tri-Anchor\" approach, which forced the beam search to include specific deterministic seeds, performed poorly (Score 3.56) compared to the fluid probabilistic approach of the higher-scoring programs. Hard-coded anchors appear to restrict the search space more than they help guide it when compared to $d^4/d^5$ sampling.\n\n## Implementation Insights\n*   **Sorting Repair Logic:** The effectiveness of the Current Best Program (Gen 86) is heavily tied to the implementation of the repair loop: `removed.sort(key=lambda t: txn_durations[t], reverse=True)`. This single line transforms the \"Recreate\" phase from a random shuffle into a directed optimization step that continually attempts to pack the most difficult transactions into the existing schedule holes.\n*   **Targeted Lookahead Implementation:** High-scoring implementations (Gen 86, 96) construct the lookahead set by filtering `sorted_lpt` against the `rem_set` to find specific high-value targets, rather than iterating through all next possible moves. This focuses computational resources on the critical path: `if t in rem_set: targets.append(t) ... if count >= 4: break`.\n*   **Optimized Beam Width Scaling:** The Current Best Program uses a dynamic beam width `max(10, num_seqs * 2.8)`. This scaling factor allows the search to be broad enough to capture diversity in complex workloads (Workload 1) while remaining efficient, whereas fixed or smaller widths in earlier generations limited exploration.\n\n## Performance Analysis\n*   **The \"Weighting Sweet Spot\":** There is a clear performance distribution curve based on sampling exponents. $d^4$ and $d^5$ algorithms cluster in the 4.00-4.12 range (Gen 86, 92, 93, 96, 98), while $d^6$ (Gen 97) drops to 3.57. This confirms that while bias toward long transactions is essential, retaining stochasticity ($d^4$ or $d^5$) is strictly better than near-deterministic selection ($d^6$).\n*   **Impact of Repair Strategy:** While Generation 96 achieved a high score of 4.05 using $d^5$ and aggressive perturbation, it did not surpass Generation 86 (4.12). The primary difference is Gen 86's structured LPT-repair versus standard perturbation. This structured repair provides a ~1.7% efficiency gain, which is significant at the high end of optimization.\n*   **Lookahead vs. Sampling:** Generation 92 achieved a score of 4.00 using $d^4$ sampling but without the specific \"Multi-Target\" lookahead of Gen 86/93. This suggests that while sampling provides the bulk of the performance (getting to 4.00), the specialized lookahead is responsible for the final optimization push to >4.05 by resolving specific future conflicts that probabilistic sampling might miss.",
  "meta_recommendations": "Based on the analysis of Generations 91-99, the Current Best Program (Generation 86), and the identified \"Sweet Spot\" in polynomial weighting, here are 5 actionable recommendations for future program mutations:\n\n1.  **Quintic ($d^5$) Probability Weighting**\n    The performance data indicates a peak between $d^4$ (Gen 86, Score 4.12) and $d^5$ (Gen 96, Score 4.05), with a sharp drop-off at $d^6$. To potentially squeeze more efficiency out of the \"Big Rocks First\" heuristic, shift the weighting exponent from 4 to 5 (`weights = [d**5 for d in pool]`). This increases the bias toward processing the longest transactions earliest\u2014crucial for defining the global schedule structure\u2014without becoming fully deterministic like the failed $d^6$ approach.\n\n2.  **Hybrid Ruin Strategy (Random + Block)**\n    The current best program's ILS removes 6-9 random items. Enhance this by introducing a probability (e.g., 50%) to remove a *contiguous block* of transactions (indices `i` to `i+k`) instead of random indices. Block removal effectively clears entire time windows of congestion, allowing the \"LPT-Sorted Repair\" logic to completely restructure dependency chains that have become locally entangled, rather than just patching individual holes.\n\n3.  **Expanded Multi-Target Lookahead**\n    Generation 86 evaluates the top 4 largest remaining transactions in its lookahead phase. Increase this horizon to check the top 6-8 targets. Since the cost of checking a few more candidates is low compared to the penalty of a bad placement, a slightly wider net ensures that the algorithm doesn't greedily block the placement of the 5th or 6th largest item, which often act as \"hidden\" bottlenecks in dense schedules.\n\n4.  **Annealed Acceptance Threshold**\n    Instead of a fixed 0.5% degradation threshold in the ILS loop, implement a \"Cooling Schedule\" (e.g., starting at 2.0% and decaying linearly to 0.1%). This allows the algorithm to accept larger structural changes (worsening the score significantly) early in the search to escape deep local optima, before tightening the constraints to fine-tune the solution in later iterations.\n\n5.  **Critical-Item Global Re-insertion**\n    In the `refine` (local search) function, the insertion window is currently limited to `w_ins=8` for efficiency. Modify this to allow **Global Insertion** (trying all possible positions) specifically for the top 10% longest transactions. These \"critical\" items often dictate the total makespan; checking all possible slots for them ensures they are not stuck in a suboptimal local basin that a",
  "meta_recommendations_history": [
    "Based on the analysis of the current best program (Gen 5) and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Integrate State Deduplication with Heuristic Tie-Breaking**\n    **Gen 9** (Score 3.39) demonstrated that ensuring the beam contains unique sets of *remaining* transactions (state deduplication) is effective, while **Gen 5** (Score 3.44) proved the superiority of the `(cost, -duration)` tie-breaker. You should combine these by modifying the beam update logic to reject candidates that result in a set of remaining transactions already present in the new beam with a lower or equal cost. This prevents the beam from being flooded by permutations of the same partial solution, effectively widening the search space without increasing the beam width.\n\n2.  **Implement Conflict-Aware Prioritization**\n    The success of the \"Heaviest-When-Neutral\" (LPT) heuristic in **Gen 5** suggests that scheduling \"difficult\" transactions early is beneficial. You should extend the priority tuple to include a precomputed \"conflict degree\" (the count of read/write overlaps a transaction has with others). Update the priority logic to `(new_cost, -conflict_degree, -duration)`, prioritizing transactions that block the most other work when immediate costs are equal, thereby resolving bottlenecks earlier in the schedule.\n\n3.  **Adopt Biased Probability Sampling**\n    **Gen 8** failed by strictly limiting sampling to LPT/SPT candidates, while **Gen 5** succeeded with uniform random sampling. You should implement a middle ground using **weighted probabilistic sampling**. Instead of `random.sample`, use `random.choices` where the weights are proportional to transaction duration or conflict degree. This statistically biases the search toward \"harder\" items (like LPT) while preserving the non-zero probability of selecting arbitrary items to escape local optima.\n\n4.  **Ensemble Beam Search Strategy**\n    Since the function receives a `num_seqs` budget (typically 10+), relying on a single heuristic logic may be limiting. You should split the computational budget to run two distinct Beam Search variations in parallel within `get_best_schedule`: one using the proven LPT tie-breaker `(cost, -duration)` and another using a variance-focused tie-breaker (e.g., `(cost, random.random())` or `(cost, -conflict)`). Returning the best schedule from the combined results exploits multiple traversal strategies simultaneously.\n\n5.  **Dynamic Beam Width Allocation**\n    Constructive algorithms are most sensitive to decisions made early in the sequence. You should implement a **tapered beam width** or sampling rate, where `BEAM_WIDTH` or `SAMPLES_PER_NODE` starts high (e.g., 2x the average) for the first 25% of transactions and linearly decreases. This reallocates the fixed computational time budget to the initial phase where structural choices have the largest impact on the final makespan.",
    "Based on the analysis of the current best program (Gen 18) and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Conflict-Aware Prioritization**\n    While Gen 18 successfully uses transaction duration as a proxy for complexity, it ignores specific read/write contentions. You should precompute a \"conflict degree\" for each transaction (the count of other transactions it overlaps with) and update the priority tuple to `(score, -conflict_degree, -total_dur)`. This prioritizes scheduling high-contention tasks early, clearing bottlenecks that duration alone does not capture.\n\n2.  **Adopt Tapered Beam Width Allocation**\n    Constructive heuristics are most sensitive to decisions made in the first 25% of the schedule. You should implement a dynamic `BEAM_WIDTH` that starts at roughly **2x the average width** and linearly decays to **0.5x** by the end of the sequence. This reallocates the fixed computational budget to the initial phase where structural choices have the largest impact on the final makespan.\n\n3.  **Enhance Refinement with Insertion Moves**\n    Gen 18 achieved a significant boost using windowed swaps. You should extend the `Local Search Refinement` phase to include **\"Shift/Insert\" operations**: iterate through the schedule, temporarily remove a transaction, and test re-inserting it at best positions within a local window (e.g., `\u00b15` indices). This handles dependency constraints better than swaps, which can get stuck in local optima when transactions are tightly packed.\n\n4.  **Ensemble Heuristic Search Strategy**\n    Gen 18 relies on a single heuristic logic (`cost - duration`). You should split the available `num_seqs` budget to run **two distinct, narrower beam searches** in parallel: one using the current LPT-focused logic and another prioritizing connectivity (e.g., `cost - conflict_degree`). Returning the best result from these parallel distinct strategies creates a robust portfolio approach that works across varied workload types.\n\n5.  **Stochastic One-Step Lookahead**\n    The current \"greedy\" beam expansion only evaluates the immediate cost. You should implement a **stochastic lookahead** for the top candidates: before finalizing the score, tentatively add one valid random or LPT transaction from the remaining set and use the *resulting* projected cost for ranking. This slight increase in evaluation depth helps avoid \"traps\" where a seemingly good move immediately blocks all optimal future moves.",
    "Based on the analysis of the top-performing Generation 24 and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Stochastic One-Step Lookahead**\n    The current greedy expansion evaluates candidates solely on the immediate `(Cost - TotalDuration)`. You should implement a **shallow lookahead** where, for the top $N$ candidates, you tentatively add the next best available LPT transaction and evaluate the *resulting* combined state. This helps the algorithm detect \"traps\" where a locally optimal move (small duration) blocks a critical large transaction in the immediate future, resolving the horizon effect inherent in greedy beam search.\n\n2.  **Iterated Local Search with Perturbation**\n    Gen 24 successfully uses a two-phase refinement (Swaps and Insertions) but stops once local convergence is reached. You should upgrade this to an **Iterated Local Search (ILS)**: when the refinement phases stabilize, apply a \"kick\" by randomly shuffling a small subsequence (e.g., 4-6 transactions) or swapping two distant transactions, then re-run the refinement loop. This \"perturbation and repair\" cycle allows the schedule to escape the local optima that deterministic refinement often settles into.\n\n3.  **Weighted Probabilistic Sampling**\n    The current approach fills the beam with `random.sample` (uniform probability) after selecting the top 3 LPT tasks. You should replace this with **Weighted Random Sampling** (e.g., `random.choices` with weights), prioritizing transactions based on Duration or Conflict Degree. This \"Soft LPT\" approach maintains the necessary stochastic diversity to prevent beam collapse while biasing the search towards structurally significant tasks, rather than wasting cycles on trivial, low-impact transactions.\n\n4.  **",
    "Based on the analysis of the Global Insights and the Current Best Program (Generation 33), here are 5 actionable recommendations for future program mutations:\n\n1.  **Multi-Cycle Iterated Local Search (ILS)**\n    The current best program performs only a single \"Perturb and Repair\" step after the initial descent. You should wrap this logic in a loop that runs for a fixed number of iterations (e",
    "Based on the analysis of the Global Insights and the current best program (Generation 48), here are 5 actionable recommendations for future program mutations:\n\n1.  **Cubic-Weighted Stochastic Sampling**\n    The shift from linear to squared weighting ($d^2$) was the primary driver of the recent performance leap (3.73 $\\to$ 3.89). You should test **Cubic Weighting ($d^3$)** in the beam search sampling phase. A steeper probability curve will further prioritize the critical \"heavy\" transactions that determine the makespan, while the stochastic nature prevents the search from becoming purely greedy.\n\n2.  **Multi-Target 1-Step Lookahead**\n    The current lookahead validates candidates by tentatively scheduling only the *single* largest remaining transaction. You should expand this to evaluate the **Top-2 or Top-3 largest remaining transactions** and use the best resulting score. This prevents the algorithm from discarding a promising branch simply because the absolute largest item caused a conflict, whereas the second-largest might have fit perfectly, adding robustness with negligible overhead.\n\n3.  **Block-Move Local Search Neighborhood**\n    The current Iterated Local Search (ILS) relies on single-item Swaps and Insertions. You should implement a **Block Insertion Neighborhood** that moves contiguous subsequences of transactions (e.g., blocks of size 2 or 3) to new positions. This allows the algorithm to relocate efficient \"sub-assemblies\" of parallel transactions without breaking their internal structure, which single-item moves often destroy.\n\n4.  **Ruin-and-Recreate Perturbation (LNS)**\n    The current random swap \"kick\" is sometimes insufficient to escape deep local optima. You should introduce a **Ruin-and-Recreate** perturbation strategy (Large Neighborhood Search): remove a small set of random transactions (e.g., 3 to 5) from the schedule and re-insert them using a greedy best-fit logic. This structural disruption is often more effective than swaps for repairing \"jammed\" packing arrangements.\n\n5.  **Stagnation-Based Adaptive Kicking**\n    Instead of the current deterministic cycle (double swap every 3rd iteration), implement a reactive **Stagnation Counter**. Track the number of ILS cycles without a global improvement and dynamically increase the perturbation intensity (e.g., number of swaps or size of the ruin set) as the counter rises. This ensures the algorithm applies aggressive disruption only when trapped in a particularly stubborn local optimum.",
    "Based on the analysis of Generations 51-60 and the success of the Current Best Program (Gen 60), here are 5 actionable recommendations for future program mutations:\n\n1.  **Quartic-Weighted Stochastic Sampling ($d^4$)**\n    The performance trend shows a direct correlation between the \"steepness\" of the weighting curve and score (Linear $\\to$ Squared $\\to$ Cubic). You should implement **Quartic Weighting ($d^4$)** for the stochastic pool in the beam search. This will virtually eliminate low-cost items from early consideration, ensuring the algorithm focuses even more aggressively on packing the heavy \"rocks\" first, while still retaining just enough randomness to break ties.\n\n2.  **Expanded Multi-Target Lookahead**\n    The move from 1-target to 3-target lookahead provided significant gains by identifying compatibility issues earlier. You should expand this to evaluate the **Top-5 or Top-6 largest remaining transactions**. Since the `frozenset` deduplication effectively limits the number of states, slightly increasing the validation breadth per state will increase the probability of finding a \"perfect fit\" for the critical path with minimal computational penalty.\n\n3.  **Block-Based Local Search Neighborhood**\n    While the current ILS uses single-item Swaps and Insertions, it lacks the ability to move \"clusters\" of transactions",
    "Based on the analysis of Generations 61-70 and the successful mechanisms in the current best program (Gen 69/60), here are 5 actionable recommendations for future program mutations:\n\n1.  **Quartic ($d^4$) Probability Weighting**\n    Align with the performance trend observed in Gen 69 by increasing the stochastic weighting exponent from Cubic ($d^3$) to **Quartic ($d^4$)**. This steeper curve will virtually eliminate low-cost items from selection during the early beam search phases, enforcing a stricter \"heavy-items-first\" policy that maximizes packing density while retaining just enough variance to break ties.\n\n2.  **Threshold-Based ILS Acceptance**\n    The current ILS implementation is strictly greedy (only accepts improvements), which limits exploration. Implement a **Threshold Acceptance** mechanism (or mild Simulated Annealing) that allows the acceptance of a \"Recreated\" schedule even if it is slightly worse (e.g., cost increases by < 1%) than the current state. This will help the algorithm escape the deep local optima that a purely greedy \"Ruin-and-Recreate\" can get stuck in.\n\n3.  **Aggressive Ruin Set Sizing**\n    The current perturbation removes only 3-5 items, which may be insufficient to untangle complex dependency knots in dense schedules. Increase the size of the \"Ruin\" set to **5-8 transactions**. A more destructive perturbation forces the \"Greedy Best-Fit\" repair logic to reconstruct larger contiguous segments of the schedule, leveraging its efficiency to find better global arrangements.\n\n4.  **Top-4 Lookahead Target Set**\n    Data indicates a performance cliff between Top-3 (successful) and Top-6 (too slow/diluted) lookaheads. Refine the multi-target lookahead to evaluate exactly the **Top-4 remaining LPT transactions**. This incremental expansion provides better visibility into near-term bottlenecks without incurring the computational overhead that caused the deeper lookahead variants (Gen 66) to fail.\n\n5.  **Deterministic \"Anchor\" Expansion**\n    The current beam search forces the top 2 LPT candidates into the next generation to prevent \"bad luck.\" Increase this **deterministic anchor count to 3 or 4**. By guaranteeing that a larger portion of the theoretically \"best\" local moves are always preserved, you stabilize the beam's trajectory along the critical path, allowing the stochastic samples to focus purely on finding high-risk/high-reward shortcuts.",
    "Based on the analysis of the current best program (Generation 69) and the successful trends identified in previous generations, here are 5 actionable recommendations for future program mutations. These recommendations focus on intensifying the heuristic biases that have proven effective and introducing controlled stochasticity to escape local optima.\n\n1.  **Quartic ($d^4$) Probability Weighting**\n    The current program uses Cubic ($d^3$) weighting for random sampling, which successfully prioritizes heavy transactions. Increase this exponent to **Quartic ($d^4$)** (`weights = [d**4 for d in pool]`). This steeper probability curve will nearly eliminate the selection of low-cost items in early beam search phases, strictly enforcing a \"heavy-items-first\" packing strategy while retaining just enough randomness to break ties among top candidates.\n\n2.  **Threshold-Based ILS Acceptance**\n    The current Iterated Local Search (ILS) uses a strictly greedy acceptance criterion (`if p_cost < curr_cost`), which limits exploration. Implement a **Threshold Acceptance** mechanism that accepts a perturbed schedule if its cost is within a small margin (e.g., 0.5% to 1%) of the current cost (`p_cost < curr_cost * 1.005`). This relaxation allows the algorithm to traverse \"valleys\" in the fitness landscape to find better global optima.\n\n3.  **Aggressive Ruin Set Sizing (6-9 Items)**\n    The current \"Ruin\" perturbation removes only 3-5 items, which is often insufficient to disrupt complex dependency knots in dense schedules. Increase the ruin set size to **6-9 transactions**. Removing a larger chunk of the schedule forces the \"Greedy Best-Fit\" repair logic to reconstruct more significant segments of the timeline, potentially finding much tighter packing arrangements.\n\n4.  **Top-4 Lookahead Target Set**\n    The current multi-target lookahead evaluates the Top-3 remaining LPT transactions, which has proven effective. Incrementally expand this to evaluate the **Top-4 remaining LPT transactions**. This slight expansion provides better visibility into near-term bottlenecks and resource contention without incurring the prohibitive computational cost of significantly deeper or wider lookaheads.\n\n5.  **Increased Deterministic Anchor Count**\n    The current beam search preserves the top 2 LPT candidates deterministically to prevent \"bad luck\" from discarding the theoretical best moves. Increase this anchor count to **4 candidates**. By guaranteeing that a larger portion of the beam follows the critical path heuristic, you stabilize the search trajectory, allowing the remaining stochastic samples to focus purely on finding high-risk/high-reward shortcuts without risking the baseline performance.",
    "Based on the analysis of the current best program (Generation 86) and the successful trends identified in Generations 81-90, here are 5 actionable recommendations for future program mutations. These recommendations aim to intensify the \"Big Rocks First\" packing efficiency while improving the algorithm's ability to escape local optima through smarter perturbation.\n\n1.  **Quintic ($d^5$) Probability Weighting**\n    The shift from cubic ($d^3$) to quartic ($d^4$) weighting significantly improved performance by effectively forcing the beam search to prioritize the longest transactions. Intensify this bias further by using **Quintic ($d^5$) weighting** (`weights = [d**5 for d in pool]`). This extremely steep probability curve will act almost deterministically for distinct transaction sizes, ensuring the absolute critical path is constructed first, while still breaking ties stochastically among similarly sized items.",
    "Based on the analysis of Generations 91-99, the Current Best Program (Generation 86), and the identified \"Sweet Spot\" in polynomial weighting, here are 5 actionable recommendations for future program mutations:\n\n1.  **Quintic ($d^5$) Probability Weighting**\n    The performance data indicates a peak between $d^4$ (Gen 86, Score 4.12) and $d^5$ (Gen 96, Score 4.05), with a sharp drop-off at $d^6$. To potentially squeeze more efficiency out of the \"Big Rocks First\" heuristic, shift the weighting exponent from 4 to 5 (`weights = [d**5 for d in pool]`). This increases the bias toward processing the longest transactions earliest\u2014crucial for defining the global schedule structure\u2014without becoming fully deterministic like the failed $d^6$ approach.\n\n2.  **Hybrid Ruin Strategy (Random + Block)**\n    The current best program's ILS removes 6-9 random items. Enhance this by introducing a probability (e.g., 50%) to remove a *contiguous block* of transactions (indices `i` to `i+k`) instead of random indices. Block removal effectively clears entire time windows of congestion, allowing the \"LPT-Sorted Repair\" logic to completely restructure dependency chains that have become locally entangled, rather than just patching individual holes.\n\n3.  **Expanded Multi-Target Lookahead**\n    Generation 86 evaluates the top 4 largest remaining transactions in its lookahead phase. Increase this horizon to check the top 6-8 targets. Since the cost of checking a few more candidates is low compared to the penalty of a bad placement, a slightly wider net ensures that the algorithm doesn't greedily block the placement of the 5th or 6th largest item, which often act as \"hidden\" bottlenecks in dense schedules.\n\n4.  **Annealed Acceptance Threshold**\n    Instead of a fixed 0.5% degradation threshold in the ILS loop, implement a \"Cooling Schedule\" (e.g., starting at 2.0% and decaying linearly to 0.1%). This allows the algorithm to accept larger structural changes (worsening the score significantly) early in the search to escape deep local optima, before tightening the constraints to fine-tune the solution in later iterations.\n\n5.  **Critical-Item Global Re-insertion**\n    In the `refine` (local search) function, the insertion window is currently limited to `w_ins=8` for efficiency. Modify this to allow **Global Insertion** (trying all possible positions) specifically for the top 10% longest transactions. These \"critical\" items often dictate the total makespan; checking all possible slots for them ensures they are not stuck in a suboptimal local basin that a"
  ],
  "total_programs_meta_processed": 100
}