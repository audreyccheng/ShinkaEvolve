<NAME>
robust_lookahead_ils
</NAME>

<DESCRIPTION>
1.  **Robust Lookahead:** Upgrades the lookahead mechanism from checking a single "next LPT" transaction to checking the top 2 LPT transactions. It assigns the *maximum* (worst) heuristic score among them to the candidate. This pessimistic scoring prevents the greedy choice from blocking secondary critical paths that are crucial for overall makespan.
2.  **Enhanced Beam Search Parameters:** Increases `BEAM_WIDTH` and `SAMPLES_PER_NODE` to broaden the search space, while slightly reducing `LOOKAHEAD_FACTOR` to balance the computational cost of the new robust check.
3.  **Stronger ILS Perturbation:** Increases the intensity of the "kick" in the Iterated Local Search phase by performing 3 random swaps instead of 1, and increasing the number of perturbation iterations. This helps the algorithm escape local optima more effectively.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Parameters ---
    BEAM_WIDTH = int(max(10, num_seqs * 2.5))
    SAMPLES_PER_NODE = 20
    MAX_CHILDREN = 3
    # Lookahead: Evaluate lookahead score for top N candidates
    # N = Beam Width * Factor. Higher = more accurate but slower.
    LOOKAHEAD_FACTOR = 2.0
=======
    # --- Parameters ---
    BEAM_WIDTH = int(max(15, num_seqs * 3.0))
    SAMPLES_PER_NODE = 24
    MAX_CHILDREN = 3
    # Lookahead: Evaluate lookahead score for top N candidates
    # N = Beam Width * Factor. Higher = more accurate but slower.
    LOOKAHEAD_FACTOR = 1.5
>>>>>>> REPLACE
<<<<<<< SEARCH
        # 3. Compute Lookahead Score
        for cand in lookahead_pool:
            rem = cand['new_rem']
            if not rem:
                cand['final_score'] = cand['base_score']
                continue

            # Find next LPT item in remaining set
            next_t = None
            for t in sorted_lpt:
                if t in rem:
                    next_t = t
                    break

            if next_t is not None:
                # Tentative addition
                la_seq = cand['seq'] + [next_t]
                la_cost = workload.get_opt_seq_cost(la_seq)
                la_total_dur = cand['total_dur'] + txn_durations[next_t]
                cand['final_score'] = la_cost - la_total_dur
            else:
                cand['final_score'] = cand['base_score']
=======
        # 3. Compute Robust Lookahead Score
        for cand in lookahead_pool:
            rem = cand['new_rem']
            if not rem:
                cand['final_score'] = cand['base_score']
                continue

            # Identify top critical transactions (LPT) in remaining set
            # We check the top 2 to ensure we don't block secondary critical paths
            check_candidates = []
            for t in sorted_lpt:
                if t in rem:
                    check_candidates.append(t)
                    if len(check_candidates) >= 2:
                        break

            if check_candidates:
                la_scores = []
                for next_t in check_candidates:
                    la_seq = cand['seq'] + [next_t]
                    la_cost = workload.get_opt_seq_cost(la_seq)
                    la_total_dur = cand['total_dur'] + txn_durations[next_t]
                    # Score = Idle time introduced
                    la_scores.append(la_cost - la_total_dur)

                # Pessimistic: assume the worst outcome among critical paths
                cand['final_score'] = max(la_scores)
            else:
                cand['final_score'] = cand['base_score']
>>>>>>> REPLACE
<<<<<<< SEARCH
    # 2. Perturbation Loop
    for _ in range(2):
        p_seq = best_seq[:]
        if len(p_seq) > 5:
            # Kick: Swap 2 random items
            i1, i2 = random.sample(range(len(p_seq)), 2)
            p_seq[i1], p_seq[i2] = p_seq[i2], p_seq[i1]

            # Repair
            p_seq, p_cost = refine(p_seq, workload.get_opt_seq_cost(p_seq))

            if p_cost < best_cost:
                best_cost = p_cost
                best_seq = p_seq
=======
    # 2. Perturbation Loop (Multi-Swap Kick)
    for _ in range(3):
        p_seq = best_seq[:]
        if len(p_seq) > 5:
            # Stronger Kick: Swap 3 random pairs
            for _ in range(3):
                i1, i2 = random.sample(range(len(p_seq)), 2)
                p_seq[i1], p_seq[i2] = p_seq[i2], p_seq[i1]

            # Repair
            p_seq, p_cost = refine(p_seq, workload.get_opt_seq_cost(p_seq))

            if p_cost < best_cost:
                best_cost = p_cost
                best_seq = p_seq
>>>>>>> REPLACE
</DIFF>