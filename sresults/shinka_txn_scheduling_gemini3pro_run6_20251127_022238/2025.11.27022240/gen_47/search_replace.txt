<NAME>
multi_cycle_ils
</NAME>

<DESCRIPTION>
I am replacing the single perturbation step at the end of the algorithm with a Multi-Cycle Iterated Local Search (ILS) loop. The single perturbation step in the current code is insufficient to escape strong local optima. By wrapping the perturbation and repair logic in a loop (6 cycles), the algorithm can explore the search space more effectively using a "Basin Hopping" approach: randomly kicking the solution (perturbation) and then descending to a local optimum (repair). I vary the kick strength (number of swaps) to balance small adjustments with larger jumps.

Additionally, I am increasing the `effort_level` passed to `get_best_schedule` from 10 to 12. This parameter scales the `BEAM_WIDTH`, allowing the beam search phase to maintain a more diverse set of candidates (width increases from 25 to 30), which provides a better starting point for the ILS phase.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # 2. Perturbation & Repair (ILS Step)
    # Create a copy to perturb
    p_seq = best_seq[:]

    # Perturbation: Random swap of two transactions
    if len(p_seq) > 5:
        idx1, idx2 = random.sample(range(len(p_seq)), 2)
        p_seq[idx1], p_seq[idx2] = p_seq[idx2], p_seq[idx1]

        # Repair (Second Descent)
        p_cost = workload.get_opt_seq_cost(p_seq)
        p_seq, p_cost = run_local_search(p_seq, p_cost)

        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq

    return best_cost, best_seq


def get_random_costs():
    """
    Evaluate scheduling algorithm on three different workloads.

    Returns:
        Tuple of (total_makespan, list_of_schedules, execution_time)
    """
    start_time = time.time()

    # Workload 1: Complex mixed read/write transactions
    workload1 = Workload(WORKLOAD_1)
    makespan1, schedule1 = get_best_schedule(workload1, 10)

    # Workload 2: Simple read-then-write pattern
    workload2 = Workload(WORKLOAD_2)
    makespan2, schedule2 = get_best_schedule(workload2, 10)

    # Workload 3: Minimal read/write operations
    workload3 = Workload(WORKLOAD_3)
    makespan3, schedule3 = get_best_schedule(workload3, 10)

    total_makespan = makespan1 + makespan2 + makespan3
    schedules = [schedule1, schedule2, schedule3]
    execution_time = time.time() - start_time

    return total_makespan, schedules, execution_time
=======
    # 2. Multi-Cycle Iterated Local Search (ILS)
    # Iterate through Perturbation -> Repair -> Acceptance cycles
    curr_seq = best_seq[:]
    curr_cost = best_cost

    ILS_CYCLES = 6

    for cycle in range(ILS_CYCLES):
        p_seq = curr_seq[:]
        if len(p_seq) < 5: break

        # Perturbation (Kick)
        # Strength: 1 swap normally, 2 swaps every 3rd cycle to jump basins
        num_swaps = 2 if (cycle % 3 == 0) else 1

        for _ in range(num_swaps):
            idx1, idx2 = random.sample(range(len(p_seq)), 2)
            p_seq[idx1], p_seq[idx2] = p_seq[idx2], p_seq[idx1]

        # Repair (Local Search)
        # Recalculate cost after kick
        p_cost = workload.get_opt_seq_cost(p_seq)
        p_seq, p_cost = run_local_search(p_seq, p_cost)

        # Acceptance Criterion
        # Always accept if better than global best
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq[:]
            curr_seq = p_seq[:]
            curr_cost = p_cost
        # Accept if better than current (Descent in Basin Hopping)
        elif p_cost < curr_cost:
            curr_seq = p_seq[:]
            curr_cost = p_cost
        # Optional: Metropolis acceptance could go here for Simulated Annealing behavior,
        # but for this problem, greedy descent + random kicks works well.

    return best_cost, best_seq


def get_random_costs():
    """
    Evaluate scheduling algorithm on three different workloads.

    Returns:
        Tuple of (total_makespan, list_of_schedules, execution_time)
    """
    start_time = time.time()

    # Effort level scales beam width. Increased to 12 for better exploration.
    effort_level = 12

    # Workload 1: Complex mixed read/write transactions
    workload1 = Workload(WORKLOAD_1)
    makespan1, schedule1 = get_best_schedule(workload1, effort_level)

    # Workload 2: Simple read-then-write pattern
    workload2 = Workload(WORKLOAD_2)
    makespan2, schedule2 = get_best_schedule(workload2, effort_level)

    # Workload 3: Minimal read/write operations
    workload3 = Workload(WORKLOAD_3)
    makespan3, schedule3 = get_best_schedule(workload3, effort_level)

    total_makespan = makespan1 + makespan2 + makespan3
    schedules = [schedule1, schedule2, schedule3]
    execution_time = time.time() - start_time

    return total_makespan, schedules, execution_time
>>>>>>> REPLACE
</DIFF>