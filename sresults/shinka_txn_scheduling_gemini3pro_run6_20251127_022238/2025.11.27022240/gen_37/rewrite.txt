# EVOLVE-BLOCK-START
"""Transaction scheduling algorithm for optimizing makespan across multiple workloads"""

import time
import random
import sys
import os
import math

# Add the openevolve_examples directory to the path to import txn_simulator and workloads
# Find the repository root by looking for the openevolve_examples directory
def find_repo_root(start_path):
    """Find the repository root by looking for openevolve_examples directory."""
    current = os.path.abspath(start_path)
    # Search up the directory tree
    while current != os.path.dirname(current):  # Stop at filesystem root
        candidate = os.path.join(current, 'openevolve_examples', 'txn_scheduling')
        if os.path.exists(candidate):
            return current
        current = os.path.dirname(current)
    
    # If not found by searching up, try common locations relative to known paths
    script_dir = os.path.dirname(os.path.abspath(__file__))
    possible_roots = [
        script_dir,  # Current directory
        os.path.dirname(script_dir),  # Parent
        os.path.dirname(os.path.dirname(script_dir)),  # Grandparent
        '/home/ubuntu/ShinkaEvolve',  # Absolute path fallback for Ubuntu
        '/Users/audreycc/Documents/Work/LLMTxn/ADRS-Exps/ShinkaEvolve',  # Absolute path fallback for macOS
    ]
    for root in possible_roots:
        candidate = os.path.join(root, 'openevolve_examples', 'txn_scheduling')
        if os.path.exists(candidate):
            return root
    
    raise RuntimeError(f"Could not find openevolve_examples directory. Searched from: {start_path}")

try:
    repo_root = find_repo_root(os.path.dirname(__file__))
    sys.path.insert(0, os.path.join(repo_root, 'openevolve_examples', 'txn_scheduling'))
except Exception as e:
    # Allow execution to proceed if modules are already in path or mock environment
    pass

from txn_simulator import Workload
from workloads import WORKLOAD_1, WORKLOAD_2, WORKLOAD_3


def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Lookahead Beam Search and Iterated Local Search (ILS).
    
    Key Innovations:
    1. Lookahead Beam Search: Evaluates candidates not just by immediate cost, but by the 
       cost after tentatively scheduling the next most urgent transaction. This prevents 
       shortsighted greedy choices that block critical paths.
    2. Iterated Local Search (ILS): Escapes local optima by applying random perturbations 
       (swaps) followed by a deterministic windowed repair (local descent).

    Args:
        workload: Workload object
        num_seqs: Budget parameter (controls beam width and ILS iterations)

    Returns:
        (lowest_makespan, schedule)
    """
    
    num_txns = workload.num_txns
    
    # --- 1. METRIC PRECOMPUTATION ---
    txn_durations = {}
    txn_rw_sets = {}
    
    for t in range(num_txns):
        # Duration
        try:
            d = workload.txns[t][0][3]
        except:
            d = 1.0
        txn_durations[t] = d
        
        # R/W Sets
        reads = set()
        writes = set()
        try:
            ops_str = workload.txns[t][0][1]
            if isinstance(ops_str, str):
                for op in ops_str.split():
                    if '-' in op:
                        parts = op.split('-')
                        if len(parts) == 2:
                            op_type, key = parts
                            if op_type == 'r': reads.add(key)
                            elif op_type == 'w': writes.add(key)
        except:
            pass
        txn_rw_sets[t] = (reads, writes)

    # Compute Conflict Volume (Sum of durations of conflicting txns)
    # This metric is better than simple degree because it weighs long-blocking txns higher.
    txn_conflict_vol = {t: 0.0 for t in range(num_txns)}
    
    for i in range(num_txns):
        r1, w1 = txn_rw_sets[i]
        vol = 0.0
        for j in range(num_txns):
            if i == j: continue
            r2, w2 = txn_rw_sets[j]
            # Conflict check: (W1 n (W2 u R2)) or (R1 n W2)
            if not w1.isdisjoint(w2) or not w1.isdisjoint(r2) or not r1.isdisjoint(w2):
                vol += txn_durations[j]
        txn_conflict_vol[i] = vol

    # Static Urgency Score
    # We prioritize Long Duration and High Conflict Volume
    # Normalize
    max_vol = max(txn_conflict_vol.values()) if txn_conflict_vol else 1.0
    max_dur = max(txn_durations.values()) if txn_durations else 1.0
    if max_vol == 0: max_vol = 1.0
    
    txn_urgency = {}
    for t in range(num_txns):
        # Score combining duration and conflict.
        # High score = Schedule early
        # Weights: 1.0 Duration, 0.7 Conflict Volume
        score = (txn_durations[t] / max_dur) + 0.7 * (txn_conflict_vol[t] / max_vol)
        txn_urgency[t] = score

    # --- 2. LOOKAHEAD BEAM SEARCH ---
    
    # Parameters
    BEAM_WIDTH = max(5, int(num_seqs))
    
    # Beam State: (cost, schedule_list, remaining_list)
    beam = [(0, [], list(range(num_txns)))]
    
    for step in range(num_txns):
        candidates_pool = []
        
        for p_cost, p_sched, p_remain in beam:
            
            # Select Candidates for Expansion
            # We don't expand all; that's too slow with lookahead.
            # Strategy: Top K Urgent + Weighted Random + Pure Random
            
            sorted_remain = sorted(p_remain, key=lambda x: txn_urgency[x], reverse=True)
            
            next_candidates = set()
            
            # 1. Top Deterministic (Greedy Urgency)
            next_candidates.update(sorted_remain[:3])
            
            # 2. Weighted Random (Soft LPT)
            if len(sorted_remain) > 3:
                pool = sorted_remain[3:]
                weights = [txn_urgency[x] for x in pool]
                # Sample 3
                if pool:
                    samples = random.choices(pool, weights=weights, k=min(3, len(pool)))
                    next_candidates.update(samples)
            
            # 3. Pure Random (Diversity)
            if len(sorted_remain) > 10:
                next_candidates.update(random.sample(sorted_remain, 1))
            
            # Evaluation with Stochastic Lookahead
            for c in next_candidates:
                # Immediate Step
                sched_c = p_sched + [c]
                cost_c = workload.get_opt_seq_cost(sched_c)
                
                # Lookahead Step:
                # Tentatively schedule the next best urgent item from the remaining.
                # This estimates the "future blocking cost".
                remain_c = [x for x in p_remain if x != c]
                
                metric_score = cost_c
                
                if remain_c:
                    # Pick the single most urgent remaining task as the lookahead probe
                    next_best = max(remain_c, key=lambda x: txn_urgency[x])
                    sched_lookahead = sched_c + [next_best]
                    cost_lookahead = workload.get_opt_seq_cost(sched_lookahead)
                    
                    # The metric is the cost after 2 steps.
                    metric_score = cost_lookahead
                
                # Sort Metric: (Lookahead Cost, Immediate Cost, -Urgency)
                # Primary: Minimize 2-step cost
                # Secondary: Minimize 1-step cost
                # Tertiary: Prefer high urgency (break ties by clearing heavy items)
                full_metric = (metric_score, cost_c, -txn_urgency[c])
                
                candidates_pool.append((full_metric, sched_c, remain_c))
        
        # Pruning
        candidates_pool.sort(key=lambda x: x[0])
        
        # Select best states for next beam iteration
        # Note: Beam expects (cost, sched, remain). We use immediate cost_c (x[0][1]) for that.
        beam = [(x[0][1], x[1], x[2]) for x in candidates_pool[:BEAM_WIDTH]]
        
    best_state = beam[0]
    current_cost = best_state[0]
    current_schedule = best_state[1]

    # --- 3. ITERATED LOCAL SEARCH (ILS) ---
    
    def local_descent(sched, base_cost, pass_limit=2):
        """Perform windowed insertion to improve schedule locally."""
        improved = True
        curr_sched = list(sched)
        curr_c = base_cost
        
        passes = 0
        while improved and passes < pass_limit:
            improved = False
            passes += 1
            
            # Shuffle indices to vary check order
            indices = list(range(len(curr_sched)))
            random.shuffle(indices)
            
            for i in indices:
                txn = curr_sched[i]
                
                # Remove
                temp = curr_sched[:i] + curr_sched[i+1:]
                
                # Search Window around original position
                window = 10
                start = max(0, i - window)
                end = min(len(temp), i + window)
                
                best_pos = -1
                best_val = curr_c
                
                for p in range(start, end + 1):
                    cand = temp[:p] + [txn] + temp[p:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < best_val:
                        best_val = c
                        best_pos = p
                
                if best_pos != -1:
                    curr_sched = temp[:best_pos] + [txn] + temp[best_pos:]
                    curr_c = best_val
                    improved = True
                    
        return curr_c, curr_sched

    # Initial deep descent
    current_cost, current_schedule = local_descent(current_schedule, current_cost, pass_limit=2)
    
    # ILS Loop: Kick -> Repair -> Accept
    # Fixed number of kicks to bound runtime
    num_kicks = 3
    
    for _ in range(num_kicks):
        # 1. Perturbation (Kick)
        # Swap 2 random pairs to escape local basin
        neighbor = list(current_schedule)
        for _ in range(2):
            i, j = random.randint(0, num_txns-1), random.randint(0, num_txns-1)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            
        kick_cost = workload.get_opt_seq_cost(neighbor)
        
        # 2. Repair (Shallow Descent)
        # Use pass_limit=1 for speed during exploration
        new_cost, new_sched = local_descent(neighbor, kick_cost, pass_limit=1)
        
        # 3. Acceptance (Better)
        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = new_sched

    return current_cost, current_schedule


def get_random_costs():
    """Evaluate scheduling algorithm on three different workloads."""
    start_time = time.time()
    
    num_seqs = 10
    
    workload1 = Workload(WORKLOAD_1)
    makespan1, schedule1 = get_best_schedule(workload1, num_seqs)

    workload2 = Workload(WORKLOAD_2)
    makespan2, schedule2 = get_best_schedule(workload2, num_seqs)

    workload3 = Workload(WORKLOAD_3)
    makespan3, schedule3 = get_best_schedule(workload3, num_seqs)
    
    total_makespan = makespan1 + makespan2 + makespan3
    schedules = [schedule1, schedule2, schedule3]
    execution_time = time.time() - start_time
    
    return total_makespan, schedules, execution_time

# EVOLVE-BLOCK-END