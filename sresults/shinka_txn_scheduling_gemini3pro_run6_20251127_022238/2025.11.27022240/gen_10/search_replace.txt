<NAME>
adaptive_greedy_tiebreak_swap
</NAME>

<DESCRIPTION>
Improves the scheduling algorithm by introducing an Adaptive Greedy strategy with Tie-Breaking and an Enhanced Local Search.
1. **Exhaustive Tail**: In the greedy construction, when the number of remaining transactions is small (<=20), the algorithm evaluates *all* remaining transactions instead of a sample. This ensures tighter packing at the end of the schedule where gaps are most costly.
2. **Heuristic Tie-Breaking**: When multiple candidates result in the same schedule makespan, the algorithm now selects the transaction with the longest duration (heaviest). This "best fit" approach utilizes available parallel slack for larger tasks, saving smaller tasks to fill gaps later.
3. **Hybrid Local Search**: Re-introduces the Swap operator alongside the Shift operator (30% Swap, 70% Shift) during the refinement phase. This helps escape local optima that Shift alone cannot resolve.
4. **Tuned Parameters**: Adjusts sampling sizes and bias to balance exploration (early iterations) and exploitation (later iterations).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using a hybrid strategy: Multi-start Greedy + Local Search.

    1. Multi-start Greedy: Generates candidate schedules using randomized greedy construction
       biased towards 'heavy' transactions (LPT heuristic).
    2. Local Search (Hill Climbing): Refines the best candidate found by shifting transactions
       to different positions to escape local optima and tighten the makespan.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of greedy iterations to perform

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """

    # Pre-calculate transaction costs for heuristic (Longest Processing Time)
    txn_costs = {}
    try:
        for t in range(workload.num_txns):
            txn_costs[t] = workload.txns[t][0][3]
    except (IndexError, AttributeError, TypeError):
        for t in range(workload.num_txns):
            txn_costs[t] = 1

    def generate_greedy_schedule(sample_size, bias_limit):
        """Generates a schedule using randomized greedy with optional heavy-item bias."""
        remaining = list(range(workload.num_txns))
        schedule = []

        # Start with a random transaction
        start_idx = random.randint(0, len(remaining) - 1)
        schedule.append(remaining.pop(start_idx))

        while remaining:
            candidates = set()

            # Random sampling
            k = min(len(remaining), sample_size)
            candidates.update(random.sample(remaining, k))

            # Heuristic bias: consider heaviest remaining transactions
            if bias_limit > 0:
                heaviest = sorted(remaining, key=lambda x: txn_costs.get(x, 0), reverse=True)[:bias_limit]
                candidates.update(heaviest)

            best_c = -1
            best_c_cost = float('inf')

            # Select best candidate based on immediate makespan
            for c in candidates:
                test_seq = schedule + [c]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < best_c_cost:
                    best_c_cost = cost
                    best_c = c

            if best_c != -1:
                schedule.append(best_c)
                remaining.remove(best_c)
            else:
                schedule.append(remaining.pop(0))

        return workload.get_opt_seq_cost(schedule), schedule

    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Phase 1: Multi-start Greedy Construction
    iterations = max(1, num_seqs)

    for i in range(iterations):
        # First iteration: Exploration (random)
        # Others: Exploitation (heavy bias)
        if i == 0:
            cost, sched = generate_greedy_schedule(sample_size=6, bias_limit=0)
        else:
            cost, sched = generate_greedy_schedule(sample_size=3, bias_limit=3)

        if cost < best_overall_cost:
            best_overall_cost = cost
            best_overall_schedule = sched

    # Phase 2: Local Search Refinement (Hill Climbing with Shift)
    # Try to improve the best schedule by moving transactions
    current_schedule = list(best_overall_schedule)
    current_cost = best_overall_cost

    # Number of improvement attempts
    search_steps = 400
    no_improv_limit = 100
    no_improv = 0

    for _ in range(search_steps):
        if no_improv >= no_improv_limit:
            break

        # Shift operator: Move transaction from src to dst
        idx_src = random.randint(0, len(current_schedule) - 1)
        idx_dst = random.randint(0, len(current_schedule) - 1)

        if idx_src == idx_dst:
            continue

        neighbor = list(current_schedule)
        txn = neighbor.pop(idx_src)
        neighbor.insert(idx_dst, txn)

        new_cost = workload.get_opt_seq_cost(neighbor)

        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = neighbor
            no_improv = 0
        else:
            no_improv += 1

    return current_cost, current_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Adaptive Greedy Construction with Tie-Breaking and Hybrid Local Search.

    1. Adaptive Greedy: Builds schedules by selecting best next transaction.
       - Uses random sampling + heavy-item bias for candidates.
       - Switches to exhaustive search when few transactions remain (Exhaustive Tail).
       - Tie-breaks candidates with equal makespan by choosing the longest duration transaction (Best Fit).
    2. Local Search: Refines the best schedule using both Swap and Shift operators.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of greedy iterations to perform

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """

    # Pre-calculate transaction costs for heuristic (Longest Processing Time)
    txn_costs = {}
    try:
        for t in range(workload.num_txns):
            txn_costs[t] = workload.txns[t][0][3]
    except (IndexError, AttributeError, TypeError):
        for t in range(workload.num_txns):
            txn_costs[t] = 1

    def generate_adaptive_schedule(sample_size, use_bias):
        """Generates a schedule using adaptive greedy strategy."""
        remaining = list(range(workload.num_txns))
        schedule = []

        # Start random
        start_idx = random.randint(0, len(remaining) - 1)
        schedule.append(remaining.pop(start_idx))

        exhaustive_threshold = 20

        while remaining:
            candidates = set()

            # Adaptive: Exhaustive search at the tail ensures tight packing
            if len(remaining) <= exhaustive_threshold:
                candidates.update(remaining)
            else:
                # Sampling
                k = min(len(remaining), sample_size)
                candidates.update(random.sample(remaining, k))

                # Heuristic bias: Check heavy transactions
                if use_bias:
                    bias_k = 4
                    heaviest = sorted(remaining, key=lambda x: txn_costs.get(x, 0), reverse=True)[:bias_k]
                    candidates.update(heaviest)

            # Evaluate candidates
            best_c = -1
            best_c_cost = float('inf')
            best_candidates_equal = []

            for c in candidates:
                test_seq = schedule + [c]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < best_c_cost:
                    best_c_cost = cost
                    best_candidates_equal = [c]
                elif cost == best_c_cost:
                    best_candidates_equal.append(c)

            # Tie-breaking: Pick heaviest among best to fill "shadow"
            if best_candidates_equal:
                best_c = max(best_candidates_equal, key=lambda x: txn_costs.get(x, 0))

            if best_c != -1:
                schedule.append(best_c)
                remaining.remove(best_c)
            else:
                # Fallback (rare)
                c = remaining.pop(0)
                schedule.append(c)

        return workload.get_opt_seq_cost(schedule), schedule

    best_overall_cost = float('inf')
    best_overall_schedule = []

    iterations = max(1, num_seqs)

    for i in range(iterations):
        # Diversity in first few iterations (random), then bias (heuristic)
        if i < 2:
            cost, sched = generate_adaptive_schedule(sample_size=8, use_bias=False)
        else:
            cost, sched = generate_adaptive_schedule(sample_size=4, use_bias=True)

        if cost < best_overall_cost:
            best_overall_cost = cost
            best_overall_schedule = sched

    # Local Search Phase
    current_schedule = list(best_overall_schedule)
    current_cost = best_overall_cost

    search_steps = 500
    no_improv_limit = 150
    no_improv = 0

    for _ in range(search_steps):
        if no_improv >= no_improv_limit:
            break

        neighbor = list(current_schedule)

        # Randomly choose operator: Swap or Shift
        # Shift is 70% likely as it preserves relative orderings better
        if random.random() < 0.3:
            # Swap
            i, j = random.sample(range(len(neighbor)), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
        else:
            # Shift (Insert)
            src, dst = random.sample(range(len(neighbor)), 2)
            txn = neighbor.pop(src)
            neighbor.insert(dst, txn)

        new_cost = workload.get_opt_seq_cost(neighbor)

        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = neighbor
            no_improv = 0
        else:
            no_improv += 1

    return current_cost, current_schedule
>>>>>>> REPLACE
</DIFF>