<NAME>
ILS_BlockMoves_LargerRuin
</NAME>

<DESCRIPTION>
1. Improves the Local Search (`refine`) by adding a **Block Move** operator. This allows moving adjacent pairs of transactions together, preserving their relative order while finding a better global position. This is effective for "coupled" transactions (e.g., interacting with the same key) that should be scheduled together.
2. Increases the **Ruin Size** in the Ruin-and-Recreate ILS phase. Instead of a static 3-5 items, it now scales slightly with problem size (up to 8 items for N=100), allowing the algorithm to escape deeper local optima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Ruin-and-Recreate ILS ---

    def refine(seq, cost):
        """Standard Local Search: Swaps (5) and Insertions (8)."""
        improved = True
        while improved:
            improved = False
            # Swaps
            for i in range(len(seq) - 1):
                for offset in range(1, 6):
                    j = i + offset
                    if j >= len(seq): break
                    seq[i], seq[j] = seq[j], seq[i]
                    c = workload.get_opt_seq_cost(seq)
                    if c < cost:
                        cost = c
                        improved = True
                    else:
                        seq[i], seq[j] = seq[j], seq[i]
                if improved: break

            if improved: continue

            # Insertions
            w_ins = 8
            for i in range(len(seq)):
                start = max(0, i - w_ins)
                end = min(len(seq), i + w_ins)
                if start >= end: continue
                curr = seq[i]
                temp = seq[:i] + seq[i+1:]
                for k in range(start, end):
                    cand = temp[:k] + [curr] + temp[k:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < cost:
                        cost = c
                        seq = cand
                        improved = True
                        break
                if improved: break
        return seq, cost

    # Phase 1: Initial Descent
    best_seq, best_cost = refine(best_seq, best_cost)

    # Phase 2: Iterated Ruin and Recreate
    curr_seq = best_seq[:]
    curr_cost = best_cost

    for _ in range(ILS_CYCLES):
        p_seq = curr_seq[:]

        # Ruin: Remove random 3-5 items
        if len(p_seq) > 5:
            ruin_size = random.choice([3, 4, 5])
            removed = []
            for _ in range(ruin_size):
                if not p_seq: break
                idx = random.randint(0, len(p_seq) - 1)
                removed.append(p_seq.pop(idx))

            # Recreate: Best-Fit greedy insertion
            # Sort removed items by duration (LPT) to place big rocks first
            removed.sort(key=lambda t: txn_durations[t], reverse=True)

            for t in removed:
                best_pos = -1
                best_c = float('inf')
                # Try all positions
                for pos in range(len(p_seq) + 1):
                    cand = p_seq[:pos] + [t] + p_seq[pos:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < best_c:
                        best_c = c
                        best_pos = pos

                if best_pos != -1:
                    p_seq.insert(best_pos, t)
                else:
                    p_seq.append(t)

        # Repair
        p_seq, p_cost = refine(p_seq, workload.get_opt_seq_cost(p_seq))

        # Acceptance
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq
            curr_seq = p_seq
            curr_cost = p_cost
        elif p_cost < curr_cost:
            curr_seq = p_seq
            curr_cost = p_cost
=======
    # --- Ruin-and-Recreate ILS ---

    def refine(seq, cost):
        """Extended Local Search: Swaps, Block Moves, and Insertions."""
        improved = True
        while improved:
            improved = False

            # 1. Swaps (Window 5)
            # Good for small local reordering
            for i in range(len(seq) - 1):
                for offset in range(1, 6):
                    j = i + offset
                    if j >= len(seq): break
                    seq[i], seq[j] = seq[j], seq[i]
                    c = workload.get_opt_seq_cost(seq)
                    if c < cost:
                        cost = c
                        improved = True
                    else:
                        seq[i], seq[j] = seq[j], seq[i] # Revert
                if improved: break

            if improved: continue

            # 2. Block Moves (Size 2)
            # Moves adjacent pairs. Effective for moving coupled transactions.
            w_block = 8 # Window size for block moves
            if len(seq) > 4:
                for i in range(len(seq) - 1):
                    # Define block
                    block = seq[i:i+2]
                    # Sequence without block
                    rem_seq = seq[:i] + seq[i+2:]

                    # Search window centered on original position
                    start = max(0, i - w_block)
                    end = min(len(rem_seq) + 1, i + w_block)

                    for k in range(start, end):
                        # Avoid reconstructing the original sequence
                        if k == i: continue

                        cand = rem_seq[:k] + block + rem_seq[k:]
                        c = workload.get_opt_seq_cost(cand)
                        if c < cost:
                            cost = c
                            seq = cand
                            improved = True
                            break
                    if improved: break

            if improved: continue

            # 3. Single Insertions (Window 8)
            # Good for moving a transaction past a region of conflict
            w_ins = 8
            for i in range(len(seq)):
                start = max(0, i - w_ins)
                end = min(len(seq), i + w_ins)
                if start >= end: continue

                curr = seq[i]
                temp = seq[:i] + seq[i+1:]

                for k in range(start, end):
                    if k == i: continue
                    cand = temp[:k] + [curr] + temp[k:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < cost:
                        cost = c
                        seq = cand
                        improved = True
                        break
                if improved: break
        return seq, cost

    # Phase 1: Initial Descent
    best_seq, best_cost = refine(best_seq, best_cost)

    # Phase 2: Iterated Ruin and Recreate
    curr_seq = best_seq[:]
    curr_cost = best_cost

    for _ in range(ILS_CYCLES):
        p_seq = curr_seq[:]

        # Ruin: Variable destruction (4-8 items for N=100)
        # Allows escaping deeper local optima
        if len(p_seq) > 10:
            max_ruin = min(8, int(len(p_seq) * 0.15))
            ruin_size = random.randint(4, max(4, max_ruin))
            removed = []
            for _ in range(ruin_size):
                if not p_seq: break
                idx = random.randint(0, len(p_seq) - 1)
                removed.append(p_seq.pop(idx))

            # Recreate: Best-Fit greedy insertion
            # Sort removed items by duration (LPT) to place big rocks first
            removed.sort(key=lambda t: txn_durations[t], reverse=True)

            for t in removed:
                best_pos = -1
                best_c = float('inf')
                # Try all positions
                for pos in range(len(p_seq) + 1):
                    cand = p_seq[:pos] + [t] + p_seq[pos:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < best_c:
                        best_c = c
                        best_pos = pos

                if best_pos != -1:
                    p_seq.insert(best_pos, t)
                else:
                    p_seq.append(t)

        # Repair
        p_seq, p_cost = refine(p_seq, workload.get_opt_seq_cost(p_seq))

        # Acceptance
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq
            curr_seq = p_seq
            curr_cost = p_cost
        elif p_cost < curr_cost:
            curr_seq = p_seq
            curr_cost = p_cost
>>>>>>> REPLACE
</DIFF>