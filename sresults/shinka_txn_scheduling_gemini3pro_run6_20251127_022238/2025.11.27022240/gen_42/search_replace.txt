<NAME>
ILS_Refinements
</NAME>

<DESCRIPTION>
This edit introduces three improvements to the scheduling algorithm:
1.  **Updated Urgency Scoring**: Shifted weights to prioritize 'Conflict Volume' (1.0) over 'Duration' (0.5). Transactions that block many others are now scheduled earlier, which is critical for minimizing makespan in high-contention workloads.
2.  **Global Critical Reinsertion**: Added a phase between Beam Search and ILS to take the top 5 most urgent transactions and optimally place them *anywhere* in the schedule. This corrects global structural errors (e.g., a critical transaction pushed to the end) that the windowed local search cannot reach.
3.  **Enhanced ILS Loop**: Increased the number of kicks to 5 and diversified the perturbation operator. It now randomly chooses between multi-swaps and a "Block Shuffle" (scrambling a contiguous segment), which helps resolve local deadlocks where a cluster of conflicting transactions is ordered sub-optimally.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    txn_urgency = {}
    for t in range(num_txns):
        # Score combining duration and conflict.
        # High score = Schedule early
        # Weights: 1.0 Duration, 0.7 Conflict Volume
        score = (txn_durations[t] / max_dur) + 0.7 * (txn_conflict_vol[t] / max_vol)
        txn_urgency[t] = score
=======
    txn_urgency = {}
    for t in range(num_txns):
        # Score combining duration and conflict.
        # High score = Schedule early
        # Weights: 0.5 Duration, 1.0 Conflict Volume (Favor unlocking conflicts)
        score = 0.5 * (txn_durations[t] / max_dur) + 1.0 * (txn_conflict_vol[t] / max_vol)
        txn_urgency[t] = score
>>>>>>> REPLACE
<<<<<<< SEARCH
    best_state = beam[0]
    current_cost = best_state[0]
    current_schedule = best_state[1]

    # --- 3. ITERATED LOCAL SEARCH (ILS) ---
=======
    best_state = beam[0]
    current_cost = best_state[0]
    current_schedule = best_state[1]

    # --- 2.5. GLOBAL CRITICAL REINSERTION ---
    # Attempt to globally reposition the most urgent transactions.
    # Beam search might have placed them sub-optimally due to local horizons.
    critical_txns = sorted(range(num_txns), key=lambda x: txn_urgency[x], reverse=True)[:5]

    for t_crit in critical_txns:
        if t_crit not in current_schedule: continue
        curr_idx = current_schedule.index(t_crit)

        # Remove
        temp = current_schedule[:curr_idx] + current_schedule[curr_idx+1:]

        best_pos = curr_idx
        best_val = current_cost

        # Global search for these few critical items
        for p in range(len(temp) + 1):
            cand = temp[:p] + [t_crit] + temp[p:]
            c = workload.get_opt_seq_cost(cand)
            if c < best_val:
                best_val = c
                best_pos = p

        if best_pos != curr_idx:
            current_schedule = temp[:best_pos] + [t_crit] + temp[best_pos:]
            current_cost = best_val

    # --- 3. ITERATED LOCAL SEARCH (ILS) ---
>>>>>>> REPLACE
<<<<<<< SEARCH
    # ILS Loop: Kick -> Repair -> Accept
    # Fixed number of kicks to bound runtime
    num_kicks = 3

    for _ in range(num_kicks):
        # 1. Perturbation (Kick)
        # Swap 2 random pairs to escape local basin
        neighbor = list(current_schedule)
        for _ in range(2):
            i, j = random.randint(0, num_txns-1), random.randint(0, num_txns-1)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

        kick_cost = workload.get_opt_seq_cost(neighbor)

        # 2. Repair (Shallow Descent)
=======
    # ILS Loop: Kick -> Repair -> Accept
    # Fixed number of kicks to bound runtime
    num_kicks = 5

    for _ in range(num_kicks):
        # 1. Perturbation (Kick)
        neighbor = list(current_schedule)

        # Mix of Swap and Block Shuffle
        if random.random() < 0.3:
            # Block Shuffle: Scramble a small segment
            # Good for resolving local deadlocks in a cluster
            blk_len = random.randint(4, 8)
            start = random.randint(0, max(0, num_txns - blk_len))
            segment = neighbor[start : start+blk_len]
            random.shuffle(segment)
            neighbor[start : start+blk_len] = segment
        else:
            # Multi-Swap: 2-3 random swaps
            swaps = random.randint(2, 3)
            for _ in range(swaps):
                i, j = random.randint(0, num_txns-1), random.randint(0, num_txns-1)
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

        kick_cost = workload.get_opt_seq_cost(neighbor)

        # 2. Repair (Shallow Descent)
>>>>>>> REPLACE
</DIFF>