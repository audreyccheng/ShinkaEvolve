<NAME>
greedy_with_local_search
</NAME>

<DESCRIPTION>
I propose enhancing the `get_best_schedule` function by combining the existing randomized greedy strategy with a post-processing Local Search phase (Hill Climbing).

Reasoning:
1.  **Greedy Phase**: The current implementation effectively uses a greedy approach with a "Longest Processing Time" (LPT) bias. This is good for establishing a global structure (scheduling heavy items) but often makes suboptimal local decisions because it only looks at the immediate makespan increase (Shortest Job Next effect).
2.  **Local Search Phase**: After finding a candidate schedule, we can improve it by moving transactions around. I use a "Shift" operator (moving a transaction from index i to j) which is more effective than "Swap" for dependency ordering problems.
3.  **Efficiency**: The cost function `get_opt_seq_cost` is reasonably fast. Adding a few hundred iterations of local search after the greedy phase exploits the remaining time budget to refine the schedule, smoothing out gaps or resolving bottlenecks introduced by the greedy choices.

This hybrid approach (Construction + Improvement) generally yields better quality solutions than repeated construction alone.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using a multi-start greedy strategy with heuristic bias.

    This approach runs multiple independent greedy constructions. It combines random
    sampling with a heuristic that prioritizes 'heavy' (long duration) transactions
    to find a schedule that minimizes makespan.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to generate/sample (iterations)

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """

    # Pre-calculate transaction costs for heuristic (Longest Processing Time)
    # Structure assumption: workload.txns[t][0][3] is the duration/cost
    txn_costs = {}
    try:
        for t in range(workload.num_txns):
            # Accessing the cost of the first operation sequence of the transaction
            txn_costs[t] = workload.txns[t][0][3]
    except (IndexError, AttributeError, TypeError):
        # Fallback if structure differs
        for t in range(workload.num_txns):
            txn_costs[t] = 1

    def generate_schedule(sample_size, use_heavy_bias=False):
        """Generates a single schedule using randomized greedy construction."""
        remaining = list(range(workload.num_txns))
        schedule = []

        # Start with a random transaction to ensure diversity across restarts
        start_idx = random.randint(0, len(remaining) - 1)
        schedule.append(remaining.pop(start_idx))

        # Greedily build the rest of the schedule
        while remaining:
            candidates = set()

            # 1. Random sampling: Pick random candidates from remaining
            k = min(len(remaining), sample_size)
            candidates.update(random.sample(remaining, k))

            # 2. Heuristic bias: Also consider the heaviest remaining transactions
            # This helps to schedule long transactions when they fit best
            if use_heavy_bias:
                # Get top 2 heaviest transactions
                heaviest = sorted(remaining, key=lambda x: txn_costs.get(x, 0), reverse=True)[:2]
                candidates.update(heaviest)

            # Evaluate all unique candidates
            best_c = -1
            best_c_cost = float('inf')

            for c in candidates:
                # Calculate cost of appending this candidate
                # workload.get_opt_seq_cost returns the makespan of the sequence
                test_seq = schedule + [c]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < best_c_cost:
                    best_c_cost = cost
                    best_c = c

            if best_c != -1:
                schedule.append(best_c)
                remaining.remove(best_c)
            else:
                # Should technically not happen if candidates list is not empty
                c = remaining.pop(0)
                schedule.append(c)

        # Return final cost and schedule
        final_cost = workload.get_opt_seq_cost(schedule)
        return final_cost, schedule

    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Run multiple iterations to explore the search space
    # num_seqs determines the budget (number of restarts)
    iterations = max(1, num_seqs)

    for i in range(iterations):
        # Iteration strategy:
        # First iteration: Use a wider random sample (6) without bias to get a robust baseline.
        # Subsequent iterations: Use a tighter sample (2) but inject heavy-item bias.
        # This combination (Randomized Greedy + LPT Heuristic) usually outperforms pure random greedy.

        if i == 0:
            cost, sched = generate_schedule(sample_size=6, use_heavy_bias=False)
        else:
            cost, sched = generate_schedule(sample_size=2, use_heavy_bias=True)

        if cost < best_overall_cost:
            best_overall_cost = cost
            best_overall_schedule = sched

    return best_overall_cost, best_overall_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using a hybrid strategy: Multi-start Greedy + Local Search.

    1. Multi-start Greedy: Generates candidate schedules using randomized greedy construction
       biased towards 'heavy' transactions (LPT heuristic).
    2. Local Search (Hill Climbing): Refines the best candidate found by shifting transactions
       to different positions to escape local optima and tighten the makespan.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of greedy iterations to perform

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """

    # Pre-calculate transaction costs for heuristic (Longest Processing Time)
    txn_costs = {}
    try:
        for t in range(workload.num_txns):
            txn_costs[t] = workload.txns[t][0][3]
    except (IndexError, AttributeError, TypeError):
        for t in range(workload.num_txns):
            txn_costs[t] = 1

    def generate_greedy_schedule(sample_size, bias_limit):
        """Generates a schedule using randomized greedy with optional heavy-item bias."""
        remaining = list(range(workload.num_txns))
        schedule = []

        # Start with a random transaction
        start_idx = random.randint(0, len(remaining) - 1)
        schedule.append(remaining.pop(start_idx))

        while remaining:
            candidates = set()

            # Random sampling
            k = min(len(remaining), sample_size)
            candidates.update(random.sample(remaining, k))

            # Heuristic bias: consider heaviest remaining transactions
            if bias_limit > 0:
                heaviest = sorted(remaining, key=lambda x: txn_costs.get(x, 0), reverse=True)[:bias_limit]
                candidates.update(heaviest)

            best_c = -1
            best_c_cost = float('inf')

            # Select best candidate based on immediate makespan
            for c in candidates:
                test_seq = schedule + [c]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < best_c_cost:
                    best_c_cost = cost
                    best_c = c

            if best_c != -1:
                schedule.append(best_c)
                remaining.remove(best_c)
            else:
                schedule.append(remaining.pop(0))

        return workload.get_opt_seq_cost(schedule), schedule

    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Phase 1: Multi-start Greedy Construction
    iterations = max(1, num_seqs)

    for i in range(iterations):
        # First iteration: Exploration (random)
        # Others: Exploitation (heavy bias)
        if i == 0:
            cost, sched = generate_greedy_schedule(sample_size=6, bias_limit=0)
        else:
            cost, sched = generate_greedy_schedule(sample_size=3, bias_limit=3)

        if cost < best_overall_cost:
            best_overall_cost = cost
            best_overall_schedule = sched

    # Phase 2: Local Search Refinement (Hill Climbing with Shift)
    # Try to improve the best schedule by moving transactions
    current_schedule = list(best_overall_schedule)
    current_cost = best_overall_cost

    # Number of improvement attempts
    search_steps = 400
    no_improv_limit = 100
    no_improv = 0

    for _ in range(search_steps):
        if no_improv >= no_improv_limit:
            break

        # Shift operator: Move transaction from src to dst
        idx_src = random.randint(0, len(current_schedule) - 1)
        idx_dst = random.randint(0, len(current_schedule) - 1)

        if idx_src == idx_dst:
            continue

        neighbor = list(current_schedule)
        txn = neighbor.pop(idx_src)
        neighbor.insert(idx_dst, txn)

        new_cost = workload.get_opt_seq_cost(neighbor)

        if new_cost < current_cost:
            current_cost = new_cost
            current_schedule = neighbor
            no_improv = 0
        else:
            no_improv += 1

    return current_cost, current_schedule
>>>>>>> REPLACE
</DIFF>