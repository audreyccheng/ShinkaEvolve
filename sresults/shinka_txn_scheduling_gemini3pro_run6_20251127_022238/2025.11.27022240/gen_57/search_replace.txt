<NAME>
tune_config_params
</NAME>
<DESCRIPTION>
Increase sampling count to 24 to support more aggressive weighting, and increase lookahead candidates to 3 to better evaluate critical paths.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Sampling
    SAMPLES_PER_NODE = 16

    # Lookahead
    # Check this many LPT candidates in lookahead phase to determine score
    LOOKAHEAD_LPT_CANDIDATES = 2
=======
    # Sampling
    SAMPLES_PER_NODE = 24

    # Lookahead
    # Check this many LPT candidates in lookahead phase to determine score
    LOOKAHEAD_LPT_CANDIDATES = 3
>>>>>>> REPLACE
</DIFF>

<NAME>
cubic_weighted_sampling
</NAME>
<DESCRIPTION>
Switch from linear to cubic weighting for random sampling in the beam search. This prioritizes heavy transactions more aggressively, which has been shown to improve makespan in this problem domain.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
                    else:
                        weights = [txn_durations[x] for x in pool]
                        # Oversample to hit unique targets
                        picks = random.choices(pool, weights=weights, k=needed + 2)
                        samples.update(picks)
=======
                    else:
                        # Cubic weights to aggressively favor heavy transactions
                        weights = [txn_durations[x]**3 for x in pool]
                        # Oversample to hit unique targets
                        picks = random.choices(pool, weights=weights, k=needed + 2)
                        samples.update(picks)
>>>>>>> REPLACE
</DIFF>

<NAME>
ils_ruin_recreate
</NAME>
<DESCRIPTION>
Enhance the ILS perturbation phase with a Ruin-and-Recreate strategy (Large Neighborhood Search). This removes a small set of random transactions and re-inserts them greedily, providing a more structured way to escape local optima compared to simple swaps or shuffles.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    def perturb(seq):
        """Apply structural perturbation."""
        n = len(seq)
        new_seq = seq[:]
        mode = random.random()

        if mode < 0.4:
            # Block Move
            # Move a chunk of transactions to a new location
            # Good for fixing phase issues
            block_size = random.randint(3, 6)
            if n > block_size:
                start = random.randint(0, n - block_size)
                block = new_seq[start : start + block_size]
                remaining = new_seq[:start] + new_seq[start + block_size:]
                insert_pos = random.randint(0, len(remaining))
                new_seq = remaining[:insert_pos] + block + remaining[insert_pos:]

        elif mode < 0.7:
            # Multi-Swap
            for _ in range(3):
                i, j = random.sample(range(n), 2)
                new_seq[i], new_seq[j] = new_seq[j], new_seq[i]

        else:
            # Shuffle Segment
            l = random.randint(5, 10)
            if n > l:
                s = random.randint(0, n - l)
                sub = new_seq[s : s+l]
                random.shuffle(sub)
                new_seq[s : s+l] = sub

        return new_seq
=======
    def perturb(seq):
        """Apply structural perturbation (Ruin-Recreate, Block Move, Swap)."""
        n = len(seq)
        new_seq = seq[:]
        mode = random.random()

        if mode < 0.35:
            # Ruin and Recreate (LNS)
            # Remove k items and reinsert them greedily
            k = random.randint(3, 6)
            removed = []
            # Remove random items
            indices = sorted(random.sample(range(n), k), reverse=True)
            for idx in indices:
                removed.append(new_seq.pop(idx))

            # Recreate: Insert heavy items first
            removed.sort(key=lambda t: txn_durations[t], reverse=True)

            for t in removed:
                best_pos = -1
                best_c = float('inf')
                # Scan all valid insertion positions
                for pos in range(len(new_seq) + 1):
                    cand = new_seq[:pos] + [t] + new_seq[pos:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < best_c:
                        best_c = c
                        best_pos = pos

                new_seq.insert(best_pos, t)

        elif mode < 0.7:
            # Block Move
            # Move a chunk of transactions to a new location
            block_size = random.randint(3, 6)
            if n > block_size:
                start = random.randint(0, n - block_size)
                block = new_seq[start : start + block_size]
                remaining = new_seq[:start] + new_seq[start + block_size:]
                insert_pos = random.randint(0, len(remaining))
                new_seq = remaining[:insert_pos] + block + remaining[insert_pos:]

        else:
            # Multi-Swap
            for _ in range(3):
                i, j = random.sample(range(n), 2)
                new_seq[i], new_seq[j] = new_seq[j], new_seq[i]

        return new_seq
>>>>>>> REPLACE
</DIFF>