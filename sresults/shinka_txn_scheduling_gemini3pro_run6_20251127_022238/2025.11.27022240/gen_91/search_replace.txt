<NAME>
optimize_search_parameters
</NAME>

<DESCRIPTION>
Optimizes the scheduling algorithm by implementing several targeted improvements:
1.  **Beam Search**: Increases deterministic LPT anchors from 2 to 4 to better adhere to the critical path heuristic. Reduces Beam Width slightly to focus computational resources.
2.  **Lookahead**: Tunes Lookahead targets to 4 for efficiency.
3.  **ILS Ruin**: Increases the aggressiveness of the Ruin phase (6-9 items for scatter, 4-7 for block) to escape stronger local optima.
4.  **ILS Acceptance**: Introduces a Threshold Acceptance criterion (0.5% tolerance) to allow traversing valleys in the optimization landscape.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    """
    Get optimal schedule using Quartic-Weighted Beam Search and Hybrid Ruin-and-Recreate ILS.

    Algorithm:
    1. Beam Search:
       - Expansion: Hybrid sampling (Deterministic Top-LPT + Quartic Weighted Random).
       - Weighting: d^4 weighting heavily biases selection towards long transactions to pack "big rocks" first.
       - Lookahead: "Optimistic" Multi-Target Lookahead. Evaluates the top-5 largest remaining transactions
         to see if *any* of them fit well (minimal idle time increase) after the current candidate.
    2. Hybrid Ruin-and-Recreate ILS:
       - Perturbation:
         - Mode A: Random scatter removal (standard ruin).
         - Mode B: Block removal (removes a contiguous time window).
       - Recreation: Re-inserts removed items greedily, sorted by duration (Longest First).
       - Refinement: Standard swap/insert local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Used to scale the beam width

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # --- Parameters ---
    BEAM_WIDTH = int(max(15, num_seqs * 2.8))
    SAMPLES_PER_NODE = 24
    MAX_CHILDREN = 4

    # Lookahead Settings
    # We filter candidates before lookahead to save time
    LOOKAHEAD_POOL_FACTOR = 2.0
    LOOKAHEAD_TARGETS = 5 # Check top 5 LPT candidates

    # ILS Settings
    ILS_CYCLES = 12
=======
    """
    Get optimal schedule using Quartic-Weighted Beam Search and Hybrid Ruin-and-Recreate ILS.

    Algorithm:
    1. Beam Search:
       - Expansion: Hybrid sampling (Deterministic Top-LPT + Quartic Weighted Random).
       - Weighting: d^4 weighting heavily biases selection towards long transactions to pack "big rocks" first.
       - Lookahead: "Optimistic" Multi-Target Lookahead. Evaluates the top-4 largest remaining transactions
         to see if *any* of them fit well (minimal idle time increase) after the current candidate.
    2. Hybrid Ruin-and-Recreate ILS:
       - Perturbation:
         - Mode A: Random scatter removal (aggressive ruin).
         - Mode B: Block removal (removes a contiguous time window).
       - Recreation: Re-inserts removed items greedily, sorted by duration (Longest First).
       - Refinement: Standard swap/insert local search.
       - Acceptance: Threshold Acceptance (allows small degradation).

    Args:
        workload: Workload object containing transaction data
        num_seqs: Used to scale the beam width

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # --- Parameters ---
    BEAM_WIDTH = int(max(10, num_seqs * 2.8))
    SAMPLES_PER_NODE = 24
    MAX_CHILDREN = 4

    # Lookahead Settings
    # We filter candidates before lookahead to save time
    LOOKAHEAD_POOL_FACTOR = 2.0
    LOOKAHEAD_TARGETS = 4 # Check top 4 LPT candidates

    # ILS Settings
    ILS_CYCLES = 12
>>>>>>> REPLACE
<<<<<<< SEARCH
            # 1. Deterministic LPT (Top 2)
            # Ensure we always consider the biggest remaining tasks
            lpt_count = 0
            for t in sorted_lpt:
                if t in parent['rem']:
                    samples.add(t)
                    lpt_count += 1
                    if lpt_count >= 2: break
=======
            # 1. Deterministic LPT (Top 4)
            # Ensure we always consider the biggest remaining tasks
            lpt_count = 0
            for t in sorted_lpt:
                if t in parent['rem']:
                    samples.add(t)
                    lpt_count += 1
                    if lpt_count >= 4: break
>>>>>>> REPLACE
<<<<<<< SEARCH
    for i in range(ILS_CYCLES):
        p_seq = curr_seq[:]

        # Determine Ruin Strategy: Random Scatter vs Block
        # Block ruin helps shift contiguous dependencies
        ruin_mode = 'block' if (i % 3 == 0) else 'scatter'
        removed = []

        if len(p_seq) > 6:
            if ruin_mode == 'block':
                # Remove a contiguous slice
                block_size = random.choice([3, 4, 5])
                start_idx = random.randint(0, len(p_seq) - block_size)
                # Slice out the block
                removed = p_seq[start_idx : start_idx + block_size]
                del p_seq[start_idx : start_idx + block_size]
            else:
                # Random scatter removal
                ruin_size = random.choice([3, 4, 5])
                for _ in range(ruin_size):
                    if not p_seq: break
                    idx = random.randint(0, len(p_seq) - 1)
                    removed.append(p_seq.pop(idx))
=======
    for i in range(ILS_CYCLES):
        p_seq = curr_seq[:]

        # Determine Ruin Strategy: Random Scatter vs Block
        # Block ruin helps shift contiguous dependencies
        ruin_mode = 'block' if (i % 3 == 0) else 'scatter'
        removed = []

        if len(p_seq) > 10:
            if ruin_mode == 'block':
                # Remove a contiguous slice
                block_size = random.randint(4, 7)
                start_idx = random.randint(0, len(p_seq) - block_size)
                # Slice out the block
                removed = p_seq[start_idx : start_idx + block_size]
                del p_seq[start_idx : start_idx + block_size]
            else:
                # Random scatter removal (Aggressive: 6-9 items)
                ruin_size = random.randint(6, 9)
                for _ in range(ruin_size):
                    if not p_seq: break
                    idx = random.randint(0, len(p_seq) - 1)
                    removed.append(p_seq.pop(idx))
>>>>>>> REPLACE
<<<<<<< SEARCH
        # Acceptance
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq
            curr_seq = p_seq
            curr_cost = p_cost
        elif p_cost < curr_cost:
            curr_seq = p_seq
            curr_cost = p_cost
=======
        # Acceptance with Threshold (Allow 0.5% degradation)
        threshold = 0.005
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq
            curr_seq = p_seq
            curr_cost = p_cost
        elif p_cost < curr_cost * (1.0 + threshold):
            curr_seq = p_seq
            curr_cost = p_cost
>>>>>>> REPLACE
</DIFF>