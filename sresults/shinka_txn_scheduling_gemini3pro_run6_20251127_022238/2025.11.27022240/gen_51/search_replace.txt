<NAME>
vnd_beam_ils
</NAME>

<DESCRIPTION>
1. Updates Urgency weights to favor Duration slightly more (1.0 vs 0.7), aligning with best historical performance.
2. Implements Tapered Beam Search (Lookahead) where beam width dynamically reduces from 1.5x to 0.5x base width, allowing exploration early and convergence late.
3. Replaces the greedy critical re-insertion and standard local descent with a Variable Neighborhood Descent (VND). VND alternates between Windowed Insertion (global placement) and Adjacent Swaps (local ordering), providing a more robust local search.
4. Updates ILS to use VND for repair.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Urgency Score
    # Normalize for combination
    max_vol = max(conflict_vol) if conflict_vol else 1.0
    max_dur = max(t[0] for t in txn_data) if txn_data else 1.0
    if max_vol == 0: max_vol = 1.0

    urgency = {}
    for t in range(num_txns):
        # Weighted mix: 40% Duration, 60% Conflict Volume
        # Prefer clearing heavy bottlenecks early
        u = 0.4 * (txn_data[t][0] / max_dur) + 0.6 * (conflict_vol[t] / max_vol)
        urgency[t] = u

    # --- 2. LOOKAHEAD BEAM SEARCH ---

    BEAM_WIDTH = max(5, int(num_seqs))

    # Beam State: (cost_heuristic, schedule_list, remaining_list)
    # Note: cost_heuristic is used for sorting in beam, we use Lookahead Cost there.
    beam = [(0, [], list(range(num_txns)))]

    for _ in range(num_txns):
        candidates_pool = []

        for _, p_sched, p_remain in beam:

            # Sort remaining by Urgency
            sorted_remain = sorted(p_remain, key=lambda x: urgency[x], reverse=True)

            # Candidate Selection
            # 1. Top K Deterministic
            to_check = set(sorted_remain[:3])

            # 2. Weighted Random (Soft urgency)
            if len(sorted_remain) > 3:
                pool = sorted_remain[3:]
                weights = [urgency[x] for x in pool]
                # Sample 3
                samples = random.choices(pool, weights=weights, k=min(3, len(pool)))
                to_check.update(samples)

            # Lookahead Setup
            # The "Next Best" item to tentatively add is the most urgent one remaining.
            # If 'c' is the most urgent, Next Best is the 2nd most urgent.
            best_urgent = sorted_remain[0]
            second_best = sorted_remain[1] if len(sorted_remain) > 1 else None

            for c in to_check:
                new_sched = p_sched + [c]

                # Lookahead Metric
                # Determine probe item
                probe = best_urgent if c != best_urgent else second_best

                if probe is not None:
                    # Cost after 2 steps
                    metric_cost = workload.get_opt_seq_cost(new_sched + [probe])
                else:
                    # End of list
                    metric_cost = workload.get_opt_seq_cost(new_sched)

                # Tuple for sorting: (LookaheadCost, -Urgency)
                metric = (metric_cost, -urgency[c])

                new_remain = list(p_remain)
                new_remain.remove(c)

                candidates_pool.append((metric, new_sched, new_remain))

        # Pruning
        candidates_pool.sort(key=lambda x: x[0])
        # Keep top Width
        # Store just the tuple needed for next iteration
        beam = [(x[0][0], x[1], x[2]) for x in candidates_pool[:BEAM_WIDTH]]

    # Best Schedule from Beam
    best_state = beam[0]
    current_schedule = best_state[1]
    current_cost = workload.get_opt_seq_cost(current_schedule)

    # --- 3. CRITICAL PATH RE-INSERTION ---
    # Global optimization for the most critical items.

    num_critical = min(8, num_txns)
    critical_txns = sorted(range(num_txns), key=lambda x: urgency[x], reverse=True)[:num_critical]

    for t in critical_txns:
        if t not in current_schedule: continue

        curr_idx = current_schedule.index(t)
        # Remove
        temp_sched = current_schedule[:curr_idx] + current_schedule[curr_idx+1:]

        best_pos = curr_idx
        best_val = current_cost

        # Try all positions
        for p in range(len(temp_sched) + 1):
            cand = temp_sched[:p] + [t] + temp_sched[p:]
            val = workload.get_opt_seq_cost(cand)
            if val < best_val:
                best_val = val
                best_pos = p

        if best_val < current_cost:
            current_cost = best_val
            current_schedule = temp_sched[:best_pos] + [t] + temp_sched[best_pos:]

    # --- 4. MULTI-CYCLE ITERATED LOCAL SEARCH ---

    def local_descent(sched, base_cost, window=10):
        s = list(sched)
        c = base_cost
        improved = True
        passes = 0
        while improved and passes < 2:
            improved = False
            passes += 1
            check_order = list(range(len(s)))
            random.shuffle(check_order)

            for i in check_order:
                item = s[i]
                temp = s[:i] + s[i+1:]

                start = max(0, i - window)
                end = min(len(temp), i + window)

                best_p = -1
                best_c = c

                for p in range(start, end + 1):
                    cand = temp[:p] + [item] + temp[p:]
                    val = workload.get_opt_seq_cost(cand)
                    if val < best_c:
                        best_c = val
                        best_p = p

                if best_p != -1:
                    s = temp[:best_p] + [item] + temp[best_p:]
                    c = best_c
                    improved = True
        return c, s

    # Initial Descent
    current_cost, current_schedule = local_descent(current_schedule, current_cost)

    # ILS Loop
    num_kicks = 4

    for _ in range(num_kicks):
        neighbor = list(current_schedule)

        # Perturbation: Block Move vs Swap
        # Block Move (60%): Good for moving dependent chains
        if random.random() < 0.6:
            block_size = random.randint(3, 6)
            if num_txns > block_size:
                src = random.randint(0, num_txns - block_size)
                block = neighbor[src : src+block_size]
                del neighbor[src : src+block_size]
                dst = random.randint(0, len(neighbor))
                neighbor[dst:dst] = block
        else:
            # Multi-Swap (40%)
            for _ in range(3):
                i, j = random.randint(0, num_txns-1), random.randint(0, num_txns-1)
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

        # Repair
        kick_cost = workload.get_opt_seq_cost(neighbor)
        repaired_cost, repaired_sched = local_descent(neighbor, kick_cost, window=8)

        # Acceptance
        if repaired_cost < current_cost:
            current_cost = repaired_cost
            current_schedule = repaired_sched
=======
    # Urgency Score
    # Normalize for combination
    max_vol = max(conflict_vol) if conflict_vol else 1.0
    max_dur = max(t[0] for t in txn_data) if txn_data else 1.0
    if max_vol == 0: max_vol = 1.0

    urgency = {}
    for t in range(num_txns):
        # Weighted mix: 1.0 Duration, 0.7 Conflict Volume (Based on historical best)
        # Duration is slightly prioritized to clear long jobs.
        u = 1.0 * (txn_data[t][0] / max_dur) + 0.7 * (conflict_vol[t] / max_vol)
        urgency[t] = u

    # --- 2. TAPERED LOOKAHEAD BEAM SEARCH ---

    # Dynamic Beam Width: Start wide to explore, taper down to exploit
    base_width = max(5, int(num_seqs))
    start_width = int(base_width * 1.5)
    min_width = max(2, int(base_width * 0.5))

    # Beam State: (cost_heuristic, schedule_list, remaining_list)
    beam = [(0, [], list(range(num_txns)))]

    for step in range(num_txns):
        # Calculate current width
        width = int(start_width - (step / num_txns) * (start_width - min_width))
        width = max(min_width, width)

        candidates_pool = []

        for _, p_sched, p_remain in beam:

            # Sort remaining by Urgency
            sorted_remain = sorted(p_remain, key=lambda x: urgency[x], reverse=True)

            # Candidate Selection
            # 1. Top K Deterministic
            to_check = set(sorted_remain[:3])

            # 2. Weighted Random
            if len(sorted_remain) > 3:
                pool = sorted_remain[3:]
                weights = [urgency[x] for x in pool]
                samples = random.choices(pool, weights=weights, k=min(2, len(pool)))
                to_check.update(samples)

            # Lookahead Setup
            best_urgent = sorted_remain[0]
            second_best = sorted_remain[1] if len(sorted_remain) > 1 else None

            for c in to_check:
                new_sched = p_sched + [c]

                # Lookahead Metric: Cost(S + c + next_best)
                probe = best_urgent if c != best_urgent else second_best

                if probe is not None:
                    metric_cost = workload.get_opt_seq_cost(new_sched + [probe])
                else:
                    metric_cost = workload.get_opt_seq_cost(new_sched)

                # Metric: (LookaheadCost, -Urgency)
                metric = (metric_cost, -urgency[c])

                new_remain = list(p_remain)
                new_remain.remove(c)

                candidates_pool.append((metric, new_sched, new_remain))

        # Pruning
        candidates_pool.sort(key=lambda x: x[0])
        beam = [(x[0][0], x[1], x[2]) for x in candidates_pool[:width]]

    # Best Schedule from Beam
    best_state = beam[0]
    current_schedule = best_state[1]
    current_cost = workload.get_opt_seq_cost(current_schedule)

    # --- 3. VARIABLE NEIGHBORHOOD DESCENT (VND) & ILS ---

    def run_vnd(sched, base_cost):
        """
        Variable Neighborhood Descent:
        Alternates between Windowed Insertion (Global) and Adjacent Swap (Local).
        """
        curr_s = list(sched)
        curr_c = base_cost

        # Limit VND loops to prevent timeout
        for _ in range(2):
            improved_in_loop = False

            # Neighborhood 1: Windowed Insertion
            # Shuffling check order avoids directional bias
            check_order = list(range(len(curr_s)))
            random.shuffle(check_order)

            for i in check_order:
                item = curr_s[i]
                temp = curr_s[:i] + curr_s[i+1:]

                window = 12
                start = max(0, i - window)
                end = min(len(temp), i + window)

                best_p = -1
                best_val = curr_c

                for p in range(start, end + 1):
                    cand = temp[:p] + [item] + temp[p:]
                    val = workload.get_opt_seq_cost(cand)
                    if val < best_val:
                        best_val = val
                        best_p = p

                if best_p != -1:
                    curr_s = temp[:best_p] + [item] + temp[best_p:]
                    curr_c = best_val
                    improved_in_loop = True

            # Neighborhood 2: Adjacent Swaps
            # Fast scan to fix local ordering
            swap_improved = False
            for i in range(len(curr_s) - 1):
                # Speculative swap
                curr_s[i], curr_s[i+1] = curr_s[i+1], curr_s[i]
                val = workload.get_opt_seq_cost(curr_s)
                if val < curr_c:
                    curr_c = val
                    swap_improved = True
                    improved_in_loop = True
                else:
                    # Revert
                    curr_s[i], curr_s[i+1] = curr_s[i+1], curr_s[i]

            if not improved_in_loop:
                break

        return curr_c, curr_s

    # Initial Deep Descent
    current_cost, current_schedule = run_vnd(current_schedule, current_cost)

    # ILS Loop
    num_kicks = 3

    for _ in range(num_kicks):
        neighbor = list(current_schedule)

        # Perturbation: Block Move or Multi-Swap
        if random.random() < 0.5:
            # Block Move
            if num_txns > 6:
                bs = random.randint(4, 8)
                src = random.randint(0, num_txns - bs)
                block = neighbor[src : src+bs]
                del neighbor[src : src+bs]
                dst = random.randint(0, len(neighbor))
                neighbor[dst:dst] = block
        else:
            # Multi-Swap
            for _ in range(3):
                i, j = random.randint(0, num_txns-1), random.randint(0, num_txns-1)
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

        # Repair
        kick_cost = workload.get_opt_seq_cost(neighbor)
        repaired_cost, repaired_sched = run_vnd(neighbor, kick_cost)

        # Acceptance
        if repaired_cost < current_cost:
            current_cost = repaired_cost
            current_schedule = repaired_sched
>>>>>>> REPLACE
</DIFF>