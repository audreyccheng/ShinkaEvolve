<NAME>
tune_beam_parameters
</NAME>
<DESCRIPTION>
Increases the beam width multiplier and samples per node to improve exploration during the beam search phase. This aligns the parameters closer to previously successful high-scoring variants by widening the search space.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # --- Parameters ---
    # Base Beam Width: Scale with effort
    # We will use a dynamic width that tapers off
    BASE_WIDTH = int(max(10, num_seqs * 1.5))

    # Samples per node: Candidates to evaluate from each parent
    SAMPLES_PER_NODE = 16
=======
    # --- Parameters ---
    # Base Beam Width: Scale with effort
    # We will use a dynamic width that tapers off
    BASE_WIDTH = int(max(12, num_seqs * 2.5))

    # Samples per node: Candidates to evaluate from each parent
    SAMPLES_PER_NODE = 20
>>>>>>> REPLACE
</DIFF>

<NAME>
implement_multi_cycle_ils
</NAME>
<DESCRIPTION>
Replaces the single-pass local search with a Multi-Cycle Iterated Local Search (ILS).
This new implementation:
1. Wraps the swap and insertion moves into a `local_search_descent` function that runs until convergence (or a pass limit).
2. Uses a Perturbation-Repair loop (ILS) to escape local optima. In each cycle, the schedule is perturbed (random swaps) and then repaired (local descent).
3. Accepts improvements to the global best, and uses a greedy acceptance criterion for the current basin (accept if better than current) to explore the landscape.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # --- Local Search Refinement ---
    # Shift/Insert moves are more effective for dependency ordering than swaps
    INSERT_WINDOW = 8

    # Pass 1: Local Swaps (Fast Cleanup)
    for i in range(num_txns - 1):
        best_seq[i], best_seq[i+1] = best_seq[i+1], best_seq[i]
        c = workload.get_opt_seq_cost(best_seq)
        if c < best_cost:
            best_cost = c
        else:
            best_seq[i], best_seq[i+1] = best_seq[i+1], best_seq[i]

    # Pass 2: Windowed Insertion (Structure optimization)
    # Try moving each transaction to a better location nearby
    for i in range(num_txns):
        txn = best_seq[i]

        # Candidate sequence without the transaction
        temp_seq = best_seq[:i] + best_seq[i+1:]

        start_j = max(0, i - INSERT_WINDOW)
        end_j = min(len(temp_seq), i + INSERT_WINDOW)

        for j in range(start_j, end_j + 1):
            if j == i: continue

            cand_seq = temp_seq[:j] + [txn] + temp_seq[j:]
            c = workload.get_opt_seq_cost(cand_seq)

            if c < best_cost:
                best_cost = c
                best_seq = cand_seq
                # Greedy: Accept immediately and move to next transaction
                # Note: This shifts indices for subsequent items, but that's acceptable for a heuristic pass
                break

    return best_cost, best_seq
=======
    # --- Multi-Cycle Iterated Local Search (ILS) ---

    def local_search_descent(seq, current_cost):
        """Refines sequence using swaps and windowed insertions."""
        improved = True
        passes = 0
        # Limit passes to ensure we don't spend too much time
        while improved and passes < 3:
            improved = False
            passes += 1

            # 1. Swaps (Window 5)
            # Good for fixing local ordering of conflicting items
            w_swap = 5
            for i in range(len(seq) - 1):
                for offset in range(1, w_swap + 1):
                    j = i + offset
                    if j >= len(seq): break

                    # Swap
                    seq[i], seq[j] = seq[j], seq[i]
                    c = workload.get_opt_seq_cost(seq)
                    if c < current_cost:
                        current_cost = c
                        improved = True
                    else:
                        seq[i], seq[j] = seq[j], seq[i] # Revert

            # 2. Insertions (Window 8)
            # Good for moving a transaction past a block of conflicts
            w_ins = 8
            for i in range(len(seq)):
                txn = seq[i]
                temp = seq[:i] + seq[i+1:]

                start = max(0, i - w_ins)
                end = min(len(temp), i + w_ins)

                for k in range(start, end + 1):
                    cand = temp[:k] + [txn] + temp[k:]
                    c = workload.get_opt_seq_cost(cand)
                    if c < current_cost:
                        current_cost = c
                        seq = cand
                        improved = True
                        break # Greedy first improvement per item
        return seq, current_cost

    # Phase 1: Initial Descent
    best_seq, best_cost = local_search_descent(best_seq, best_cost)

    # Phase 2: Perturbation Loop (ILS)
    # Cycles: Perturb -> Repair -> Accept
    curr_seq = best_seq[:]
    curr_cost = best_cost

    ILS_CYCLES = 5

    for cycle in range(ILS_CYCLES):
        p_seq = curr_seq[:]
        if len(p_seq) < 4: break

        # Perturbation: Random Kicks
        # Vary kick strength: occasional strong kick (double swap)
        num_swaps = 2 if cycle % 2 == 0 else 1

        for _ in range(num_swaps):
            i1, i2 = random.sample(range(len(p_seq)), 2)
            p_seq[i1], p_seq[i2] = p_seq[i2], p_seq[i1]

        # Repair
        p_cost = workload.get_opt_seq_cost(p_seq)
        p_seq, p_cost = local_search_descent(p_seq, p_cost)

        # Acceptance
        if p_cost < best_cost:
            best_cost = p_cost
            best_seq = p_seq[:]
            curr_seq = p_seq[:]
            curr_cost = p_cost
        elif p_cost < curr_cost:
            # Accept if better than current baseline (Basin Hopping descent)
            curr_seq = p_seq[:]
            curr_cost = p_cost

    return best_cost, best_seq
>>>>>>> REPLACE
</DIFF>