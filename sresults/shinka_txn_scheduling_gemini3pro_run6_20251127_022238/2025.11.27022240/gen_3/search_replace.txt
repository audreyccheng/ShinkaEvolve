<NAME>
implement_greedy_restarts
</NAME>

<DESCRIPTION>
The current `get_best_schedule` function accepts a `num_seqs` argument but fails to use it, running only a single randomized greedy pass. This limits the exploration of the scheduling search space. I will implement a "greedy with restarts" strategy that actually runs the greedy construction `num_seqs` times and returns the best schedule found. I will also clean up the inner `get_greedy_cost_sampled` function to be more efficient, removing unused code and using a slightly larger sample size (15) to improve decision quality at each step.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    def get_greedy_cost_sampled(num_samples, sample_rate):
        # greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = [x for x in range(0, workload.num_txns)]
        remaining_txns.remove(start_txn)
        running_cost = workload.txns[start_txn][0][3]

        for i in range(0, workload.num_txns - 1):
            min_cost = 100000  # MAX
            min_relative_cost = 10
            min_txn = -1
            holdout_txns = []
            done = False
            key_maps = []

            sample = random.random()
            if sample > sample_rate:
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                txn_seq.append(t)
                remaining_txns.pop(idx)
                continue

            for j in range(0, num_samples):
                idx = 0
                if len(remaining_txns) > 1:
                    idx = random.randint(0, len(remaining_txns) - 1)
                else:
                    done = True
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                txn_len = workload.txns[t][0][3]
                test_seq = txn_seq.copy()
                test_seq.append(t)
                cost = 0
                cost = workload.get_opt_seq_cost(test_seq)
                if cost < min_cost:
                    min_cost = cost
                    min_txn = t
                if done:
                    break
            assert(min_txn != -1)
            running_cost = min_cost
            txn_seq.append(min_txn)
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        assert len(set(txn_seq)) == workload.num_txns

        overall_cost = workload.get_opt_seq_cost(txn_seq)
        return overall_cost, txn_seq

    return get_greedy_cost_sampled(10, 1.0)
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_cost = float('inf')
    best_schedule = []

    def get_greedy_cost_sampled(num_samples):
        # greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        for i in range(workload.num_txns - 1):
            min_cost = float('inf')
            min_txn = -1
            holdout_txns = []

            # Determine how many samples to check
            # Check up to num_samples, but not more than available
            current_samples = min(num_samples, len(remaining_txns))

            # Sample candidates
            for _ in range(current_samples):
                # Pick a random candidate from remaining
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]

                # Move from remaining to holdout so we don't pick it again this step
                remaining_txns.pop(idx)
                holdout_txns.append(t)

                # Evaluate cost
                test_seq = txn_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < min_cost:
                    min_cost = cost
                    min_txn = t

            # Select the best candidate found
            if min_txn != -1:
                txn_seq.append(min_txn)
                holdout_txns.remove(min_txn)

            remaining_txns.extend(holdout_txns)

        overall_cost = workload.get_opt_seq_cost(txn_seq)
        return overall_cost, txn_seq

    # Run multiple sequences and pick the best one
    for _ in range(num_seqs):
        cost, schedule = get_greedy_cost_sampled(15)
        if cost < best_cost:
            best_cost = cost
            best_schedule = schedule

    return best_cost, best_schedule
>>>>>>> REPLACE
</DIFF>