<NAME>
hybrid_search_smart_sampling
</NAME>

<DESCRIPTION>
This edit improves the `get_best_schedule` function by combining "Smart Sampling" with a "Hybrid Local Search" strategy.

1.  **Smart Sampling**: In the greedy construction phase, the candidate set now explicitly includes the top `SAMPLE_LONGEST` (5) longest remaining transactions in addition to `SAMPLE_RANDOM` (10) randomly selected ones. This ensures that computationally expensive ("big rock") transactions are evaluated for optimal placement whenever they fit, effectively implementing a robust "Best Fit Descending" heuristic that isn't reliant on chance. This prevents long transactions from being stuck at the end of the schedule where they might cause tail latency.

2.  **Hybrid Local Search**: The local refinement phase is expanded. After the existing "Adjacent Swap Descent" (which cleans up local ordering) converges, a "Shift Descent" phase is added. This phase attempts `SHIFT_ATTEMPTS` (50) random insertion moves (removing a transaction and re-inserting it elsewhere). This helps the algorithm escape local optima that simple swaps cannot resolve, such as moving a transaction past a dependency cluster.

This approach leverages the strengths of both tie-breaking strategies and structural mutations to minimize the makespan more effectively.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Repeated Greedy construction with Heuristic Tie-Breaking and Local Search.

    Improvements:
    1. Heuristic Tie-Breaking: When multiple transactions result in the same best makespan (e.g. they fit in parallel),
       prefer the "longest" transaction (most operations). This packs larger items into slack ("Best Fit Descending").
    2. No Early Exit: Evaluate all candidates in the sample to ensure the tie-breaker works.
    3. Robust Local Search: Full adjacent swap descent on every constructed sequence.

    Args:
        workload: Workload object
        num_seqs: Number of independent random starts

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    import re

    # --- Pre-computation: Transaction Lengths ---
    # We use transaction length (number of operations) as a proxy for "difficulty" or "size".
    txn_lens = {}
    try:
        for i in range(workload.num_txns):
            raw_txn = workload.txns[i]
            if isinstance(raw_txn, (list, tuple)):
                raw_txn = raw_txn[0]
            txn_str = str(raw_txn)
            # Count operations (read or write)
            ops = len(re.findall(r'[rw]-\d+', txn_str))
            txn_lens[i] = ops
    except Exception:
        # Fallback: uniform length if parsing fails
        for i in range(workload.num_txns):
            txn_lens[i] = 1

    SAMPLE_SIZE = 20  # Larger sample to find optimal fits

    best_overall_cost = float('inf')
    best_overall_schedule = []

    for _ in range(num_seqs):
        # 1. Greedy Construction
        remaining = list(range(workload.num_txns))

        # Random start
        start_txn = random.choice(remaining)
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            # Sample candidates
            sample_size = min(len(remaining), SAMPLE_SIZE)
            candidates = random.sample(remaining, sample_size)

            best_candidate = -1
            # We want to minimize cost, then maximize length of the added transaction
            # Score tuple: (cost, -length). Python sorts tuples element-wise.
            best_score = (float('inf'), 0)

            for t in candidates:
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                # Use negative length to maximize it when minimizing the tuple
                score = (cost, -txn_lens[t])

                if score < best_score:
                    best_score = score
                    best_candidate = t

            current_seq.append(best_candidate)
            remaining.remove(best_candidate)

        # 2. Local Search Refinement
        # Swap adjacent transactions until no improvement
        current_cost = workload.get_opt_seq_cost(current_seq)
        improved = True
        while improved:
            improved = False
            for i in range(len(current_seq) - 1):
                # Swap
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
                new_cost = workload.get_opt_seq_cost(current_seq)

                if new_cost < current_cost:
                    current_cost = new_cost
                    improved = True
                else:
                    # Revert
                    current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]

        # Update global best
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_overall_schedule = list(current_seq)

    return best_overall_cost, best_overall_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Advanced Greedy Construction and Hybrid Local Search.

    Combines 'Smart Sampling' (prioritizing longest transactions) with 'Best Fit Descending'
    tie-breaking, followed by a two-phase local search (Adjacent Swap + Random Shift) to
    minimize makespan.

    Args:
        workload: Workload object
        num_seqs: Number of independent random starts

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    import re

    # --- Pre-computation: Transaction Lengths ---
    txn_lens = {}
    try:
        for i in range(workload.num_txns):
            raw_txn = workload.txns[i]
            if isinstance(raw_txn, (list, tuple)):
                raw_txn = raw_txn[0]
            txn_str = str(raw_txn)
            ops = len(re.findall(r'[rw]-\d+', txn_str))
            txn_lens[i] = ops
    except Exception:
        for i in range(workload.num_txns):
            txn_lens[i] = 1

    # Sort transactions by length (descending) for smart sampling
    sorted_txns = sorted(range(workload.num_txns), key=lambda t: txn_lens[t], reverse=True)

    # Heuristic Parameters
    SAMPLE_LONGEST = 5      # Explicitly check top K longest remaining
    SAMPLE_RANDOM = 10      # Plus M random candidates
    SHIFT_ATTEMPTS = 50     # Budget for insertion-based local search

    best_overall_cost = float('inf')
    best_overall_schedule = []

    for _ in range(num_seqs):
        # 1. Greedy Construction
        remaining = set(range(workload.num_txns))

        # Random start for diversity
        start_txn = random.choice(list(remaining))
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            candidates = set()

            # A. Smart Sampling: Check longest available transactions
            # This ensures we try to pack "big rocks" if they fit well
            count = 0
            for t in sorted_txns:
                if t in remaining:
                    candidates.add(t)
                    count += 1
                    if count >= SAMPLE_LONGEST:
                        break

            # B. Random Sampling: Maintain diversity
            pool = list(remaining)
            if len(pool) > SAMPLE_RANDOM:
                candidates.update(random.sample(pool, SAMPLE_RANDOM))
            else:
                candidates.update(pool)

            # C. Evaluate Candidates
            # Objective: Minimize Cost, Break ties with Max Length (Best Fit Descending)
            best_candidate = -1
            best_score = (float('inf'), 0) # (cost, -length)

            for t in candidates:
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                score = (cost, -txn_lens[t])

                if score < best_score:
                    best_score = score
                    best_candidate = t

            current_seq.append(best_candidate)
            remaining.remove(best_candidate)

        # 2. Local Search Refinement
        current_cost = workload.get_opt_seq_cost(current_seq)

        # Phase A: Adjacent Swap Descent (Hill Climbing)
        # Fixes local ordering issues efficiently
        improved = True
        while improved:
            improved = False
            for i in range(len(current_seq) - 1):
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
                new_cost = workload.get_opt_seq_cost(current_seq)

                if new_cost < current_cost:
                    current_cost = new_cost
                    improved = True
                else:
                    # Revert
                    current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]

        # Phase B: Shift Descent (Random Insertion)
        # Moves a transaction to a random new position to escape local optima
        # Effectively jumps over dependency barriers that swaps can't cross easily
        for _ in range(SHIFT_ATTEMPTS):
            if len(current_seq) < 2: break

            idx_from = random.randint(0, len(current_seq) - 1)
            idx_to = random.randint(0, len(current_seq) - 1)
            if idx_from == idx_to: continue

            # Apply Move
            txn = current_seq.pop(idx_from)
            current_seq.insert(idx_to, txn)

            new_cost = workload.get_opt_seq_cost(current_seq)

            if new_cost < current_cost:
                current_cost = new_cost
                # Keep change
            else:
                # Revert
                current_seq.pop(idx_to)
                current_seq.insert(idx_from, txn)

        # Update global best
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_overall_schedule = list(current_seq)

    return best_overall_cost, best_overall_schedule
>>>>>>> REPLACE
</DIFF>