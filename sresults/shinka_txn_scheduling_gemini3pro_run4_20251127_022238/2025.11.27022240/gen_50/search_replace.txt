<NAME>
diverse_greedy_funnel_lahc
</NAME>

<DESCRIPTION>
Replaces the single-trajectory hill climbing with a "Funnel" strategy (Filter -> Sprint -> Marathon) to optimize multiple candidates.
1. Implements Diversity-Driven Greedy Construction where `alpha` (weight for duration) and Big Rock thresholds are randomized for each sequence, creating a diverse pool of initial candidates.
2. Uses a 3-stage funnel: Filter (top 5, 50 iters), Sprint (top 3, 300 iters), and Marathon (winner, 2500 iters).
3. Upgrades the local search to Late Acceptance Hill Climbing (LAHC) with Block Insert operators (moving chunks of 2-6 items) and Stagnation Perturbation (shuffling segments) to escape local optima.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling with Big Rocks strategy
    and local search refinement.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Pre-calculate individual transaction costs (lengths) for tie-breaking
    # Longer transactions are "heavier" and should be scheduled earlier if costs are equal
    txn_durations = {t: workload.get_opt_seq_cost([t]) for t in range(workload.num_txns)}
    # Sort transactions by duration descending to prioritize long transactions
    sorted_txns_by_len = sorted(range(workload.num_txns), key=lambda t: txn_durations[t], reverse=True)

    # Iteratively build solutions
    for i in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]

        remaining_txns = set(range(workload.num_txns))
        remaining_txns.remove(start_txn)
        remaining_list = list(remaining_txns)

        # Build sequence
        while remaining_list:
            candidates = set()

            # Strategy:
            # 1. First iteration: Check ALL candidates for maximum quality baseline.
            # 2. Other iterations: Hybrid sampling (Big Rocks + Random).

            if i == 0:
                # Full scan for the first sequence
                candidates = set(remaining_list)
            else:
                # "Big Rocks" - prioritize longest available transactions
                # Adding the top available long transactions helps fill "holes" early
                # or schedule bottlenecks before they become critical.
                added_rocks = 0
                target_rocks = 4
                for t in sorted_txns_by_len:
                    if t in remaining_txns:
                        candidates.add(t)
                        added_rocks += 1
                        if added_rocks >= target_rocks:
                            break

                # Random sampling for diversity
                target_total = 20
                if len(remaining_list) <= target_total:
                    candidates.update(remaining_list)
                else:
                    while len(candidates) < target_total:
                        candidates.add(random.choice(remaining_list))

            # Find best candidate
            # Criteria: Minimize new makespan, Tie-break: Maximize transaction length
            best_txn = -1
            best_cost_tuple = (float('inf'), float('-inf'))

            for t in candidates:
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                # We want smallest cost, then largest length (so smallest negative length)
                cost_tuple = (cost, -txn_durations[t])

                if cost_tuple < best_cost_tuple:
                    best_cost_tuple = cost_tuple
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)
            remaining_list.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Hill Climbing with Sideways Moves
    # We accept moves that improve or maintain the cost to traverse plateaus.
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Budget for optimization
        num_optimizations = 2000

        for _ in range(num_optimizations):
            # Propose a move: 70% Insert, 30% Swap
            is_insert = random.random() < 0.7

            if is_insert:
                # Insert Move
                idx1 = random.randint(0, len(current_schedule) - 1)
                idx2 = random.randint(0, len(current_schedule) - 1)
                if idx1 == idx2:
                    continue

                item = current_schedule.pop(idx1)
                current_schedule.insert(idx2, item)

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                    # Keep move
                else:
                    # Revert insert
                    item = current_schedule.pop(idx2)
                    current_schedule.insert(idx1, item)
            else:
                # Swap Move
                idx1, idx2 = random.sample(range(len(current_schedule)), 2)
                current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                    # Keep move
                else:
                    # Revert swap
                    current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

        best_overall_cost = current_cost
        best_schedule = current_schedule

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Diverse Weighted Greedy Construction and Staged LAHC Refinement.
    Strategies:
    1. Diversity-Driven Greedy: Randomized alpha (duration weight) and Big Rocks thresholds.
    2. Funnel Refinement: 3-stage process (Filter -> Sprint -> Marathon).
    3. LAHC with Enhanced Operators: Includes Block Insert (moving dependency chains) and Stagnation Kicks.
    """
    # 1. Pre-calculation
    txn_durations = {t: workload.get_opt_seq_cost([t]) for t in range(workload.num_txns)}
    sorted_txns_by_len = sorted(range(workload.num_txns), key=lambda t: txn_durations[t], reverse=True)

    candidates_pool = []

    # 2. Greedy Construction Phase
    for i in range(num_seqs):
        # Diversity: Randomize parameters for each sequence
        if i == 0:
            alpha = 0.4
            threshold_ratio = 0.90
        else:
            alpha = random.uniform(0.2, 0.6)
            threshold_ratio = random.uniform(0.85, 0.99)

        # Random start
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]

        remaining_txns = set(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        while remaining_txns:
            candidates = set()

            if i == 0:
                # Full scan for first sequence
                candidates = remaining_txns
            else:
                # Dynamic Big Rocks Heuristic
                max_dur = 0
                for t in sorted_txns_by_len:
                    if t in remaining_txns:
                        max_dur = txn_durations[t]
                        break

                threshold = max_dur * threshold_ratio

                # Add Big Rocks
                rocks_added = 0
                for t in sorted_txns_by_len:
                    if t in remaining_txns:
                        if txn_durations[t] >= threshold:
                            candidates.add(t)
                            rocks_added += 1
                            if rocks_added >= 6:
                                break
                        else:
                            break

                # Add Random Samples
                if len(remaining_txns) > 20:
                    candidates.update(random.sample(list(remaining_txns), 15))
                else:
                    candidates.update(remaining_txns)

            # Weighted Selection: Score = Cost - (Alpha * Duration)
            best_t = -1
            best_score = float('inf')

            for t in candidates:
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                score = cost - (alpha * txn_durations[t])

                if score < best_score:
                    best_score = score
                    best_t = t
                elif score == best_score:
                    if txn_durations[t] > txn_durations.get(best_t, 0):
                        best_t = t

            txn_seq.append(best_t)
            remaining_txns.remove(best_t)

        total_cost = workload.get_opt_seq_cost(txn_seq)
        candidates_pool.append((total_cost, txn_seq))

    # 3. Funnel Selection Setup
    candidates_pool.sort(key=lambda x: x[0])

    unique_candidates = []
    seen_hashes = set()
    for cost, seq in candidates_pool:
        h = tuple(seq)
        if h not in seen_hashes:
            unique_candidates.append((cost, list(seq)))
            seen_hashes.add(h)
        if len(unique_candidates) >= 5:
            break

    if not unique_candidates and candidates_pool:
        unique_candidates = [(candidates_pool[0][0], list(candidates_pool[0][1]))]

    # Helper: LAHC Optimization
    def run_lahc(schedule, start_cost, budget, use_kick=False):
        current_sched = list(schedule)
        current_cost = start_cost
        best_sched = list(schedule)
        best_cost = start_cost

        history_len = 50
        history = [start_cost] * history_len
        last_imp_idx = 0

        for k in range(budget):
            # Stagnation Kick
            if use_kick and (k - last_imp_idx > 400):
                # Shuffle a random segment
                idx = random.randint(0, max(0, len(current_sched) - 15))
                seg_len = random.randint(10, 20)
                end = min(len(current_sched), idx + seg_len)
                segment = current_sched[idx:end]
                random.shuffle(segment)
                current_sched[idx:end] = segment

                current_cost = workload.get_opt_seq_cost(current_sched)
                history = [current_cost] * history_len
                last_imp_idx = k
                continue

            op_rand = random.random()
            neighbor = list(current_sched)

            # Operators: 50% Insert, 40% Block Insert, 10% Swap
            if op_rand < 0.50:
                # Single Insert
                idx1 = random.randint(0, len(neighbor) - 1)
                idx2 = random.randint(0, len(neighbor) - 1)
                if idx1 != idx2:
                    item = neighbor.pop(idx1)
                    neighbor.insert(idx2, item)
            elif op_rand < 0.90:
                # Block Insert (Move contiguous block of 2-6 items)
                bsize = random.randint(2, 6)
                if len(neighbor) > bsize:
                    start = random.randint(0, len(neighbor) - bsize)
                    block = neighbor[start : start + bsize]
                    del neighbor[start : start + bsize]
                    dest = random.randint(0, len(neighbor))
                    neighbor[dest:dest] = block
                else:
                    continue
            else:
                # Swap
                idx1, idx2 = random.sample(range(len(neighbor)), 2)
                neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]

            new_cost = workload.get_opt_seq_cost(neighbor)

            # LAHC Acceptance Logic
            v = k % history_len
            if new_cost <= current_cost or new_cost <= history[v]:
                current_sched = neighbor
                current_cost = new_cost
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_sched = list(current_sched)
                    last_imp_idx = k

            history[v] = current_cost

        return best_cost, best_sched

    # 4. Funnel Execution

    # Stage 1: Filter (Top 5 -> 50 iters)
    stage1_results = []
    for cost, seq in unique_candidates:
        c, s = run_lahc(seq, cost, 50, use_kick=False)
        stage1_results.append((c, s))

    stage1_results.sort(key=lambda x: x[0])
    top_3 = stage1_results[:3]

    # Stage 2: Sprint (Top 3 -> 300 iters)
    stage2_results = []
    for cost, seq in top_3:
        c, s = run_lahc(seq, cost, 300, use_kick=False)
        stage2_results.append((c, s))

    stage2_results.sort(key=lambda x: x[0])
    winner_cost, winner_seq = stage2_results[0]

    # Stage 3: Marathon (Winner -> 2500 iters)
    final_cost, final_seq = run_lahc(winner_seq, winner_cost, 2500, use_kick=True)

    return final_cost, final_seq
>>>>>>> REPLACE
</DIFF>