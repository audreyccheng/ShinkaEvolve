<NAME>
optimize_greedy_and_kick
</NAME>

<DESCRIPTION>
1.  **Greedy Parameter Tuning**: Widened the `alpha` range for the weighted greedy construction to `[0.2, 1.2]`.
    *   Previously `[0.2, 0.6]`, which effectively favored shorter transactions (since minimizing `Delay + (1-alpha)*Duration` with `alpha < 1` penalizes duration).
    *   By extending to `1.2`, we allow strategies that purely minimize delay (`alpha=1`) or actively favor longer transactions (`alpha > 1`), improving the diversity of the initial candidate pool.
    *   Also increased `rock_limit` to `[2, 12]` to allow more "Big Rocks" to be considered.

2.  **Enhanced Kick & Operators**:
    *   Replaced the "Shuffle" kick (which destroys local structure) with a "Large Block Relocation" kick. This takes a significant contiguous segment (preserving its internal optimized order) and moves it to a random location. This is a more constructive perturbation for scheduling.
    *   Adjusted operator probabilities: Increased Block Insert to 50% (from 45%) and decreased Single Insert to 40%.
    *   Increased the maximum block size for local moves from 8 to 12. This allows the algorithm to move larger chains of dependent transactions, helping to resolve more complex conflicts.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        else:
            alpha = random.uniform(0.2, 0.6)
            threshold_ratio = random.uniform(0.85, 0.98)
            rock_limit = random.randint(2, 8)
=======
        else:
            alpha = random.uniform(0.2, 1.2)
            threshold_ratio = random.uniform(0.80, 0.99)
            rock_limit = random.randint(2, 12)
>>>>>>> REPLACE
<<<<<<< SEARCH
        for k in range(budget):
            # Stagnation Kick (only enabled in Marathon phase)
            if use_kick and (k - last_imp_idx > 500):
                # Shuffle a random segment to escape local optima
                idx = random.randint(0, max(0, len(current_sched) - 15))
                seg_len = random.randint(10, 20)
                end = min(len(current_sched), idx + seg_len)
                segment = current_sched[idx:end]
                random.shuffle(segment)
                current_sched[idx:end] = segment

                # Reset history and costs
                current_cost = workload.get_opt_seq_cost(current_sched)
                history = [current_cost] * history_len
                last_imp_idx = k
                continue

            op_rand = random.random()
            neighbor = list(current_sched)

            # Operators: 45% Insert, 45% Block Insert (2-8 items), 10% Swap
            if op_rand < 0.45:
                # Single Insert
                idx1 = random.randint(0, len(neighbor) - 1)
                idx2 = random.randint(0, len(neighbor) - 1)
                if idx1 != idx2:
                    item = neighbor.pop(idx1)
                    neighbor.insert(idx2, item)
            elif op_rand < 0.90:
                # Block Insert
                bsize = random.randint(2, 8)
                if len(neighbor) > bsize:
                    start = random.randint(0, len(neighbor) - bsize)
                    block = neighbor[start : start + bsize]
                    del neighbor[start : start + bsize]
                    dest = random.randint(0, len(neighbor))
                    neighbor[dest : dest] = block
                else:
                    continue
            else:
=======
        for k in range(budget):
            # Stagnation Kick (only enabled in Marathon phase)
            if use_kick and (k - last_imp_idx > 500):
                # "Large Block Relocation" Kick: Move a significant chunk to a new location
                # Preserves local structure (likely optimized) but changes global context
                seg_len = random.randint(10, max(11, len(current_sched) // 3))
                if len(current_sched) > seg_len:
                    start_idx = random.randint(0, len(current_sched) - seg_len)
                    segment = current_sched[start_idx : start_idx + seg_len]
                    del current_sched[start_idx : start_idx + seg_len]
                    insert_idx = random.randint(0, len(current_sched))
                    current_sched[insert_idx:insert_idx] = segment

                    # Reset history and costs
                    current_cost = workload.get_opt_seq_cost(current_sched)
                    history = [current_cost] * history_len
                    last_imp_idx = k
                    continue

            op_rand = random.random()
            neighbor = list(current_sched)

            # Operators: 40% Insert, 50% Block Insert (2-12 items), 10% Swap
            if op_rand < 0.40:
                # Single Insert
                idx1 = random.randint(0, len(neighbor) - 1)
                idx2 = random.randint(0, len(neighbor) - 1)
                if idx1 != idx2:
                    item = neighbor.pop(idx1)
                    neighbor.insert(idx2, item)
            elif op_rand < 0.90:
                # Block Insert (variable size up to 12 to jump dependencies)
                bsize = random.randint(2, 12)
                if len(neighbor) > bsize:
                    start = random.randint(0, len(neighbor) - bsize)
                    block = neighbor[start : start + bsize]
                    del neighbor[start : start + bsize]
                    dest = random.randint(0, len(neighbor))
                    neighbor[dest : dest] = block
                else:
                    continue
            else:
>>>>>>> REPLACE
</DIFF>