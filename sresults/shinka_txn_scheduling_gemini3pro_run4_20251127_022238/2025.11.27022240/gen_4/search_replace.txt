<NAME>
multiple_restart_greedy_scheduling
</NAME>

<DESCRIPTION>
The `get_best_schedule` function currently defines a greedy strategy that constructs a single schedule, ignoring the `num_seqs` parameter which suggests multiple attempts should be made. I am modifying the function to implement a "Multiple Restart Greedy" approach.

1.  **Multiple Restarts:** The function will now loop `num_seqs` times. In each iteration, it constructs a full schedule from scratch starting with a random transaction. This allows the algorithm to explore different parts of the solution space and avoid getting stuck in the local optimum of a single greedy pass.
2.  **Refined Greedy Step:** Inside the construction loop, for each position in the schedule, the algorithm samples a subset of remaining transactions (`num_samples_per_step=10`) and evaluates which one yields the lowest makespan when added. This stochastic greedy decision making is preserved from the original but cleaned up (using `random.sample` instead of list manipulation) for better readability and efficiency.
3.  **Global Best:** The function tracks the best schedule found across all restarts and returns it.

This change significantly increases the probability of finding a lower makespan schedule by leveraging the randomized nature of the greedy process multiple times.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    def get_greedy_cost_sampled(num_samples, sample_rate):
        # greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = [x for x in range(0, workload.num_txns)]
        remaining_txns.remove(start_txn)
        running_cost = workload.txns[start_txn][0][3]

        for i in range(0, workload.num_txns - 1):
            min_cost = 100000  # MAX
            min_relative_cost = 10
            min_txn = -1
            holdout_txns = []
            done = False
            key_maps = []

            sample = random.random()
            if sample > sample_rate:
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                txn_seq.append(t)
                remaining_txns.pop(idx)
                continue

            for j in range(0, num_samples):
                idx = 0
                if len(remaining_txns) > 1:
                    idx = random.randint(0, len(remaining_txns) - 1)
                else:
                    done = True
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                txn_len = workload.txns[t][0][3]
                test_seq = txn_seq.copy()
                test_seq.append(t)
                cost = 0
                cost = workload.get_opt_seq_cost(test_seq)
                if cost < min_cost:
                    min_cost = cost
                    min_txn = t
                if done:
                    break
            assert(min_txn != -1)
            running_cost = min_cost
            txn_seq.append(min_txn)
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        assert len(set(txn_seq)) == workload.num_txns

        overall_cost = workload.get_opt_seq_cost(txn_seq)
        return overall_cost, txn_seq

    return get_greedy_cost_sampled(10, 1.0)
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy with multiple restarts.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample/restarts

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_overall_schedule = None

    # Number of candidates to sample at each step.
    num_samples_per_step = 10

    for _ in range(num_seqs):
        # Greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        while remaining_txns:
            # Determine candidates to evaluate
            # If few transactions remain, check all of them.
            if len(remaining_txns) <= num_samples_per_step:
                candidates = remaining_txns
            else:
                candidates = random.sample(remaining_txns, num_samples_per_step)

            best_next_txn = -1
            min_extended_cost = float('inf')

            # Evaluate candidates
            for t in candidates:
                # Calculate cost if we append this transaction
                # get_opt_seq_cost calculates the makespan of the sequence
                current_cost = workload.get_opt_seq_cost(txn_seq + [t])

                if current_cost < min_extended_cost:
                    min_extended_cost = current_cost
                    best_next_txn = t

            # Fallback if needed (should not happen with logic above)
            if best_next_txn == -1:
                best_next_txn = candidates[0]

            # Append best candidate
            txn_seq.append(best_next_txn)
            remaining_txns.remove(best_next_txn)

        # Check total cost
        total_cost = workload.get_opt_seq_cost(txn_seq)

        if total_cost < best_overall_cost:
            best_overall_cost = total_cost
            best_overall_schedule = txn_seq

    return best_overall_cost, best_overall_schedule
>>>>>>> REPLACE
</DIFF>