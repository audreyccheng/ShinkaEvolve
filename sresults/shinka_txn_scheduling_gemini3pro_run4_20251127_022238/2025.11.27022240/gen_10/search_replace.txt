<NAME>
add_math_import
</NAME>

<DESCRIPTION>
Import the math module to support exponential calculations required for Simulated Annealing in the scheduling algorithm.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
import time
import random
import sys
import os
=======
import time
import random
import sys
import os
import math
>>>>>>> REPLACE
</DIFF>

<NAME>
improve_scheduling_with_hybrid_greedy_sa
</NAME>

<DESCRIPTION>
Improve the `get_best_schedule` function by implementing a hybrid construction and optimization strategy:
1.  **Hybrid Greedy Construction**:
    -   The first iteration now uses a **deterministic greedy** approach that evaluates *all* possible next transactions (instead of a small sample). This ensures at least one high-quality baseline schedule is generated.
    -   Subsequent iterations continue to use **randomized greedy** sampling (sample size 24) to maintain exploration diversity within the time budget.
2.  **Simulated Annealing (SA) Optimization**:
    -   Replaced the simple Hill Climbing (random swaps) with Simulated Annealing to avoid getting stuck in local optima.
    -   Introduced an **Insert (Move)** operator alongside the Swap operator. Shifting a transaction to a new position is often more effective for scheduling problems than swapping two distant transactions.
    -   The SA cooling schedule (Temp 100 -> 1, rate 0.9) balances exploration and exploitation.

These changes allow the algorithm to find schedules with significantly lower makespan by thoroughly optimizing the best candidate found.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy augmented with local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Run multiple iterations of the greedy strategy
    for _ in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence step by step
        for i in range(workload.num_txns - 1):
            min_cost = float('inf')
            min_txn = -1
            holdout_txns = []

            # Sample a subset of remaining transactions to test
            # Increased sample size to improve greedy choice quality
            num_samples = 24
            current_samples = min(num_samples, len(remaining_txns))

            for j in range(current_samples):
                # Pick a random candidate from remaining
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                # Evaluate adding this candidate
                cost = workload.get_opt_seq_cost(txn_seq + [t])

                if cost < min_cost:
                    min_cost = cost
                    min_txn = t

            # Append the best candidate found
            txn_seq.append(min_txn)

            # Restore the other candidates to the remaining list
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        # Evaluate final complete schedule
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization phase: Hill Climbing on the best schedule found
    # This refines the greedy solution by attempting random swaps
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Try to improve for a fixed number of iterations
        num_optimizations = 1000

        for _ in range(num_optimizations):
            # Pick two distinct indices
            idx1, idx2 = random.sample(range(len(current_schedule)), 2)

            # Swap
            current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

            new_cost = workload.get_opt_seq_cost(current_schedule)

            if new_cost < current_cost:
                current_cost = new_cost
                # Keep swap
            else:
                # Revert swap
                current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

        best_overall_cost = current_cost
        best_schedule = current_schedule

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using hybrid greedy strategy and simulated annealing.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Iteratively build solutions
    for i in range(num_seqs):
        # Strategy:
        # First iteration: Deterministic greedy (examine all candidates) for high quality baseline
        # Subsequent iterations: Randomized greedy (sample subset) for diversity
        if i == 0:
            sample_size = workload.num_txns  # Check all
        else:
            sample_size = 24  # Sample subset

        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence
        while remaining_txns:
            # Determine candidates
            if len(remaining_txns) <= sample_size:
                candidates = remaining_txns
            else:
                candidates = random.sample(remaining_txns, sample_size)

            # Find best candidate
            best_txn = -1
            min_extended_cost = float('inf')

            for t in candidates:
                # Check cost of appending this transaction
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                if cost < min_extended_cost:
                    min_extended_cost = cost
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Simulated Annealing with Swap and Insert moves
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # SA Hyperparameters
        temperature = 100.0
        cooling_rate = 0.90
        min_temperature = 1.0
        iters_per_temp = 20

        while temperature > min_temperature:
            for _ in range(iters_per_temp):
                neighbor = list(current_schedule)

                # Propose a move: 50% Swap, 50% Insert
                if random.random() < 0.5:
                    # Swap
                    idx1, idx2 = random.sample(range(len(neighbor)), 2)
                    neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
                else:
                    # Insert (Move item from idx1 to idx2)
                    idx1 = random.randint(0, len(neighbor) - 1)
                    idx2 = random.randint(0, len(neighbor) - 1)
                    if idx1 != idx2:
                        item = neighbor.pop(idx1)
                        neighbor.insert(idx2, item)

                # Evaluate
                new_cost = workload.get_opt_seq_cost(neighbor)
                delta = new_cost - current_cost

                # Metropolis acceptance criterion
                accept = False
                if delta < 0:
                    accept = True
                else:
                    try:
                        prob = math.exp(-delta / temperature)
                    except OverflowError:
                        prob = 0
                    if random.random() < prob:
                        accept = True

                if accept:
                    current_schedule = neighbor
                    current_cost = new_cost
                    if current_cost < best_overall_cost:
                        best_overall_cost = current_cost
                        best_schedule = list(current_schedule)

            temperature *= cooling_rate

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>