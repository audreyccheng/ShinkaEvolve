<NAME>
multi_start_greedy
</NAME>

<DESCRIPTION>
Update `get_best_schedule` to properly utilize the `num_seqs` parameter by running multiple iterations of the greedy scheduling algorithm and selecting the best result. The previous implementation ignored `num_seqs` and only ran a single pass. Additionally, increase the number of samples per step from 10 to 15 to improve the quality of the greedy choices, and clean up unused variables and dead code.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    def get_greedy_cost_sampled(num_samples, sample_rate):
        # greedy with random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = [x for x in range(0, workload.num_txns)]
        remaining_txns.remove(start_txn)
        running_cost = workload.txns[start_txn][0][3]

        for i in range(0, workload.num_txns - 1):
            min_cost = 100000  # MAX
            min_relative_cost = 10
            min_txn = -1
            holdout_txns = []
            done = False
            key_maps = []

            sample = random.random()
            if sample > sample_rate:
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                txn_seq.append(t)
                remaining_txns.pop(idx)
                continue

            for j in range(0, num_samples):
                idx = 0
                if len(remaining_txns) > 1:
                    idx = random.randint(0, len(remaining_txns) - 1)
                else:
                    done = True
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                txn_len = workload.txns[t][0][3]
                test_seq = txn_seq.copy()
                test_seq.append(t)
                cost = 0
                cost = workload.get_opt_seq_cost(test_seq)
                if cost < min_cost:
                    min_cost = cost
                    min_txn = t
                if done:
                    break
            assert(min_txn != -1)
            running_cost = min_cost
            txn_seq.append(min_txn)
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        assert len(set(txn_seq)) == workload.num_txns

        overall_cost = workload.get_opt_seq_cost(txn_seq)
        return overall_cost, txn_seq

    return get_greedy_cost_sampled(10, 1.0)
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Run multiple iterations of the greedy strategy
    for _ in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence step by step
        for i in range(workload.num_txns - 1):
            min_cost = float('inf')
            min_txn = -1
            holdout_txns = []

            # Sample a subset of remaining transactions to test
            # Using 15 samples provides a good balance of exploration vs speed
            num_samples = 15
            current_samples = min(num_samples, len(remaining_txns))

            for j in range(current_samples):
                # Pick a random candidate from remaining
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                # Evaluate adding this candidate
                # Note: We pass a new list to avoid modifying txn_seq yet
                cost = workload.get_opt_seq_cost(txn_seq + [t])

                if cost < min_cost:
                    min_cost = cost
                    min_txn = t

            # Append the best candidate found
            txn_seq.append(min_txn)

            # Restore the other candidates to the remaining list
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        # Evaluate final complete schedule
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>