<NAME>
two_phase_greedy_insert
</NAME>

<DESCRIPTION>
Implements a two-phase scheduling strategy to improve makespan.
1. **Exploration Phase**: Generates `num_seqs` candidate schedules using a randomized greedy algorithm. Includes an "early exit" optimization: if a candidate transaction doesn't increase the current makespan (i.e., runs in parallel), it is selected immediately without evaluating other candidates, saving simulation time and promoting parallelism.
2. **Exploitation Phase**: Selects the best schedule from phase 1 and applies a deep local search. This combines standard adjacent swaps (Descent) with random insertion moves (Perturbation). The insertion moves help escape local optima where adjacent swaps are ineffective (e.g., moving a transaction past a block of conflicts).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using repeated greedy strategy with local search refinement.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Run the greedy process num_seqs times to explore different start points and paths
    for _ in range(num_seqs):
        # 1. Randomized Greedy Construction
        remaining = list(range(workload.num_txns))

        # Random start transaction
        start_txn = random.choice(remaining)
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            # Sample a subset of remaining transactions to evaluate
            # Checking more candidates improves decision quality
            sample_size = min(len(remaining), 15)
            candidates = random.sample(remaining, sample_size)

            best_candidate = -1
            min_candidate_cost = float('inf')

            # Evaluate candidates
            for t in candidates:
                # Calculate cost of adding candidate t to current sequence
                # We want to minimize the makespan of the partial schedule
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < min_candidate_cost:
                    min_candidate_cost = cost
                    best_candidate = t

            # Append the best candidate found
            current_seq.append(best_candidate)
            remaining.remove(best_candidate)

        # 2. Local Search Refinement
        # Attempt to improve the constructed schedule by swapping adjacent transactions
        # This helps fix minor sub-optimal greedy choices
        current_cost = workload.get_opt_seq_cost(current_seq)
        improved = True
        while improved:
            improved = False
            for i in range(len(current_seq) - 1):
                # Swap adjacent elements
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
                new_cost = workload.get_opt_seq_cost(current_seq)

                if new_cost < current_cost:
                    current_cost = new_cost
                    improved = True
                else:
                    # Revert swap if no improvement
                    current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]

        # Update global best if this run found a better schedule
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_overall_schedule = list(current_seq)

    return best_overall_cost, best_overall_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using repeated greedy construction followed by deep local search.

    Strategy:
    1. Generate multiple candidate schedules using a randomized greedy approach.
       - Use an early-exit optimization: if a transaction fits without increasing makespan, pick it immediately.
    2. Select the best candidate from the generation phase.
    3. Apply intensive local search on the best candidate:
       - Alternating between Adjacent Swaps (Descent) and Random Insertions (Perturbation).

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    SAMPLE_SIZE = 15
    MAX_SHIFTS = 100  # Budget for random insertion attempts

    candidates = []

    # Phase 1: Exploration (Generate diverse good schedules)
    for _ in range(num_seqs):
        remaining = list(range(workload.num_txns))

        # Start with a random transaction
        start_txn = random.choice(remaining)
        current_seq = [start_txn]
        remaining.remove(start_txn)

        # Greedy Construction
        current_makespan = workload.get_opt_seq_cost(current_seq)

        while remaining:
            sample_size = min(len(remaining), SAMPLE_SIZE)
            sample_candidates = random.sample(remaining, sample_size)

            best_next = -1
            min_inc_cost = float('inf')

            for t in sample_candidates:
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < min_inc_cost:
                    min_inc_cost = cost
                    best_next = t
                    # Optimization: If we find a transaction that fits 'perfectly'
                    # (doesn't increase makespan or increases minimally), take it.
                    # This biases towards high parallelism and saves simulation calls.
                    if cost <= current_makespan:
                        break

            current_seq.append(best_next)
            remaining.remove(best_next)
            current_makespan = min_inc_cost

        # Light Local Search (1 pass of adjacent swaps)
        # Quickly clean up local inefficiencies before adding to candidates
        for i in range(len(current_seq) - 1):
            current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
            new_cost = workload.get_opt_seq_cost(current_seq)
            if new_cost < current_makespan:
                current_makespan = new_cost
            else:
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i] # Revert

        candidates.append((current_makespan, current_seq))

    # Phase 2: Exploitation (Deep optimization of the best candidate)
    candidates.sort(key=lambda x: x[0])
    best_cost, best_seq = candidates[0]

    # Iterative improvement: Swap Descent + Random Insertions
    improved = True
    while improved:
        improved = False

        # A. Full Adjacent Swap Descent
        swap_improved = True
        while swap_improved:
            swap_improved = False
            for i in range(len(best_seq) - 1):
                best_seq[i], best_seq[i+1] = best_seq[i+1], best_seq[i]
                new_cost = workload.get_opt_seq_cost(best_seq)
                if new_cost < best_cost:
                    best_cost = new_cost
                    swap_improved = True
                    improved = True
                else:
                    best_seq[i], best_seq[i+1] = best_seq[i+1], best_seq[i] # Revert

        # B. Random Insertions (Shifting) to escape local optima
        # Attempt to move transactions to random positions
        for _ in range(MAX_SHIFTS):
            idx_from = random.randint(0, len(best_seq) - 1)
            idx_to = random.randint(0, len(best_seq) - 1)
            if idx_from == idx_to: continue

            # Move transaction
            txn = best_seq.pop(idx_from)
            best_seq.insert(idx_to, txn)

            new_cost = workload.get_opt_seq_cost(best_seq)
            if new_cost < best_cost:
                best_cost = new_cost
                improved = True
                # If improvement found, break to resume swap descent
                break
            else:
                # Revert move
                best_seq.pop(idx_to)
                best_seq.insert(idx_from, txn)

    return best_cost, best_seq
>>>>>>> REPLACE
</DIFF>