<NAME>
greedy_tie_break_and_insert_search
</NAME>

<DESCRIPTION>
I am proposing a comprehensive update to the `get_best_schedule` function to incorporate several optimizations:

1.  **Greedy Construction with "Big Rocks" Priority and Tie-Breaking**:
    *   **Length-Based Sampling**: Instead of purely random sampling, the greedy step now ensures that the longest remaining transactions (based on individual duration) are always considered as candidates. This helps in scheduling difficult transactions early.
    *   **Tie-Breaking**: When multiple candidates yield the same partial makespan, the algorithm now selects the one with the longest duration. This "packs" larger transactions into the available schedule gaps, increasing parallelism density.

2.  **Enhanced Local Search (Refinement)**:
    *   **Insertion Moves**: The refinement phase now utilizes both "Swap" and "Insertion" (shift) moves. Insertion is often more effective than swapping for dependency scheduling as it preserves the relative order of other transactions.
    *   **Plateau Traversal**: The acceptance criterion allows moves that result in equal cost (`<=`), helping the search algorithm traverse plateaus in the cost landscape to find better basins of attraction.

3.  **Optimization**:
    *   Uses a `set` for O(1) lookups when filtering the longest remaining transactions to keep the greedy step efficient.

These changes directly address the recommendations to prioritize long transactions, use tie-breaking, and implement insertion-based local search.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy augmented with local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Run multiple iterations of the greedy strategy
    for _ in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence step by step
        for i in range(workload.num_txns - 1):
            min_cost = float('inf')
            min_txn = -1
            holdout_txns = []

            # Sample a subset of remaining transactions to test
            # Increased sample size to improve greedy choice quality
            num_samples = 24
            current_samples = min(num_samples, len(remaining_txns))

            for j in range(current_samples):
                # Pick a random candidate from remaining
                idx = random.randint(0, len(remaining_txns) - 1)
                t = remaining_txns[idx]
                holdout_txns.append(remaining_txns.pop(idx))

                # Evaluate adding this candidate
                cost = workload.get_opt_seq_cost(txn_seq + [t])

                if cost < min_cost:
                    min_cost = cost
                    min_txn = t

            # Append the best candidate found
            txn_seq.append(min_txn)

            # Restore the other candidates to the remaining list
            holdout_txns.remove(min_txn)
            remaining_txns.extend(holdout_txns)

        # Evaluate final complete schedule
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization phase: Hill Climbing on the best schedule found
    # This refines the greedy solution by attempting random swaps
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Try to improve for a fixed number of iterations
        num_optimizations = 1000

        for _ in range(num_optimizations):
            # Pick two distinct indices
            idx1, idx2 = random.sample(range(len(current_schedule)), 2)

            # Swap
            current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

            new_cost = workload.get_opt_seq_cost(current_schedule)

            if new_cost < current_cost:
                current_cost = new_cost
                # Keep swap
            else:
                # Revert swap
                current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

        best_overall_cost = current_cost
        best_schedule = current_schedule

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling strategy augmented with local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    # Precompute transaction durations for tie-breaking
    txn_durations = {t: workload.get_opt_seq_cost([t]) for t in range(workload.num_txns)}
    # Sort transactions by duration descending to prioritize long transactions
    sorted_txns_by_len = sorted(range(workload.num_txns), key=lambda t: txn_durations[t], reverse=True)

    best_overall_cost = float('inf')
    best_schedule = []

    # Run multiple iterations of the greedy strategy
    for _ in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence step by step
        for i in range(workload.num_txns - 1):
            best_candidate = -1
            min_cost = float('inf')
            max_duration = -1

            # Create a set for O(1) lookups
            remaining_set = set(remaining_txns)
            candidates = set()

            # 1. Add top available longest transactions (Big Rocks)
            added_long = 0
            for t in sorted_txns_by_len:
                if t in remaining_set:
                    candidates.add(t)
                    added_long += 1
                    if added_long >= 3:
                        break

            # 2. Add random samples
            target_samples = 20
            attempts = 0
            max_attempts = target_samples * 2

            # If remaining set is small, check all
            if len(remaining_txns) <= target_samples:
                candidates = remaining_set
            else:
                while len(candidates) < target_samples and attempts < max_attempts:
                    t = random.choice(remaining_txns)
                    candidates.add(t)
                    attempts += 1

            for t in candidates:
                # Evaluate adding this candidate
                # We calculate the makespan of the sequence so far
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                dur = txn_durations[t]

                # Minimize cost, tie-break with larger duration
                if cost < min_cost:
                    min_cost = cost
                    best_candidate = t
                    max_duration = dur
                elif cost == min_cost:
                    if dur > max_duration:
                        best_candidate = t
                        max_duration = dur

            # Append the best candidate found
            txn_seq.append(best_candidate)
            remaining_txns.remove(best_candidate)

        # Evaluate final complete schedule
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization phase: Randomized Local Search with Insert and Swap moves
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Iterations budget
        num_optimizations = 1500

        for _ in range(num_optimizations):
            # Randomly choose move type: Swap or Insert
            if random.random() < 0.5:
                # Swap Move
                idx1, idx2 = random.sample(range(len(current_schedule)), 2)
                current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                else:
                    # Revert swap
                    current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]
            else:
                # Insert Move (Shift)
                idx1 = random.randint(0, len(current_schedule) - 1)
                idx2 = random.randint(0, len(current_schedule) - 1)
                if idx1 == idx2:
                    continue

                item = current_schedule.pop(idx1)
                current_schedule.insert(idx2, item)

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                else:
                    # Revert insert
                    item = current_schedule.pop(idx2)
                    current_schedule.insert(idx1, item)

        best_overall_cost = current_cost
        best_schedule = current_schedule

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>