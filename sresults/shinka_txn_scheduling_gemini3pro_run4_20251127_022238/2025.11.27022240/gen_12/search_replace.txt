<NAME>
smart_greedy_extended_sa
</NAME>

<DESCRIPTION>
1.  **Length-Based Tie-Breaking**: In the greedy phase, pre-calculate individual transaction costs (lengths). When evaluating candidate transactions to append, if multiple candidates result in the same makespan (or very close), prioritize the one with the longer duration. This "Longest Processing Time" heuristic helps schedule difficult items early when gaps are available.
2.  **Extended Simulated Annealing**: Increased the SA search budget (higher start temp, slower cooling, more iterations) to explore the search space more thoroughly.
3.  **Biased Mutation**: Changed the neighborhood function in SA to favor "Insert" moves (70%) over "Swap" moves (30%). Insertion is generally more effective for scheduling as it can move a transaction from a bottleneck position to a slack position without disrupting the relative order of other transactions as much as a swap.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using hybrid greedy strategy and simulated annealing.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Iteratively build solutions
    for i in range(num_seqs):
        # Strategy:
        # First iteration: Deterministic greedy (examine all candidates) for high quality baseline
        # Subsequent iterations: Randomized greedy (sample subset) for diversity
        if i == 0:
            sample_size = workload.num_txns  # Check all
        else:
            sample_size = 24  # Sample subset

        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence
        while remaining_txns:
            # Determine candidates
            if len(remaining_txns) <= sample_size:
                candidates = remaining_txns
            else:
                candidates = random.sample(remaining_txns, sample_size)

            # Find best candidate
            best_txn = -1
            min_extended_cost = float('inf')

            for t in candidates:
                # Check cost of appending this transaction
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                if cost < min_extended_cost:
                    min_extended_cost = cost
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Simulated Annealing with Swap and Insert moves
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # SA Hyperparameters
        temperature = 100.0
        cooling_rate = 0.90
        min_temperature = 1.0
        iters_per_temp = 20

        while temperature > min_temperature:
            for _ in range(iters_per_temp):
                neighbor = list(current_schedule)

                # Propose a move: 50% Swap, 50% Insert
                if random.random() < 0.5:
                    # Swap
                    idx1, idx2 = random.sample(range(len(neighbor)), 2)
                    neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
                else:
                    # Insert (Move item from idx1 to idx2)
                    idx1 = random.randint(0, len(neighbor) - 1)
                    idx2 = random.randint(0, len(neighbor) - 1)
                    if idx1 != idx2:
                        item = neighbor.pop(idx1)
                        neighbor.insert(idx2, item)

                # Evaluate
                new_cost = workload.get_opt_seq_cost(neighbor)
                delta = new_cost - current_cost

                # Metropolis acceptance criterion
                accept = False
                if delta < 0:
                    accept = True
                else:
                    try:
                        prob = math.exp(-delta / temperature)
                    except OverflowError:
                        prob = 0
                    if random.random() < prob:
                        accept = True

                if accept:
                    current_schedule = neighbor
                    current_cost = new_cost
                    if current_cost < best_overall_cost:
                        best_overall_cost = current_cost
                        best_schedule = list(current_schedule)

            temperature *= cooling_rate

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using hybrid greedy strategy with length-based tie-breaking
    and insertion-based simulated annealing.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Pre-calculate individual transaction costs (lengths) for tie-breaking
    # Longer transactions are "heavier" and should be scheduled earlier if costs are equal
    txn_lengths = {}
    for t in range(workload.num_txns):
        txn_lengths[t] = workload.get_opt_seq_cost([t])

    # Iteratively build solutions
    for i in range(num_seqs):
        # Strategy:
        # First iteration: Deterministic greedy (examine all candidates) for high quality baseline
        # Subsequent iterations: Randomized greedy (sample subset) for diversity
        if i == 0:
            sample_size = workload.num_txns  # Check all
        else:
            sample_size = 20  # Sample subset

        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence
        while remaining_txns:
            # Determine candidates
            if len(remaining_txns) <= sample_size:
                candidates = remaining_txns
            else:
                candidates = random.sample(remaining_txns, sample_size)

            # Find best candidate
            # Criteria: Minimize new makespan, Tie-break: Maximize transaction length
            best_txn = -1
            best_cost_tuple = (float('inf'), float('-inf'))  # (makespan, -length)

            for t in candidates:
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                # We want smallest cost, then largest length (so smallest negative length)
                cost_tuple = (cost, -txn_lengths[t])

                if cost_tuple < best_cost_tuple:
                    best_cost_tuple = cost_tuple
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Simulated Annealing with bias towards Insertion
    # Insertion is generally more effective for scheduling than Swap
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Tuned SA Hyperparameters for better exploration/exploitation balance
        temperature = 200.0  # Start higher to escape initial basins
        cooling_rate = 0.95  # Cool slower
        min_temperature = 0.5
        iters_per_temp = 30

        while temperature > min_temperature:
            for _ in range(iters_per_temp):
                neighbor = list(current_schedule)

                # Propose a move: 70% Insert, 30% Swap
                # Insertion preserves relative order of other items better
                if random.random() < 0.3:
                    # Swap
                    idx1, idx2 = random.sample(range(len(neighbor)), 2)
                    neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
                else:
                    # Insert (Move item from idx1 to idx2)
                    idx1 = random.randint(0, len(neighbor) - 1)
                    idx2 = random.randint(0, len(neighbor) - 1)
                    if idx1 != idx2:
                        item = neighbor.pop(idx1)
                        neighbor.insert(idx2, item)

                # Evaluate
                new_cost = workload.get_opt_seq_cost(neighbor)
                delta = new_cost - current_cost

                # Metropolis acceptance criterion
                accept = False
                if delta < 0:
                    accept = True
                else:
                    try:
                        prob = math.exp(-delta / temperature)
                    except OverflowError:
                        prob = 0
                    if random.random() < prob:
                        accept = True

                if accept:
                    current_schedule = neighbor
                    current_cost = new_cost
                    if current_cost < best_overall_cost:
                        best_overall_cost = current_cost
                        best_schedule = list(current_schedule)

            temperature *= cooling_rate

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>