<NAME>
big_rocks_greedy_and_hc_refinement
</NAME>

<DESCRIPTION>
Implements a "Big Rocks" priority mechanism in the greedy construction phase and switches the refinement phase to Hill Climbing with Sideways Moves.
In the greedy phase, candidate sampling now explicitly includes the top longest available transactions (Big Rocks) in addition to random samples. This prevents long transactions from being deferred to the end of the schedule where they often cause large makespan increases.
The refinement phase is changed from Simulated Annealing to Hill Climbing that accepts equal-cost moves. This allows the search to traverse plateaus in the solution space, which is critical for scheduling problems where many permutations have similar makespans, but some lead to better neighbors. The move set retains the 70% insertion / 30% swap bias.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using hybrid greedy strategy with length-based tie-breaking
    and insertion-based simulated annealing.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Pre-calculate individual transaction costs (lengths) for tie-breaking
    # Longer transactions are "heavier" and should be scheduled earlier if costs are equal
    txn_lengths = {}
    for t in range(workload.num_txns):
        txn_lengths[t] = workload.get_opt_seq_cost([t])

    # Iteratively build solutions
    for i in range(num_seqs):
        # Strategy:
        # First iteration: Deterministic greedy (examine all candidates) for high quality baseline
        # Subsequent iterations: Randomized greedy (sample subset) for diversity
        if i == 0:
            sample_size = workload.num_txns  # Check all
        else:
            sample_size = 20  # Sample subset

        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]
        remaining_txns = list(range(workload.num_txns))
        remaining_txns.remove(start_txn)

        # Build sequence
        while remaining_txns:
            # Determine candidates
            if len(remaining_txns) <= sample_size:
                candidates = remaining_txns
            else:
                candidates = random.sample(remaining_txns, sample_size)

            # Find best candidate
            # Criteria: Minimize new makespan, Tie-break: Maximize transaction length
            best_txn = -1
            best_cost_tuple = (float('inf'), float('-inf'))  # (makespan, -length)

            for t in candidates:
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                # We want smallest cost, then largest length (so smallest negative length)
                cost_tuple = (cost, -txn_lengths[t])

                if cost_tuple < best_cost_tuple:
                    best_cost_tuple = cost_tuple
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Simulated Annealing with bias towards Insertion
    # Insertion is generally more effective for scheduling than Swap
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Tuned SA Hyperparameters for better exploration/exploitation balance
        temperature = 200.0  # Start higher to escape initial basins
        cooling_rate = 0.95  # Cool slower
        min_temperature = 0.5
        iters_per_temp = 30

        while temperature > min_temperature:
            for _ in range(iters_per_temp):
                neighbor = list(current_schedule)

                # Propose a move: 70% Insert, 30% Swap
                # Insertion preserves relative order of other items better
                if random.random() < 0.3:
                    # Swap
                    idx1, idx2 = random.sample(range(len(neighbor)), 2)
                    neighbor[idx1], neighbor[idx2] = neighbor[idx2], neighbor[idx1]
                else:
                    # Insert (Move item from idx1 to idx2)
                    idx1 = random.randint(0, len(neighbor) - 1)
                    idx2 = random.randint(0, len(neighbor) - 1)
                    if idx1 != idx2:
                        item = neighbor.pop(idx1)
                        neighbor.insert(idx2, item)

                # Evaluate
                new_cost = workload.get_opt_seq_cost(neighbor)
                delta = new_cost - current_cost

                # Metropolis acceptance criterion
                accept = False
                if delta < 0:
                    accept = True
                else:
                    try:
                        prob = math.exp(-delta / temperature)
                    except OverflowError:
                        prob = 0
                    if random.random() < prob:
                        accept = True

                if accept:
                    current_schedule = neighbor
                    current_cost = new_cost
                    if current_cost < best_overall_cost:
                        best_overall_cost = current_cost
                        best_schedule = list(current_schedule)

            temperature *= cooling_rate

    return best_overall_cost, best_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using greedy cost sampling with Big Rocks strategy
    and local search refinement.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_schedule = []

    # Pre-calculate individual transaction costs (lengths) for tie-breaking
    # Longer transactions are "heavier" and should be scheduled earlier if costs are equal
    txn_durations = {t: workload.get_opt_seq_cost([t]) for t in range(workload.num_txns)}
    # Sort transactions by duration descending to prioritize long transactions
    sorted_txns_by_len = sorted(range(workload.num_txns), key=lambda t: txn_durations[t], reverse=True)

    # Iteratively build solutions
    for i in range(num_seqs):
        # Random starting point
        start_txn = random.randint(0, workload.num_txns - 1)
        txn_seq = [start_txn]

        remaining_txns = set(range(workload.num_txns))
        remaining_txns.remove(start_txn)
        remaining_list = list(remaining_txns)

        # Build sequence
        while remaining_list:
            candidates = set()

            # Strategy:
            # 1. First iteration: Check ALL candidates for maximum quality baseline.
            # 2. Other iterations: Hybrid sampling (Big Rocks + Random).

            if i == 0:
                # Full scan for the first sequence
                candidates = set(remaining_list)
            else:
                # "Big Rocks" - prioritize longest available transactions
                # Adding the top available long transactions helps fill "holes" early
                # or schedule bottlenecks before they become critical.
                added_rocks = 0
                target_rocks = 4
                for t in sorted_txns_by_len:
                    if t in remaining_txns:
                        candidates.add(t)
                        added_rocks += 1
                        if added_rocks >= target_rocks:
                            break

                # Random sampling for diversity
                target_total = 20
                if len(remaining_list) <= target_total:
                    candidates.update(remaining_list)
                else:
                    while len(candidates) < target_total:
                        candidates.add(random.choice(remaining_list))

            # Find best candidate
            # Criteria: Minimize new makespan, Tie-break: Maximize transaction length
            best_txn = -1
            best_cost_tuple = (float('inf'), float('-inf'))

            for t in candidates:
                cost = workload.get_opt_seq_cost(txn_seq + [t])
                # We want smallest cost, then largest length (so smallest negative length)
                cost_tuple = (cost, -txn_durations[t])

                if cost_tuple < best_cost_tuple:
                    best_cost_tuple = cost_tuple
                    best_txn = t

            # Append best found
            txn_seq.append(best_txn)
            remaining_txns.remove(best_txn)
            remaining_list.remove(best_txn)

        # Check total cost
        overall_cost = workload.get_opt_seq_cost(txn_seq)
        if overall_cost < best_overall_cost:
            best_overall_cost = overall_cost
            best_schedule = txn_seq

    # Optimization Phase: Hill Climbing with Sideways Moves
    # We accept moves that improve or maintain the cost to traverse plateaus.
    if best_schedule:
        current_schedule = list(best_schedule)
        current_cost = best_overall_cost

        # Budget for optimization
        num_optimizations = 2000

        for _ in range(num_optimizations):
            # Propose a move: 70% Insert, 30% Swap
            is_insert = random.random() < 0.7

            if is_insert:
                # Insert Move
                idx1 = random.randint(0, len(current_schedule) - 1)
                idx2 = random.randint(0, len(current_schedule) - 1)
                if idx1 == idx2:
                    continue

                item = current_schedule.pop(idx1)
                current_schedule.insert(idx2, item)

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                    # Keep move
                else:
                    # Revert insert
                    item = current_schedule.pop(idx2)
                    current_schedule.insert(idx1, item)
            else:
                # Swap Move
                idx1, idx2 = random.sample(range(len(current_schedule)), 2)
                current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

                new_cost = workload.get_opt_seq_cost(current_schedule)

                if new_cost <= current_cost:
                    current_cost = new_cost
                    # Keep move
                else:
                    # Revert swap
                    current_schedule[idx1], current_schedule[idx2] = current_schedule[idx2], current_schedule[idx1]

        best_overall_cost = current_cost
        best_schedule = current_schedule

    return best_overall_cost, best_schedule
>>>>>>> REPLACE
</DIFF>