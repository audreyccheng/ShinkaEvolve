<NAME>
randomize_greedy_params
</NAME>

<DESCRIPTION>
Implement Diversity-Driven Parameter Randomization in the Adaptive Greedy phase. Instead of fixed thresholds and weights, sample `alpha` and `Big Rock` threshold for each generated sequence. This creates a diverse pool of initial candidates with different structural characteristics (e.g., some prioritize packing big rocks more aggressively than others). This diversity improves the probability that the Sprint and Marathon phases start from a basin of attraction leading to a better global optimum.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Parameters
    SAMPLE_SIZE = 12
    BIG_ROCK_THRESHOLD = 0.90
    WEIGHT_ALPHA = 0.05

    candidates = []

    # --- Phase 1: Adaptive Greedy Construction ---
    for _ in range(num_seqs):
        remaining = set(range(workload.num_txns))

        # Random start
        start_txn = random.choice(list(remaining))
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            # Determine dynamic "Big Rocks" threshold
            rem_lens = [txn_lens[t] for t in remaining]
            max_rem_len = max(rem_lens) if rem_lens else 0
            threshold = max_rem_len * BIG_ROCK_THRESHOLD

            # Form pool: Big Rocks + Randoms
            big_rocks = [t for t in remaining if txn_lens[t] >= threshold]

            pool = list(big_rocks)
            needed = SAMPLE_SIZE - len(pool)

            if needed > 0:
                others = [t for t in remaining if t not in big_rocks]
                if len(others) > needed:
                    pool.extend(random.sample(others, needed))
                else:
                    pool.extend(others)

            # Deduplicate
            pool = list(set(pool))

            best_cand = -1
            best_score = float('inf')

            # Evaluate Pool
            for t in pool:
                cost = workload.get_opt_seq_cost(current_seq + [t])
                # Weighted score: allow worse cost if txn is long
                score = cost - (WEIGHT_ALPHA * txn_lens[t])

                if score < best_score:
                    best_score = score
                    best_cand = t

            current_seq.append(best_cand)
            remaining.remove(best_cand)
=======
    # Parameters
    SAMPLE_SIZE = 12
    candidates = []

    # --- Phase 1: Adaptive Greedy Construction with Diversity ---
    for _ in range(num_seqs):
        # Diversity: Jitter parameters to create different structural candidates
        # Randomize 'Big Rock' threshold (0.80-0.95) and Weight Alpha (0.02-0.08)
        current_threshold_ratio = random.uniform(0.80, 0.95)
        current_alpha = random.uniform(0.02, 0.08)

        remaining = set(range(workload.num_txns))

        # Random start
        start_txn = random.choice(list(remaining))
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            # Determine dynamic "Big Rocks" threshold
            rem_lens = [txn_lens[t] for t in remaining]
            max_rem_len = max(rem_lens) if rem_lens else 0
            threshold = max_rem_len * current_threshold_ratio

            # Form pool: Big Rocks + Randoms
            big_rocks = [t for t in remaining if txn_lens[t] >= threshold]

            pool = list(big_rocks)
            needed = SAMPLE_SIZE - len(pool)

            if needed > 0:
                others = [t for t in remaining if t not in big_rocks]
                if len(others) > needed:
                    pool.extend(random.sample(others, needed))
                else:
                    pool.extend(others)

            # Deduplicate
            pool = list(set(pool))

            best_cand = -1
            best_score = float('inf')

            # Evaluate Pool
            for t in pool:
                cost = workload.get_opt_seq_cost(current_seq + [t])
                # Weighted score: allow worse cost if txn is long
                score = cost - (current_alpha * txn_lens[t])

                if score < best_score:
                    best_score = score
                    best_cand = t

            current_seq.append(best_cand)
            remaining.remove(best_cand)
>>>>>>> REPLACE
</DIFF>

<NAME>
enhance_lahc_operators
</NAME>

<DESCRIPTION>
Enhance the Block Shift operator in the LAHC phase. Increase the maximum block size from 4 to 8 to allow moving larger dependency chains intact. Adjust operator probabilities to favor Single Shift (45%) and Block Shift (35%) over Swap (20%), as Shift operations are more effective at structural reorganization than local swaps.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # LAHC Engine
    def run_lahc(start_seq, start_cost, iterations, history_len=50):
        curr_s = list(start_seq)
        curr_c = start_cost
        best_s = list(start_seq)
        best_c = start_cost

        history = [curr_c] * history_len

        for i in range(iterations):
            # Mutate
            op = random.random()
            neigh_s = list(curr_s)
            slen = len(neigh_s)

            if op < 0.5: # Single Shift
                if slen < 2: continue
                f = random.randint(0, slen-1)
                t = random.randint(0, slen-1)
                if f==t: continue
                item = neigh_s.pop(f)
                neigh_s.insert(t, item)
            elif op < 0.8: # Block Shift
                if slen < 5: continue
                bsize = random.randint(2, 4)
                f = random.randint(0, slen-bsize)
                block = neigh_s[f:f+bsize]
                del neigh_s[f:f+bsize]
                t = random.randint(0, len(neigh_s))
                neigh_s[t:t] = block
            else: # Swap
                if slen < 2: continue
                idx = random.randint(0, slen-2)
                neigh_s[idx], neigh_s[idx+1] = neigh_s[idx+1], neigh_s[idx]

            neigh_c = workload.get_opt_seq_cost(neigh_s)
=======
    # LAHC Engine
    def run_lahc(start_seq, start_cost, iterations, history_len=50):
        curr_s = list(start_seq)
        curr_c = start_cost
        best_s = list(start_seq)
        best_c = start_cost

        history = [curr_c] * history_len

        for i in range(iterations):
            # Mutate
            op = random.random()
            neigh_s = list(curr_s)
            slen = len(neigh_s)

            if op < 0.45: # Single Shift (45%)
                if slen < 2: continue
                f = random.randint(0, slen-1)
                t = random.randint(0, slen-1)
                if f==t: continue
                item = neigh_s.pop(f)
                neigh_s.insert(t, item)
            elif op < 0.8: # Block Shift (35%)
                if slen < 8: continue
                # Increased block size to move larger dependency chains
                bsize = random.randint(2, 8)
                f = random.randint(0, slen-bsize)
                block = neigh_s[f:f+bsize]
                del neigh_s[f:f+bsize]
                t = random.randint(0, len(neigh_s))
                neigh_s[t:t] = block
            else: # Swap (20%)
                if slen < 2: continue
                idx = random.randint(0, slen-2)
                neigh_s[idx], neigh_s[idx+1] = neigh_s[idx+1], neigh_s[idx]

            neigh_c = workload.get_opt_seq_cost(neigh_s)
>>>>>>> REPLACE
</DIFF>