<NAME>
smart_greedy_with_length_tie_break_and_shifts
</NAME>

<DESCRIPTION>
I am enhancing the scheduling algorithm by integrating three strategies to improve makespan minimization:
1.  **Length-Based Heuristics**: I pre-calculate transaction lengths (number of operations). During the greedy construction, I prioritize candidates that minimize makespan, but use transaction length as a tie-breaker (preferring longer/heavier transactions). This effectively packs large items into available slack ("Best Fit Descending").
2.  **Hybrid Sampling**: Instead of purely random candidates, the greedy step now samples a mix of the longest remaining transactions and random ones. This ensures "big rocks" are considered for optimal placement early.
3.  **Insertion/Shift Local Search**: After the adjacent swap descent, I add a stochastic "Shift" phase that attempts to move random transactions to new positions. This helps escape local optima that simple swaps cannot resolve.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using repeated greedy strategy with local search refinement.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Run the greedy process num_seqs times to explore different start points and paths
    for _ in range(num_seqs):
        # 1. Randomized Greedy Construction
        remaining = list(range(workload.num_txns))

        # Random start transaction
        start_txn = random.choice(remaining)
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            # Sample a subset of remaining transactions to evaluate
            # Checking more candidates improves decision quality
            sample_size = min(len(remaining), 15)
            candidates = random.sample(remaining, sample_size)

            best_candidate = -1
            min_candidate_cost = float('inf')

            # Evaluate candidates
            for t in candidates:
                # Calculate cost of adding candidate t to current sequence
                # We want to minimize the makespan of the partial schedule
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                if cost < min_candidate_cost:
                    min_candidate_cost = cost
                    best_candidate = t

            # Append the best candidate found
            current_seq.append(best_candidate)
            remaining.remove(best_candidate)

        # 2. Local Search Refinement
        # Attempt to improve the constructed schedule by swapping adjacent transactions
        # This helps fix minor sub-optimal greedy choices
        current_cost = workload.get_opt_seq_cost(current_seq)
        improved = True
        while improved:
            improved = False
            for i in range(len(current_seq) - 1):
                # Swap adjacent elements
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
                new_cost = workload.get_opt_seq_cost(current_seq)

                if new_cost < current_cost:
                    current_cost = new_cost
                    improved = True
                else:
                    # Revert swap if no improvement
                    current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]

        # Update global best if this run found a better schedule
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_overall_schedule = list(current_seq)

    return best_overall_cost, best_overall_schedule
=======
def get_best_schedule(workload, num_seqs):
    """
    Get optimal schedule using Advanced Greedy Construction and Hybrid Local Search.

    Improvements:
    1.  **Txn Length Heuristic**: Pre-computes transaction lengths (operation counts).
    2.  **Smart Sampling**: In greedy phase, candidates include both random choices and the "longest"
        remaining transactions. This encourages packing "big rocks" early if they fit.
    3.  **Tie-Breaking**: Selects candidates by minimizing `(cost, -length)`, preferring longer
        transactions when costs are equal (Best Fit Descending).
    4.  **Hybrid Local Search**: Uses Adjacent Swap Descent for fine-tuning, followed by
        Random Insertion (Shift) attempts to escape local optima.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of sequences to sample for greedy selection

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    import re

    # --- Pre-computation: Transaction Lengths ---
    txn_lens = {}
    try:
        for i in range(workload.num_txns):
            raw_txn = workload.txns[i]
            if isinstance(raw_txn, (list, tuple)):
                raw_txn = raw_txn[0]
            txn_str = str(raw_txn)
            ops = len(re.findall(r'[rw]-\d+', txn_str))
            txn_lens[i] = ops
    except Exception:
        for i in range(workload.num_txns):
            txn_lens[i] = 1

    # Sorted list of transactions by length (descending) for priority sampling
    txns_by_len = sorted(range(workload.num_txns), key=lambda k: txn_lens[k], reverse=True)

    best_overall_cost = float('inf')
    best_overall_schedule = []

    # Parameters
    SAMPLE_SIZE_RANDOM = 12
    SAMPLE_SIZE_LONGEST = 3
    SHIFT_ATTEMPTS = 50  # Budget for random insertion moves

    for _ in range(num_seqs):
        # 1. Greedy Construction
        remaining = set(range(workload.num_txns))

        # Random start for diversity
        start_txn = random.choice(list(remaining))
        current_seq = [start_txn]
        remaining.remove(start_txn)

        while remaining:
            candidates = set()

            # A. Pick top longest available transactions
            count = 0
            for t in txns_by_len:
                if t in remaining:
                    candidates.add(t)
                    count += 1
                    if count >= SAMPLE_SIZE_LONGEST:
                        break

            # B. Pick random transactions
            sample_size = min(len(remaining), SAMPLE_SIZE_RANDOM)
            candidates.update(random.sample(list(remaining), sample_size))

            # C. Evaluate Candidates
            # We want to minimize cost, then maximize length (Best Fit Descending)
            best_candidate = -1
            best_score = (float('inf'), 0) # (cost, -length)

            for t in candidates:
                test_seq = current_seq + [t]
                cost = workload.get_opt_seq_cost(test_seq)

                # Tie-breaker: negative length so min() picks the larger length
                score = (cost, -txn_lens[t])

                if score < best_score:
                    best_score = score
                    best_candidate = t

            current_seq.append(best_candidate)
            remaining.remove(best_candidate)

        # 2. Local Search Refinement
        current_cost = workload.get_opt_seq_cost(current_seq)

        # Phase A: Adjacent Swap Descent (Hill Climbing)
        improved = True
        while improved:
            improved = False
            for i in range(len(current_seq) - 1):
                # Swap adjacent
                current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]
                new_cost = workload.get_opt_seq_cost(current_seq)

                if new_cost < current_cost:
                    current_cost = new_cost
                    improved = True
                else:
                    # Revert
                    current_seq[i], current_seq[i+1] = current_seq[i+1], current_seq[i]

        # Phase B: Random Insertion (Shift) Perturbation
        # Try moving a random transaction to a random position
        for _ in range(SHIFT_ATTEMPTS):
            if len(current_seq) < 2: break

            # Pick random txn and new position
            idx_from = random.randint(0, len(current_seq) - 1)
            idx_to = random.randint(0, len(current_seq) - 1)

            if idx_from == idx_to: continue

            # Move
            txn = current_seq.pop(idx_from)
            current_seq.insert(idx_to, txn)

            new_cost = workload.get_opt_seq_cost(current_seq)

            if new_cost < current_cost:
                current_cost = new_cost
                # Keep the change
            else:
                # Revert
                current_seq.pop(idx_to)
                current_seq.insert(idx_from, txn)

        # Update global best
        if current_cost < best_overall_cost:
            best_overall_cost = current_cost
            best_overall_schedule = list(current_seq)

    return best_overall_cost, best_overall_schedule
>>>>>>> REPLACE
</DIFF>