# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Cost-Sampled Transaction Scheduler**
- **Implementation**: Greedy scheduler with a random start; at each step it samples up to 10 remaining transactions without replacement and picks the one minimizing workload.get_opt_seq_cost. The sample_rate is fixed at 1.0 (disabling random fallback), and num_seqs is ignored; costs are recomputed per candidate and a holdout list prevents within-step resampling.
- **Performance**: Achieved a combined score of 2.88 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Fixed full-sampling (1.0) and a single random restart limit exploration, which may cap optimality despite stable performance; redundant recomputation and unused variables indicate minor inefficiencies. Still, the approach reliably produces valid schedules with predictable greedy behavior.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Beam-Search Transaction Scheduler with Local Refinement**
- **Implementation**: Uses a memoized beam search over transaction orderings with beam width derived from num_seqs, sampled expansions (thresholded full expansion), and diversity enforced by unique end elements; followed by adjacent-swap first-improvement hill-climbing. Includes robust repo-root discovery to import the simulator and workloads.
- **Performance**: Achieved combined score 3.36 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization substantially reduces repeated cost evaluations, while sampled expansion and bounded beam width keep runtime controlled without sacrificing much quality; the local swap pass reliably trims makespan further. Randomized sampling can introduce minor run-to-run variance, but diversity heuristics mitigate premature convergence.
**Program Identifier:** Generation 1 - Patch Name beam_and_local_search - Correct Program: True

**Program Name: Cached Beam Search with Local Refinement for Scheduling**
- **Implementation**: Implements beam search guided by partial-prefix costs with memoized caching and randomized candidate sampling, plus multiple seeded restarts. Applies adjacent-swap local refinement and greedy/identity fallbacks, with beam width and expansion limits scaled to problem size.
- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Cost caching and partial-cost guidance reduced evaluations and stabilized search, while restarts and local refinement shaved makespan further. Score indicates room for improvement likely limited by conservative beam width and sampling bounds; increasing num_seqs could trade runtime for better schedules.
**Program Identifier:** Generation 2 - Patch Name beam_cached_greedy_scheduler - Correct Program: True

**Program Name: GRASP-based Transaction Scheduler with Local Search**
- **Implementation**: Uses multi-start GRASP with randomized best-insertion (candidate and insertion-position sampling), seeding with a best-of-two second insert. Refines with multi-pass adjacent swaps and random relocations; parameters adapt to workload size with validity assertions.
- **Performance**: Achieved a combined score of 4.00 on three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Adaptive sampling and local search balanced solution quality and runtime, yielding robust, feasible schedules. Multi-start diversification and seeding improved consistency across runs.
**Program Identifier:** Generation 3 - Patch Name grasp_insertion_localsearch - Correct Program: True

**Program Name: Greedy-ILS Transaction Scheduler**
- **Implementation**: Greedy best-insertion with memoized cost evaluations seeded by singleton-cost ordering; sampled insertion positions include endpoints and use deterministic ordering to aid cache hits. First-improvement local refinement (adjacent swaps and reinsertion) is followed by a light iterated local search using a few random swaps; includes robust repo-root discovery for dependable imports.
- **Performance**: Achieved a combined score of 4.08 across 3 workloads (300 transactions), producing valid schedules for each and passing all validation tests; execution time is recorded per run.
- **Feedback**: Memoization and sampled insertion reduced simulator calls, delivering a good makespan/runtime trade-off, while local refinement consistently improved seed solutions. Limited perturbations likely cap deeper exploration, so most gains stem from construction and local moves rather than heavy global search.
**Program Identifier:** Generation 4 - Patch Name greedy_insertion_ils - Correct Program: True

**Program Name: Beam-Search GRASP Transaction Scheduler**
- **Implementation**: Implements a cached beam search with two-step lookahead (k=5, alpha=0.7), seeded by a randomized best-insertion GRASP and diversified via random survivors and multiple restarts. Applies strong local refinement (reinsertion with sampled positions and adjacent swaps), adapts beam width/candidate expansion to problem size, and includes greedy/identity fallbacks.
- **Performance**: Achieved combined score 3.92, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Prefix-cost caching reduces duplicate evaluations and stabilizes lookahead scoring; the reinsertion+swap passes consistently improve makespan over raw beam outputs. Diversification (GRASP seed, survivors, restarts) enhances exploration and robustness across workloads.
**Program Identifier:** Generation 5 - Patch Name beam_lookahead_and_reinsertion_local_search - Correct Program: True

**Program Name: Greedy-Guided ILS Transaction Scheduler**
- **Implementation**: Uses greedy best-insertion seeded by elite and random starts, with memoized cost evaluations and pairwise two-transaction precedence to guide insertion positions. Applies strong local refinement (adjacent swaps, guided reinsertion, sampled 2-opt) and a light iterated local search with random perturbations.
- **Performance**: Achieved combined score 3.68 across 3 workloads (300 transactions), producing valid schedules and reporting execution time.
- **Feedback**: Pairwise guidance and memoization reduce cost evaluations and improve search efficiency, while multi-seed starts and ILS help escape local minima for lower makespan. Program is correct and passed all validation tests; parameters keep runtime modest without sacrificing quality.
**Program Identifier:** Generation 6 - Patch Name pairwise_guided_insertion_ils - Correct Program: True

**Program Name: Regret-Guided Beam ILS Scheduler**
- **Implementation**: Combines memoized regret-guided insertion beam search (diversified by end element) with deterministic position sampling and sampled candidate transactions to construct schedules. Applies strong local refinement (adjacent swaps, reinsertion, sampled pair swaps, segment reversals) followed by a light iterated local search with structured perturbations; parameters scale with num_seqs.
- **Performance**: Achieved a combined score of 4.17 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and deterministic sampling reduced redundant evaluations and stabilized search, while the regret heuristic plus multi-operator local search consistently lowered makespan. Further gains likely come from tuning beam width and sampling sizes (via num_seqs) to balance runtime and quality per workload.
**Program Identifier:** Generation 7 - Patch Name regret_beam_and_vnd - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: Implements GRASP-style randomized best-insertion with a prefix cost cache and RCL, followed by VND local search (adjacent swaps then relocations), with adaptive candidate/position sampling by workload size and multi-start restarts.
- **Performance**: Achieved a combined score of 3.91 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching prefix evaluations reduced repeated cost calls, enabling broader exploration, while adaptive sampling and RCL improved diversification and VND tightened makespan with reasonable runtime. The score indicates solid performance; more restarts or a higher position sample cap for large n may yield further gains.
**Program Identifier:** Generation 9 - Patch Name grasp_beam_cached_vnd - Correct Program: True

**Program Name: GRASP Transaction Scheduler with Local Search**
- **Implementation**: Implements a multi-start GRASP using randomized best-insertion with a restricted candidate list and adaptive position sampling, supported by a partial-prefix cost cache. Refines sequences via deterministic best reinsertion, adjacent swap hill-climbing, and random relocations, with parameters scaling to workload size and restart count.
- **Performance**: Combined score to maximize: 4.05 across 3 workloads (300 transactions); all validation tests passed.
- **Feedback**: Adaptive RCL plus layered local search balanced exploration and exploitation, improving makespan while caching and position sampling controlled evaluation cost. Robust path discovery ensured portability; tuning position limits and relocation trials can further optimize speed-quality trade-offs on larger workloads.
**Program Identifier:** Generation 10 - Patch Name grasp_cache_reinsert_rcl - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Regret-guided insertion within a cached beam plus diversified seeds and strong local refinement delivered the top score. The Regret-Guided Beam ILS Scheduler (score 4.17) combines memoized regret-based insertion in a beam (with end-element diversity) and a rich local search (adjacent swaps, reinsertion, sampled pair swaps, segment reversals) followed by light ILS perturbations; this outperformed Greedy-ILS (4.08) that used best-insertion and lighter perturbations.
- Memoization of sequence costs is a consistent win. Programs explicitly caching partial/prefix costs—Beam-Search Transaction Scheduler with Local Refinement (3.36), Cached Beam Search with Local Refinement (3.33), GRASP variants (~3.91–4.05), Greedy-ILS (4.08), and the current best (4.17)—all show improved runtime/quality balance compared to the non-cached greedy baseline (2.88).
- Layered local search (VND-like) consistently improves makespan beyond initial constructions. Schedulers using adjacent swaps plus reinsertion and additional operators (e.g., pair swaps, segment reversals) scored higher: Regret-Guided Beam ILS (4.17) > GRASP Transaction Scheduler with Local Search (4.05; reinsertion + adjacent swaps + relocations) > GRASP-VND (3.91; swaps then relocations).
- Diversified construction seeds improve robustness. Elite singleton seeds plus a few random seeds (current best, 4.17) and GRASP-style randomized best-insertion seeds (4.00–4.05) outperform single-start approaches, reducing variance and avoiding early convergence.

## Ineffective Approaches
- Pure greedy with fixed full sampling and minimal exploration capped performance. The Greedy Cost-Sampled Transaction Scheduler (2.88) fixed sample_rate=1.0, had a single random start, and recomputed costs redundantly; validation passed but optimality was limited by narrow search and inefficiencies.
- Overly conservative beam widths/sampling constrained solution quality. Cached Beam Search with Local Refinement (3.33) notes “room for improvement likely limited by conservative beam width and sampling bounds,” trailing both stronger GRASP variants (~3.9–4.05) and the regret-guided beam approach (4.17).
- Light/limited perturbations in ILS restrict deeper improvements. Greedy-ILS (4.08) achieved strong results via memoized best-insertion and modest perturbations; feedback indicates “limited perturbations likely cap deeper exploration,” which aligns with it being surpassed by the regret-guided beam with richer local operators (4.17).
- Randomized sampling without strong diversity control introduces variance and can underperform. Beam-Search Transaction Scheduler with Local Refinement (3.36) highlights run-to-run variance from randomized expansion; while diversity by end element mitigated premature convergence, it still lagged behind methods with stronger insertion heuristics and local search.

## Implementation Insights
- Effective caching design: keying seq_cost by tuple(sequence) and using deterministic position sampling. The best program sorts position samples (always including endpoints and mid) to stabilize cache hits and reduce duplicate evaluations; similar memoization benefits were cited in multiple programs (e.g., beam and GRASP variants).
- Diversity control in beam expansions matters. The current best enforces uniqueness by end element within the beam, which reduces redundant expansions and spreads exploration—an idea also present in earlier beam implementations (3.36) but paired here with regret-guided scoring for stronger selection pressure.
- Regret-based insertion outperforms pure best-insertion for construction. By ranking candidates with both best insertion cost and regret (gap to second-best), the best program produces higher-quality partials than purely greedy insertions used in Greedy-ILS (4.08) and several GRASP constructions (~4.00–4.05).
- Layered, first-improvement local refinement with multiple move operators is key to closing the gap. The best program’s sequence of adjacent swaps → reinsertion → sampled pair swaps → segment reversals, coupled with a small ILS (segment reversal + random swaps), consistently trimmed makespan beyond construction. Programs using fewer operators or lighter perturbations scored lower.

## Performance Analysis
- Clear upward trend from naive greedy to beam/GRASP to regret-guided beam with VND: 2.88 (Greedy Cost-Sampled) → ~3.33–3.36 (cached beam variants) → ~3.91–4.05 (GRASP and GRASP+local search) → 4.08 (Greedy-ILS) → 4.17 (Regret-Guided Beam ILS).
- The biggest observed gains correlate with adding: (1) memoization, (2) stronger construction heuristics (regret-guided insertion within a beam), and (3) richer local search neighborhoods plus light ILS. Each layer adds measurable improvement over prior configurations.
- Beam search alone with caching (3.33–3.36) underperforms compared to GRASP+local search (~3.9–4.05), indicating that local refinement quality contributes more than broader but shallow construction; combining both (regret-guided beam + strong local refinement) yields the best result (4.17).
- Parameter scaling and diversification contribute but are not sufficient independently. Multiple restarts/seeds improved mid-tier methods (e.g., GRASP-based at 4.00–4.05), yet the best score required combining diversified seeds with regret-guided beam selection and multi-operator local search.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Enhance beam selection with regret-weighted diversity and duplicate pruning
   - In the expansion ranking, select primarily by cost but include a small quota (e.g., 20–30% of beam width) of high-regret candidates even if their cost is slightly worse. Enforce diversity by suffix signature (last-2 elements) instead of only the last element, and keep a per-iteration set of seen sequences (tuple(seq)) to prune duplicates before sorting. This preserves strong selection pressure while broadening exploration where regret signals high opportunity.

2. Add a ruin-and-recreate LNS step using regret-guided reinsertion
   - Between local_refine and ILS iterations, remove a subset of transactions (e.g., k = 8–15 or 5–10% of n), chosen either as a random contiguous segment and a few high-variance positions, then rebuild the partial using the existing regret-guided insertion over a small beam. Run 2–3 such LNS iterations per best solution found, followed by the existing local_refine. This leverages your strongest constructor to escape deeper local minima than simple segment reversals.

3. Upgrade local search to VND with Or-opt blocks and don’t-look bits (DLB)
   - Extend reinsertion moves to Or-opt of block sizes 1, 2, and 3 in a deterministic best-improvement pass, then adjacent swaps, then sampled pair swaps, then segment reversals. Maintain DLB: track indices (or blocks) with no improving moves in the last pass and skip them until a neighboring change occurs, which speeds convergence and enables deeper neighborhoods without large runtime. Stop the VND loop only after a full cycle across all neighborhoods with no improvement.

4. Make sampling and beam widths adaptive to construction progress and stagnation
   - When len(rem) <= T (e.g., T = 2·local_beam_width), evaluate all candidate transactions and all insertion positions (k_pos_sample = len(seq)+1) and widen local_beam_width by +1–2 to avoid endgame myopia. If no improvement in the last two construction layers, temporarily increase k_txn_sample (e.g., +50%) for one layer to diversify. Similarly, scale local_refine sampling counts with n and restart them at higher values after two non-improving ILS perturbations.

5. Strengthen seed diversification with GRASP-style constructed seeds and path relinking
   - In addition to elite singletons and a few random seeds, generate 2–3 GRASP seeds via randomized regret-guided insertion (alpha-greediness: pick among top-m candidates by cost/regret) and pass them through a quick local_refine. After refining the top-2–3 solutions from different seeds, perform path relinking: iteratively transform one sequence toward the other using the best-improving move at each step, then refine the intermediate. This recombination has shown strong synergy with diversified starts and rich local search.