<NAME>
endgame_branch_and_bound
</NAME>

<DESCRIPTION>
I introduce an exact endgame completion using bounded branch-and-bound enumeration for the last K transactions, with memoization and regret-ordered branching. This strengthens the tail of schedules where many conflicts manifest, significantly reducing makespan versus heuristic append. Specifically:
- Add endgame_enum_K and a node cap for predictable runtime.
- Implement endgame_optimal_completion(prefix, remaining_set) that enumerates orders with best-position insertions, prunes via partial-cost and current best bound, and uses a small memo keyed by (tuple(prefix), frozenset(remaining)).
- Use the endgame completion when selecting the best sequence from the construction beam and during LNS repair both initially (if the destroy size is small) and when the remaining set becomes small mid-repair.

This focuses expensive exact search only when the remaining set is small, complementing the existing regret-beam and local search. It directly optimizes makespan in the hardest tail segment, which heuristics often misorder, and should improve the combined score with modest overhead due to pruning and caps.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Elite pool size for path relinking
    elite_size = max(3, min(6, 2 + num_seqs // 3))
=======
    # Elite pool size for path relinking
    elite_size = max(3, min(6, 2 + num_seqs // 3))
    # Endgame exact completion parameters
    endgame_enum_K = max(6, min(9, 3 + num_seqs // 3))
    endgame_node_cap = 3000
>>>>>>> REPLACE

>>>>>>> REPLACE
<<<<<<< SEARCH
    def suffix_sig(seq):
        if not seq:
            return (None,)
        L = len(seq)
        if L >= diversity_suffix_len:
            return tuple(seq[-diversity_suffix_len:])
        return tuple([None] * (diversity_suffix_len - L) + seq)
=======
    def suffix_sig(seq):
        if not seq:
            return (None,)
        L = len(seq)
        if L >= diversity_suffix_len:
            return tuple(seq[-diversity_suffix_len:])
        return tuple([None] * (diversity_suffix_len - L) + seq)

    # Endgame exact completion (branch-and-bound over last K txns)
    endgame_memo = {}
    def endgame_optimal_completion(prefix_seq, rem_set):
        """
        Given a prefix sequence and a small remaining set of txns (|rem_set| <= K),
        enumerate txn orders with best-position insertion to find the minimal-cost completion.
        Uses branch-and-bound with the current best bound and partial-cost pruning.
        Returns (best_cost, best_seq).
        """
        key0 = (tuple(prefix_seq), frozenset(rem_set))
        if key0 in endgame_memo:
            return endgame_memo[key0]

        best_c = float('inf')
        best_s = None
        nodes = 0

        def dfs(seq, rem):
            nonlocal best_c, best_s, nodes
            if nodes >= endgame_node_cap:
                return
            # Prune by current partial cost
            c_prefix = seq_cost(seq)
            if c_prefix >= best_c:
                return
            if not rem:
                if c_prefix < best_c:
                    best_c = c_prefix
                    best_s = seq[:]
                return
            # Order candidates by high regret first, then by lower best insertion cost
            order = []
            for t in rem:
                b, p, s2 = best_two_insertion_policy(seq, t, use_all_pos=True)
                regret = (s2 - b) if s2 < float('inf') else 0.0
                order.append((-regret, b, t, p))
            order.sort()
            for _, bcost, t, p in order:
                if nodes >= endgame_node_cap:
                    break
                if bcost >= best_c:
                    continue
                nodes += 1
                new_seq = seq[:p] + [t] + seq[p:]
                new_rem = rem.copy()
                new_rem.remove(t)
                dfs(new_seq, new_rem)

        dfs(prefix_seq[:], set(rem_set))
        if best_s is None:
            # Fallback: deterministic append to avoid None
            seq_complete = prefix_seq[:] + sorted(list(rem_set))
            best_c = seq_cost(seq_complete)
            best_s = seq_complete
        endgame_memo[key0] = (best_c, best_s)
        return best_c, best_s
>>>>>>> REPLACE

>>>>>>> REPLACE
<<<<<<< SEARCH
        # Choose the best complete sequence from the beam
        best_seq = None
        best_cost = float('inf')
        for seq, rem, cost in beam:
            if rem:
                # Append remaining deterministically and evaluate
                seq_complete = seq + sorted(list(rem))
                c = seq_cost(seq_complete)
                if c < best_cost:
                    best_cost = c
                    best_seq = seq_complete
            else:
                if cost < best_cost:
                    best_cost = cost
                    best_seq = seq

        return best_seq
=======
        # Choose the best complete sequence from the beam (use exact endgame when few remain)
        best_seq = None
        best_cost = float('inf')
        for seq, rem, cost in beam:
            if rem:
                if len(rem) <= endgame_enum_K:
                    c, s = endgame_optimal_completion(seq, set(rem))
                else:
                    seq_complete = seq + sorted(list(rem))
                    c, s = seq_cost(seq_complete), seq_complete
                if c < best_cost:
                    best_cost = c
                    best_seq = s
            else:
                if cost < best_cost:
                    best_cost = cost
                    best_seq = seq

        return best_seq
>>>>>>> REPLACE

>>>>>>> REPLACE
<<<<<<< SEARCH
    def lns_attempt(seq):
        cur = seq[:]
        frac = random.uniform(*destroy_frac_range)
        m = max(4, min(n // 2, int(frac * n)))
        # Choose removal indices: random subset or contiguous block
        if random.random() < 0.5:
            remove_idxs = sorted(random.sample(range(n), m))
        else:
            start = random.randint(0, n - m)
            remove_idxs = list(range(start, start + m))
        remove_set = set(remove_idxs)
        removed = [cur[i] for i in remove_idxs]
        remaining = [cur[i] for i in range(n) if i not in remove_set]

        seq_rep = remaining[:]
        rem_set = removed[:]
        while rem_set:
            if len(rem_set) > k_txn_sample:
                cand_txns = random.sample(rem_set, k_txn_sample)
            else:
                cand_txns = rem_set[:]
            best_overall = (float('inf'), None, None)  # cost, txn, pos
            best_by_regret = (float('-inf'), None, None)  # regret, txn, pos

            for t in cand_txns:
                use_all = (len(seq_rep) <= 18) or (len(rem_set) <= 2 * base_beam_width)
                best_c, best_p, second_c = best_two_insertion_policy(seq_rep, t, use_all_pos=use_all)
                regret = (second_c - best_c) if second_c < float('inf') else 0.0
                if best_c < best_overall[0]:
                    best_overall = (best_c, t, best_p)
                if regret > best_by_regret[0]:
                    best_by_regret = (regret, t, best_p)

            pick_regret = (random.random() < lns_regret_prob)
            chosen = best_by_regret if pick_regret and best_by_regret[1] is not None else best_overall
            t = chosen[1]
            p = chosen[2] if chosen[2] is not None else len(seq_rep)
            if t is None:
                t = random.choice(rem_set)
                p = len(seq_rep)
            seq_rep = seq_rep[:p] + [t] + seq_rep[p:]
            rem_set.remove(t)

        c_rep, s_rep = local_refine(seq_rep)
        return c_rep, s_rep
=======
    def lns_attempt(seq):
        cur = seq[:]
        frac = random.uniform(*destroy_frac_range)
        m = max(4, min(n // 2, int(frac * n)))
        # Choose removal indices: random subset or contiguous block
        if random.random() < 0.5:
            remove_idxs = sorted(random.sample(range(n), m))
        else:
            start = random.randint(0, n - m)
            remove_idxs = list(range(start, start + m))
        remove_set = set(remove_idxs)
        removed = [cur[i] for i in remove_idxs]
        remaining = [cur[i] for i in range(n) if i not in remove_set]

        # If destroy size is small, solve exactly via endgame completion
        if len(removed) <= endgame_enum_K:
            c_end, s_end = endgame_optimal_completion(remaining, set(removed))
            c_rep, s_rep = local_refine(s_end)
            return c_rep, s_rep

        # Otherwise, repair incrementally; when rem becomes small, finish exactly
        seq_rep = remaining[:]
        rem_set = removed[:]
        while rem_set:
            if len(rem_set) <= endgame_enum_K:
                c_end, s_end = endgame_optimal_completion(seq_rep, set(rem_set))
                seq_rep = s_end
                rem_set = []
                break

            if len(rem_set) > k_txn_sample:
                cand_txns = random.sample(rem_set, k_txn_sample)
            else:
                cand_txns = rem_set[:]
            best_overall = (float('inf'), None, None)  # cost, txn, pos
            best_by_regret = (float('-inf'), None, None)  # regret, txn, pos

            for t in cand_txns:
                use_all = (len(seq_rep) <= 18) or (len(rem_set) <= 2 * base_beam_width)
                best_c, best_p, second_c = best_two_insertion_policy(seq_rep, t, use_all_pos=use_all)
                regret = (second_c - best_c) if second_c < float('inf') else 0.0
                if best_c < best_overall[0]:
                    best_overall = (best_c, t, best_p)
                if regret > best_by_regret[0]:
                    best_by_regret = (regret, t, best_p)

            pick_regret = (random.random() < lns_regret_prob)
            chosen = best_by_regret if pick_regret and best_by_regret[1] is not None else best_overall
            t = chosen[1]
            p = chosen[2] if chosen[2] is not None else len(seq_rep)
            if t is None:
                t = random.choice(rem_set)
                p = len(seq_rep)
            seq_rep = seq_rep[:p] + [t] + seq_rep[p:]
            rem_set.remove(t)

        c_rep, s_rep = local_refine(seq_rep)
        return c_rep, s_rep
>>>>>>> REPLACE

</DIFF>