<NAME>
grasp_regret_vnd_lns
</NAME>

<DESCRIPTION>
I introduce three targeted improvements to reduce makespan:

1) Regret-weighted GRASP insertion: During construction, for each candidate transaction we now compute both the best and second-best insertion costs. We select among the top candidates by weighting toward higher regret (second-best minus best), which prioritizes placing transactions whose placement options vary widely, reducing future conflicts and delays.

2) Stronger local search via VND Or-opt blocks: I add a Variable Neighborhood Descent with Or-opt block relocations of sizes 3, 2, and 1 (deterministic best-improving passes), followed by a quick adjacent-swap and a light relocation pass. This digs much deeper than simple adjacent swaps or random relocations, improving schedules with complex conflict structures.

3) Ruin-and-recreate Large Neighborhood Search: Between construction and final polishing, I perform a small LNS step by removing a contiguous block (and a few extras) and reinserting greedily by best insertion positions. If it improves, I run VND again to polish. This helps escape local minima found by the deterministic VND.

I also keep the cost cache for partial prefixes to amortize expensive cost evaluations. These changes should provide better makespans with modest runtime increase and maintain robustness across workloads.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def best_insertion_for_txn(current_seq, txn):
        """
        Try inserting txn into multiple positions in current_seq.
        Returns (best_cost, best_pos).
        """
        seq_len = len(current_seq)
        best_cost = float('inf')
        best_pos = 0
        positions = sample_positions(seq_len)
        # Evaluate each possible position
        for pos in positions:
            cand = current_seq.copy()
            cand.insert(pos, txn)
            cost = eval_cost(cand)
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return best_cost, best_pos
=======
    def best_insertion_for_txn(current_seq, txn):
        """
        Try inserting txn into multiple positions in current_seq.
        Returns (best_cost, best_pos, second_best_cost) to enable regret-based selection.
        """
        seq_len = len(current_seq)
        best_cost = float('inf')
        second_best = float('inf')
        best_pos = 0
        positions = sample_positions(seq_len)
        # Evaluate each possible position, track the two best costs
        for pos in positions:
            cand = current_seq.copy()
            cand.insert(pos, txn)
            cost = eval_cost(cand)
            if cost < best_cost:
                second_best = best_cost
                best_cost = cost
                best_pos = pos
            elif cost < second_best:
                second_best = cost
        # In case we only had one position, second_best may remain inf; normalize
        if second_best == float('inf'):
            second_best = best_cost
        return best_cost, best_pos, second_best
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def construct_sequence():
        """
        GRASP randomized best-insertion construction with RCL.
        """
        remaining = all_txns.copy()
        start_txn = select_best_starter()
        seq = [start_txn]
        remaining.remove(start_txn)
        curr_cost = eval_cost(seq)

        # Try to find a good second transaction by testing a small candidate set thoroughly
        if remaining:
            k = min(6, len(remaining))
            second_cands = random.sample(remaining, k)
            best_pair_cost = float('inf')
            best_txn = None
            best_pos = 1  # only positions 0 or 1 possible
            for t in second_cands:
                for pos in [0, 1]:
                    cand = seq.copy()
                    cand.insert(pos, t)
                    cost = eval_cost(cand)
                    if cost < best_pair_cost:
                        best_pair_cost = cost
                        best_txn = t
                        best_pos = pos
            if best_txn is not None:
                seq.insert(best_pos, best_txn)
                remaining.remove(best_txn)
                curr_cost = best_pair_cost

        # Build the rest using sampled candidates and best insertion positions + RCL selection
        while remaining:
            # Adaptive candidate sample size with slight randomness
            dynamic_base = CAND_SAMPLE_BASE
            cand_size = min(len(remaining), max(3, dynamic_base + random.randint(-JITTER, JITTER)))
            cand_txns = random.sample(remaining, cand_size)

            scored = []
            for t in cand_txns:
                cost_t, pos_t = best_insertion_for_txn(seq, t)
                scored.append((cost_t, t, pos_t))

            # If no candidate improved, still proceed with best known; use RCL for diversification
            scored.sort(key=lambda x: x[0])
            rcl_size = min(RCL_K, len(scored))
            # random pick among the top rcl_size candidates to diversify
            chosen_idx = random.randint(0, rcl_size - 1)
            best_step_cost, best_txn, best_pos = scored[chosen_idx]

            seq.insert(best_pos, best_txn)
            curr_cost = best_step_cost
            remaining.remove(best_txn)

        return seq, curr_cost
=======
    def construct_sequence():
        """
        GRASP randomized best-insertion construction with regret-weighted RCL.
        """
        remaining = all_txns.copy()
        start_txn = select_best_starter()
        seq = [start_txn]
        remaining.remove(start_txn)
        curr_cost = eval_cost(seq)

        # Try to find a good second transaction by testing a small candidate set thoroughly
        if remaining:
            k = min(6, len(remaining))
            second_cands = random.sample(remaining, k)
            best_pair_cost = float('inf')
            best_txn = None
            best_pos = 1  # only positions 0 or 1 possible
            for t in second_cands:
                for pos in [0, 1]:
                    cand = seq.copy()
                    cand.insert(pos, t)
                    cost = eval_cost(cand)
                    if cost < best_pair_cost:
                        best_pair_cost = cost
                        best_txn = t
                        best_pos = pos
            if best_txn is not None:
                seq.insert(best_pos, best_txn)
                remaining.remove(best_txn)
                curr_cost = best_pair_cost

        # Build the rest using sampled candidates and best insertion positions + regret-weighted RCL selection
        while remaining:
            # Adaptive candidate sample size with slight randomness
            dynamic_base = CAND_SAMPLE_BASE
            cand_size = min(len(remaining), max(3, dynamic_base + random.randint(-JITTER, JITTER)))
            cand_txns = random.sample(remaining, cand_size)

            step_evals = []
            for t in cand_txns:
                cost_t, pos_t, second_cost_t = best_insertion_for_txn(seq, t)
                step_evals.append((cost_t, t, pos_t, second_cost_t))

            # Sort by best insertion cost
            step_evals.sort(key=lambda x: x[0])

            # Build RCL: include a few best candidates, then choose weighted by regret
            rcl_size = min(max(3, RCL_K), len(step_evals))
            rcl = step_evals[:rcl_size]

            # Regret = (second_best_cost - best_cost). Prefer higher regret among good candidates.
            regrets = [max(0.0, s2 - s1) for (s1, _, _, s2) in rcl]
            total_regret = sum(regrets)

            if total_regret > 0 and random.random() < 0.7:
                # Pick by regret weights among RCL to emphasize critical placements
                choices = [item for item in rcl]
                weights = regrets
                chosen = random.choices(choices, weights=weights, k=1)[0]
                best_step_cost, best_txn, best_pos, _ = chosen
            else:
                # Greedy fallback among RCL
                best_step_cost, best_txn, best_pos, _ = rcl[0]

            seq.insert(best_pos, best_txn)
            curr_cost = best_step_cost
            remaining.remove(best_txn)

        return seq, curr_cost
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def local_search_relocations(seq, curr_cost, tries=RELOC_TRIES):
        """
        Random relocation: remove at index i and reinsert at j if improves.
        Accepts first improving move and continues until no improvement across budgeted tries.
        """
        best_seq = list(seq)
        best_cost = curr_cost

        if len(best_seq) <= 2:
            return best_seq, best_cost

        trials = 0
        while trials < tries:
            i = random.randint(0, len(best_seq) - 1)
            j = random.randint(0, len(best_seq) - 1)
            if i == j:
                trials += 1
                continue
            cand = best_seq.copy()
            t = cand.pop(i)
            if j > i:
                j -= 1
            cand.insert(j, t)
            c = eval_cost(cand)
            if c < best_cost:
                best_cost = c
                best_seq = cand
                trials = 0  # reset upon improvement
            else:
                trials += 1
        return best_seq, best_cost
=======
    def local_search_relocations(seq, curr_cost, tries=RELOC_TRIES):
        """
        Random relocation: remove at index i and reinsert at j if improves.
        Accepts first improving move and continues until no improvement across budgeted tries.
        """
        best_seq = list(seq)
        best_cost = curr_cost

        if len(best_seq) <= 2:
            return best_seq, best_cost

        trials = 0
        while trials < tries:
            i = random.randint(0, len(best_seq) - 1)
            j = random.randint(0, len(best_seq) - 1)
            if i == j:
                trials += 1
                continue
            cand = best_seq.copy()
            t = cand.pop(i)
            if j > i:
                j -= 1
            cand.insert(j, t)
            c = eval_cost(cand)
            if c < best_cost:
                best_cost = c
                best_seq = cand
                trials = 0  # reset upon improvement
            else:
                trials += 1
        return best_seq, best_cost

    def or_opt_block(seq, curr_cost, k):
        """
        Or-opt move with block size k: relocate any contiguous block of length k to its best position.
        Performs best-improving passes until no improvement.
        """
        best_seq = list(seq)
        best_cost = curr_cost
        if len(best_seq) <= k:
            return best_seq, best_cost

        improved = True
        while improved:
            improved = False
            move_best_cost = best_cost
            move = None  # (i, pos)
            L = len(best_seq)
            for i in range(0, L - k + 1):
                block = best_seq[i:i + k]
                base = best_seq[:i] + best_seq[i + k:]
                positions = sample_positions(len(base))
                for pos in positions:
                    cand = base[:]
                    cand[pos:pos] = block
                    c = eval_cost(cand)
                    if c < move_best_cost:
                        move_best_cost = c
                        move = (i, pos)
            if move is not None:
                i, pos = move
                block = best_seq[i:i + k]
                base = best_seq[:i] + best_seq[i + k:]
                new_seq = base[:]
                new_seq[pos:pos] = block
                best_seq = new_seq
                best_cost = move_best_cost
                improved = True
        return best_seq, best_cost

    def vnd_local_search(seq, curr_cost):
        """
        Variable Neighborhood Descent:
        Or-opt blocks k=3,2,1 (best-improving), then adjacent swaps, then light relocations.
        Repeat cycle until no further improvement.
        """
        best_seq = list(seq)
        best_cost = curr_cost
        changed = True
        while changed:
            changed = False
            for k in (3, 2, 1):
                s, c = or_opt_block(best_seq, best_cost, k)
                if c < best_cost:
                    best_seq, best_cost = s, c
                    changed = True
            s, c = local_search_adjacent_swaps(best_seq, best_cost, max_passes=1)
            if c < best_cost:
                best_seq, best_cost = s, c
                changed = True
            s, c = local_search_relocations(best_seq, best_cost, tries=max(8, RELOC_TRIES // 2))
            if c < best_cost:
                best_seq, best_cost = s, c
                changed = True
        return best_seq, best_cost

    def lns_ruin_recreate(seq, curr_cost, rounds=2):
        """
        Ruin-and-recreate LNS: remove a contiguous block (plus a few random extras) and reinsert greedily.
        Accept only improving reconstructions; repeat for a few rounds.
        """
        best_seq = list(seq)
        best_cost = curr_cost
        for _ in range(max(1, rounds)):
            L = len(best_seq)
            if L < 6:
                break
            # Choose block to remove
            base_len = max(4, L // 10)
            block_len = min(L - 2, base_len + random.randint(0, 3))
            start = random.randint(0, L - block_len)
            removed = best_seq[start:start + block_len]
            skeleton = best_seq[:start] + best_seq[start + block_len:]
            # Optionally remove a few extras for diversification
            extra_count = min(3, max(0, L // 30))
            extras_idx = sorted(random.sample(range(len(skeleton)), extra_count)) if extra_count and len(skeleton) > extra_count else []
            extras = []
            offset = 0
            for idx in extras_idx:
                idx_adj = idx - offset
                extras.append(skeleton.pop(idx_adj))
                offset += 1
            to_insert = removed + extras

            # Reinsert removed items using best insertion positions
            rebuilt = list(skeleton)
            for t in to_insert:
                best_c = float('inf')
                best_p = 0
                positions = sample_positions(len(rebuilt))
                for pos in positions:
                    cand = rebuilt[:]
                    cand.insert(pos, t)
                    c = eval_cost(cand)
                    if c < best_c:
                        best_c = c
                        best_p = pos
                rebuilt.insert(best_p, t)

            c_final = eval_cost(rebuilt)
            if c_final < best_cost:
                best_cost = c_final
                best_seq = rebuilt
        return best_seq, best_cost
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Multi-start GRASP with VND refinement
    restarts = max(1, num_seqs)
    global_best_seq = None
    global_best_cost = float('inf')

    for r in range(restarts):
        # Slightly perturb RNG per restart for diversity
        # Do not fix global seed; rely on Python RNG progression plus restart index
        seq, cost = construct_sequence()
        # Local search refinement: adjacent swaps then relocations (VND)
        seq, cost = local_search_adjacent_swaps(seq, cost, MAX_LS_PASSES)
        seq, cost = local_search_relocations(seq, cost, RELOC_TRIES)
        # A final quick adjacent pass can pick up improvements after relocations
        seq, cost = local_search_adjacent_swaps(seq, cost, 1)

        if cost < global_best_cost:
            global_best_cost = cost
            global_best_seq = seq
=======
    # Multi-start GRASP with VND + LNS refinement
    restarts = max(1, num_seqs)
    global_best_seq = None
    global_best_cost = float('inf')

    for r in range(restarts):
        # Diverse construction
        seq, cost = construct_sequence()
        # Strong local search via VND (Or-opt blocks + swaps + relocations)
        seq, cost = vnd_local_search(seq, cost)
        # Ruin-and-recreate to escape local minima, then polish again if improved
        seq_rr, cost_rr = lns_ruin_recreate(seq, cost, rounds=2 if n > 50 else 3)
        if cost_rr < cost:
            seq, cost = vnd_local_search(seq_rr, cost_rr)
        else:
            # quick polish
            seq, cost = local_search_adjacent_swaps(seq, cost, 1)

        if cost < global_best_cost:
            global_best_cost = cost
            global_best_seq = seq
>>>>>>> REPLACE
</DIFF>