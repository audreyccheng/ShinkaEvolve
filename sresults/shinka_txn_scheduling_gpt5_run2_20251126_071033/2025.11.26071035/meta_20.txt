# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Cost-Sampled Transaction Scheduler**
- **Implementation**: Greedy scheduler with a random start; at each step it samples up to 10 remaining transactions without replacement and picks the one minimizing workload.get_opt_seq_cost. The sample_rate is fixed at 1.0 (disabling random fallback), and num_seqs is ignored; costs are recomputed per candidate and a holdout list prevents within-step resampling.
- **Performance**: Achieved a combined score of 2.88 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Fixed full-sampling (1.0) and a single random restart limit exploration, which may cap optimality despite stable performance; redundant recomputation and unused variables indicate minor inefficiencies. Still, the approach reliably produces valid schedules with predictable greedy behavior.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Beam-Search Transaction Scheduler with Local Refinement**
- **Implementation**: Uses a memoized beam search over transaction orderings with beam width derived from num_seqs, sampled expansions (thresholded full expansion), and diversity enforced by unique end elements; followed by adjacent-swap first-improvement hill-climbing. Includes robust repo-root discovery to import the simulator and workloads.
- **Performance**: Achieved combined score 3.36 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization substantially reduces repeated cost evaluations, while sampled expansion and bounded beam width keep runtime controlled without sacrificing much quality; the local swap pass reliably trims makespan further. Randomized sampling can introduce minor run-to-run variance, but diversity heuristics mitigate premature convergence.
**Program Identifier:** Generation 1 - Patch Name beam_and_local_search - Correct Program: True

**Program Name: Cached Beam Search with Local Refinement for Scheduling**
- **Implementation**: Implements beam search guided by partial-prefix costs with memoized caching and randomized candidate sampling, plus multiple seeded restarts. Applies adjacent-swap local refinement and greedy/identity fallbacks, with beam width and expansion limits scaled to problem size.
- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Cost caching and partial-cost guidance reduced evaluations and stabilized search, while restarts and local refinement shaved makespan further. Score indicates room for improvement likely limited by conservative beam width and sampling bounds; increasing num_seqs could trade runtime for better schedules.
**Program Identifier:** Generation 2 - Patch Name beam_cached_greedy_scheduler - Correct Program: True

**Program Name: GRASP-based Transaction Scheduler with Local Search**
- **Implementation**: Uses multi-start GRASP with randomized best-insertion (candidate and insertion-position sampling), seeding with a best-of-two second insert. Refines with multi-pass adjacent swaps and random relocations; parameters adapt to workload size with validity assertions.
- **Performance**: Achieved a combined score of 4.00 on three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Adaptive sampling and local search balanced solution quality and runtime, yielding robust, feasible schedules. Multi-start diversification and seeding improved consistency across runs.
**Program Identifier:** Generation 3 - Patch Name grasp_insertion_localsearch - Correct Program: True

**Program Name: Greedy-ILS Transaction Scheduler**
- **Implementation**: Greedy best-insertion with memoized cost evaluations seeded by singleton-cost ordering; sampled insertion positions include endpoints and use deterministic ordering to aid cache hits. First-improvement local refinement (adjacent swaps and reinsertion) is followed by a light iterated local search using a few random swaps; includes robust repo-root discovery for dependable imports.
- **Performance**: Achieved a combined score of 4.08 across 3 workloads (300 transactions), producing valid schedules for each and passing all validation tests; execution time is recorded per run.
- **Feedback**: Memoization and sampled insertion reduced simulator calls, delivering a good makespan/runtime trade-off, while local refinement consistently improved seed solutions. Limited perturbations likely cap deeper exploration, so most gains stem from construction and local moves rather than heavy global search.
**Program Identifier:** Generation 4 - Patch Name greedy_insertion_ils - Correct Program: True

**Program Name: Beam-Search GRASP Transaction Scheduler**
- **Implementation**: Implements a cached beam search with two-step lookahead (k=5, alpha=0.7), seeded by a randomized best-insertion GRASP and diversified via random survivors and multiple restarts. Applies strong local refinement (reinsertion with sampled positions and adjacent swaps), adapts beam width/candidate expansion to problem size, and includes greedy/identity fallbacks.
- **Performance**: Achieved combined score 3.92, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Prefix-cost caching reduces duplicate evaluations and stabilizes lookahead scoring; the reinsertion+swap passes consistently improve makespan over raw beam outputs. Diversification (GRASP seed, survivors, restarts) enhances exploration and robustness across workloads.
**Program Identifier:** Generation 5 - Patch Name beam_lookahead_and_reinsertion_local_search - Correct Program: True

**Program Name: Greedy-Guided ILS Transaction Scheduler**
- **Implementation**: Uses greedy best-insertion seeded by elite and random starts, with memoized cost evaluations and pairwise two-transaction precedence to guide insertion positions. Applies strong local refinement (adjacent swaps, guided reinsertion, sampled 2-opt) and a light iterated local search with random perturbations.
- **Performance**: Achieved combined score 3.68 across 3 workloads (300 transactions), producing valid schedules and reporting execution time.
- **Feedback**: Pairwise guidance and memoization reduce cost evaluations and improve search efficiency, while multi-seed starts and ILS help escape local minima for lower makespan. Program is correct and passed all validation tests; parameters keep runtime modest without sacrificing quality.
**Program Identifier:** Generation 6 - Patch Name pairwise_guided_insertion_ils - Correct Program: True

**Program Name: Regret-Guided Beam ILS Scheduler**
- **Implementation**: Combines memoized regret-guided insertion beam search (diversified by end element) with deterministic position sampling and sampled candidate transactions to construct schedules. Applies strong local refinement (adjacent swaps, reinsertion, sampled pair swaps, segment reversals) followed by a light iterated local search with structured perturbations; parameters scale with num_seqs.
- **Performance**: Achieved a combined score of 4.17 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and deterministic sampling reduced redundant evaluations and stabilized search, while the regret heuristic plus multi-operator local search consistently lowered makespan. Further gains likely come from tuning beam width and sampling sizes (via num_seqs) to balance runtime and quality per workload.
**Program Identifier:** Generation 7 - Patch Name regret_beam_and_vnd - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: Implements GRASP-style randomized best-insertion with a prefix cost cache and RCL, followed by VND local search (adjacent swaps then relocations), with adaptive candidate/position sampling by workload size and multi-start restarts.
- **Performance**: Achieved a combined score of 3.91 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching prefix evaluations reduced repeated cost calls, enabling broader exploration, while adaptive sampling and RCL improved diversification and VND tightened makespan with reasonable runtime. The score indicates solid performance; more restarts or a higher position sample cap for large n may yield further gains.
**Program Identifier:** Generation 9 - Patch Name grasp_beam_cached_vnd - Correct Program: True

**Program Name: GRASP Transaction Scheduler with Local Search**
- **Implementation**: Implements a multi-start GRASP using randomized best-insertion with a restricted candidate list and adaptive position sampling, supported by a partial-prefix cost cache. Refines sequences via deterministic best reinsertion, adjacent swap hill-climbing, and random relocations, with parameters scaling to workload size and restart count.
- **Performance**: Combined score to maximize: 4.05 across 3 workloads (300 transactions); all validation tests passed.
- **Feedback**: Adaptive RCL plus layered local search balanced exploration and exploitation, improving makespan while caching and position sampling controlled evaluation cost. Robust path discovery ensured portability; tuning position limits and relocation trials can further optimize speed-quality trade-offs on larger workloads.
**Program Identifier:** Generation 10 - Patch Name grasp_cache_reinsert_rcl - Correct Program: True

**Program Name: MCTS+LNS Transaction Scheduler with Progressive Widening**
- **Implementation**: Monte Carlo Tree Search with UCB1 and progressive widening, candidate expansion via sampled remaining transactions ranked by partial cost using a cached prefix-cost function. Rollouts use epsilon-greedy selection over small random subsets, and solutions are refined by local search (adjacent swaps, block relocation, 2-opt) with periodic and final passes; iteration budgets and parameters scale with problem size, and seeding ensures deterministic runs.
- **Performance**: Combined score to maximize: 3.21 on 3 workloads (300 total transactions), passing all validation tests.
- **Feedback**: Progressive widening plus candidate pre-scoring and cost caching efficiently reduce branching and simulator calls, yielding strong incumbents that LNS refines further. Results suggest good convergence and robustness across workloads, though solution quality may depend on sampling caps, epsilon, and local search attempt counts.
**Program Identifier:** Generation 8 - Patch Name mcts_conflict_aware_lns - Correct Program: True

**Program Name: Hybrid Regret-Insertion Transaction Scheduler**
- **Implementation**: Uses regret-based best-insertion with memoized cost evaluations to construct schedules, then refines via adjacent swaps, reinsertion, sampled 2-opt, iterated local search perturbations, large-neighborhood destroy/repair, and elite path relinking. Parameters (sampling sizes, rounds) adapt to num_seqs, and an elite pool with simple diversity (by last element) is maintained.
- **Performance**: Combined score to maximize: 4.13 across 3 workloads (300 transactions); program is correct and passes all validation tests.
- **Feedback**: Memoization and adaptive sampling significantly reduce redundant evaluations, while multi-neighborhood refinement and LNS/relinking balance exploration and exploitation to improve makespan. Elite diversity helps avoid premature convergence; modest gains may be possible by tuning 2-opt sampling or reinsertion breadth.
**Program Identifier:** Generation 11 - Patch Name regret_lns_refiner - Correct Program: True

**Program Name: Conflict-Regret LNS Scheduler**
- **Implementation**: Multi-start lookahead GRASP with RCL and cached cost evaluations, followed by VND (relocate, sampled two-opt, adjacent swaps) and LNS ruin-and-recreate using regret-2 reinsertion; parameters adapt to workload size and insertion positions are sampled to reduce simulation calls. Includes repo-root discovery for imports, global cost cache, and plateau-escaping random swaps.
- **Performance**: Combined score: 0.0 (failed validation due to non-execution).
- **Feedback**: Syntax errors in construct_lookahead and construct_rcl_best_insertion return statements (extra parenthesis) prevent the program from running. Unseeded randomness and brittle path discovery via __file__ can also cause nondeterminism/import failures in tests; fix syntax, add deterministic seeding, and simplify imports to pass validation.
**Program Identifier:** Generation 12 - Patch Name conflict_regret_lns - Correct Program: False

**Program Name: Regret-Beam Transaction Scheduler with Local Search**
- **Implementation**: Uses regret-guided insertion beam search with diversity and high-regret quotas, GRASP seeding, memoized cost evaluation, and adaptive position sampling/endgame widening. Refines solutions via VND with Don't-Look Bits (Or-opt 1–3, swaps, segment reversals), ruin-and-recreate LNS, light path relinking, and brief ILS perturbations.
- **Performance**: Combined score to maximize: 0.0; the program fails validation tests.
- **Feedback**: Despite a sophisticated hybrid metaheuristic, the approach is brittle in testing—likely due to unseeded randomness and environment-dependent path discovery/imports. Make the search deterministic, reduce reliance on filesystem heuristics, and ensure robust fallbacks to pass validation.
**Program Identifier:** Generation 13 - Patch Name regret_beam_vnd_lns - Correct Program: False

**Program Name: Beam-GRASP Transaction Scheduler**
- **Implementation**: Combines a cached beam search with two-step lookahead, suffix-2 diversity, and regret-weighted selection, seeded by a GRASP-style best-insertion constructor. Applies strong local search (Or-opt reinsertion then adjacent swaps), multi-restarts, greedy completion, and adaptive beam/candidate sizing, all using a memoized cost evaluator.
- **Performance**: Achieved a combined score of 4.00 on three 100-transaction workloads, producing valid schedules and passing all validation tests.
- **Feedback**: Cost caching and sampled lookahead kept evaluation overhead low while preserving solution quality; local reinsertion+swap refinement consistently improved the beam output. Diversity constraints and regret-guided filling mitigated premature convergence, yielding robust schedules across workloads.
**Program Identifier:** Generation 14 - Patch Name regret_diverse_beam_and_oropt - Correct Program: True

**Program Name: Hybrid GRASP-Beam-LNS Scheduler**
- **Implementation**: Combines regret-guided GRASP construction with beam search (lookahead and regret diversity), VND local search (Or-opt 1–3 and adjacent swaps with DLB), LNS ruin-and-recreate, and path relinking under adaptive parameters based on problem size. Uses a cached cost evaluator and sampled insertion positions to reduce evaluation overhead.
- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Hybridization and caching provided stable quality under limited search effort, while adaptive sampling and beam diversity maintained effective exploration without excessive runtime. Additional tuning of neighborhood rounds and beam/lns parameters could further reduce makespan.
**Program Identifier:** Generation 15 - Patch Name regret_beam_lns_vnd - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: Implements a GRASP randomized best-insertion constructor with regret-weighted RCL and cached prefix cost evaluations, using adaptive candidate/position sampling by workload size. Refinement applies VND (or-opt k=3/2/1, adjacent swaps, relocations) plus light ruin-and-recreate LNS over multiple restarts.
- **Performance**: Achieved a combined score of 4.26 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and adaptive sampling reduce evaluation overhead while maintaining quality, and VND+LNS effectively escapes local minima to improve makespan. Construction diversity and regret weighting support robust schedules, with no correctness issues observed.
**Program Identifier:** Generation 18 - Patch Name grasp_regret_vnd_lns - Correct Program: True

**Program Name: GRASP Transaction Scheduler with Local Search**
- **Implementation**: Multi-start randomized best-insertion with regret-based RCL, adaptive candidate/position sampling by workload size, and memoized cost evaluations to cut duplicate simulator calls. Refined via layered local search: best-improving reinsertion (Or-opt-1), adjacent swap hill-climbing, random relocations, and a final adjacent-swap polish.
- **Performance**: Combined score 4.10 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Adaptive sampling and caching effectively control evaluation cost while maintaining solution quality; the local search stack consistently improves makespan over initial constructions. Multi-start diversification aids robustness across workloads.
**Program Identifier:** Generation 19 - Patch Name cached_grasp_regret_vnd - Correct Program: True

**Program Name: GRASP-based Transaction Makespan Optimizer**
- **Implementation**: Uses GRASP randomized best-insertion with regret-biased RCL, adaptive candidate/position sampling, and LRU-cached cost evaluation. Refines sequences via Or-opt (blocks 1–3), adjacent swaps, random relocations, and ruin-and-recreate, with multi-start restarts and safety checks.
- **Performance**: Achieved a combined score of 4.02 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Adaptive sampling and memoization reduce evaluation overhead, enabling more aggressive local search. Multi-start and LNS steps improve solution quality and robustness across heterogeneous workloads.
**Program Identifier:** Generation 20 - Patch Name grasp_regret_vnd_lns - Correct Program: True

**Program Name: Regret-Guided Beam and LNS Transaction Scheduler**
- **Implementation**: Uses a regret-guided insertion beam search with memoized cost evaluations and suffix-based diversity, followed by strong local refinement (Or-opt 1–3, adjacent and sampled pair swaps, segment reversals), iterated local search perturbations, and LNS destroy-and-repair with regret-aware reinsertion. Deterministic position sampling (ends/mid plus random) supports caching efficiency; parameters scale with num_seqs.
- **Performance**: Achieved combined score 4.18, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Memoization and deterministic sampling significantly cut repeated evaluations; mixing cost- and regret-driven beam expansions with diversity controls mitigates premature convergence. Layered local search and LNS provide meaningful post-construction improvements while sampling thresholds balance solution quality and runtime.
**Program Identifier:** Generation 22 - Patch Name regret_diverse_beam_lns_oropt - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Hybrid GRASP + cached beam + VND/LNS + path relinking delivered the best score. The Hybrid GRASP-Beam-LNS Scheduler (Generation 15, 4.33) combines regret-guided GRASP construction, beam search with lookahead and regret-driven diversity, VND with Or-opt 1–3 plus adjacent swaps and DLB, LNS ruin-and-recreate, and elite path relinking under adaptive parameters. This layered design, coupled with memoized cost evaluation and sampled insertion positions, outperformed all other implementations.
- Regret-guided insertion with memoized cost evaluation consistently improves construction quality. Programs that incorporate regret into insertion decisions and cache prefix costs—Hybrid Regret-Insertion Transaction Scheduler (Gen 11, 4.13), GRASP-VND Transaction Scheduler (Gen 18, 4.26), Regret-Guided Beam and LNS (Gen 22, 4.18), and the current best (4.33)—score higher than approaches without strong regret pressure or caching.
- Strong, layered local search (VND-like) is a continual differentiator. Using Or-opt (1–3) and adjacent swaps (with DLB in the best program) reliably trims makespan after construction: Hybrid GRASP-Beam-LNS (4.33), GRASP-VND (4.26), and Regret-Guided Beam and LNS (4.18) all leverage multi-operator local refinement and outperform lighter refinement stacks.
- Beam diversity with lookahead stabilizes exploration. Suffix-based diversity and regret-weighted expansion in beam search improve robustness and reduce premature convergence: seen in Beam-GRASP (Gen 14, 4.00), Regret-Guided Beam and LNS (Gen 22, 4.18), and reinforced in the best program (4.33) via suffix-2 diversity plus lookahead scoring.

## Ineffective Approaches
- Brittle implementations that rely on environment-dependent imports and unseeded randomness failed validation. Conflict-Regret LNS Scheduler (Gen 12, 0.0) and Regret-Beam Transaction Scheduler with Local Search (Gen 13, 0.0) both failed due to syntax errors, nondeterminism, and path discovery issues; these prevented execution despite sophisticated algorithmic ideas.
- MCTS with rollouts underperformed relative to regret/beam + strong local search stacks. MCTS+LNS Transaction Scheduler with Progressive Widening (Gen 8, 3.21) uses UCB1, progressive widening, and epsilon-greedy rollouts; even with cost caching, branching and rollout sampling capped solution quality compared to cached regret/beam-based constructors refined by VND/LNS (4.02–4.33).
- Beam-only or shallow beam hybrids lag without richer refinement. Beam-GRASP (Gen 14, 4.00) improved over naive baselines but trails GRASP-VND (4.26) and Hybrid GRASP-Beam-LNS (4.33), indicating that beam breadth/diversity alone is insufficient without stronger local search and LNS/relinking.

## Implementation Insights
- Effective caching and deterministic sampling are central. Top programs memoize prefix costs keyed by tuple(sequence) and use deterministic position sampling (endpoints + bounded interior), as in the current best and Regret-Guided Beam and LNS (4.18). This reduces simulator calls and improves cache hit rates during insertions and local moves.
- The current best program’s orchestration amplifies gains: deterministic seeding per (n, num_seqs), diversified GRASP seeds, cached beam with lookahead and suffix-2 diversity, VND with DLB, regret-guided LNS reinsertion (combining contiguous and scattered removals), and elite path relinking. Each step contributes small, compounding improvements that collectively push the score to 4.33.
- Diversity controls that are cheap and local pay off. Enforcing beam-level suffix uniqueness (last-2) and small elite pools with simple duplicate filtering (current best; Hybrid Regret-Insertion 4.13 uses elite diversity by last element) maintain exploration without exploding evaluation cost.
- Robust engineering supports correctness and stability. Programs that seed RNG deterministically and avoid brittle import heuristics pass validation and retain performance across runs, contrasting with the 0.0-score failures that had syntax errors and path discovery issues.

## Performance Analysis
- Ranking by combined score: Hybrid GRASP-Beam-LNS (Gen 15, 4.33) > GRASP-VND (Gen 18, 4.26) > Regret-Guided Beam and LNS (Gen 22, 4.18) > Hybrid Regret-Insertion (Gen 11, 4.13) > GRASP with Local Search (Gen 19, 4.10) > GRASP-based Optimizer (Gen 20, 4.02) > Beam-GRASP (Gen 14, 4.00) >> MCTS+LNS (Gen 8, 3.21) >> failed validation (Gen 12, Gen 13, 0.0).
- The jump from ~4.00–4.18 (beam/GRASP variants) to 4.26–4.33 correlates with adding stronger VND (Or-opt 1–3 with DLB), regret-driven LNS, and path relinking on top of regret-guided construction and cached beam expansion. The current best (4.33) is a direct example of this layered improvement.
- Memoization appears in every top performer and aligns with higher scores; methods with heavier rollout-based evaluation (MCTS, 3.21) or execution brittleness (0.0) underperform.
- Diversified but deterministic search improves both robustness and scores. Programs combining seed diversity (GRASP/elite pools) with controlled beam diversity (suffix/end-element) and deterministic sampling outperform single-start or non-diversified approaches, consistent with prior best results (~4.17) and strengthened here by the new top score (4.33).

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Make beam lookahead and diversity adaptive to layer regret
   - In beam_search, replace the fixed 0.7/0.3 lookahead mix with a regret-aware blend: if (max(second_costs) - min(second_costs)) > τ (e.g., τ = median regret in the layer), score = 0.5*c1 + 0.5*best_c2; otherwise use 0.8*c1 + 0.2*best_c2. Additionally, when remaining <= 2*beam_width, increase beam_width by +2 and raise diversity_quota from 25% to 40% to avoid myopic endgame convergence. This builds directly on the current lookahead and suffix-2 diversity that have proven effective.

2. Extend VND with sampled 2-opt and non-adjacent pair swaps under DLB
   - After Or-opt (1–3) and adjacent swaps, add two neighborhoods: (a) sampled 2-opt segment reversals over up to S = min(200, n) pairs (i, j) with j - i >= 2; (b) sampled non-adjacent pair swaps over up to S pairs chosen to be at least 2 apart. Use best-improvement with DLB keyed by segment start index (and length bucket) and reset bits only near modified regions. This deepens the local refinement stack that’s been a key differentiator for top performers.

3. Make LNS removals regret/sensitivity-guided, with stagnation escalation
   - Before choosing scattered removals, score K sampled indices (e.g., K = min(20, n)) by “move sensitivity”: for each index i, evaluate the variance of eval_cost after moving that element to P sampled positions (e.g., P = 6); select top-k_high (e.g., 30–50% of k_remove) by highest variance. Keep one contiguous block as in the current code, and fill the rest with these high-sensitivity positions; if two LNS rounds don’t improve, escalate k_remove by +25% and allow two blocks. This leverages regret/sensitivity signals that improved construction to also guide ruin, increasing escape power.

4. Upgrade path relinking to bidirectional, block-aware relinking with elite diversity control
   - For each elite pair, perform both A→B and B→A relinking, moving either a single element or the longest consecutive block that matches target order at each step, and keep the best intermediate at each move. After each move, run a single Or-opt(1) pass for quick polishing, then apply vnd_local_search(max_rounds=1) only to the best few intermediates. Maintain elite diversity by enforcing last-3 suffix uniqueness when adding to elites to promote complementary templates for future relinking.

5. Improve insertion-position sampling and reuse best-two computations across phases
   - Replace purely random interior sampling in sample_positions with stratified picks: always include [0, mid, n, quartiles], plus up to R random interiors (R = pos_sample_cap - fixed points), ensuring deterministic order. Cache best_two_insertions per (tuple(seq), txn) within a construction/LNS episode to reuse when the same prefix recurs during GRASP, beam expansion, and LNS reinsertion; invalidate only when the prefix changes. When len(rem) <= 2*beam_width, evaluate all positions (no sampling) to maximize endgame precision, consistent with observed gains from deterministic sampling and caching.