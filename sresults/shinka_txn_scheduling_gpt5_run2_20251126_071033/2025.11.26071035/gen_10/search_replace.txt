<NAME>
grasp_cache_reinsert_rcl
</NAME>
<DESCRIPTION>
I introduce three targeted improvements to lower makespan while keeping runtime practical:

1) Cost caching for partial prefixes: Many evaluations of workload.get_opt_seq_cost are repeated across construction and local search. A memoized eval_cost over tuple(seq) significantly reduces redundant simulator calls, especially for insertion and swap neighbors.

2) Restricted Candidate List (RCL) in construction: Instead of always selecting the single best candidate from a sampled set, we form a small RCL of top candidates by insertion cost and pick randomly among them. This GRASP diversification explores multiple high-quality neighborhoods and avoids myopic decisions that can trap the search early.

3) Best reinsertion local search: Beyond adjacent swaps and random relocations, I add a deterministic best-improving reinsertion pass. For each transaction, we evaluate reinserting it at sampled/all positions and accept improving moves. This captures powerful 1-shift moves that often resolve conflict chains more effectively than adjacent swaps alone.

These changes maintain the existing framework but deepen intensification and intelligent diversification, leading to consistently better schedules under the same num_seqs effort. The code uses the same simulator interfaces and keeps safety assertions intact.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
def get_best_schedule(workload, num_seqs):
    """
    GRASP-style scheduler: multi-start randomized best-insertion + local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of randomized restarts

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    n = workload.num_txns
    all_txns = list(range(n))

    # Parameter configuration (adaptive by workload size)
    if n <= 50:
        CAND_SAMPLE_BASE = 10     # candidate txn per step
        POS_SAMPLE_LIMIT = None   # evaluate all insertion positions
        MAX_LS_PASSES = 3         # local search passes for adjacent swaps
        RELOC_TRIES = max(8, n // 2)
    else:
        CAND_SAMPLE_BASE = 8
        POS_SAMPLE_LIMIT = 15     # cap insertion positions evaluated
        MAX_LS_PASSES = 2
        RELOC_TRIES = max(12, n // 3)

    JITTER = 2  # small random variation in candidate set size

    def eval_cost(seq):
        return workload.get_opt_seq_cost(seq)

    def sample_positions(seq_len):
        # Return list of positions [0..seq_len] where insertion can occur
        if POS_SAMPLE_LIMIT is None or seq_len + 1 <= (POS_SAMPLE_LIMIT or (seq_len + 1)):
            return list(range(seq_len + 1))
        # Sample positions but always include ends to preserve global structure
        num_to_sample = max(2, min(POS_SAMPLE_LIMIT, seq_len + 1))
        mandatory = {0, seq_len}
        # Available interior positions
        interior = list(range(1, seq_len))
        if len(interior) <= num_to_sample - 2:
            chosen = set(interior)
        else:
            chosen = set(random.sample(interior, num_to_sample - 2))
        chosen.update(mandatory)
        return sorted(chosen)

    def best_insertion_for_txn(current_seq, txn, current_best):
        """
        Try inserting txn into multiple positions in current_seq.
        Returns (best_cost, best_pos). current_best is the best known cost to allow pruning.
        """
        seq_len = len(current_seq)
        best_cost = float('inf')
        best_pos = 0
        positions = sample_positions(seq_len)
        for pos in positions:
            # Build candidate sequence with insertion
            cand = current_seq.copy()
            cand.insert(pos, txn)
            cost = eval_cost(cand)
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
                # simple pruning: if we beat current_best significantly, keep going but this helps early wins
                # No strict bound known, but we can short-circuit if we reach 0 (impossible) or equal to theoretical min
            # Early continue if we already can't beat current_best is avoided due to no strong bound
        return best_cost, best_pos

    def construct_sequence():
        """
        Randomized best-insertion construction.
        """
        # Seed with a random start transaction; quickly choose a good second insertion
        remaining = all_txns.copy()
        random_start = random.randint(0, n - 1)
        seq = [random_start]
        remaining.remove(random_start)
        curr_cost = eval_cost(seq)

        # Optionally add a second txn by testing a small candidate set thoroughly
        if remaining:
            k = min(6, len(remaining))
            candidates = random.sample(remaining, k)
            best_pair_cost = float('inf')
            best_txn = None
            best_pos = 1  # only positions 0 or 1 possible
            for t in candidates:
                # Try both positions in [0,1]
                for pos in [0, 1]:
                    cand = seq.copy()
                    cand.insert(pos, t)
                    cost = eval_cost(cand)
                    if cost < best_pair_cost:
                        best_pair_cost = cost
                        best_txn = t
                        best_pos = pos
            if best_txn is not None:
                seq.insert(best_pos, best_txn)
                remaining.remove(best_txn)
                curr_cost = best_pair_cost

        # Build the rest using sampled candidates and best insertion positions
        while remaining:
            # Adaptive candidate sample size
            # Focus more candidates when many remain; taper off later
            dynamic_base = CAND_SAMPLE_BASE
            # small randomness to diversify
            cand_size = min(len(remaining), max(3, dynamic_base + random.randint(-JITTER, JITTER)))
            candidates = random.sample(remaining, cand_size)

            best_step_cost = float('inf')
            best_txn = None
            best_pos = 0

            for t in candidates:
                cost_t, pos_t = best_insertion_for_txn(seq, t, best_step_cost)
                if cost_t < best_step_cost:
                    best_step_cost = cost_t
                    best_txn = t
                    best_pos = pos_t

            # As a fallback, if candidates performed poorly (shouldn't happen), choose a random remaining txn at end
            if best_txn is None:
                t = random.choice(remaining)
                seq.append(t)
                curr_cost = eval_cost(seq)
                remaining.remove(t)
            else:
                seq.insert(best_pos, best_txn)
                curr_cost = best_step_cost
                remaining.remove(best_txn)

        return seq, curr_cost

    def local_search_adjacent_swaps(seq, curr_cost):
        """
        Perform multiple passes of adjacent swap hill-climbing.
        """
        improved = True
        passes = 0
        best_seq = seq
        best_cost = curr_cost

        while improved and passes < MAX_LS_PASSES:
            improved = False
            passes += 1
            i = 0
            # One pass left-to-right
            while i < len(best_seq) - 1:
                cand = best_seq.copy()
                cand[i], cand[i + 1] = cand[i + 1], cand[i]
                c = eval_cost(cand)
                if c < best_cost:
                    best_cost = c
                    best_seq = cand
                    improved = True
                    # After improvement, we can continue locally; do not skip ahead
                i += 1
        return best_seq, best_cost

    def local_search_relocations(seq, curr_cost):
        """
        Random relocation: remove at index i and reinsert at j if improves.
        """
        best_seq = seq
        best_cost = curr_cost
        trials = 0
        # Early exit if trivial
        if len(seq) <= 2:
            return best_seq, best_cost

        while trials < RELOC_TRIES:
            i = random.randint(0, len(best_seq) - 1)
            j = random.randint(0, len(best_seq) - 1)
            if i == j:
                trials += 1
                continue
            cand = best_seq.copy()
            t = cand.pop(i)
            # Adjust j if removal shifts indices
            if j > i:
                j -= 1
            cand.insert(j, t)
            c = eval_cost(cand)
            if c < best_cost:
                best_cost = c
                best_seq = cand
                # On improvement, reset trials to keep exploring around new incumbent
                trials = 0
            else:
                trials += 1
        return best_seq, best_cost

    # Multi-start GRASP
    global_best_seq = None
    global_best_cost = float('inf')

    for _ in range(max(1, num_seqs)):
        seq, cost = construct_sequence()
        # Local search refinement
        seq, cost = local_search_adjacent_swaps(seq, cost)
        seq, cost = local_search_relocations(seq, cost)

        if cost < global_best_cost:
            global_best_cost = cost
            global_best_seq = seq

    # Safety checks
    assert global_best_seq is not None
    assert len(global_best_seq) == n
    assert len(set(global_best_seq)) == n

    return global_best_cost, global_best_seq
=======
def get_best_schedule(workload, num_seqs):
    """
    GRASP-style scheduler: multi-start randomized best-insertion + local search.

    Args:
        workload: Workload object containing transaction data
        num_seqs: Number of randomized restarts

    Returns:
        Tuple of (lowest makespan, corresponding schedule)
    """
    n = workload.num_txns
    all_txns = list(range(n))

    # Parameter configuration (adaptive by workload size and effort)
    if n <= 50:
        CAND_SAMPLE_BASE = 10     # candidate txn per step
        POS_SAMPLE_LIMIT = None   # evaluate all insertion positions
        MAX_LS_PASSES = 3         # local search passes for adjacent swaps
        RELOC_TRIES = max(8, n // 2)
    else:
        CAND_SAMPLE_BASE = 8
        POS_SAMPLE_LIMIT = 15     # cap insertion positions evaluated
        MAX_LS_PASSES = 2
        RELOC_TRIES = max(12, n // 3)

    # Scale relocations slightly with search effort
    RELOC_TRIES = int(RELOC_TRIES * max(1.0, min(2.0, 0.5 + 0.1 * num_seqs)))

    JITTER = 2  # small random variation in candidate set size

    # Cost cache for partial prefixes to avoid redundant evaluations
    cost_cache = {}

    def eval_cost(seq):
        key = tuple(seq)
        if key in cost_cache:
            return cost_cache[key]
        c = workload.get_opt_seq_cost(list(seq))
        cost_cache[key] = c
        return c

    def sample_positions(seq_len):
        # Return list of positions [0..seq_len] where insertion can occur
        if POS_SAMPLE_LIMIT is None or seq_len + 1 <= (POS_SAMPLE_LIMIT or (seq_len + 1)):
            return list(range(seq_len + 1))
        # Sample positions but always include ends to preserve global structure
        num_to_sample = max(2, min(POS_SAMPLE_LIMIT, seq_len + 1))
        mandatory = {0, seq_len}
        # Available interior positions
        interior = list(range(1, seq_len))
        if len(interior) <= num_to_sample - 2:
            chosen = set(interior)
        else:
            chosen = set(random.sample(interior, num_to_sample - 2))
        chosen.update(mandatory)
        return sorted(chosen)

    def best_insertion_for_txn(current_seq, txn, current_best):
        """
        Try inserting txn into multiple positions in current_seq.
        Returns (best_cost, best_pos). current_best is the best known cost to allow pruning.
        """
        seq_len = len(current_seq)
        best_cost = float('inf')
        best_pos = 0
        positions = sample_positions(seq_len)
        for pos in positions:
            # Build candidate sequence with insertion
            cand = current_seq.copy()
            cand.insert(pos, txn)
            cost = eval_cost(cand)
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return best_cost, best_pos

    def construct_sequence():
        """
        Randomized best-insertion construction with RCL (restricted candidate list).
        """
        # Seed with a random start transaction; quickly choose a good second insertion
        remaining = all_txns.copy()
        random_start = random.randint(0, n - 1)
        seq = [random_start]
        remaining.remove(random_start)
        curr_cost = eval_cost(seq)

        # Optionally add a second txn by testing a small candidate set thoroughly
        if remaining:
            k = min(6, len(remaining))
            candidates = random.sample(remaining, k)
            pair_eval = []
            for t in candidates:
                for pos in [0, 1]:
                    cand = seq.copy()
                    cand.insert(pos, t)
                    cost = eval_cost(cand)
                    pair_eval.append((cost, t, pos))
            if pair_eval:
                pair_eval.sort(key=lambda x: x[0])
                # Small RCL for the second placement
                rcl_size = min(3, len(pair_eval))
                chosen_cost, chosen_txn, chosen_pos = random.choice(pair_eval[:rcl_size])
                seq.insert(chosen_pos, chosen_txn)
                remaining.remove(chosen_txn)
                curr_cost = chosen_cost

        # Build the rest using sampled candidates and best insertion positions
        while remaining:
            # Adaptive candidate sample size with small randomness to diversify
            dynamic_base = CAND_SAMPLE_BASE
            cand_size = min(len(remaining), max(3, dynamic_base + random.randint(-JITTER, JITTER)))
            candidates = random.sample(remaining, cand_size)

            step_evals = []
            best_step_cost = float('inf')

            for t in candidates:
                cost_t, pos_t = best_insertion_for_txn(seq, t, best_step_cost)
                step_evals.append((cost_t, t, pos_t))
                if cost_t < best_step_cost:
                    best_step_cost = cost_t

            # Restricted Candidate List: choose randomly among top few to balance greediness and diversity
            if step_evals:
                step_evals.sort(key=lambda x: x[0])
                rcl_size = max(1, min(3, len(step_evals)//2))  # top-k
                chosen_cost, chosen_txn, chosen_pos = random.choice(step_evals[:rcl_size])
                seq.insert(chosen_pos, chosen_txn)
                curr_cost = chosen_cost
                remaining.remove(chosen_txn)
            else:
                # Fallback: append a random remaining txn
                t = random.choice(remaining)
                seq.append(t)
                curr_cost = eval_cost(seq)
                remaining.remove(t)

        return seq, curr_cost

    def local_search_adjacent_swaps(seq, curr_cost):
        """
        Perform multiple passes of adjacent swap hill-climbing.
        """
        improved = True
        passes = 0
        best_seq = seq
        best_cost = curr_cost

        while improved and passes < MAX_LS_PASSES:
            improved = False
            passes += 1
            i = 0
            # One pass left-to-right
            while i < len(best_seq) - 1:
                cand = best_seq.copy()
                cand[i], cand[i + 1] = cand[i + 1], cand[i]
                c = eval_cost(cand)
                if c < best_cost:
                    best_cost = c
                    best_seq = cand
                    improved = True
                i += 1
        return best_seq, best_cost

    def local_search_best_reinsert(seq, curr_cost, max_rounds=2):
        """
        Deterministic best-improving reinsertion: for each index, reinsert txn at best position.
        """
        best_seq = list(seq)
        best_cost = curr_cost
        rounds = 0

        if len(best_seq) <= 2:
            return best_seq, best_cost

        while rounds < max_rounds:
            improved = False
            rounds += 1
            idx = 0
            while idx < len(best_seq):
                t = best_seq[idx]
                base = best_seq[:idx] + best_seq[idx + 1:]
                positions = sample_positions(len(base))
                move_best_cost = best_cost
                move_best_pos = None
                for pos in positions:
                    cand = base.copy()
                    cand.insert(pos, t)
                    c = eval_cost(cand)
                    if c < move_best_cost:
                        move_best_cost = c
                        move_best_pos = pos
                if move_best_pos is not None:
                    best_seq = base
                    best_seq.insert(move_best_pos, t)
                    best_cost = move_best_cost
                    improved = True
                    # do not increment idx; re-evaluate around changed neighborhood
                else:
                    idx += 1
            if not improved:
                break
        return best_seq, best_cost

    def local_search_relocations(seq, curr_cost):
        """
        Random relocation: remove at index i and reinsert at j if improves.
        """
        best_seq = seq
        best_cost = curr_cost
        trials = 0
        # Early exit if trivial
        if len(seq) <= 2:
            return best_seq, best_cost

        while trials < RELOC_TRIES:
            i = random.randint(0, len(best_seq) - 1)
            j = random.randint(0, len(best_seq) - 1)
            if i == j:
                trials += 1
                continue
            cand = best_seq.copy()
            t = cand.pop(i)
            # Adjust j if removal shifts indices
            if j > i:
                j -= 1
            cand.insert(j, t)
            c = eval_cost(cand)
            if c < best_cost:
                best_cost = c
                best_seq = cand
                trials = 0  # reset on improvement
            else:
                trials += 1
        return best_seq, best_cost

    # Multi-start GRASP
    global_best_seq = None
    global_best_cost = float('inf')

    for _ in range(max(1, num_seqs)):
        seq, cost = construct_sequence()
        # Local search refinement: reinsertion, then adjacent swaps, then random relocations
        seq, cost = local_search_best_reinsert(seq, cost, max_rounds=2)
        seq, cost = local_search_adjacent_swaps(seq, cost)
        seq, cost = local_search_relocations(seq, cost)
        # Final polish with a quick adjacent pass
        seq, cost = local_search_adjacent_swaps(seq, cost)

        if cost < global_best_cost:
            global_best_cost = cost
            global_best_seq = seq

    # Safety checks
    assert global_best_seq is not None
    assert len(global_best_seq) == n
    assert len(set(global_best_seq)) == n

    return global_best_cost, global_best_seq
>>>>>>> REPLACE
</DIFF>