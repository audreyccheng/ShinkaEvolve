# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy Cost-Sampled Transaction Scheduler**
- **Implementation**: Greedy scheduler with a random start; at each step it samples up to 10 remaining transactions without replacement and picks the one minimizing workload.get_opt_seq_cost. The sample_rate is fixed at 1.0 (disabling random fallback), and num_seqs is ignored; costs are recomputed per candidate and a holdout list prevents within-step resampling.
- **Performance**: Achieved a combined score of 2.88 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Fixed full-sampling (1.0) and a single random restart limit exploration, which may cap optimality despite stable performance; redundant recomputation and unused variables indicate minor inefficiencies. Still, the approach reliably produces valid schedules with predictable greedy behavior.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Beam-Search Transaction Scheduler with Local Refinement**
- **Implementation**: Uses a memoized beam search over transaction orderings with beam width derived from num_seqs, sampled expansions (thresholded full expansion), and diversity enforced by unique end elements; followed by adjacent-swap first-improvement hill-climbing. Includes robust repo-root discovery to import the simulator and workloads.
- **Performance**: Achieved combined score 3.36 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization substantially reduces repeated cost evaluations, while sampled expansion and bounded beam width keep runtime controlled without sacrificing much quality; the local swap pass reliably trims makespan further. Randomized sampling can introduce minor run-to-run variance, but diversity heuristics mitigate premature convergence.
**Program Identifier:** Generation 1 - Patch Name beam_and_local_search - Correct Program: True

**Program Name: Cached Beam Search with Local Refinement for Scheduling**
- **Implementation**: Implements beam search guided by partial-prefix costs with memoized caching and randomized candidate sampling, plus multiple seeded restarts. Applies adjacent-swap local refinement and greedy/identity fallbacks, with beam width and expansion limits scaled to problem size.
- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Cost caching and partial-cost guidance reduced evaluations and stabilized search, while restarts and local refinement shaved makespan further. Score indicates room for improvement likely limited by conservative beam width and sampling bounds; increasing num_seqs could trade runtime for better schedules.
**Program Identifier:** Generation 2 - Patch Name beam_cached_greedy_scheduler - Correct Program: True

**Program Name: GRASP-based Transaction Scheduler with Local Search**
- **Implementation**: Uses multi-start GRASP with randomized best-insertion (candidate and insertion-position sampling), seeding with a best-of-two second insert. Refines with multi-pass adjacent swaps and random relocations; parameters adapt to workload size with validity assertions.
- **Performance**: Achieved a combined score of 4.00 on three workloads (300 transactions) and passed all validation tests.
- **Feedback**: Adaptive sampling and local search balanced solution quality and runtime, yielding robust, feasible schedules. Multi-start diversification and seeding improved consistency across runs.
**Program Identifier:** Generation 3 - Patch Name grasp_insertion_localsearch - Correct Program: True

**Program Name: Greedy-ILS Transaction Scheduler**
- **Implementation**: Greedy best-insertion with memoized cost evaluations seeded by singleton-cost ordering; sampled insertion positions include endpoints and use deterministic ordering to aid cache hits. First-improvement local refinement (adjacent swaps and reinsertion) is followed by a light iterated local search using a few random swaps; includes robust repo-root discovery for dependable imports.
- **Performance**: Achieved a combined score of 4.08 across 3 workloads (300 transactions), producing valid schedules for each and passing all validation tests; execution time is recorded per run.
- **Feedback**: Memoization and sampled insertion reduced simulator calls, delivering a good makespan/runtime trade-off, while local refinement consistently improved seed solutions. Limited perturbations likely cap deeper exploration, so most gains stem from construction and local moves rather than heavy global search.
**Program Identifier:** Generation 4 - Patch Name greedy_insertion_ils - Correct Program: True

**Program Name: Beam-Search GRASP Transaction Scheduler**
- **Implementation**: Implements a cached beam search with two-step lookahead (k=5, alpha=0.7), seeded by a randomized best-insertion GRASP and diversified via random survivors and multiple restarts. Applies strong local refinement (reinsertion with sampled positions and adjacent swaps), adapts beam width/candidate expansion to problem size, and includes greedy/identity fallbacks.
- **Performance**: Achieved combined score 3.92, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Prefix-cost caching reduces duplicate evaluations and stabilizes lookahead scoring; the reinsertion+swap passes consistently improve makespan over raw beam outputs. Diversification (GRASP seed, survivors, restarts) enhances exploration and robustness across workloads.
**Program Identifier:** Generation 5 - Patch Name beam_lookahead_and_reinsertion_local_search - Correct Program: True

**Program Name: Greedy-Guided ILS Transaction Scheduler**
- **Implementation**: Uses greedy best-insertion seeded by elite and random starts, with memoized cost evaluations and pairwise two-transaction precedence to guide insertion positions. Applies strong local refinement (adjacent swaps, guided reinsertion, sampled 2-opt) and a light iterated local search with random perturbations.
- **Performance**: Achieved combined score 3.68 across 3 workloads (300 transactions), producing valid schedules and reporting execution time.
- **Feedback**: Pairwise guidance and memoization reduce cost evaluations and improve search efficiency, while multi-seed starts and ILS help escape local minima for lower makespan. Program is correct and passed all validation tests; parameters keep runtime modest without sacrificing quality.
**Program Identifier:** Generation 6 - Patch Name pairwise_guided_insertion_ils - Correct Program: True

**Program Name: Regret-Guided Beam ILS Scheduler**
- **Implementation**: Combines memoized regret-guided insertion beam search (diversified by end element) with deterministic position sampling and sampled candidate transactions to construct schedules. Applies strong local refinement (adjacent swaps, reinsertion, sampled pair swaps, segment reversals) followed by a light iterated local search with structured perturbations; parameters scale with num_seqs.
- **Performance**: Achieved a combined score of 4.17 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and deterministic sampling reduced redundant evaluations and stabilized search, while the regret heuristic plus multi-operator local search consistently lowered makespan. Further gains likely come from tuning beam width and sampling sizes (via num_seqs) to balance runtime and quality per workload.
**Program Identifier:** Generation 7 - Patch Name regret_beam_and_vnd - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: Implements GRASP-style randomized best-insertion with a prefix cost cache and RCL, followed by VND local search (adjacent swaps then relocations), with adaptive candidate/position sampling by workload size and multi-start restarts.
- **Performance**: Achieved a combined score of 3.91 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching prefix evaluations reduced repeated cost calls, enabling broader exploration, while adaptive sampling and RCL improved diversification and VND tightened makespan with reasonable runtime. The score indicates solid performance; more restarts or a higher position sample cap for large n may yield further gains.
**Program Identifier:** Generation 9 - Patch Name grasp_beam_cached_vnd - Correct Program: True

**Program Name: GRASP Transaction Scheduler with Local Search**
- **Implementation**: Implements a multi-start GRASP using randomized best-insertion with a restricted candidate list and adaptive position sampling, supported by a partial-prefix cost cache. Refines sequences via deterministic best reinsertion, adjacent swap hill-climbing, and random relocations, with parameters scaling to workload size and restart count.
- **Performance**: Combined score to maximize: 4.05 across 3 workloads (300 transactions); all validation tests passed.
- **Feedback**: Adaptive RCL plus layered local search balanced exploration and exploitation, improving makespan while caching and position sampling controlled evaluation cost. Robust path discovery ensured portability; tuning position limits and relocation trials can further optimize speed-quality trade-offs on larger workloads.
**Program Identifier:** Generation 10 - Patch Name grasp_cache_reinsert_rcl - Correct Program: True

**Program Name: MCTS+LNS Transaction Scheduler with Progressive Widening**
- **Implementation**: Monte Carlo Tree Search with UCB1 and progressive widening, candidate expansion via sampled remaining transactions ranked by partial cost using a cached prefix-cost function. Rollouts use epsilon-greedy selection over small random subsets, and solutions are refined by local search (adjacent swaps, block relocation, 2-opt) with periodic and final passes; iteration budgets and parameters scale with problem size, and seeding ensures deterministic runs.
- **Performance**: Combined score to maximize: 3.21 on 3 workloads (300 total transactions), passing all validation tests.
- **Feedback**: Progressive widening plus candidate pre-scoring and cost caching efficiently reduce branching and simulator calls, yielding strong incumbents that LNS refines further. Results suggest good convergence and robustness across workloads, though solution quality may depend on sampling caps, epsilon, and local search attempt counts.
**Program Identifier:** Generation 8 - Patch Name mcts_conflict_aware_lns - Correct Program: True

**Program Name: Hybrid Regret-Insertion Transaction Scheduler**
- **Implementation**: Uses regret-based best-insertion with memoized cost evaluations to construct schedules, then refines via adjacent swaps, reinsertion, sampled 2-opt, iterated local search perturbations, large-neighborhood destroy/repair, and elite path relinking. Parameters (sampling sizes, rounds) adapt to num_seqs, and an elite pool with simple diversity (by last element) is maintained.
- **Performance**: Combined score to maximize: 4.13 across 3 workloads (300 transactions); program is correct and passes all validation tests.
- **Feedback**: Memoization and adaptive sampling significantly reduce redundant evaluations, while multi-neighborhood refinement and LNS/relinking balance exploration and exploitation to improve makespan. Elite diversity helps avoid premature convergence; modest gains may be possible by tuning 2-opt sampling or reinsertion breadth.
**Program Identifier:** Generation 11 - Patch Name regret_lns_refiner - Correct Program: True

**Program Name: Conflict-Regret LNS Scheduler**
- **Implementation**: Multi-start lookahead GRASP with RCL and cached cost evaluations, followed by VND (relocate, sampled two-opt, adjacent swaps) and LNS ruin-and-recreate using regret-2 reinsertion; parameters adapt to workload size and insertion positions are sampled to reduce simulation calls. Includes repo-root discovery for imports, global cost cache, and plateau-escaping random swaps.
- **Performance**: Combined score: 0.0 (failed validation due to non-execution).
- **Feedback**: Syntax errors in construct_lookahead and construct_rcl_best_insertion return statements (extra parenthesis) prevent the program from running. Unseeded randomness and brittle path discovery via __file__ can also cause nondeterminism/import failures in tests; fix syntax, add deterministic seeding, and simplify imports to pass validation.
**Program Identifier:** Generation 12 - Patch Name conflict_regret_lns - Correct Program: False

**Program Name: Regret-Beam Transaction Scheduler with Local Search**
- **Implementation**: Uses regret-guided insertion beam search with diversity and high-regret quotas, GRASP seeding, memoized cost evaluation, and adaptive position sampling/endgame widening. Refines solutions via VND with Don't-Look Bits (Or-opt 1–3, swaps, segment reversals), ruin-and-recreate LNS, light path relinking, and brief ILS perturbations.
- **Performance**: Combined score to maximize: 0.0; the program fails validation tests.
- **Feedback**: Despite a sophisticated hybrid metaheuristic, the approach is brittle in testing—likely due to unseeded randomness and environment-dependent path discovery/imports. Make the search deterministic, reduce reliance on filesystem heuristics, and ensure robust fallbacks to pass validation.
**Program Identifier:** Generation 13 - Patch Name regret_beam_vnd_lns - Correct Program: False

**Program Name: Beam-GRASP Transaction Scheduler**
- **Implementation**: Combines a cached beam search with two-step lookahead, suffix-2 diversity, and regret-weighted selection, seeded by a GRASP-style best-insertion constructor. Applies strong local search (Or-opt reinsertion then adjacent swaps), multi-restarts, greedy completion, and adaptive beam/candidate sizing, all using a memoized cost evaluator.
- **Performance**: Achieved a combined score of 4.00 on three 100-transaction workloads, producing valid schedules and passing all validation tests.
- **Feedback**: Cost caching and sampled lookahead kept evaluation overhead low while preserving solution quality; local reinsertion+swap refinement consistently improved the beam output. Diversity constraints and regret-guided filling mitigated premature convergence, yielding robust schedules across workloads.
**Program Identifier:** Generation 14 - Patch Name regret_diverse_beam_and_oropt - Correct Program: True

**Program Name: Hybrid GRASP-Beam-LNS Scheduler**
- **Implementation**: Combines regret-guided GRASP construction with beam search (lookahead and regret diversity), VND local search (Or-opt 1–3 and adjacent swaps with DLB), LNS ruin-and-recreate, and path relinking under adaptive parameters based on problem size. Uses a cached cost evaluator and sampled insertion positions to reduce evaluation overhead.
- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Hybridization and caching provided stable quality under limited search effort, while adaptive sampling and beam diversity maintained effective exploration without excessive runtime. Additional tuning of neighborhood rounds and beam/lns parameters could further reduce makespan.
**Program Identifier:** Generation 15 - Patch Name regret_beam_lns_vnd - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: Implements a GRASP randomized best-insertion constructor with regret-weighted RCL and cached prefix cost evaluations, using adaptive candidate/position sampling by workload size. Refinement applies VND (or-opt k=3/2/1, adjacent swaps, relocations) plus light ruin-and-recreate LNS over multiple restarts.
- **Performance**: Achieved a combined score of 4.26 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and adaptive sampling reduce evaluation overhead while maintaining quality, and VND+LNS effectively escapes local minima to improve makespan. Construction diversity and regret weighting support robust schedules, with no correctness issues observed.
**Program Identifier:** Generation 18 - Patch Name grasp_regret_vnd_lns - Correct Program: True

**Program Name: GRASP Transaction Scheduler with Local Search**
- **Implementation**: Multi-start randomized best-insertion with regret-based RCL, adaptive candidate/position sampling by workload size, and memoized cost evaluations to cut duplicate simulator calls. Refined via layered local search: best-improving reinsertion (Or-opt-1), adjacent swap hill-climbing, random relocations, and a final adjacent-swap polish.
- **Performance**: Combined score 4.10 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Adaptive sampling and caching effectively control evaluation cost while maintaining solution quality; the local search stack consistently improves makespan over initial constructions. Multi-start diversification aids robustness across workloads.
**Program Identifier:** Generation 19 - Patch Name cached_grasp_regret_vnd - Correct Program: True

**Program Name: GRASP-based Transaction Makespan Optimizer**
- **Implementation**: Uses GRASP randomized best-insertion with regret-biased RCL, adaptive candidate/position sampling, and LRU-cached cost evaluation. Refines sequences via Or-opt (blocks 1–3), adjacent swaps, random relocations, and ruin-and-recreate, with multi-start restarts and safety checks.
- **Performance**: Achieved a combined score of 4.02 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Adaptive sampling and memoization reduce evaluation overhead, enabling more aggressive local search. Multi-start and LNS steps improve solution quality and robustness across heterogeneous workloads.
**Program Identifier:** Generation 20 - Patch Name grasp_regret_vnd_lns - Correct Program: True

**Program Name: Regret-Guided Beam and LNS Transaction Scheduler**
- **Implementation**: Uses a regret-guided insertion beam search with memoized cost evaluations and suffix-based diversity, followed by strong local refinement (Or-opt 1–3, adjacent and sampled pair swaps, segment reversals), iterated local search perturbations, and LNS destroy-and-repair with regret-aware reinsertion. Deterministic position sampling (ends/mid plus random) supports caching efficiency; parameters scale with num_seqs.
- **Performance**: Achieved combined score 4.18, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.
- **Feedback**: Memoization and deterministic sampling significantly cut repeated evaluations; mixing cost- and regret-driven beam expansions with diversity controls mitigates premature convergence. Layered local search and LNS provide meaningful post-construction improvements while sampling thresholds balance solution quality and runtime.
**Program Identifier:** Generation 22 - Patch Name regret_diverse_beam_lns_oropt - Correct Program: True

**Program Name: Hybrid LNS-ILS Regret Scheduler**
- **Implementation**: Uses regret-based best-insertion with memoized cost evaluation in an adaptive, diversity-aware beam; followed by local refinement (Or-opt 3/2/1, adjacent swaps, sampled 2-opt), iterated local search (swap/block perturbations), large-neighborhood destroy/repair with regret insertion, and elite path relinking.
- **Performance**: Achieved combined score 4.29 across three workloads (300 transactions total), producing valid schedules and passing all validation tests.
- **Feedback**: Memoization and targeted position sampling reduce evaluation overhead, enabling deeper search; adaptive beam/sampling and elite diversity bolster robustness across workloads. Stochastic exploration (regret mixing, perturbations, LNS) can introduce variance but delivered good makespan and correctness in evaluation.
**Program Identifier:** Generation 16 - Patch Name beam_vnd_ooropt_diversity - Correct Program: True

**Program Name: Regret-diversified beam + VND for txn scheduling**
- **Implementation**: Builds schedules via a regret-diversified insertion beam search with memoized cost evaluation, suffix-diversity control, and a regret quota; refines with VND (adjacent swaps, Or-opt 1–3, sampled pair swaps, segment reversals), then light ILS and a small ruin-and-recreate LNS with regret-based repair. Includes adaptive sampling of transactions/positions and seed selection from elite singleton evaluations plus random seeds.
- **Performance**: Achieved combined score 4.31 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Memoization and diversified beam expansion reduced duplicate evaluations and produced strong starting sequences that local search consistently improved. Layered VND/ILS/LNS yielded robust makespan reductions across workloads with a good quality/runtime balance.
**Program Identifier:** Generation 17 - Patch Name beam_lns_vnd_upgrade - Correct Program: True

**Program Name: Memoized Regret-Insertion Metaheuristic for Transaction Scheduling**
- **Implementation**: Hybrid pipeline combining regret-guided best-insertion with small-beam diversity and memoized cost evaluations, followed by VND local search (adjacent swaps, Or-opt 1–3, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite path relinking; parameters adapt to num_seqs with endgame exhaustive position checks. Seeding uses top singleton costs plus random seeds, and an elite pool is maintained with suffix-based diversity control.
- **Performance**: Combined score to maximize: 4.37 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Memoization and adaptive sampling reduce expensive evaluations, while the multi-neighborhood refinement and LNS/relinking steps improve makespan beyond construction quality. Some outcome variability stems from randomness (no fixed seed); tuning regret_prob and sampling thresholds may further stabilize and enhance results.
**Program Identifier:** Generation 21 - Patch Name beam_regret_vnd_oropt - Correct Program: True

**Program Name: Hybrid Beam-GRASP VND/ILS Transaction Scheduler**
- **Implementation**: Combines a regret-guided GRASP seed and a two-step lookahead beam search with suffix-2 diversity, then refines via VND (Or-opt with DLB, adjacent/pair swaps, segment reversals) and LNS ruin-and-recreate within an ILS multi-start/elite framework. Uses LRU-cached partial-sequence costs and adaptive sampling/beam widths tuned to workload size.
- **Performance**: Achieved combined score 4.07 on 3 workloads (300 transactions) with valid schedules; all validation tests passed.
- **Feedback**: Hybrid seeding plus regret-diverse beam produced strong initial solutions, while VND and LNS/ILS reliably improved makespan. Caching and adaptive exploration balanced solution quality and runtime, aiding robustness across heterogeneous workloads.
**Program Identifier:** Generation 23 - Patch Name vnd_beam_lns_ils - Correct Program: True

**Program Name: GRASP-VND Transaction Scheduler**
- **Implementation**: GRASP-style randomized best-insertion with regret-based RCL and memoized cost evaluation, followed by VND local search (Or-opt-3/2 blocks, best reinsertion, adjacent swaps, random relocations), plus ruin-and-recreate LNS and path relinking over a small elite pool. Adaptive candidate/position sampling and workload-size–aware parameters aim to balance exploration and speed across three workloads.
- **Performance**: Combined score: 0.0 (failed validation tests).
- **Feedback**: Execution likely fails due to a signature mismatch: vnd_local_search calls local_search_adjacent_swaps with max_passes, but the function does not accept this parameter (TypeError). Import path discovery is brittle and may raise at runtime; unseeded randomness also reduces reproducibility and can hurt test stability.
**Program Identifier:** Generation 24 - Patch Name vnd_lns_path_relink - Correct Program: False

**Program Name: Beam-GRASP Transaction Scheduler with Local Search**
- **Implementation**: Combines a cached beam search with adaptive two-step lookahead (alpha tuned by second-step cost span), suffix-2 diversity, and regret-boosted selection, seeded by a GRASP-style randomized best-insertion. Strong local refinements (Or-opt reinsertion, adjacent swaps, sampled pair swaps, segment reversals) run after multiple randomized restarts; parameters scale with problem size and effort hint.
- **Performance**: Achieved combined score 4.02 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Prefix cost caching and adaptive lookahead improved pruning accuracy, while diversity and regret preserved exploration; sampling kept expansions tractable. The aggressive refinement chain reliably improved beam outputs, and size-aware parameterization maintained practical runtimes.
**Program Identifier:** Generation 28 - Patch Name adaptive_beam_vnd_plus - Correct Program: True

**Program Name: Hybrid GRASP-Beam-VND-LNS Transaction Scheduler**
- **Implementation**: Hybrid metaheuristic combining GRASP (regret-based best-insertion with cached partial-cost evaluations), beam search with two-step lookahead and suffix/diversity control, VND (or-opt k=3/2/1, adjacent swaps, relocations), LNS ruin-and-recreate, and elite pool with path relinking and adaptive parameters by problem size/effort.
- **Performance**: Achieved a combined score of 4.20 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Caching and adaptive sampling lowered evaluation overhead while beam diversity, VND, and LNS helped avoid local minima, yielding consistently valid high-quality schedules. No correctness issues observed; the approach appears robust across workloads.
**Program Identifier:** Generation 29 - Patch Name hybrid_beam_grasp_lns_vnd - Correct Program: True

**Program Name: Regret-Guided Hybrid Transaction Scheduler**
- **Implementation**: Combines regret-guided GRASP construction, diversity-aware beam search with shallow lookahead, VND (Or-opt/adjacent + sampled pair swaps), LNS ruin-and-recreate, and an elite pool with path relinking/ILS. Uses lru-cached cost evaluation, sampled insertion positions, and suffix/prefix deduplication to control branching and speed evaluation.
- **Performance**: Combined score to maximize: 4.18 on three workloads (300 transactions); program is correct and passes all validation tests.
- **Feedback**: Caching and sampling reduced evaluation overhead, while regret/diversity mechanisms improved solution quality and avoided premature convergence. Adaptive sizing and iterative LNS+VND polishing yielded robust makespans; tuning beam width and LNS removal rates may further improve results on larger instances.
**Program Identifier:** Generation 31 - Patch Name grasp_beam_lns_vnd_hybrid - Correct Program: True

**Program Name: Conflict-aware divide-merge DP scheduler**
- **Implementation**: Builds a conflict graph via cached pairwise cost probes (full or sampled), clusters high-degree transactions, orders each cluster with a small beam+lookahead, then DP-interleaves clusters and lightly polishes with Or-opt and adjacent swaps. Uses an LRU-cached evaluator and deterministic seeding to constrain evaluation budget.
- **Performance**: Achieved combined score 3.39 on 3 workloads (300 txns) and passed all validation tests.
- **Feedback**: Conflict-aware clustering plus exact DP interleaving produced strong makespans while caching and sampling kept runtime practical; light polishing yielded incremental gains. The computed directional preference is currently unused and could further guide ordering/merge decisions.
**Program Identifier:** Generation 33 - Patch Name conflict_aware_divide_and_merge - Correct Program: True

**Program Name: Hybrid GRASP–Beam–VND–LNS Scheduler**
- **Implementation**: Hybrid metaheuristic combining GRASP construction (regret-guided insertions), regret-diverse beam search with two-step lookahead, VND (Or-opt with DLB and adjacent swaps), LNS ruin-and-recreate, and path relinking with an elite pool. Uses lru_cache for cached prefix evaluations, adaptive parameters by problem size, multi-start restarts, and custom repo-root discovery with sys.path injection.
- **Performance**: Achieved a combined score of 0.0; failed validation and produced incorrect results.
- **Feedback**: Environment-dependent path discovery and external imports likely broke portability and validation, causing runtime failures. Randomized sampling plus aggressive caching can induce nondeterminism or time/memory issues; make the module self-contained, stabilize seeding per test, and harden schedule validity checks.
**Program Identifier:** Generation 35 - Patch Name grasp_beam_vnd_lns_elite - Correct Program: False

**Program Name: Hybrid GRASP-Beam Scheduler with VND/LNS Relinking**
- **Implementation**: Uses a regret-diverse GRASP constructor (best-two insertions with mixed cost/regret RCL), adaptive beam search with lookahead and regret-dispersion blending plus suffix diversity, followed by VND (Or-opt 1..3, adjacent swaps, sampled 2-opt/pair-swaps with DLB), sensitivity-guided LNS ruin-and-recreate, and bidirectional path relinking over a suffix-diverse elite pool. An lru_cache-backed cost evaluator and stratified position sampling with size-adaptive parameters reduce evaluations and maintain diversification.
- **Performance**: Achieved a combined score of 4.18 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Diversity controls (regret/suffix) and relinking+LNS improved exploration and final makespan, while caching/sampling kept runtime reasonable. Further gains likely from tuning beam width/lookahead and LNS removal fractions for larger instances.
**Program Identifier:** Generation 30 - Patch Name regret_beam_vnd_lns_plus - Correct Program: True

**Program Name: Regret-Guided Beam Scheduler with Local Search**
- **Implementation**: Uses a regret-guided insertion beam search with 2-step lookahead and memoized cost evaluation, seeded by best singletons plus random starts. Adds suffix-2 diversity, adaptive beam width, sampled insertion positions (all positions in endgame), and blends immediate vs lookahead cost; followed by strong local refinement (adjacent swaps, reinsertion/Or-opt 1–3, sampled pair swaps, segment reversals) and a light iterated local search with structured perturbations.
- **Performance**: Achieved a combined score of 4.18 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Memoization and adaptive sampling kept evaluations tractable while the lookahead and robust local refinements consistently improved makespan. Stochastic elements introduce run-to-run variance; increasing num_seqs should further improve quality at additional runtime cost.
**Program Identifier:** Generation 34 - Patch Name lookahead_beam_and_oropt - Correct Program: True

**Program Name: Regret-Guided Beam + LNS Scheduler**
- **Implementation**: Uses regret-guided insertion beam search with memoized cost evaluation, suffix-diverse beam selection, and sampled positions/transactions. Applies strong local refinement (Or-opt reinsertion, adjacent/non-adjacent swaps, segment reversals), followed by iterated perturb-and-refine and LNS destroy-and-repair.
- **Performance**: Achieved combined score 4.18 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Parameters scale with num_seqs to balance search breadth and runtime; memoization and position sampling reduce evaluation overhead while ILS/LNS steps consistently improve makespan beyond seed builds. Beam suffix-diversity and a regret quota mitigate premature convergence and enhance solution quality on mixed workloads.
**Program Identifier:** Generation 36 - Patch Name beam_regret_diversity_oropt_lns - Correct Program: True

**Program Name: Beam-LNS Transaction Scheduler with Cached Lookahead**
- **Implementation**: Combines beam search with two-step lookahead, suffix-2 diversity, and a GRASP seed, followed by layered local refinements (reinsertion, adjacent swaps, sampled pair swaps, segment reversals) and a regret-guided ruin-and-recreate (best-two insertion) with per-repair caching. Prefix-cost memoization, adaptive beam sizing, and multiple randomized restarts balance quality and runtime.
- **Performance**: Achieved a combined score of 4.10 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.
- **Feedback**: Caching and multi-stage refinement improved stability and makespan, while regret-aware lookahead and diversity mitigated premature convergence. Further gains may be possible by tuning beam width and LNS rounds per workload size.
**Program Identifier:** Generation 37 - Patch Name lns_regret_repair_integration - Correct Program: True

**Program Name: Regret-guided hybrid scheduler with LNS and relinking**
- **Implementation**: Uses regret-based best-insertion with a small, diversity-aware beam and memoized sequence/insertion costs, followed by VND-style local refinement (Or-opt 3/2/1, adjacent swaps, sampled 2‑opt), iterated local search perturbations, LNS destroy–repair, and elite path relinking. Parameters adapt to problem size/num_seqs, with deterministic position sampling and caching to cut evaluation overhead.
- **Performance**: Achieved a combined score of 4.35 across 3 workloads (300 transactions) and passed all validation tests, returning valid schedules and execution time.
- **Feedback**: Cost and insertion memoization plus deterministic sampling materially reduce expensive evaluations while preserving solution quality, and the elite pool with suffix-based diversity and relinking helps avoid premature convergence. The multi-neighborhood refinement and LNS phases contribute observable improvements after construction, yielding robust performance on the tested workloads.
**Program Identifier:** Generation 38 - Patch Name best_two_insertion_cache_and_bidirectional_relink - Correct Program: True

**Program Name: Pairwise-guided VND/LNS scheduler**
- **Implementation**: Constructs a pairwise margin tournament from exact 2-length costs, seeds schedules via Borda/PageRank and randomized QuickSort, then refines with a VND (Or-opt 1–3, adjacent/non-adjacent swaps, 2-opt) using DLB and a global seq_cost cache, followed by sensitivity-guided LNS with pairwise-informed repair validated by exact costs. Includes elite portfolio management and diverse seeding; defines a best-two reinsertion cache that is not actually used.
- **Performance**: Combined score: 0.0 (failed all validation tests).
- **Feedback**: Nondeterministic search (no fixed RNG seed) and brittle repository path resolution likely cause validation failures; extensive exact cost evaluations may also lead to timeouts. Some implementation pieces are dead code (unused reinsertion cache), and the approach’s external dependency assumptions reduce robustness in the test harness.
**Program Identifier:** Generation 39 - Patch Name fas_tournament_rank_lns - Correct Program: False

**Program Name: Regret-Insert Metaheuristic for Txn Scheduling**
- **Implementation**: Uses memoized cost evaluation with a regret-based beam insertion constructor, followed by VND (adjacent swaps, Or-opt 1–3, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite set path relinking. Parameters adapt to search breadth; position sampling biases near focus and evaluates all positions on small sequences for accuracy.
- **Performance**: Achieved combined score 4.39 across 3 workloads (300 transactions) and passed all validation tests.
- **Feedback**: Cost memoization and focused position sampling reduced evaluations and stabilized runtime while preserving solution quality; beam diversity and regret-driven choices aided exploration. Elite management and path relinking provided incremental improvements post-refinement; num_seqs=10 offered a good quality–time tradeoff.
**Program Identifier:** Generation 40 - Patch Name regret_beam_elite_lns_pr - Correct Program: True

**Program Name: Hybrid GRASP-Beam-VND-LNS Scheduler**
- **Implementation**: Adaptive hybrid combining GRASP (regret-based insertion with cached best-two evaluations and stratified position sampling), beam search with lookahead and suffix-3 diversity plus greedy completion, VND (or-opt, adjacent/pair swaps, segment reversals with DLB), and sensitivity-guided LNS repair, with an elite pool and bidirectional block-aware path relinking. Sequence cost caching and parameter tuning by instance size reduce evaluations and balance intensification/diversification.
- **Performance**: Combined score to maximize: 4.20 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.
- **Feedback**: Caching (cost and best-two insertions) and stratified position sampling effectively trim simulator calls while preserving solution quality, and suffix-3 diversity/path relinking improve exploration. LNS plus VND polishing consistently refines makespan, though the approach remains evaluation-heavy and thus benefits substantially from the implemented caches.
**Program Identifier:** Generation 41 - Patch Name regret_beam_vnd_lns_pr - Correct Program: True

**Program Name: GRASP+VND Transaction Scheduler with LNS**
- **Implementation**: GRASP randomized best-insertion with regret-weighted RCL, deterministic stratified position sampling, and two-level caching (prefix costs and best-two insertions); followed by VND (Or-opt k=3..1, adjacent/non-adjacent swaps, relocations) and ruin-and-recreate LNS within a multi-start framework with size-adaptive parameters. Safety checks ensure permutation validity and completeness for all transactions.
- **Performance**: Combined score 4.24 across 3 workloads (300 transactions), passing all validation tests.
- **Feedback**: Caching plus deterministic sampling improved evaluation efficiency and repeatability, enabling deeper search per restart. VND and LNS effectively escaped local minima, while capped insertion positions, regret-weighted RCL, and adaptive sampling balanced solution quality with runtime.
**Program Identifier:** Generation 42 - Patch Name regret_cached_insertion_and_pair_swaps - Correct Program: True

**Program Name: Regret-Beam VND/LNS Transaction Scheduler**
- **Implementation**: Multi-phase metaheuristic combining GRASP with best-two insertion caching and stratified position sampling, a regret-dispersion beam search with suffix diversity and endgame widening, strong VND (Or-opt, swaps, segment reversals), sensitivity-guided LNS, and bidirectional path relinking over a suffix-3-diverse elite set. Extensive cost memoization, adaptive parameters by problem size, and deterministic seeding reduce evaluation overhead and improve search robustness.
- **Performance**: Combined score 4.13 across 3 workloads totaling 300 transactions, with all validation tests passing.
- **Feedback**: Caching (cost and best-two insertions) and stratified sampling effectively cut repeated evaluations, enabling deeper local search and LNS within the time budget. Diversity mechanisms (suffix-3 elites, regret-dispersion beam, endgame widening) improved exploration and mitigated premature convergence, contributing to the observed score.
**Program Identifier:** Generation 43 - Patch Name regret_beam_ctx_vnd_lns - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

## Successful Algorithmic Patterns
- Regret-based best-two insertion inside a small, diversity-aware beam, backed by memoized cost evaluation, consistently lifted scores. The current best, Regret-Insert Metaheuristic for Txn Scheduling (Gen 40, 4.39), centers on evaluate_best_two_positions to compute precise regret and uses suffix-k beam diversity with a regret quota; similar designs in Regret-guided hybrid scheduler with LNS and relinking (Gen 38, 4.35) also benefited from best-two insertion caching and bidirectional relinking.
- Deterministic/stratified position sampling with an endgame switch to exhaustive position evaluation improved final placements without exploding evaluations. This pattern shows up explicitly in Gen 40 (4.39) and Gen 42 GRASP+VND with LNS (4.24), which both report deterministic sampling and broader evaluation when few remain; both outscore comparable hybrids lacking these specifics (e.g., Gen 41 at 4.20).
- Layered post-construction refinement compounds gains: VND (adjacent swaps, Or-opt 1–3, sampled 2-opt) + ILS perturbations + LNS destroy/repair + elite path relinking. Gen 40 (4.39) stacks all four; Gen 38 (4.35) includes VND/LNS plus relinking; programs with fewer layers plateau lower (4.10–4.20).
- Elite management with suffix-based diversity and relinking consistently adds value beyond local optima. Gen 40 (4.39) and Gen 38 (4.35) both maintain a suffix-diverse elite pool and run (bi)directional path relinking; earlier hybrids without strong elite/relinking mechanisms cluster at 4.18–4.20 (Gen 30, Gen 34, Gen 36, Gen 41).

## Ineffective Approaches
- Brittle engineering and nondeterminism cause hard failures. Pairwise-guided VND/LNS scheduler (Gen 39, 0.0) failed validation due to nondeterministic search (no fixed RNG seed) and brittle repository path discovery, with dead code and heavy exact cost use that likely induced timeouts.
- Over-reliance on lookahead or beam breadth without strong post-processing underperforms. Beam-LNS with cached lookahead (Gen 37, 4.10) and regret-guided beam variants (Gen 30, Gen 34, Gen 36 at 4.18) show that beam+lookahead alone, even with memoization and some local search, stalls below the top cluster unless augmented by richer refinement (VND+ILS+LNS) and elite relinking.
- Excessive exact evaluation without caching or sampling discipline risks runtime issues and instability. Gen 39’s feedback flags “extensive exact cost evaluations” and external assumptions, echoing earlier failures where aggressive evaluation without robust memoization/sampling led to timeouts or brittle behavior.

## Implementation Insights
- What makes the current best (Gen 40, 4.39) effective:
  - Construction: evaluate_best_two_positions computes best and second-best costs to form a regret signal; a small beam with suffix-2 diversity and a regret quota selects expansions, while endgame_all_pos_threshold flips to exhaustive positions late for accuracy.
  - Efficiency: a dict-based cost cache keyed by tuple(seq) and deterministic, stratified position_samples (anchors, focus bias, and all positions for short sequences) sharply reduce simulator calls, enabling deeper refinement within the time budget.
  - Refinement stack: VND with limited adjacent-swap rounds, Or-opt (1–3), and sampled 2-opt; ILS perturbations (swaps/block moves) with size-adaptive rounds; LNS destroy/repair using regret-driven insertion; and path relinking aligning by largest displacement toward elite targets. Each layer provides incremental makespan reductions.
  - Robust search management: suffix-diverse elite pool maintenance and adaptive parameters tied to num_seqs balance intensification and diversification; deterministic sampling improves repeatability and stability, as echoed in Gen 42’s gains (4.24) over similar stacks without it (Gen 41, 4.20).
- Concrete coding patterns tied to performance:
  - Suffix-k diversity in beam expansion and elite pruning (Gen 40: k=2; Gen 38: suffix-based) avoids duplicate exploration and preserves variety, correlating with higher scores (≥4.35).
  - Endgame switches to exhaustive positions (Gen 40) and adaptive candidate/position sampling scales evaluation cost to sequence length and remaining items, improving late-stage accuracy at modest overhead.
  - Cached evaluation everywhere (dict/lru_cache) appears in nearly all high scorers (Gen 40 at 4.39; Gen 38 at 4.35; Gen 42 at 4.24), directly trading memory for time to enable multi-operator refinement within limits.
  - Path relinking after VND/LNS (Gen 40, Gen 38) yields consistent post-local-optimum improvements; implementations aligning by displacement or bidirectional moves are explicitly credited in feedback.

## Performance Analysis
- New peak established: Gen 40 at 4.39 surpasses the previous best cited in earlier insights (Gen 21, 4.37), confirming that precise regret modeling during construction plus elite relinking and a full refinement stack remain the dominant recipe.
- Clear strata across approaches:
  - Top cluster with elite relinking and best-two insertion caching: Gen 40 (4.39), Gen 38 (4.35).
  - Mid-high hybrids with strong VND/LNS but lighter elite/relinking/sampling: Gen 42 (4.24) > Gen 41 (4.20) > Gen 43 (4.13) > Gen 37 (4.10). The step from 4.20 to 4.24 aligns with adding deterministic sampling and two-level caching (Gen 42), while Gen 37’s lower score despite lookahead suggests breadth without robust post-processing is insufficient.
  - Beam-centric or partial stacks plateau around 4.18 (Gen 30, Gen 34, Gen 36), reinforcing that construction-time lookahead/diversity alone does not bridge the gap to the top tier without LNS+relinking depth and rigorous caching/sampling.
- Correlations:
  - Elite management with suffix-based diversity and path relinking correlates with ≥0.15–0.25 absolute gains over similar stacks lacking it (e.g., Gen 38/40 vs 4.18–4.20 group).
  - Deterministic/stratified position evaluation and endgame exhaustiveness track with incremental improvements (Gen 42 at 4.24 vs Gen 41 at 4.20), and, when combined with best-two regret and full refinement (Gen 40), reach the top score.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

1. Add reusable best-two insertion memoization with deterministic, stratified position sampling across construction and LNS repair
   - Maintain best_two_cache[(tuple(seq), t, pos_sig)] -> (best_cost, best_pos, second_cost), where pos_sig = ('all', len(seq)) when evaluating all positions or a deterministic tuple from position_samples; reuse entries in regret_insertion_build and lns_attempt. Replace random positions with a deterministic set: anchors [0, n//4, n//2, 3n//4, n], a small ring around focus_idx (±1..±3 bounded), and a fixed low-discrepancy sequence of interiors; when len(rem) <= 2*local_beam_width or len(seq) <= 20, evaluate all positions.

2. Make beam selection adaptive to regret dispersion and endgame, with stronger suffix diversity late
   - During expansion, compute dispersion = max(second_best) − min(second_best) for the layer; if dispersion > median(second_best), rank by 0.5*best_cost + 0.5*second_best, else 0.8*best_cost + 0.2*second_best, and keep a regret quota (e.g., high_regret_quota_ratio 0.3→0.45 in endgame). When remaining <= 2*local_beam_width, increase local_beam_width by +2 and diversity_suffix_k from 2→3, and force all-position evaluation for higher accuracy.

3. Upgrade VND: implement true sampled 2-opt (segment reversal) and non-adjacent swaps under don’t-look bits
   - Add a 2-opt neighborhood that samples up to S = min(200, n) pairs (i, j) with j - i >= 2 and applies segment reversal; maintain don’t-look bits per index, resetting only near improved segments and using length buckets to bias larger spans early. Include a separate sampled non-adjacent swap pass; run best-improvement for 1–2 outer rounds, preserving existing adjacent swaps and Or-opt(1–3).

4. Sensitivity-guided LNS destroys with stagnation escalation and quick polish
   - Before removal, score K = min(20, n) indices by sensitivity: for each i, move txn i to P = 6 deterministic positions, compute the variance/mean delta of seq_cost, and pick top ceil(0.4·m) for removal; fill the rest with one contiguous block. If two LNS attempts fail, increase m by 25% and allow two contiguous blocks; after regret-based repair, run a single light polish (reinsertion + Or-opt(1)) using the cached best-two evaluations.

5. Bidirectional, block-aware path relinking with on-the-fly micro-polishing and tighter elite diversity
   - For each elite pair, perform both A→B and B→A; at each step, move either the single item or the longest consecutive block already matching the target order that maximally reduces displacement/Kendall distance, keeping the best intermediate. After each move, run a fast Or-opt(1) pass; admit top 2–3 intermediates (improving) into the elite pool and enforce suffix-3 uniqueness (k=3) to maintain diversity.