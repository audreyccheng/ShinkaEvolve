<NAME>
best_two_insertion_cache_and_bidirectional_relink
</NAME>

<DESCRIPTION>
I propose two targeted improvements that directly lower makespan by reducing evaluation noise during construction/repair and by exploring better cross-elite combinations:

1) Deterministic best-two insertion caching across beam and LNS:
- Problem: We repeatedly compute the best and second-best insertion positions for the same (partial sequence, candidate txn) during beam expansion and LNS repair, often with different random position samples. This adds noise and redundant cost evaluations, weakening regret signals and wasting time.
- Fix: Introduce a best_two_cache keyed by (tuple(seq), txn, use_all_pos) with deterministic, stratified position sampling based on a seed derived from the sequence suffix and txn. We always include anchors {0, L, L//2, L/4, 3L/4} and near-focus positions, then add deterministic random positions. For small sequences or endgame, we evaluate all positions. This yields stable regret values, reduces workload.get_opt_seq_cost calls, and sharpens selection.

2) Bidirectional path relinking with quick polish:
- Problem: Current path relinking only moves from best to partner and only accepts improving one-step moves, which can miss improvements along reverse direction or near the path.
- Fix: For each elite partner, perform both A→B and B→A relinking, take the better intermediate, and apply a quick local_refine polish. This often uncovers better schedules not accessible by a single-direction, greedy-only path.

These changes keep the algorithm’s structure intact, improve construction accuracy and LNS repair via caching and deterministic sampling, and strengthen the elite combination step. Overall, this reduces makespan while keeping runtime reasonable thanks to fewer redundant evaluations.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def evaluate_best_two_positions(base_seq, t, pos_list):
        """Return (best_cost, best_pos, second_best_cost) for inserting t into base_seq over pos_list."""
        best = (float('inf'), None)
        second = float('inf')
        for p in pos_list:
            cand = base_seq[:p] + [t] + base_seq[p:]
            c = seq_cost(cand)
            if c < best[0]:
                second = best[0]
                best = (c, p)
            elif c < second:
                second = c
        return best[0], best[1], second
=======
    def evaluate_best_two_positions(base_seq, t, pos_list):
        """Return (best_cost, best_pos, second_best_cost) for inserting t into base_seq over pos_list."""
        best = (float('inf'), None)
        second = float('inf')
        for p in pos_list:
            cand = base_seq[:p] + [t] + base_seq[p:]
            c = seq_cost(cand)
            if c < best[0]:
                second = best[0]
                best = (c, p)
            elif c < second:
                second = c
        return best[0], best[1], second

    # Cache for best-two insertion per (sequence, txn, policy) within a run
    best_two_cache = {}

    def best_two_insertion(base_seq, t, use_all_pos=False, focus_idx=None, k_positions=None):
        """
        Deterministically sample positions and compute best and second-best insertion of t into base_seq.
        Caches results per (tuple(base_seq), t, use_all_pos) to avoid recomputation across beam/LNS.
        """
        key = (tuple(base_seq), t, bool(use_all_pos))
        if key in best_two_cache:
            return best_two_cache[key]
        L = len(base_seq)
        if use_all_pos or L <= 12:
            pos_list = list(range(L + 1))
        else:
            # Deterministic stratified sampling around anchors and (optionally) focus
            rng = random.Random((hash((tuple(base_seq[-min(10, L):]), t, L)) & 0xffffffff))
            pos_set = {0, L, L // 2, (L * 1) // 4, (L * 3) // 4}
            if focus_idx is not None:
                for d in (-3, -2, -1, 0, 1, 2, 3):
                    p = focus_idx + d
                    if 0 <= p <= L:
                        pos_set.add(p)
            cap = k_positions if k_positions is not None else k_pos_sample
            for _ in range(min(cap, L + 1)):
                pos_set.add(rng.randint(0, L))
            pos_list = sorted(pos_set)
        res = evaluate_best_two_positions(base_seq, t, pos_list)
        best_two_cache[key] = res
        return res
>>>>>>> REPLACE

<<<<<<< SEARCH
                # For each candidate txn, compute best and second-best insertion pos
                for t in cand_txns:
                    # Use all positions when short sequence for accuracy
                    pos_list = position_samples(len(seq))
                    best_c, best_p, second_c = evaluate_best_two_positions(seq, t, pos_list)
                    new_seq = seq[:best_p] + [t] + seq[best_p:]
                    new_rem = rem.copy()
                    new_rem.remove(t)
                    regret = (second_c - best_c) if second_c < float('inf') else 0.0
                    key = tuple(new_seq)
                    if key in seen_seqs:
                        continue
                    seen_seqs.add(key)
                    expansions.append((new_seq, new_rem, best_c, regret))
=======
                # For each candidate txn, compute best and second-best insertion pos
                for t in cand_txns:
                    use_all = (len(seq) <= 20) or (len(rem) <= rem_all_threshold) or (len(rem) <= build_beam_width * 2)
                    best_c, best_p, second_c = best_two_insertion(seq, t, use_all_pos=use_all)
                    new_seq = seq[:best_p] + [t] + seq[best_p:]
                    new_rem = rem.copy()
                    new_rem.remove(t)
                    regret = (second_c - best_c) if second_c < float('inf') else 0.0
                    key = tuple(new_seq)
                    if key in seen_seqs:
                        continue
                    seen_seqs.add(key)
                    expansions.append((new_seq, new_rem, best_c, regret))
>>>>>>> REPLACE

<<<<<<< SEARCH
            for t in cand_txns:
                pos_list = position_samples(len(seq_rep))
                best_c, best_p, second_c = evaluate_best_two_positions(seq_rep, t, pos_list)
                # Track pure best
                if best_c < best_overall[0]:
                    new_seq = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_overall = (best_c, t, new_seq)
                # Track regret
                regret = second_c - best_c if second_c < float('inf') else 0.0
                if regret > best_by_regret[0]:
                    new_seq_r = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_by_regret = (regret, t, new_seq_r)
=======
            for t in cand_txns:
                use_all = (len(rem_set) <= build_beam_width * 2) or (len(seq_rep) <= 20)
                best_c, best_p, second_c = best_two_insertion(seq_rep, t, use_all_pos=use_all)
                # Track pure best
                if best_c < best_overall[0]:
                    new_seq = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_overall = (best_c, t, new_seq)
                # Track regret
                regret = second_c - best_c if second_c < float('inf') else 0.0
                if regret > best_by_regret[0]:
                    new_seq_r = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_by_regret = (regret, t, new_seq_r)
>>>>>>> REPLACE

<<<<<<< SEARCH
    if len(elite) >= 2:
        base_cost, base_seq = best_overall_cost, best_overall_seq
        # Try relinking with a few elite partners
        partners = elite[1:min(len(elite), elite_size)]
        for c_t, s_t in partners:
            pr_c, pr_s = path_relink(base_seq, s_t, max_moves=max(8, min(12, n // 8)))
            if pr_c < best_overall_cost:
                best_overall_cost, best_overall_seq = pr_c, pr_s
=======
    if len(elite) >= 2:
        base_cost, base_seq = best_overall_cost, best_overall_seq
        # Try relinking with a few elite partners (bidirectional) and quick polish
        partners = elite[1:min(len(elite), elite_size)]
        for c_t, s_t in partners:
            pr1_c, pr1_s = path_relink(base_seq, s_t, max_moves=max(8, min(12, n // 8)))
            pr2_c, pr2_s = path_relink(s_t, base_seq, max_moves=max(8, min(12, n // 8)))
            cand_c, cand_s = (pr1_c, pr1_s) if pr1_c <= pr2_c else (pr2_c, pr2_s)
            if cand_c < best_overall_cost:
                lc, ls = local_refine(cand_s)
                if lc < best_overall_cost:
                    best_overall_cost, best_overall_seq = lc, ls
                else:
                    best_overall_cost, best_overall_seq = cand_c, cand_s
>>>>>>> REPLACE

</DIFF>