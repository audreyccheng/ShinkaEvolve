{
  "unprocessed_programs": [],
  "meta_summary": "**Program Name: Greedy Cost-Sampled Transaction Scheduler**\n- **Implementation**: Greedy scheduler with a random start; at each step it samples up to 10 remaining transactions without replacement and picks the one minimizing workload.get_opt_seq_cost. The sample_rate is fixed at 1.0 (disabling random fallback), and num_seqs is ignored; costs are recomputed per candidate and a holdout list prevents within-step resampling.\n- **Performance**: Achieved a combined score of 2.88 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Fixed full-sampling (1.0) and a single random restart limit exploration, which may cap optimality despite stable performance; redundant recomputation and unused variables indicate minor inefficiencies. Still, the approach reliably produces valid schedules with predictable greedy behavior.\n**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True\n\n**Program Name: Beam-Search Transaction Scheduler with Local Refinement**\n- **Implementation**: Uses a memoized beam search over transaction orderings with beam width derived from num_seqs, sampled expansions (thresholded full expansion), and diversity enforced by unique end elements; followed by adjacent-swap first-improvement hill-climbing. Includes robust repo-root discovery to import the simulator and workloads.\n- **Performance**: Achieved combined score 3.36 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Memoization substantially reduces repeated cost evaluations, while sampled expansion and bounded beam width keep runtime controlled without sacrificing much quality; the local swap pass reliably trims makespan further. Randomized sampling can introduce minor run-to-run variance, but diversity heuristics mitigate premature convergence.\n**Program Identifier:** Generation 1 - Patch Name beam_and_local_search - Correct Program: True\n\n**Program Name: Cached Beam Search with Local Refinement for Scheduling**\n- **Implementation**: Implements beam search guided by partial-prefix costs with memoized caching and randomized candidate sampling, plus multiple seeded restarts. Applies adjacent-swap local refinement and greedy/identity fallbacks, with beam width and expansion limits scaled to problem size.\n- **Performance**: Achieved combined score 3.33 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Cost caching and partial-cost guidance reduced evaluations and stabilized search, while restarts and local refinement shaved makespan further. Score indicates room for improvement likely limited by conservative beam width and sampling bounds; increasing num_seqs could trade runtime for better schedules.\n**Program Identifier:** Generation 2 - Patch Name beam_cached_greedy_scheduler - Correct Program: True\n\n**Program Name: GRASP-based Transaction Scheduler with Local Search**\n- **Implementation**: Uses multi-start GRASP with randomized best-insertion (candidate and insertion-position sampling), seeding with a best-of-two second insert. Refines with multi-pass adjacent swaps and random relocations; parameters adapt to workload size with validity assertions.\n- **Performance**: Achieved a combined score of 4.00 on three workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Adaptive sampling and local search balanced solution quality and runtime, yielding robust, feasible schedules. Multi-start diversification and seeding improved consistency across runs.\n**Program Identifier:** Generation 3 - Patch Name grasp_insertion_localsearch - Correct Program: True\n\n**Program Name: Greedy-ILS Transaction Scheduler**\n- **Implementation**: Greedy best-insertion with memoized cost evaluations seeded by singleton-cost ordering; sampled insertion positions include endpoints and use deterministic ordering to aid cache hits. First-improvement local refinement (adjacent swaps and reinsertion) is followed by a light iterated local search using a few random swaps; includes robust repo-root discovery for dependable imports.\n- **Performance**: Achieved a combined score of 4.08 across 3 workloads (300 transactions), producing valid schedules for each and passing all validation tests; execution time is recorded per run.\n- **Feedback**: Memoization and sampled insertion reduced simulator calls, delivering a good makespan/runtime trade-off, while local refinement consistently improved seed solutions. Limited perturbations likely cap deeper exploration, so most gains stem from construction and local moves rather than heavy global search.\n**Program Identifier:** Generation 4 - Patch Name greedy_insertion_ils - Correct Program: True\n\n**Program Name: Beam-Search GRASP Transaction Scheduler**\n- **Implementation**: Implements a cached beam search with two-step lookahead (k=5, alpha=0.7), seeded by a randomized best-insertion GRASP and diversified via random survivors and multiple restarts. Applies strong local refinement (reinsertion with sampled positions and adjacent swaps), adapts beam width/candidate expansion to problem size, and includes greedy/identity fallbacks.\n- **Performance**: Achieved combined score 3.92, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.\n- **Feedback**: Prefix-cost caching reduces duplicate evaluations and stabilizes lookahead scoring; the reinsertion+swap passes consistently improve makespan over raw beam outputs. Diversification (GRASP seed, survivors, restarts) enhances exploration and robustness across workloads.\n**Program Identifier:** Generation 5 - Patch Name beam_lookahead_and_reinsertion_local_search - Correct Program: True\n\n**Program Name: Greedy-Guided ILS Transaction Scheduler**\n- **Implementation**: Uses greedy best-insertion seeded by elite and random starts, with memoized cost evaluations and pairwise two-transaction precedence to guide insertion positions. Applies strong local refinement (adjacent swaps, guided reinsertion, sampled 2-opt) and a light iterated local search with random perturbations.\n- **Performance**: Achieved combined score 3.68 across 3 workloads (300 transactions), producing valid schedules and reporting execution time.\n- **Feedback**: Pairwise guidance and memoization reduce cost evaluations and improve search efficiency, while multi-seed starts and ILS help escape local minima for lower makespan. Program is correct and passed all validation tests; parameters keep runtime modest without sacrificing quality.\n**Program Identifier:** Generation 6 - Patch Name pairwise_guided_insertion_ils - Correct Program: True\n\n**Program Name: Regret-Guided Beam ILS Scheduler**\n- **Implementation**: Combines memoized regret-guided insertion beam search (diversified by end element) with deterministic position sampling and sampled candidate transactions to construct schedules. Applies strong local refinement (adjacent swaps, reinsertion, sampled pair swaps, segment reversals) followed by a light iterated local search with structured perturbations; parameters scale with num_seqs.\n- **Performance**: Achieved a combined score of 4.17 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and deterministic sampling reduced redundant evaluations and stabilized search, while the regret heuristic plus multi-operator local search consistently lowered makespan. Further gains likely come from tuning beam width and sampling sizes (via num_seqs) to balance runtime and quality per workload.\n**Program Identifier:** Generation 7 - Patch Name regret_beam_and_vnd - Correct Program: True\n\n**Program Name: GRASP-VND Transaction Scheduler**\n- **Implementation**: Implements GRASP-style randomized best-insertion with a prefix cost cache and RCL, followed by VND local search (adjacent swaps then relocations), with adaptive candidate/position sampling by workload size and multi-start restarts.\n- **Performance**: Achieved a combined score of 3.91 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching prefix evaluations reduced repeated cost calls, enabling broader exploration, while adaptive sampling and RCL improved diversification and VND tightened makespan with reasonable runtime. The score indicates solid performance; more restarts or a higher position sample cap for large n may yield further gains.\n**Program Identifier:** Generation 9 - Patch Name grasp_beam_cached_vnd - Correct Program: True\n\n**Program Name: GRASP Transaction Scheduler with Local Search**\n- **Implementation**: Implements a multi-start GRASP using randomized best-insertion with a restricted candidate list and adaptive position sampling, supported by a partial-prefix cost cache. Refines sequences via deterministic best reinsertion, adjacent swap hill-climbing, and random relocations, with parameters scaling to workload size and restart count.\n- **Performance**: Combined score to maximize: 4.05 across 3 workloads (300 transactions); all validation tests passed.\n- **Feedback**: Adaptive RCL plus layered local search balanced exploration and exploitation, improving makespan while caching and position sampling controlled evaluation cost. Robust path discovery ensured portability; tuning position limits and relocation trials can further optimize speed-quality trade-offs on larger workloads.\n**Program Identifier:** Generation 10 - Patch Name grasp_cache_reinsert_rcl - Correct Program: True\n\n**Program Name: MCTS+LNS Transaction Scheduler with Progressive Widening**\n- **Implementation**: Monte Carlo Tree Search with UCB1 and progressive widening, candidate expansion via sampled remaining transactions ranked by partial cost using a cached prefix-cost function. Rollouts use epsilon-greedy selection over small random subsets, and solutions are refined by local search (adjacent swaps, block relocation, 2-opt) with periodic and final passes; iteration budgets and parameters scale with problem size, and seeding ensures deterministic runs.\n- **Performance**: Combined score to maximize: 3.21 on 3 workloads (300 total transactions), passing all validation tests.\n- **Feedback**: Progressive widening plus candidate pre-scoring and cost caching efficiently reduce branching and simulator calls, yielding strong incumbents that LNS refines further. Results suggest good convergence and robustness across workloads, though solution quality may depend on sampling caps, epsilon, and local search attempt counts.\n**Program Identifier:** Generation 8 - Patch Name mcts_conflict_aware_lns - Correct Program: True\n\n**Program Name: Hybrid Regret-Insertion Transaction Scheduler**\n- **Implementation**: Uses regret-based best-insertion with memoized cost evaluations to construct schedules, then refines via adjacent swaps, reinsertion, sampled 2-opt, iterated local search perturbations, large-neighborhood destroy/repair, and elite path relinking. Parameters (sampling sizes, rounds) adapt to num_seqs, and an elite pool with simple diversity (by last element) is maintained.\n- **Performance**: Combined score to maximize: 4.13 across 3 workloads (300 transactions); program is correct and passes all validation tests.\n- **Feedback**: Memoization and adaptive sampling significantly reduce redundant evaluations, while multi-neighborhood refinement and LNS/relinking balance exploration and exploitation to improve makespan. Elite diversity helps avoid premature convergence; modest gains may be possible by tuning 2-opt sampling or reinsertion breadth.\n**Program Identifier:** Generation 11 - Patch Name regret_lns_refiner - Correct Program: True\n\n**Program Name: Conflict-Regret LNS Scheduler**\n- **Implementation**: Multi-start lookahead GRASP with RCL and cached cost evaluations, followed by VND (relocate, sampled two-opt, adjacent swaps) and LNS ruin-and-recreate using regret-2 reinsertion; parameters adapt to workload size and insertion positions are sampled to reduce simulation calls. Includes repo-root discovery for imports, global cost cache, and plateau-escaping random swaps.\n- **Performance**: Combined score: 0.0 (failed validation due to non-execution).\n- **Feedback**: Syntax errors in construct_lookahead and construct_rcl_best_insertion return statements (extra parenthesis) prevent the program from running. Unseeded randomness and brittle path discovery via __file__ can also cause nondeterminism/import failures in tests; fix syntax, add deterministic seeding, and simplify imports to pass validation.\n**Program Identifier:** Generation 12 - Patch Name conflict_regret_lns - Correct Program: False\n\n**Program Name: Regret-Beam Transaction Scheduler with Local Search**\n- **Implementation**: Uses regret-guided insertion beam search with diversity and high-regret quotas, GRASP seeding, memoized cost evaluation, and adaptive position sampling/endgame widening. Refines solutions via VND with Don't-Look Bits (Or-opt 1\u20133, swaps, segment reversals), ruin-and-recreate LNS, light path relinking, and brief ILS perturbations.\n- **Performance**: Combined score to maximize: 0.0; the program fails validation tests.\n- **Feedback**: Despite a sophisticated hybrid metaheuristic, the approach is brittle in testing\u2014likely due to unseeded randomness and environment-dependent path discovery/imports. Make the search deterministic, reduce reliance on filesystem heuristics, and ensure robust fallbacks to pass validation.\n**Program Identifier:** Generation 13 - Patch Name regret_beam_vnd_lns - Correct Program: False\n\n**Program Name: Beam-GRASP Transaction Scheduler**\n- **Implementation**: Combines a cached beam search with two-step lookahead, suffix-2 diversity, and regret-weighted selection, seeded by a GRASP-style best-insertion constructor. Applies strong local search (Or-opt reinsertion then adjacent swaps), multi-restarts, greedy completion, and adaptive beam/candidate sizing, all using a memoized cost evaluator.\n- **Performance**: Achieved a combined score of 4.00 on three 100-transaction workloads, producing valid schedules and passing all validation tests.\n- **Feedback**: Cost caching and sampled lookahead kept evaluation overhead low while preserving solution quality; local reinsertion+swap refinement consistently improved the beam output. Diversity constraints and regret-guided filling mitigated premature convergence, yielding robust schedules across workloads.\n**Program Identifier:** Generation 14 - Patch Name regret_diverse_beam_and_oropt - Correct Program: True\n\n**Program Name: Hybrid GRASP-Beam-LNS Scheduler**\n- **Implementation**: Combines regret-guided GRASP construction with beam search (lookahead and regret diversity), VND local search (Or-opt 1\u20133 and adjacent swaps with DLB), LNS ruin-and-recreate, and path relinking under adaptive parameters based on problem size. Uses a cached cost evaluator and sampled insertion positions to reduce evaluation overhead.\n- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Hybridization and caching provided stable quality under limited search effort, while adaptive sampling and beam diversity maintained effective exploration without excessive runtime. Additional tuning of neighborhood rounds and beam/lns parameters could further reduce makespan.\n**Program Identifier:** Generation 15 - Patch Name regret_beam_lns_vnd - Correct Program: True\n\n**Program Name: GRASP-VND Transaction Scheduler**\n- **Implementation**: Implements a GRASP randomized best-insertion constructor with regret-weighted RCL and cached prefix cost evaluations, using adaptive candidate/position sampling by workload size. Refinement applies VND (or-opt k=3/2/1, adjacent swaps, relocations) plus light ruin-and-recreate LNS over multiple restarts.\n- **Performance**: Achieved a combined score of 4.26 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and adaptive sampling reduce evaluation overhead while maintaining quality, and VND+LNS effectively escapes local minima to improve makespan. Construction diversity and regret weighting support robust schedules, with no correctness issues observed.\n**Program Identifier:** Generation 18 - Patch Name grasp_regret_vnd_lns - Correct Program: True\n\n**Program Name: GRASP Transaction Scheduler with Local Search**\n- **Implementation**: Multi-start randomized best-insertion with regret-based RCL, adaptive candidate/position sampling by workload size, and memoized cost evaluations to cut duplicate simulator calls. Refined via layered local search: best-improving reinsertion (Or-opt-1), adjacent swap hill-climbing, random relocations, and a final adjacent-swap polish.\n- **Performance**: Combined score 4.10 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Adaptive sampling and caching effectively control evaluation cost while maintaining solution quality; the local search stack consistently improves makespan over initial constructions. Multi-start diversification aids robustness across workloads.\n**Program Identifier:** Generation 19 - Patch Name cached_grasp_regret_vnd - Correct Program: True\n\n**Program Name: GRASP-based Transaction Makespan Optimizer**\n- **Implementation**: Uses GRASP randomized best-insertion with regret-biased RCL, adaptive candidate/position sampling, and LRU-cached cost evaluation. Refines sequences via Or-opt (blocks 1\u20133), adjacent swaps, random relocations, and ruin-and-recreate, with multi-start restarts and safety checks.\n- **Performance**: Achieved a combined score of 4.02 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Adaptive sampling and memoization reduce evaluation overhead, enabling more aggressive local search. Multi-start and LNS steps improve solution quality and robustness across heterogeneous workloads.\n**Program Identifier:** Generation 20 - Patch Name grasp_regret_vnd_lns - Correct Program: True\n\n**Program Name: Regret-Guided Beam and LNS Transaction Scheduler**\n- **Implementation**: Uses a regret-guided insertion beam search with memoized cost evaluations and suffix-based diversity, followed by strong local refinement (Or-opt 1\u20133, adjacent and sampled pair swaps, segment reversals), iterated local search perturbations, and LNS destroy-and-repair with regret-aware reinsertion. Deterministic position sampling (ends/mid plus random) supports caching efficiency; parameters scale with num_seqs.\n- **Performance**: Achieved combined score 4.18, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.\n- **Feedback**: Memoization and deterministic sampling significantly cut repeated evaluations; mixing cost- and regret-driven beam expansions with diversity controls mitigates premature convergence. Layered local search and LNS provide meaningful post-construction improvements while sampling thresholds balance solution quality and runtime.\n**Program Identifier:** Generation 22 - Patch Name regret_diverse_beam_lns_oropt - Correct Program: True\n\n**Program Name: Hybrid LNS-ILS Regret Scheduler**\n- **Implementation**: Uses regret-based best-insertion with memoized cost evaluation in an adaptive, diversity-aware beam; followed by local refinement (Or-opt 3/2/1, adjacent swaps, sampled 2-opt), iterated local search (swap/block perturbations), large-neighborhood destroy/repair with regret insertion, and elite path relinking.\n- **Performance**: Achieved combined score 4.29 across three workloads (300 transactions total), producing valid schedules and passing all validation tests.\n- **Feedback**: Memoization and targeted position sampling reduce evaluation overhead, enabling deeper search; adaptive beam/sampling and elite diversity bolster robustness across workloads. Stochastic exploration (regret mixing, perturbations, LNS) can introduce variance but delivered good makespan and correctness in evaluation.\n**Program Identifier:** Generation 16 - Patch Name beam_vnd_ooropt_diversity - Correct Program: True\n\n**Program Name: Regret-diversified beam + VND for txn scheduling**\n- **Implementation**: Builds schedules via a regret-diversified insertion beam search with memoized cost evaluation, suffix-diversity control, and a regret quota; refines with VND (adjacent swaps, Or-opt 1\u20133, sampled pair swaps, segment reversals), then light ILS and a small ruin-and-recreate LNS with regret-based repair. Includes adaptive sampling of transactions/positions and seed selection from elite singleton evaluations plus random seeds.\n- **Performance**: Achieved combined score 4.31 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and diversified beam expansion reduced duplicate evaluations and produced strong starting sequences that local search consistently improved. Layered VND/ILS/LNS yielded robust makespan reductions across workloads with a good quality/runtime balance.\n**Program Identifier:** Generation 17 - Patch Name beam_lns_vnd_upgrade - Correct Program: True\n\n**Program Name: Memoized Regret-Insertion Metaheuristic for Transaction Scheduling**\n- **Implementation**: Hybrid pipeline combining regret-guided best-insertion with small-beam diversity and memoized cost evaluations, followed by VND local search (adjacent swaps, Or-opt 1\u20133, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite path relinking; parameters adapt to num_seqs with endgame exhaustive position checks. Seeding uses top singleton costs plus random seeds, and an elite pool is maintained with suffix-based diversity control.\n- **Performance**: Combined score to maximize: 4.37 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Memoization and adaptive sampling reduce expensive evaluations, while the multi-neighborhood refinement and LNS/relinking steps improve makespan beyond construction quality. Some outcome variability stems from randomness (no fixed seed); tuning regret_prob and sampling thresholds may further stabilize and enhance results.\n**Program Identifier:** Generation 21 - Patch Name beam_regret_vnd_oropt - Correct Program: True\n\n**Program Name: Hybrid Beam-GRASP VND/ILS Transaction Scheduler**\n- **Implementation**: Combines a regret-guided GRASP seed and a two-step lookahead beam search with suffix-2 diversity, then refines via VND (Or-opt with DLB, adjacent/pair swaps, segment reversals) and LNS ruin-and-recreate within an ILS multi-start/elite framework. Uses LRU-cached partial-sequence costs and adaptive sampling/beam widths tuned to workload size.\n- **Performance**: Achieved combined score 4.07 on 3 workloads (300 transactions) with valid schedules; all validation tests passed.\n- **Feedback**: Hybrid seeding plus regret-diverse beam produced strong initial solutions, while VND and LNS/ILS reliably improved makespan. Caching and adaptive exploration balanced solution quality and runtime, aiding robustness across heterogeneous workloads.\n**Program Identifier:** Generation 23 - Patch Name vnd_beam_lns_ils - Correct Program: True\n\n**Program Name: GRASP-VND Transaction Scheduler**\n- **Implementation**: GRASP-style randomized best-insertion with regret-based RCL and memoized cost evaluation, followed by VND local search (Or-opt-3/2 blocks, best reinsertion, adjacent swaps, random relocations), plus ruin-and-recreate LNS and path relinking over a small elite pool. Adaptive candidate/position sampling and workload-size\u2013aware parameters aim to balance exploration and speed across three workloads.\n- **Performance**: Combined score: 0.0 (failed validation tests).\n- **Feedback**: Execution likely fails due to a signature mismatch: vnd_local_search calls local_search_adjacent_swaps with max_passes, but the function does not accept this parameter (TypeError). Import path discovery is brittle and may raise at runtime; unseeded randomness also reduces reproducibility and can hurt test stability.\n**Program Identifier:** Generation 24 - Patch Name vnd_lns_path_relink - Correct Program: False\n\n**Program Name: Beam-GRASP Transaction Scheduler with Local Search**\n- **Implementation**: Combines a cached beam search with adaptive two-step lookahead (alpha tuned by second-step cost span), suffix-2 diversity, and regret-boosted selection, seeded by a GRASP-style randomized best-insertion. Strong local refinements (Or-opt reinsertion, adjacent swaps, sampled pair swaps, segment reversals) run after multiple randomized restarts; parameters scale with problem size and effort hint.\n- **Performance**: Achieved combined score 4.02 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Prefix cost caching and adaptive lookahead improved pruning accuracy, while diversity and regret preserved exploration; sampling kept expansions tractable. The aggressive refinement chain reliably improved beam outputs, and size-aware parameterization maintained practical runtimes.\n**Program Identifier:** Generation 28 - Patch Name adaptive_beam_vnd_plus - Correct Program: True\n\n**Program Name: Hybrid GRASP-Beam-VND-LNS Transaction Scheduler**\n- **Implementation**: Hybrid metaheuristic combining GRASP (regret-based best-insertion with cached partial-cost evaluations), beam search with two-step lookahead and suffix/diversity control, VND (or-opt k=3/2/1, adjacent swaps, relocations), LNS ruin-and-recreate, and elite pool with path relinking and adaptive parameters by problem size/effort.\n- **Performance**: Achieved a combined score of 4.20 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and adaptive sampling lowered evaluation overhead while beam diversity, VND, and LNS helped avoid local minima, yielding consistently valid high-quality schedules. No correctness issues observed; the approach appears robust across workloads.\n**Program Identifier:** Generation 29 - Patch Name hybrid_beam_grasp_lns_vnd - Correct Program: True\n\n**Program Name: Regret-Guided Hybrid Transaction Scheduler**\n- **Implementation**: Combines regret-guided GRASP construction, diversity-aware beam search with shallow lookahead, VND (Or-opt/adjacent + sampled pair swaps), LNS ruin-and-recreate, and an elite pool with path relinking/ILS. Uses lru-cached cost evaluation, sampled insertion positions, and suffix/prefix deduplication to control branching and speed evaluation.\n- **Performance**: Combined score to maximize: 4.18 on three workloads (300 transactions); program is correct and passes all validation tests.\n- **Feedback**: Caching and sampling reduced evaluation overhead, while regret/diversity mechanisms improved solution quality and avoided premature convergence. Adaptive sizing and iterative LNS+VND polishing yielded robust makespans; tuning beam width and LNS removal rates may further improve results on larger instances.\n**Program Identifier:** Generation 31 - Patch Name grasp_beam_lns_vnd_hybrid - Correct Program: True\n\n**Program Name: Conflict-aware divide-merge DP scheduler**\n- **Implementation**: Builds a conflict graph via cached pairwise cost probes (full or sampled), clusters high-degree transactions, orders each cluster with a small beam+lookahead, then DP-interleaves clusters and lightly polishes with Or-opt and adjacent swaps. Uses an LRU-cached evaluator and deterministic seeding to constrain evaluation budget.\n- **Performance**: Achieved combined score 3.39 on 3 workloads (300 txns) and passed all validation tests.\n- **Feedback**: Conflict-aware clustering plus exact DP interleaving produced strong makespans while caching and sampling kept runtime practical; light polishing yielded incremental gains. The computed directional preference is currently unused and could further guide ordering/merge decisions.\n**Program Identifier:** Generation 33 - Patch Name conflict_aware_divide_and_merge - Correct Program: True\n\n**Program Name: Hybrid GRASP\u2013Beam\u2013VND\u2013LNS Scheduler**\n- **Implementation**: Hybrid metaheuristic combining GRASP construction (regret-guided insertions), regret-diverse beam search with two-step lookahead, VND (Or-opt with DLB and adjacent swaps), LNS ruin-and-recreate, and path relinking with an elite pool. Uses lru_cache for cached prefix evaluations, adaptive parameters by problem size, multi-start restarts, and custom repo-root discovery with sys.path injection.\n- **Performance**: Achieved a combined score of 0.0; failed validation and produced incorrect results.\n- **Feedback**: Environment-dependent path discovery and external imports likely broke portability and validation, causing runtime failures. Randomized sampling plus aggressive caching can induce nondeterminism or time/memory issues; make the module self-contained, stabilize seeding per test, and harden schedule validity checks.\n**Program Identifier:** Generation 35 - Patch Name grasp_beam_vnd_lns_elite - Correct Program: False\n\n**Program Name: Hybrid GRASP-Beam Scheduler with VND/LNS Relinking**\n- **Implementation**: Uses a regret-diverse GRASP constructor (best-two insertions with mixed cost/regret RCL), adaptive beam search with lookahead and regret-dispersion blending plus suffix diversity, followed by VND (Or-opt 1..3, adjacent swaps, sampled 2-opt/pair-swaps with DLB), sensitivity-guided LNS ruin-and-recreate, and bidirectional path relinking over a suffix-diverse elite pool. An lru_cache-backed cost evaluator and stratified position sampling with size-adaptive parameters reduce evaluations and maintain diversification.\n- **Performance**: Achieved a combined score of 4.18 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Diversity controls (regret/suffix) and relinking+LNS improved exploration and final makespan, while caching/sampling kept runtime reasonable. Further gains likely from tuning beam width/lookahead and LNS removal fractions for larger instances.\n**Program Identifier:** Generation 30 - Patch Name regret_beam_vnd_lns_plus - Correct Program: True\n\n**Program Name: Regret-Guided Beam Scheduler with Local Search**\n- **Implementation**: Uses a regret-guided insertion beam search with 2-step lookahead and memoized cost evaluation, seeded by best singletons plus random starts. Adds suffix-2 diversity, adaptive beam width, sampled insertion positions (all positions in endgame), and blends immediate vs lookahead cost; followed by strong local refinement (adjacent swaps, reinsertion/Or-opt 1\u20133, sampled pair swaps, segment reversals) and a light iterated local search with structured perturbations.\n- **Performance**: Achieved a combined score of 4.18 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and adaptive sampling kept evaluations tractable while the lookahead and robust local refinements consistently improved makespan. Stochastic elements introduce run-to-run variance; increasing num_seqs should further improve quality at additional runtime cost.\n**Program Identifier:** Generation 34 - Patch Name lookahead_beam_and_oropt - Correct Program: True\n\n**Program Name: Regret-Guided Beam + LNS Scheduler**\n- **Implementation**: Uses regret-guided insertion beam search with memoized cost evaluation, suffix-diverse beam selection, and sampled positions/transactions. Applies strong local refinement (Or-opt reinsertion, adjacent/non-adjacent swaps, segment reversals), followed by iterated perturb-and-refine and LNS destroy-and-repair.\n- **Performance**: Achieved combined score 4.18 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Parameters scale with num_seqs to balance search breadth and runtime; memoization and position sampling reduce evaluation overhead while ILS/LNS steps consistently improve makespan beyond seed builds. Beam suffix-diversity and a regret quota mitigate premature convergence and enhance solution quality on mixed workloads.\n**Program Identifier:** Generation 36 - Patch Name beam_regret_diversity_oropt_lns - Correct Program: True\n\n**Program Name: Beam-LNS Transaction Scheduler with Cached Lookahead**\n- **Implementation**: Combines beam search with two-step lookahead, suffix-2 diversity, and a GRASP seed, followed by layered local refinements (reinsertion, adjacent swaps, sampled pair swaps, segment reversals) and a regret-guided ruin-and-recreate (best-two insertion) with per-repair caching. Prefix-cost memoization, adaptive beam sizing, and multiple randomized restarts balance quality and runtime.\n- **Performance**: Achieved a combined score of 4.10 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and multi-stage refinement improved stability and makespan, while regret-aware lookahead and diversity mitigated premature convergence. Further gains may be possible by tuning beam width and LNS rounds per workload size.\n**Program Identifier:** Generation 37 - Patch Name lns_regret_repair_integration - Correct Program: True\n\n**Program Name: Regret-guided hybrid scheduler with LNS and relinking**\n- **Implementation**: Uses regret-based best-insertion with a small, diversity-aware beam and memoized sequence/insertion costs, followed by VND-style local refinement (Or-opt 3/2/1, adjacent swaps, sampled 2\u2011opt), iterated local search perturbations, LNS destroy\u2013repair, and elite path relinking. Parameters adapt to problem size/num_seqs, with deterministic position sampling and caching to cut evaluation overhead.\n- **Performance**: Achieved a combined score of 4.35 across 3 workloads (300 transactions) and passed all validation tests, returning valid schedules and execution time.\n- **Feedback**: Cost and insertion memoization plus deterministic sampling materially reduce expensive evaluations while preserving solution quality, and the elite pool with suffix-based diversity and relinking helps avoid premature convergence. The multi-neighborhood refinement and LNS phases contribute observable improvements after construction, yielding robust performance on the tested workloads.\n**Program Identifier:** Generation 38 - Patch Name best_two_insertion_cache_and_bidirectional_relink - Correct Program: True\n\n**Program Name: Pairwise-guided VND/LNS scheduler**\n- **Implementation**: Constructs a pairwise margin tournament from exact 2-length costs, seeds schedules via Borda/PageRank and randomized QuickSort, then refines with a VND (Or-opt 1\u20133, adjacent/non-adjacent swaps, 2-opt) using DLB and a global seq_cost cache, followed by sensitivity-guided LNS with pairwise-informed repair validated by exact costs. Includes elite portfolio management and diverse seeding; defines a best-two reinsertion cache that is not actually used.\n- **Performance**: Combined score: 0.0 (failed all validation tests).\n- **Feedback**: Nondeterministic search (no fixed RNG seed) and brittle repository path resolution likely cause validation failures; extensive exact cost evaluations may also lead to timeouts. Some implementation pieces are dead code (unused reinsertion cache), and the approach\u2019s external dependency assumptions reduce robustness in the test harness.\n**Program Identifier:** Generation 39 - Patch Name fas_tournament_rank_lns - Correct Program: False\n\n**Program Name: Regret-Insert Metaheuristic for Txn Scheduling**\n- **Implementation**: Uses memoized cost evaluation with a regret-based beam insertion constructor, followed by VND (adjacent swaps, Or-opt 1\u20133, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite set path relinking. Parameters adapt to search breadth; position sampling biases near focus and evaluates all positions on small sequences for accuracy.\n- **Performance**: Achieved combined score 4.39 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Cost memoization and focused position sampling reduced evaluations and stabilized runtime while preserving solution quality; beam diversity and regret-driven choices aided exploration. Elite management and path relinking provided incremental improvements post-refinement; num_seqs=10 offered a good quality\u2013time tradeoff.\n**Program Identifier:** Generation 40 - Patch Name regret_beam_elite_lns_pr - Correct Program: True\n\n**Program Name: Hybrid GRASP-Beam-VND-LNS Scheduler**\n- **Implementation**: Adaptive hybrid combining GRASP (regret-based insertion with cached best-two evaluations and stratified position sampling), beam search with lookahead and suffix-3 diversity plus greedy completion, VND (or-opt, adjacent/pair swaps, segment reversals with DLB), and sensitivity-guided LNS repair, with an elite pool and bidirectional block-aware path relinking. Sequence cost caching and parameter tuning by instance size reduce evaluations and balance intensification/diversification.\n- **Performance**: Combined score to maximize: 4.20 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Caching (cost and best-two insertions) and stratified position sampling effectively trim simulator calls while preserving solution quality, and suffix-3 diversity/path relinking improve exploration. LNS plus VND polishing consistently refines makespan, though the approach remains evaluation-heavy and thus benefits substantially from the implemented caches.\n**Program Identifier:** Generation 41 - Patch Name regret_beam_vnd_lns_pr - Correct Program: True\n\n**Program Name: GRASP+VND Transaction Scheduler with LNS**\n- **Implementation**: GRASP randomized best-insertion with regret-weighted RCL, deterministic stratified position sampling, and two-level caching (prefix costs and best-two insertions); followed by VND (Or-opt k=3..1, adjacent/non-adjacent swaps, relocations) and ruin-and-recreate LNS within a multi-start framework with size-adaptive parameters. Safety checks ensure permutation validity and completeness for all transactions.\n- **Performance**: Combined score 4.24 across 3 workloads (300 transactions), passing all validation tests.\n- **Feedback**: Caching plus deterministic sampling improved evaluation efficiency and repeatability, enabling deeper search per restart. VND and LNS effectively escaped local minima, while capped insertion positions, regret-weighted RCL, and adaptive sampling balanced solution quality with runtime.\n**Program Identifier:** Generation 42 - Patch Name regret_cached_insertion_and_pair_swaps - Correct Program: True\n\n**Program Name: Regret-Beam VND/LNS Transaction Scheduler**\n- **Implementation**: Multi-phase metaheuristic combining GRASP with best-two insertion caching and stratified position sampling, a regret-dispersion beam search with suffix diversity and endgame widening, strong VND (Or-opt, swaps, segment reversals), sensitivity-guided LNS, and bidirectional path relinking over a suffix-3-diverse elite set. Extensive cost memoization, adaptive parameters by problem size, and deterministic seeding reduce evaluation overhead and improve search robustness.\n- **Performance**: Combined score 4.13 across 3 workloads totaling 300 transactions, with all validation tests passing.\n- **Feedback**: Caching (cost and best-two insertions) and stratified sampling effectively cut repeated evaluations, enabling deeper local search and LNS within the time budget. Diversity mechanisms (suffix-3 elites, regret-dispersion beam, endgame widening) improved exploration and mitigated premature convergence, contributing to the observed score.\n**Program Identifier:** Generation 43 - Patch Name regret_beam_ctx_vnd_lns - Correct Program: True\n\n**Program Name: Hybrid Insertion-Beam Scheduler with LNS and VND**\n- **Implementation**: Implements a hybrid metaheuristic combining regret-guided GRASP construction, insertion-based beam search with lookahead/diversity, VND (Or-opt 1/2/3 and adjacent swaps), LNS ruin-and-recreate, and path relinking. Uses cached cost/insertion evaluations with deterministic sampling and adaptive size-based parameters, plus elite pool management and robust repo-root discovery for imports.\n- **Performance**: Achieved combined score 4.33 across 3 workloads (300 transactions); produced valid schedules and passed all tests.\n- **Feedback**: Caching and deterministic sampling cut redundant evaluations, enabling broader beam exploration and effective local improvements within time bounds. Hybrid recombination (path relinking) and LNS/VND consistently refine seeds, supporting scalability and contributing to the observed score.\n**Program Identifier:** Generation 25 - Patch Name grasp_beam_vnd_lns_pr - Correct Program: True\n\n**Program Name: Hybrid regret-beam transaction scheduler**\n- **Implementation**: Combines regret-guided insertion beam search with adaptive lookahead/diversity, stratified position sampling, and memoized best-two/cost caches; refined via VND (Or-opt 1\u20133, adjacent/non-adjacent swaps, segment reversals), sensitivity-guided LNS with escalation, and bidirectional path relinking over an elite set with suffix-based diversity. Parameters adapt to remaining size; caches are pruned (best-two capped at 12k) to bound memory.\n- **Performance**: Achieved a combined score of 4.22 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and stratified sampling substantially reduce evaluations, enabling deeper search; adaptive beam/lookahead plus elite diversity mitigate premature convergence and deliver strong makespans. Stochastic sampling and perturbations imply run-to-run variance; exposing a seed would improve reproducibility.\n**Program Identifier:** Generation 26 - Patch Name regret_lookahead_adaptive_vnd_lns_pr - Correct Program: True\n\n**Program Name: Regret-Guided Beam + LNS Scheduler**\n- **Implementation**: Uses regret-guided insertion beam search with adaptive 1-step lookahead and suffix diversity, with memoized sequence costs and cached best-two insertion evaluations. It applies multi-operator local refinement (Or-opt 3/2/1, adjacent/sampled pair swaps, segment reversals), then iterated local search and LNS destroy/repair after elite-seeded construction.\n- **Performance**: Achieved combined score 4.35 on 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and adaptive beam/lookahead reduced cost evaluations and helped avoid premature convergence, yielding strong makespans across heterogeneous workloads. Stochastic components (sampling, perturbations, LNS) introduce run-to-run variance; the num_seqs parameter effectively trades off quality and runtime.\n**Program Identifier:** Generation 27 - Patch Name adaptive_lookahead_lns_oropt - Correct Program: True\n\n**Program Name: Regret-Beam ILS Scheduler with VND and LNS**\n- **Implementation**: Hybrid GRASP + regret-diverse beam with lookahead builds seeds using cached prefix evaluations (lru_cache) and best-two insertion caching with stratified positions, followed by VND (Or-opt, swaps, 2-opt) with DLB, sensitivity-guided LNS, and elite path relinking inside an ILS loop. Parameters adapt to workload size/effort to balance exploration and exploitation.\n- **Performance**: Achieved combined score 4.15 on 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and stratified insertions cut evaluation overhead while maintaining solution quality; suffix-diverse beam and bidirectional path relinking improved diversity and convergence. Sensitivity-driven LNS and stagnation-aware ILS reliably escaped local minima, yielding robust schedules across workloads.\n**Program Identifier:** Generation 44 - Patch Name regret_beam_vnd_lns_plus - Correct Program: True\n\n**Program Name: GRASP-VND Transaction Scheduler**\n- **Implementation**: Multi-start GRASP with randomized best-insertion and regret-guided RCL, using memoized prefix costs and cached best/second-best insert evaluations. Refinement applies VND (Or-opt k=3/2/1, adjacent swaps, relocations) plus light LNS ruin-and-recreate; parameters adapt by workload size and restart count.\n- **Performance**: Achieved combined score 4.10 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Caching and stratified insertion-position sampling reduced simulator calls and stabilized evaluations, enabling deeper local search within budget. The GRASP+VND+LNS pipeline balanced diversification and intensification, which likely drove the observed score.\n**Program Identifier:** Generation 46 - Patch Name best_two_cache_vnd_lns - Correct Program: True\n\n**Program Name: Hybrid GRASP-Beam-LNS Transaction Scheduler**\n- **Implementation**: Uses regret-guided GRASP with best-two insertion and stratified position sampling, followed by adaptive beam search with lookahead/diversity, and a VND local search (Or-opt, adjacent/non-adjacent swaps, 2-opt with DLB). Adds sensitivity-guided LNS ruin-and-recreate, an elite pool with suffix-3 uniqueness, block-aware path relinking, deterministic seeding, and memoized cost evaluation.\n- **Performance**: Achieved combined score 4.24 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Hybridization with caching and adaptive sampling likely improved makespan-quality tradeoffs while containing evaluations; diversity controls and elite relinking helped avoid local minima. Deterministic seeding yields reproducible results across runs.\n**Program Identifier:** Generation 47 - Patch Name regret_beam_lns_vnd_elite - Correct Program: True\n\n**Program Name: Regret-Guided Hybrid Transaction Scheduler**\n- **Implementation**: Uses regret-based best-insertion with memoized cost evaluation and deterministic position sampling, seeded by singleton scoring and a small cost/regret-diverse beam. It applies adaptive VND (adjacent swaps, Or-opt 1-3, sampled 2-opt), ILS perturbations, LNS destroy/repair with regret insertion, and elite path relinking.\n- **Performance**: Achieved combined score 4.33 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and best-two-position caching cut expensive evaluations, stabilizing construction and accelerating local improvement. Multi-neighborhood VND plus LNS and relinking improved makespan quality, while adaptive beam/diversity maintained solution variety without excessive runtime.\n**Program Identifier:** Generation 50 - Patch Name best_two_memoized_insertion - Correct Program: True\n\n**Program Name: Hybrid Regret-Insertion Scheduler**\n- **Implementation**: Combines regret-based insertion beam search with deterministic position sampling and best-two insertion memoization. Refinement uses VND (Or-opt 1\u20133, adjacent and sampled swaps, 2-opt with don\u2019t-look bits), ILS perturbations, sensitivity-guided LNS, and bidirectional path relinking with elite management and suffix-based diversity.\n- **Performance**: Combined score 0.0; failed validation tests across workloads.\n- **Feedback**: Failures likely stem from brittle repository path resolution (environment-specific fallbacks) and stochastic behavior without seeding, leading to import errors or non-reproducible outputs; algorithmic complexity may also exceed time constraints. Make dependency discovery robust, enforce determinism (fixed seeds), and validate each phase individually to meet test requirements.\n**Program Identifier:** Generation 51 - Patch Name regret_beam_lns_vnd_pr - Correct Program: False\n\n**Program Name: Cached beam and LNS transaction scheduler**\n- **Implementation**: Uses a cached beam search with two-step lookahead, span-adaptive scoring (alpha), suffix-2 diversity, and GRASP seeding; cost evaluations are memoized for prefixes. Post-processing applies a multi-operator local search (Or-opt reinsertion, adjacent/pair swaps, 2-opt reversals) and a regret-guided ruin-and-recreate with best-two insertion, with anchored position sampling, greedy completion, and multiple randomized restarts sized to n and num_seqs.\n- **Performance**: Achieved combined score 4.08 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: The hybrid beam+LNS design with caching and diversity mechanisms yields robust exploration and strong makespan reductions, with local refinements consistently improving beam outputs while keeping runtime practical. Parameter scaling and regret-weighted choices aid solution quality, though heavy randomization may affect reproducibility.\n**Program Identifier:** Generation 52 - Patch Name beam_endgame_fix_and_insertion_completion - Correct Program: True\n\n**Program Name: Pairwise Rank-Centrality Kemeny-LNS Scheduler**\n- **Implementation**: Builds pairwise margins with cached cost calls, generates multiple global orders (Rank Centrality, Borda, Copeland, greedy, blended), then refines via margin-verified adjacent swaps, VND Or-Opt (k=1..3), Kemeny-guided reinsertions, and light ruin\u2013recreate LNS; effort scales by n and num_seqs. Deduplicated seeds and a Kemeny-like pairwise penalty guide moves while every change is validated by true cost.\n- **Performance**: Combined score 3.80 across 3 workloads (300 transactions total), producing valid schedules and passing all validation tests.\n- **Feedback**: Blended pairwise-preference seeding plus guided local search/LNS reliably improved makespan while the cost cache reduced evaluations. Light LNS and adaptive budgets balanced quality and runtime, indicating stable behavior across workloads.\n**Program Identifier:** Generation 53 - Patch Name pairwise_rank_centrality_kemeny - Correct Program: True\n\n**Program Name: Regret-Diversified Beam Search Scheduler**\n- **Implementation**: Combines regret-guided insertion beam search with memoized cost and adaptive lookahead, then applies VND (Or-opt blocks 1\u20133, adjacent and sampled non-adjacent swaps, segment reversals), lightweight ILS perturbations, and a small LNS destroy-repair phase. Parameters (seeds, beam width, sampling) scale with num_seqs, with suffix diversity and endgame all-position evaluation to improve completion quality.\n- **Performance**: Achieved combined score 4.33 across 3 workloads (300 transactions), producing valid schedules and aggregating makespan within measured runtime.\n- **Feedback**: Memoization and targeted sampling substantially reduce redundant evaluations while regret/diversity in the beam improves constructive quality. The layered local search (VND/ILS/LNS) reliably refines schedules without excessive runtime, and the program passed all validation tests.\n**Program Identifier:** Generation 32 - Patch Name adaptive_lookahead_beam_and_vnd_order - Correct Program: True\n\n**Program Name: Hybrid Regret-LNS Transaction Scheduler**\n- **Implementation**: Uses deterministic-stratified regret insertion with best-two position caching and an adaptive beam guided by regret dispersion, then refines with VND (Or-opt 1..3, DLB swaps, sampled 2-opt), sensitivity-guided LNS with quick polish, and bidirectional block-aware path relinking among elites. Memoized cost evaluations and suffix-based elite diversity reduce redundant work and maintain exploration.\n- **Performance**: Achieved a combined score of 4.27 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and deterministic position sampling noticeably cut cost evaluations while preserving search quality; adaptive beam/regret dispersion balanced exploitation and diversity. LNS plus path relinking further improved elites without compromising correctness.\n**Program Identifier:** Generation 48 - Patch Name stratified_regret_vnd_lns_pr - Correct Program: True\n\n**Program Name: Regret-diverse GRASP with Adaptive Beam, VND, and LNS**\n- **Implementation**: Hybrid metaheuristic combining regret-based GRASP construction, adaptive beam search with regret-aware lookahead and suffix diversity, VND (Or-opt 1\u20133, adjacent swaps, sampled pair swaps, 2-opt with DLB), sensitivity-guided LNS (variance-based removals with regret reinsertion), and block-aware bidirectional path relinking with elite pool management. Uses adaptive parameterization by problem size, lru_cache for sequence cost evaluation, and per-episode insertion caches to reduce recomputation.\n- **Performance**: Achieved combined score 4.17 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching plus adaptive beam/GRASP seeding enabled deeper exploration within the time budget, while suffix diversity, relinking, and sensitivity-guided LNS improved solution quality and avoided premature convergence. Further gains are likely by increasing num_seqs (widening the beam and LNS attempts) given the algorithm\u2019s scalable, sample-based neighborhoods.\n**Program Identifier:** Generation 49 - Patch Name regret_insertion_completion_and_suffix_best - Correct Program: True\n\n**Program Name: Hybrid Transaction Scheduler with GRASP, Beam, VND, LNS**\n- **Implementation**: Implements a hybrid metaheuristic combining GRASP construction, adaptive beam search with lookahead and suffix-3 diversity, VND (OR-opt, swaps, reversals with DLB), LNS ruin/repair, and bidirectional path relinking, finalized by exhaustive OR-opt(1) polish. Uses cached cost evaluations and best-two insertion with stratified position sampling and size-adaptive parameters.\n- **Performance**: Achieved a combined score of 4.26, producing valid schedules for 3 workloads (300 transactions) and passing all validation tests.\n- **Feedback**: Caching and stratified insertion evaluation reduce simulator calls while preserving quality; elite pooling and path relinking improve convergence and robustness. Final OR-opt(1) and brief VND passes deliver consistent marginal gains, with adaptive tuning maintaining reasonable runtime on larger instances.\n**Program Identifier:** Generation 56 - Patch Name exhaustive_insertion_and_final_polish - Correct Program: True\n\n**Program Name: Hybrid Beam-VND-LNS Transaction Scheduler**\n- **Implementation**: Combines deterministic best-two insertion memoization, a regret-dispersion beam search with suffix diversity and endgame widening, strong VND (Or-opt, swaps, reversals), sensitivity-guided LNS with stagnation escalation, and bidirectional block-aware path relinking among elites. Uses adaptive parameters by instance size and episode-wide cost caching to reduce recomputation.\n- **Performance**: Achieved combined score 4.37 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Deterministic caching and focused position sampling stabilize construction/repair while significantly cutting cost evaluations; diversity controls (suffix-k beam and suffix-3 elites) and endgame widening mitigate beam collapse and improve exploration. The multi-phase orchestration (GRASP seeds \u2192 beam \u2192 relinking \u2192 LNS+VND) yields consistently low makespans with good robustness across mixed workloads.\n**Program Identifier:** Generation 57 - Patch Name regret_beam_lns_vnd_v2 - Correct Program: True\n\n**Program Name: Hybrid GRASP/Beam/VND/LNS Transaction Scheduler**\n- **Implementation**: Combines regret-guided GRASP (best-two insertions) with cached prefix evaluations and deterministic position sampling, a lookahead beam search with suffix diversity, VND (or-opt k=3/2/1, adjacent and pair swaps, relocations), and LNS ruin\u2013recreate, plus elites and path relinking. Parameters adapt to problem size for balanced exploration and intensification.\n- **Performance**: Combined score: 4.13; produced valid schedules for 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and stratified position sampling reduce simulator calls while preserving solution quality; beam diversity and LNS aid exploration, while VND and path relinking effectively polish incumbents. Correctness confirmed\u2014schedules are permutations of all transactions.\n**Program Identifier:** Generation 58 - Patch Name grasp_beam_vnd_lns_elite_mix - Correct Program: True\n\n**Program Name: MCTS Progressive-Widening Transaction Scheduler**\n- **Implementation**: Uses MCTS with UCT over transaction-order prefixes, progressive widening with candidate ranking by incremental partial cost (memoized via lru_cache), regret-aware greedy rollouts, and light post-optimization (Or-opt reinsertion and sampled swaps). Implements a transposition table keyed by prefixes, stratified insertion positions, multiple seeded restarts, and repository path discovery for simulator/workloads.\n- **Performance**: Combined score 0.0; failed validation tests.\n- **Feedback**: Failures likely stem from environment-dependent path resolution and/or runtime-heavy search (no time caps, high iterations) causing timeouts, plus possible mismatch in partial-cost calls to the simulator API leading to incorrectness. Add strict time limits, trim iterations, verify prefix evaluation semantics, and ensure deterministic, environment-agnostic imports/returns.\n**Program Identifier:** Generation 60 - Patch Name mcts_ucb_rollout - Correct Program: False\n\n**Program Name: Hybrid GRASP-Beam-LNS Transaction Scheduler**\n- **Implementation**: Combines a regret-guided GRASP constructor, adaptive beam search with lookahead and suffix-based diversity, VND (Or-opt/adjacent-swap/sampled swap/2-opt with don\u2019t-look-bits), and sensitivity-guided LNS, integrated via an elite pool with block-aware path relinking. Employs cached cost and best-two insertion evaluations with deterministic position sampling and adaptive parameters based on instance size and effort.\n- **Performance**: Achieved a combined score of 4.15 over 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and deterministic sampling substantially reduce evaluation overhead while preserving solution quality; regret quotas and suffix diversity improve exploration-exploitation balance in beam search. Sensitivity-driven ruin/repair with quick Or-opt polish tightens makespan reliably, though further incremental cost updates could reduce eval_cost frequency and improve scalability.\n**Program Identifier:** Generation 62 - Patch Name deterministic_best_two_cache_and_insertion_completion - Correct Program: True\n\n**Program Name: Hybrid Regret-Insertion LNS Transaction Scheduler**\n- **Implementation**: Combines regret-based best-insertion with small-beam diversity and a memoized \u201cbest-two\u201d insertion oracle (deterministic position sampling + LRU cache), followed by VND local refinement (Or-opt 3/2/1, adjacent swaps, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite path relinking with adaptive parameters. Seeding uses top singleton starts plus random seeds with elite maintenance via suffix-diversity.\n- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Deterministic sampling and caching reduced cost evaluations substantially, enabling deeper exploration and better makespan via LNS and relinking intensification/diversification. The algorithm consistently produced valid schedules and met correctness checks.\n**Program Identifier:** Generation 64 - Patch Name best_two_lru_and_bidirectional_relink - Correct Program: True\n\n**Program Name: Regret Beam-LNS Transaction Scheduler**\n- **Implementation**: Builds schedules via regret-based insertion beam search with adaptive diversification, deterministic position sampling, and an LRU \u201cbest-two\u201d insertion cache to minimize cost evaluations. Refines with VND (adjacent swaps, Or-opt reinsertion, sampled non-adjacent swaps, 2-opt), then applies sensitivity-guided LNS destroy-and-repair, ILS perturbations, and bidirectional path relinking over an elite pool with suffix-based diversity.\n- **Performance**: Combined score 4.31 across three workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Memoization and deterministic sampling substantially reduce redundant get_opt_seq_cost calls, improving stability and search efficiency; adaptive beam width and elite diversity help avoid premature convergence. Robust across varied workloads, with effectiveness influenced by sampling sizes and destroy fractions.\n**Program Identifier:** Generation 65 - Patch Name regret_beam_lns_pr_lru - Correct Program: True\n\n**Program Name: Regret-Lookahead Beam LNS Scheduler**\n- **Implementation**: Uses regret-based best-insertion with adaptive lookahead and beam search with suffix-diversity, backed by memoized cost evaluations and deterministic position sampling. Refines solutions via VND with don\u2019t-look bits, ILS perturbations, sensitivity-guided LNS (with escalation), and bidirectional path relinking across an elite set.\n- **Performance**: Achieved combined score 4.29 on 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and deterministic sampling reduce evaluation overhead, enabling broader/deeper search; diversity-aware beam/elite management and LNS effectively avoid local minima to improve makespan. Further gains likely depend on tuning destroy sizes and relinking move limits to balance runtime and quality.\n**Program Identifier:** Generation 54 - Patch Name regret_lookahead_lns_pr - Correct Program: True\n\n**Program Name: Deterministic GRASP\u2013Beam VND/LNS Scheduler**\n- **Implementation**: Uses deterministic position-sampled regret insertion with best-two insertion memoization and cached cost evaluations, then a dispersion-adaptive beam search with suffix-3 diversity and endgame widening. Refinement combines VND (Or-opt, adjacent and non-adjacent swaps, sampled 2-opt under DLB), sensitivity-guided LNS, an elite pool, and bidirectional block-aware path relinking, with reproducible seeding and size-adaptive parameters.\n- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Deterministic sampling plus caching reduces redundant evaluations and stabilizes construction quality, while suffix-diverse elites, regret-driven choices, and sensitivity-guided LNS improve diversification and escape from local minima. The num_seqs parameter effectively controls beam width and refinement budgets, offering a clear quality\u2013time trade-off.\n**Program Identifier:** Generation 55 - Patch Name regret_beam_lns_vnd_pr - Correct Program: True\n\n**Program Name: Hybrid Beam-GRASP + VND/LNS Transaction Scheduler**\n- **Implementation**: Combines regret-guided GRASP seeding with an adaptive, regret-diverse beam search (two-step lookahead and suffix-2 diversity), backed by an LRU \u201cbest-two insertion\u201d cache and memoized partial evaluations. Refines via VND with DLB (Or-opt 1\u20133, adjacent/pair swaps, segment reversals), uses sensitivity-driven ruin-and-recreate LNS/ILS, and manages elites with bidirectional path relinking and micro-polish; parameters adapt to workload size.\n- **Performance**: Achieved a combined score of 4.22 on three workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching plus stratified insertion positions notably reduced evaluation calls and stabilized search, while regret-diverse beam selection and path relinking improved exploration quality. VND + LNS consistently improved incumbents; however, large LRU caches may increase memory footprint on very large instances.\n**Program Identifier:** Generation 59 - Patch Name insertion_lru_beam_oropt_improve - Correct Program: True\n\n**Program Name: Regret-guided beam search scheduler**\n- **Implementation**: Uses regret-guided insertion beam search with adaptive 1-step lookahead, suffix diversity, and memoized cost evaluation with cached best/second-best insertion positions. Refinement combines Or-opt (3/2/1), adjacent/non-adjacent swaps, segment reversals, elite maintenance and path relinking, iterated local search, and LNS destroy/repair with deterministic position sampling.\n- **Performance**: Achieved a combined score of 4.29 on 3 workloads (300 transactions) with valid schedules; all validation tests passed.\n- **Feedback**: The combination of lookahead beam construction and strong local refinement appears to lower makespan effectively, while caching and deterministic sampling improve consistency and runtime. Elite diversity (suffix-2) and path relinking help avoid premature convergence and yield incremental improvements across workloads.\n**Program Identifier:** Generation 61 - Patch Name elite_relink_and_deterministic_positions - Correct Program: True\n\n**Program Name: Regret-diverse GRASP-Beam-VND Scheduler**\n- **Implementation**: Hybrid pipeline combining regret-guided GRASP construction, insertion-based beam search with one-step lookahead and suffix-regret diversity, VND (Or-opt 3/2/1, adjacent swaps, sampled pair swaps, segment reversal), regret-guided LNS, and a final exhaustive Or-opt(1) polish. Uses an lru_cache-backed cost evaluator plus a best-two-insertions cache with deterministic position sampling and adaptive parameters by problem size to control evaluation budget.\n- **Performance**: Combined score to maximize: 4.27 across 3 workloads (300 transactions); program is correct and passes all validation tests.\n- **Feedback**: Best-two insertion caching and adaptive position sampling reduced evaluator calls, enabling deeper search without timeouts, while regret-diverse beam/LNS improved solution quality and robustness across workloads. Further gains likely come from tuning beam width and POS_SAMPLE_CAP for larger instances.\n**Program Identifier:** Generation 63 - Patch Name grasp_insertion_beam_vnd_lns_relink_free - Correct Program: True\n\n**Program Name: Hybrid GRASP-Beam-VND-LNS Transaction Scheduler**\n- **Implementation**: Implements a hybrid pipeline combining regret-guided GRASP construction, regret-diverse beam search with shallow lookahead, VND (Or-opt/adjacent/sampled pair swaps with DLB), LNS ruin-and-recreate, and elite pool path-relinking. Uses an lru_cache-backed cost oracle, deterministic/sampled insertion positions with a focus ring, and size-adaptive parameters.\n- **Performance**: Achieved combined score 4.26 on 3 workloads (300 transactions), generating valid schedules and passing all validation tests.\n- **Feedback**: Memoized evaluations and position sampling reduced cost calls, enabling deeper exploration; regret diversity and suffix filtering improved beam variety and reduced duplicates. Adaptive move sets plus quick VND polishing after each stage likely contributed to competitive makespan while keeping runtime reasonable.\n**Program Identifier:** Generation 66 - Patch Name beam_insertion_memo - Correct Program: True\n\n**Program Name: GRASP+VND Transaction Scheduler with LNS**\n- **Implementation**: Uses GRASP randomized best-insertion with regret-based RCL, cached prefix costs, and a \u201cbest-two insertion\u201d cache, then applies VND (Or-opt blocks k=3..1, adjacent/pair swaps, relocations) and a ruin-and-recreate LNS. Adaptive candidate/position sampling with deterministic stratified positions enables effective cache reuse; multi-start restarts with quick polish finalize schedules.\n- **Performance**: Achieved a combined score of 4.17 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and deterministic position sampling reduce redundant evaluations and speed construction while preserving quality; VND plus LNS aids escaping local minima. Adaptive parameters by workload size balance exploration and runtime, contributing to stable makespan improvements.\n**Program Identifier:** Generation 69 - Patch Name best_two_cache_regret_lns_pair_swaps - Correct Program: True\n\n**Program Name: Consensus-guided Beam-VND Transaction Scheduler**\n- **Implementation**: Uses an episode-wide LRU \u201cbest-two\u201d insertion memo (single and block) with deterministic position sampling and elite-driven consensus ranks to guide a regret-adaptive beam search with bounded endgame enumeration. After construction, it applies VND (Or-opt, swaps, 2-opt), consensus-guided LNS, and bidirectional path relinking, all sharing a centralized cost cache.\n- **Performance**: Achieved combined score 4.15 on 3 workloads (300 transactions total) and passed all validation tests.\n- **Feedback**: The insertion memos and consensus-guided diversification improved search efficiency and solution quality without compromising correctness. Endgame bounding and suffix-diverse beam layers helped avoid premature convergence and tightened completions on small remainders.\n**Program Identifier:** Generation 70 - Patch Name consensus_regret_branchbeam_lns - Correct Program: True\n\n**Program Name: Consensus-guided hybrid scheduler with memoized insertions**\n- **Implementation**: Integrates LRU-memoized best-two insertions (single and block) with consensus-regret adaptive beam search (suffix diversity, endgame widening), VND (Or-opt 1\u20133 with block memo, non-adjacent swaps, 2-opt with DLB), sensitivity-guided LNS with stagnation escalation, bidirectional path relinking, and endgame branch-and-bound; supported by an episode-wide cost cache and deterministic position sampling with focus rings. Elites are managed with suffix-3 diversity and median-rank consensus to guide diversification during search.\n- **Performance**: Combined score to maximize: 4.20; produced valid schedules for 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and deterministic position sampling substantially reduce evaluation overhead, enabling deeper beam/LNS exploration and effective endgame tightening. Consensus-guided diversification and relinking improve robustness and avoid premature convergence, yielding low makespans within tight time budgets.\n**Program Identifier:** Generation 75 - Patch Name consensus_regret_beam_lns_bnb - Correct Program: True\n\n**Program Name: Regret-Beam LNS Transaction Scheduler**\n- **Implementation**: Combines regret-based best-insertion with small-beam diversification, memoized cost evaluation, and a bounded endgame branch-and-bound; then applies VND local refinement (Or-opt, adjacent swaps, sampled 2-opt), iterated local search, LNS destroy/repair, and elite path relinking with adaptive parameters. Includes per-sequence insertion caching and deterministic-ish position sampling seeded by sequence-dependent hashes.\n- **Performance**: Combined score reported as 0.0; the program failed all validation tests.\n- **Feedback**: Repository-path probing and sys.path manipulation make imports fragile in the test harness, likely causing failures; heavy use of randomness (including Python\u2019s salted hash for sampling) introduces nondeterminism. Simplify imports (no path hacks), seed RNG for reproducibility, and consider trimming heuristics/time budgets to meet validation and runtime constraints.\n**Program Identifier:** Generation 76 - Patch Name endgame_bnb_for_last_k - Correct Program: False\n\n**Program Name: Regret-Guided Beam Search with LNS and Path Relinking**\n- **Implementation**: Uses regret-guided insertion beam search with adaptive 1-step lookahead, suffix-based diversity, and memoized cost evaluation plus cached best-two insertion positions via deterministic sampling and LRU-style pruning. Solutions are refined via multi-operator local search (Or-opt, adjacent/non-adjacent swaps, segment reversals), iterated local search, LNS destroy/repair, and elite-pool path relinking with suffix-2 diversity control.\n- **Performance**: Achieved combined score 4.39 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and deterministic position sampling reduce costly evaluations, enabling broader search while maintaining runtime; lookahead and suffix diversity improve solution quality and robustness. Parameter choices (num_seqs-driven widths, adaptive beams, LNS intensity) appear well-balanced; reproducibility could improve by fixing global seeds.\n**Program Identifier:** Generation 67 - Patch Name deterministic_best_two_cache_and_elite_relink - Correct Program: True\n\n**Program Name: Hybrid Regret-Beam LNS Scheduler**\n- **Implementation**: Implements a hybrid GRASP (regret-guided insertion) + beam search with lookahead/diversity, followed by VND (Or-opt 1/2/3, swaps, segment reversals with DLB), LNS ruin\u2013recreate, and path relinking over an elite set. Uses cached cost/insertion evaluations with deterministic position signatures and adapts beam/LNS/VND parameters to workload size.\n- **Performance**: Combined score 4.31; produced valid schedules across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Caching and deterministic position sampling reduce expensive evaluations, enabling deeper search within practical time. Diversity mechanisms (regret-biased RCL, suffix diversity, elite path relinking) help avoid local minima and likely contributed to the achieved score; adaptive parameterization improves robustness across problem sizes.\n**Program Identifier:** Generation 68 - Patch Name insertion_beam_memo_vnd2opt - Correct Program: True\n\n**Program Name: GRASP Beam VND LNS Transaction Scheduler**\n- **Implementation**: Uses deterministic regret-insertion with reusable best-two memoization, insertion-based beam search with lookahead, suffix diversity, and endgame widening, followed by strong VND (Or-opt 3/2/1, adjacent, sampled non-adjacent swaps, sampled 2-opt) under DLB, sensitivity-guided LNS with stagnation escalation and micro-polish, bidirectional path relinking among elites, and a final exhaustive 1-block reinsertion polish. Shared cost/best-two caches, suffix-3 elite diversity, adaptive parameters by instance size, and seeded RNG ensure efficiency and reproducibility.\n- **Performance**: Achieved combined score 4.37 on three workloads (300 transactions total) and passed all validation tests.\n- **Feedback**: Deterministic position sampling with memoization substantially reduces evaluations and stabilizes construction, while beam and elite suffix diversity mitigate premature convergence and endgame widening improves completion quality. Most improvements are realized during VND+LNS and the final OR-opt1 polish; adaptive sizing maintains scalability on larger workloads.\n**Program Identifier:** Generation 71 - Patch Name regret_beam_vnd_lns_pr - Correct Program: True\n\n**Program Name: Consensus-Regret Beam Scheduling with LNS and BnB**\n- **Implementation**: Uses a consensus-regret GRASP constructor and a dispersion-adaptive beam search guided by elite-derived consensus, with LRU-memoized best-two insertions and block reinsertions to cut evaluations. Enhancements include VND (Or-opt, adjacent/non-adjacent swaps, 2-opt), consensus-guided LNS ruin-repair, path relinking, and a time-bounded endgame BnB; parameters adapt to problem size and a suffix-aware elite pool manages diversity.\n- **Performance**: Achieved a combined score of 4.26 on 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Insertion/block caching significantly reduces cost evaluations and speeds local search, while endgame BnB tightens final sequences. Consensus-guided candidate focus and regret-dispersion balancing improve convergence and robustness; num_seqs provides a clear quality\u2013time tradeoff.\n**Program Identifier:** Generation 72 - Patch Name consensus_regret_beam_lns_vnd_bnb - Correct Program: True\n\n**Program Name: Regret-Driven Beam LNS Scheduler**\n- **Implementation**: Combines regret-based best-insertion with memoized cost and deterministic position sampling within a small, diversity-enforced beam, followed by VND local refinement, ILS perturbations, LNS destroy/repair, endgame branch-and-bound completion, and elite path relinking. Adaptive parameters and caches (sequence cost, best-two insertion, endgame) reduce evaluations and stabilize search.\n- **Performance**: Achieved combined score 4.41 across three workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching and deterministic sampling notably reduced redundant evaluations and improved stability, while exact endgame enumeration improved quality when few transactions remained. Mixing cost and regret in beam expansion plus LNS/ILS and path relinking provided effective exploration at the chosen breadth (num_seqs=10).\n**Program Identifier:** Generation 74 - Patch Name endgame_branch_and_bound_k8 - Correct Program: True\n\n**Program Name: PUCT MCTS + Endgame + VND Scheduler**\n- **Implementation**: PUCT-style MCTS uses best-insertion derived priors with deterministic position sampling, plus exact endgame DFS with memoized BnB and an LRU-cached prefix cost oracle. It applies adaptive parameters, a best-two insertion cache with regret-aware greedy rollouts, cpuct annealing, and a light VND polish (1/2-opt, adjacent swaps, sampled reversals).\n- **Performance**: Combined score 0.0; the program fails validation and produces no successful result under the test harness.\n- **Feedback**: Heavy search without strict time caps and reliance on external path/module resolution likely caused instability or timeouts; additionally, final schedule reconstruction uses priors instead of visit counts, weakening solution reliability. Add robust import fallbacks and hard runtime limits, and prefer visit-count-guided extraction or a deterministic greedy fallback to improve correctness and stability.\n**Program Identifier:** Generation 77 - Patch Name puct_mcts_endgame_bb - Correct Program: False\n\n**Program Name: Regret-guided hybrid LNS scheduler**\n- **Implementation**: Combines regret-based best-insertion with memoized cost evaluation and deterministic position sampling, then applies VND (adjacent swaps, Or-opt k=1\u20133, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite path relinking with an exact small endgame branch-and-bound. Adaptive beam/diversity control and best-two-position caching reduce evaluations and guide construction.\n- **Performance**: Achieved combined score 4.35 on 3 workloads (300 txns), returning valid schedules and passing all validation tests.\n- **Feedback**: Evaluation indicates effective exploration\u2013exploitation balance across heterogeneous workloads; memoization and bounded endgame search keep runtime predictable while enabling quality improvements. Local refinement plus LNS drives most gains, with elite maintenance and path relinking providing additional polishing.\n**Program Identifier:** Generation 80 - Patch Name endgame_tt_and_bidirectional_relink - Correct Program: True\n\n**Program Name: Regret-Adaptive Beam Scheduler**\n- **Implementation**: Multi-stage metaheuristic combining regret-adaptive beam construction with memoized best-two insertion (LRU caches for sequence cost and insertion), exact endgame DFS branch-and-bound, VND local refinement (reinsertion/or-opt, adjacent swaps, sampled 2-opt with don't-look bits), ILS/LNS ruin-and-repair, and elite pool with path relinking. Position sampling with stable signatures improves cache hit rates; parameters adapt to num_seqs (10 here) and the solver auto-finds the repo root for imports.\n- **Performance**: Achieved a combined score of 4.35 across 3 workloads (300 transactions), generating valid schedules and passing all validation tests.\n- **Feedback**: Memoization plus regret-guided construction reduced expensive evaluations and enabled deeper search; exact endgame and path relinking improved final makespan robustness. Further gains likely from tuning the beam/regret mix, cache sizes, and seeding randomness for reproducibility.\n**Program Identifier:** Generation 82 - Patch Name regret_beam_bnb_lns_vnd - Correct Program: True\n\n**Program Name: Regret-Guided GRASP-Beam-VND Scheduler**\n- **Implementation**: Hybrid pipeline combining regret-diverse GRASP construction, insertion-based beam search with one-step lookahead and suffix-2 diversity, and VND (Or-opt 3/2/1, adjacent swaps, sampled pair swaps/segment reversals) with regret-guided LNS and a final Or-opt(1) polish. Uses an LRU-cached evaluator and an EpisodeContext that caches best-two insertion positions with deterministic position sampling, plus an endgame branch-and-bound finisher; parameters adapt to instance size and search effort.\n- **Performance**: Achieved combined score 4.27 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Best-two insertion caching and regret/diversity-guided beam expansions likely drive both solution quality and speed, while deterministic seeding improves reproducibility for evaluation. Endgame BnB helps on small remainders, and adaptive sampling/caching choices balance runtime and memory.\n**Program Identifier:** Generation 83 - Patch Name endgame_bnb_completion - Correct Program: True\n\n**Program Name: Hybrid Regret-Beam Transaction Scheduler**\n- **Implementation**: Hybrid metaheuristic combining GRASP, regret-adaptive beam search, bounded endgame BnB, VND (block-aware Or-opt), LNS (sensitivity+marginal), and bidirectional path relinking. Uses a unified best-two insertion memo with LRU (40k), golden-ratio stratified position sampling, and a suffix-3-diverse elite pool.\n- **Performance**: Achieved combined score 4.22 on 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoized best-two evaluations and stratified position sampling significantly reduced cost evaluations, enabling deeper search within time. Endgame BnB and relinking consistently improved partial solutions to high-quality schedules, while diversity controls mitigated premature convergence.\n**Program Identifier:** Generation 86 - Patch Name regret_bnb_lru - Correct Program: True\n\n**Program Name: Memetic GA for Transaction Scheduling**\n- **Implementation**: Uses Order Crossover (OX), adaptive swap/insert/2-opt mutations, and an embedded VND (Or-opt 1\u20133, adjacent swaps, sampled 2-opt) with tournament selection, elitism, and stagnation-triggered immigrant injection. Population is greedily seeded and random, evaluation is memoized, and parameters (population size, mutation/LS rates) adapt to problem size with increased late-phase local search.\n- **Performance**: Achieved combined score 4.22 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: The hybrid GA+VND with greedy seeding and caching accelerates convergence and improves makespan, while immigrant injection and duplicate avoidance maintain diversity. Reproducible seeding and permutation integrity checks contribute to stable, correct schedules across runs.\n**Program Identifier:** Generation 45 - Patch Name memetic_ga_ox_vnd - Correct Program: True\n\n**Program Name: Deterministic GRASP\u2013Beam VND/LNS Scheduler**\n- **Implementation**: Pipeline combines regret-based GRASP construction, dispersion-adaptive beam search with suffix-3 diversity, strong VND (Or-opt, non-adjacent swaps, sampled 2-opt), sensitivity-guided LNS, and bidirectional path relinking. Episode-level caches (cost and best-two insertion with deterministic position sampling via anchors/golden-ratio) reduce evaluations; adaptive budgets, endgame widening, and bounded DFS complete partial beams.\n- **Performance**: Achieved a combined score of 4.33 across three workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Deterministic memoization and position sampling noticeably cut simulator calls and stabilize search, while beam diversity and regret weighting improve exploration. VND/LNS reliably polish GRASP/beam seeds, and path relinking adds incremental gains among elites.\n**Program Identifier:** Generation 78 - Patch Name insertion_beam_endgame_dfs - Correct Program: True\n\n**Program Name: Hybrid Consensus\u2011Regret Beam Scheduler**\n- **Implementation**: Hybrid pipeline combining consensus\u2011regret GRASP construction, dispersion\u2011adaptive beam search, VND (Or\u2011opt 3/2/1, adjacent/non\u2011adjacent swaps, 2\u2011opt), consensus\u2011guided LNS ruin\u2011repair, path relinking, and endgame branch\u2011and\u2011bound with a transposition table (suffix\u20112 key). Uses adaptive parameters by problem size and aggressive LRU memoization for best\u2011two single insertions and block reinsertions with position sampling to cut cost evaluations.\n- **Performance**: Combined score to maximize: 4.20 across 3 workloads (300 transactions); produced valid schedules and passed all validation tests.\n- **Feedback**: Caching plus sampled insertion positions reduce simulator calls, while consensus guidance and exact endgame BnB improve final makespan quality. The elite pool\u2019s consensus ranking and suffix\u2011based deduplication balance diversification and intensification, contributing to robust results under the given compute budget.\n**Program Identifier:** Generation 84 - Patch Name bnb_and_block_repair_upgrade - Correct Program: True\n\n**Program Name: Regret-Guided Beam + LNS Scheduler**\n- **Implementation**: Builds schedules via regret-guided insertion beam search with adaptive 1-step lookahead, suffix-2 diversity, and endgame branch-and-bound completion (K-limited with node cap). It memoizes sequence costs and caches best/second-best insertion positions with deterministic position sampling (LRU-pruned), then intensifies with Or-opt/adjacent/pair-swap/reversal local search, iterated perturbations, LNS destroy/repair, and elite path relinking.\n- **Performance**: Achieved combined score 4.39 across three workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and deterministic position sampling reduced cost evaluations, enabling deeper beam/LNS exploration without large runtime. Suffix diversity, elite pool management, and exact endgame completion improved solution quality by preventing beam collapse and tightening endgame makespan.\n**Program Identifier:** Generation 85 - Patch Name endgame_branch_and_bound - Correct Program: True\n\n**Program Name: MCTS Transaction Scheduler with Endgame BnB and Polish**\n- **Implementation**: Uses MCTS with PUCT and progressive widening, deriving softmax priors from immediate append costs and epsilon-greedy rollouts. A bounded branch-and-bound exact endgame (\u22649 tasks) with a transposition table is followed by suffix BnB, sparse Or-Opt(1), and adjacent swaps, with all sequence evaluations memoized.\n- **Performance**: Achieved combined score 3.23 across 3 workloads (300 transactions), passing all validation tests.\n- **Feedback**: Exact endgame plus suffix optimization improved makespan quality, while progressive widening, node caps, and cached evaluations kept runtime controlled; deterministic seeding provided reproducible yet diverse search. Schedules were valid and unique for all workloads, indicating robustness of the approach.\n**Program Identifier:** Generation 87 - Patch Name mcts_bnb_suffix_opt - Correct Program: True\n\n**Program Name: Block-Aware Best-Two Transaction Scheduler**\n- **Implementation**: Uses best-two insertion memoization (single and block) with deterministic position signatures and a cost cache to drive a regret-adaptive insertion beam enhanced by elite median-rank misalignment and suffix-3 diversity. Refinement combines bounded endgame BnB with a transposition table, VND (best-two\u2013guided Or-opt/adjacent swaps/2-opt), sensitivity-guided LNS ruin-repair, and bidirectional block-aware path relinking; parameters adapt to problem size with deterministic seeding.\n- **Performance**: Achieved combined score 4.31 across 3 workloads (300 transactions total) and passed all validation tests.\n- **Feedback**: Memoization plus adaptive position sampling reduced cost evaluations, enabling deeper search and consistent improvements; endgame BnB and LNS reliably polished beam results. Suffix-3 elite diversity and median-rank misalignment improved exploration and mitigated premature convergence while keeping runs reproducible.\n**Program Identifier:** Generation 90 - Patch Name blockwise_regret_bnb - Correct Program: True\n\n**Program Name: Conflict-Aware Surrogate Transaction Scheduler**\n- **Implementation**: Uses a pairwise precedence oracle to estimate orientation advantages and surrogate-pruned best-two insertion with LRU-cached sequence costs. Construction is via regret-adaptive beam search with exact endgame BnB, then refined by surrogate-guided VND (Or-opt/reinsertion/2-opt), Iterated Local Search, LNS ruin-and-repair, and path relinking over an elite set; parameters adapt to num_seqs.\n- **Performance**: Achieved combined score 4.39 on three workloads (300 transactions), passing all validation tests.\n- **Feedback**: Surrogate position pruning and best-two caching substantially reduce expensive evaluations while maintaining quality, and regret-aware diversification stabilizes construction. Exact endgame plus VND/LNS/path-relinking consistently improve makespan, though overall efficiency still hinges on seq_cost call performance and cache effectiveness.\n**Program Identifier:** Generation 91 - Patch Name pairwise_conflict_beam_lns - Correct Program: True\n\n**Program Name: Regret-beam LNS transaction scheduler**\n- **Implementation**: Combines a regret-adaptive beam insertion with 1-step lookahead, a unified best-two insertion cache with deterministic position policies, bounded endgame branch-and-bound, and VND (Or-opt 1/2/3, swaps, 2-opt), augmented by LNS destroy/repair and bidirectional path relinking; extensive memoization (sequence costs, insertion results, position policies) and suffix-diverse elite management are used to guide search.\n- **Performance**: Achieved a combined score of 0.0 and failed validation tests.\n- **Feedback**: Likely fragility stems from unseeded randomness (non-deterministic search) and brittle repository path discovery, which can cause inconsistent results or import failures; enforce deterministic sampling (fixed seeds), harden import/path logic, and verify output consistency and schedule validity to satisfy tests.\n**Program Identifier:** Generation 92 - Patch Name conflict_aware_regret_vnd_bnb - Correct Program: False\n\n**Program Name: Hybrid Regret/VND/ILS-LNS Transaction Scheduler**\n- **Implementation**: Uses regret-guided best-two insertion with memoized cost evaluations and deterministic position sampling. Refines solutions via VND (adjacent swaps, Or-opt 1\u20133, sampled 2-opt), ILS perturbations, LNS destroy/repair, elite maintenance with path relinking, and a bounded branch-and-bound endgame; parameters adapt to problem size.\n- **Performance**: Achieved combined score 4.37 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoized \u201cbest-two\u201d insertion and deterministic position signatures reduce cost evaluations and enable reuse across neighborhoods, while exact endgame enumeration improves final makespan. Beam diversification and path relinking add robustness; main overheads are cache growth and Python-level loops, mitigated by adaptive caps and sampling.\n**Program Identifier:** Generation 94 - Patch Name best_two_block_and_path_relink_upgrade - Correct Program: True\n\n**Program Name: Hybrid LNS-ILS Transaction Scheduler**\n- **Implementation**: Uses a regret-based best-insertion beam constructor with memoized cost evaluations and deterministic position sampling, plus an endgame branch-and-bound with a small transposition table for exact completion on small subsets. Refinement combines VND (Or-opt 3/2/1), limited adjacent swaps, sampled 2-opt, iterated local search perturbations, LNS destroy-repair, and elite maintenance with suffix-based diversity and path relinking.\n- **Performance**: Achieved a combined score of 4.33 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Caching (cost and best-two insertions) and the exact endgame sharply reduce evaluations and improve convergence, while beam/regret and elite diversity controls mitigate premature convergence. Stochastic components introduce run-to-run variance, partially stabilized by deterministic sampling in insertion evaluation.\n**Program Identifier:** Generation 97 - Patch Name endgame_bnb_pruning - Correct Program: True\n\n**Program Name: Regret-beam LNS scheduler**\n- **Implementation**: Adaptive regret-based beam constructor with LRU-cached best-two insertion (single and block), endgame branch-and-bound with memoization, and a VND local search (Or-opt, adjacent swaps, sampled 2-opt); wrapped in ILS, LNS ruin-and-repair, and elite path relinking. Includes dynamic hyperparameters and seeding from singleton costs; loads workloads via a custom repository path finder.\n- **Performance**: Combined score 0.0; program failed validation tests.\n- **Feedback**: Brittle repository path resolution and nondeterministic search likely caused test failures; additionally, insertion-oracle cache keys ignore focus_idx/k_override, leading to incorrect reuse of sampled-position results. Endgame enumeration does not use the current global best for pruning, hurting efficiency.\n**Program Identifier:** Generation 73 - Patch Name regret_beam_bnb_vnd - Correct Program: False\n\n**Program Name: Memetic GA with BnB Tail for Txn Scheduling**\n- **Implementation**: Memetic GA using order/position crossovers, swap/relocate/scramble mutations, and a light VND (Or-opt(2\u21921), adjacent/pair swaps, 2-opt) around a cached evaluator. It employs adaptive parameters, an elite pool with Borda-consensus parent injection, a suffix-2 diversity filter, and a bounded endgame BnB on the last K tasks using a transposition table and node cap.\n- **Performance**: Achieved combined score 4.17 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Most gains stem from the VND plus BnB tail refinement; caching and stratified position sampling cut evaluation cost while keeping quality high. Diversity control and consensus injection reduce premature convergence without noticeably increasing runtime.\n**Program Identifier:** Generation 79 - Patch Name memetic_bnb - Correct Program: True\n\n**Program Name: Hybrid Regret-LNS Transaction Scheduler**\n- **Implementation**: Builds schedules with regret-based best-insertion using memoized cost evaluations and a diversity-aware beam, then refines via VND (Or-opt 3/2/1, adjacent swaps, sampled 2-opt), iterated local search, large-neighborhood destroy/repair, endgame branch-and-bound, and elite path relinking. Insertion evaluations use deterministic position sampling and caching; parameters adapt to workload size and search breadth.\n- **Performance**: Achieved a combined score of 4.27 across 3 workloads (300 transactions), producing valid schedules and passing all validation tests.\n- **Feedback**: Memoization and deterministic sampling reduced repeated evaluations and stabilized outcomes, while endgame enumeration and path relinking improved tail optimality. Adaptive exploration/exploitation (e.g., regret_prob=0.65 and mixed beam selection) likely contributed to the strong makespan results at num_seqs=10.\n**Program Identifier:** Generation 81 - Patch Name endgame_branch_and_bound - Correct Program: True\n\n**Program Name: MCTS Scheduler with Progressive Widening**\n- **Implementation**: Uses MCTS with progressive widening and UCB over normalized rewards, cache-backed cost evaluation, epsilon-greedy top-k rollouts with one-step lookahead scoring, and light local search (adjacent swaps and restricted Or-opt-1) for polish. Iteration budget scales by problem size and num_seqs; deterministic seeding ensures reproducible yet diverse rollouts.\n- **Performance**: Achieved combined score 3.61 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Cost caching and progressive widening effectively reduced branching and recomputation, while limited polish delivered incremental makespan gains without heavy overhead. Reward normalization stabilized value estimates for UCB, and the lookahead-weighted action scoring improved early expansion choices.\n**Program Identifier:** Generation 88 - Patch Name mcts_progressive_widening_scheduler - Correct Program: True\n\n**Program Name: Regret-augmented beam and LNS scheduler**\n- **Implementation**: Uses memoized best-two insertion with LRU caches and deterministic position sampling inside a regret+lookahead beam builder with suffix-diversity; completes small remainders via exact DFS branch-and-bound with a transposition table. Quality is improved by VND (reinsertion/or-opt, swaps, 2-opt with don\u2019t-look bits), ILS/LNS ruin\u2013repair, elite management, and path relinking; parameters adapt to num_seqs.\n- **Performance**: Combined score to maximize: 4.37; produced valid schedules for 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Best-two memoization and deterministic position policies increased cache hits and stability, while exact endgame search and blended scoring improved late-stage quality. Path relinking and LNS added effective intensification/diversification; further tuning of beam width/alpha and cache capacities may yield additional gains on larger workloads.\n**Program Identifier:** Generation 89 - Patch Name txn_sched_beam_lookahead_vnd_lns_pr - Correct Program: True\n\n**Program Name: Regret-beam VND/LNS transaction scheduler with caching**\n- **Implementation**: Uses a shared episode context with memoized cost and best-two insertion evaluations plus deterministic position sampling. Constructs schedules via regret-driven GRASP and insertion-based beam search with lookahead/diversity and BnB endgame, then refines with strong VND, sensitivity-guided LNS, bidirectional path relinking, elite suffix-3 diversity, and a final 1-block reinsertion polish.\n- **Performance**: Achieved a combined score of 4.39 across 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and deterministic sampling reduced simulator calls, enabling deeper exploration (beam) and effective exploitation (VND/LNS) within time budgets. Endgame branch-and-bound and elite path relinking contributed to consistent makespan improvements across workloads.\n**Program Identifier:** Generation 93 - Patch Name bnb_endgame_pruning - Correct Program: True\n\n**Program Name: Regret-Beam ILS/LNS Transaction Scheduler**\n- **Implementation**: Uses regret-guided beam insertion with deterministic position sampling and global memoization (cost and best-two caches), plus bounded endgame BnB; then applies VND (reinsertion/or-opt/2-opt with don't-look bits), ILS perturbations, LNS destroy-repair, and elite path relinking with suffix-diversity control.\n- **Performance**: Achieved combined score 4.39 (to maximize) across 3 workloads (300 transactions) with valid schedules; all validation tests passed.\n- **Feedback**: Memoization and seeded sampling reduced recomputation and stabilized search, while exact endgame and path relinking improved final makespan quality; adaptive beam quotas and elite diversity helped exploration without notable runtime spikes.\n**Program Identifier:** Generation 95 - Patch Name besttwo_endgame_vnd_pr - Correct Program: True\n\n**Program Name: Hybrid Beam-LNS Scheduler with Caching and BnB**\n- **Implementation**: Uses a consensus-regret GRASP constructor feeding a dispersion-adaptive beam search with lookahead, backed by LRU \u201cbest-two\u201d insertion and block-reinsertion memos plus adaptive position sampling and an elite-based consensus. Improves solutions via VND (Or-opt, adjacent/non-adjacent swaps, 2-opt), consensus-guided LNS repair, path relinking, and an endgame BnB with a time budget.\n- **Performance**: Achieved combined score 4.26 across 3 workloads (300 transactions), passing all validation tests.\n- **Feedback**: Memoization and consensus-guided focusing reduce cost evaluations and help the beam/LNS converge to lower makespans, while the bounded BnB suffix optimization reliably tightens endgame quality without hurting runtime stability. Adaptive parameterization (size-aware caps and efforts) balances exploration and exploitation across small to large instances.\n**Program Identifier:** Generation 96 - Patch Name bnb_greedy_insert_relink_block_and_cache_bump - Correct Program: True\n\n**Program Name: Deterministic memoized GRASP-Beam-LNS scheduler**\n- **Implementation**: Integrates deterministic position-sampled regret-insertion with reusable best-two memoization (for single and block insertions) and a suffix-diverse, dispersion-adaptive beam search with endgame widening and bounded DFS completion. Augmented by strong VND (Or-opt, adjacent/non-adjacent swaps, sampled 2-opt under DLB), sensitivity-guided LNS with stagnation escalation and micro-polish, and bidirectional path relinking; shared cost/best-two caches and size-adaptive parameters drive efficiency.\n- **Performance**: Achieved combined score 4.27 across 3 workloads (300 transactions total), producing valid schedules and passing all validation tests.\n- **Feedback**: Deterministic position sampling plus cross-module memoization substantially reduced evaluations and stabilized results; suffix-3 diversity and dispersion-aware scoring improved exploration and avoided premature convergence. The orchestrated pipeline (GRASP seeds, beam, relinking, LNS+VND) yielded consistent improvements with modest time budgets.\n**Program Identifier:** Generation 98 - Patch Name best_two_block_endgame_bnb_focus - Correct Program: True\n\n**Program Name: Hybrid Regret-LNS Transaction Scheduler**\n- **Implementation**: Uses regret-based best-insertion with memoized best-two insertion evaluation and deterministic stratified position sampling, followed by VND local refinement (adjacent swaps, Or-opt 1\u20133, sampled 2-opt), ILS perturbations, LNS destroy/repair, and elite path relinking. Adds an exact branch-and-bound endgame for small remainders and maintains a diversity-aware elite pool.\n- **Performance**: Combined score to maximize: 4.37; produced valid schedules for 3 workloads (300 transactions) and passed all validation tests.\n- **Feedback**: Memoization and deterministic sampling substantially reduce cost evaluations and stabilize search, while endgame enumeration improves final makespan quality. Diversity-controlled elites and path relinking provide additional improvements without noticeable instability.\n**Program Identifier:** Generation 99 - Patch Name endgame_besttwo_and_stronger_2opt - Correct Program: True",
  "meta_scratch_pad": "## Successful Algorithmic Patterns\n- Deterministic best-two insertion with cross-phase memoization is the decisive driver at the top end. The current best program (Combined score 4.41) caches (best_cost, best_pos, second_best) per (tuple(seq), txn, use_all_pos) and uses deterministic anchors plus suffix-seeded interior positions, reusing these results across beam construction, LNS repair, and endgame enumeration. Similar memoized best-two designs in the 4.39 group\u2014Regret-beam VND/LNS transaction scheduler with caching (4.39), Regret-Beam ILS/LNS Transaction Scheduler (4.39), and bnb_endgame_pruning (4.39)\u2014consistently reduced simulator calls and stabilized quality.\n- Exact endgame completion via bounded BnB, ordered by regret, closes the last gap. The 4.41 leader enumerates \u22649 remaining tasks with branch-and-bound and reuses this inside LNS when the destroyed set is small; this exact tail finisher underpins the 4.39\u20134.37 cohort as well (e.g., endgame_branch_and_bound at 4.27 and endgame_besttwo_and_stronger_2opt at 4.37), explaining the step up from lighter or absent endgame handling.\n- Small regret-adaptive beams with suffix diversity prevent collapse and balance exploration/exploitation. The best program mixes by-cost and by-regret selection with a ~30% regret quota and suffix-2 diversity; the same beam pattern appears in the 4.39 cluster and the 4.37\u20134.26 variants (e.g., txn_sched_beam_lookahead_vnd_lns_pr at 4.37, bnb_greedy_insert_relink_block_and_cache_bump at 4.26), correlating with higher scores than non-beam approaches.\n- Layered refinement (VND + ILS + LNS + path relinking) consistently polishes solutions. The 4.41 leader\u2019s VND (adjacent swaps, Or-opt 1\u20133, sampled 2-opt), ILS perturbations, sensitivity-guided LNS with endgame reuse, and displacement-based path relinking mirrors the primary post-construction improvers cited in the 4.39 and 4.37 implementations.\n\n## Ineffective Approaches\n- Fragile engineering and nondeterminism cause outright failure. The Regret-beam LNS scheduler (0.0, failed validation) suffered from brittle repository path resolution and nondeterministic search, plus an insertion-oracle cache that ignored focus_idx/k_override in its keys, leading to incorrect reuse. In contrast, the 4.41 best includes robust repo-root discovery and deterministic position sampling to keep caches sound.\n- Heavy MCTS overhead under fixed budgets underperforms. MCTS Scheduler with Progressive Widening (3.61) paid for tree machinery (UCB, PW, rollouts) while only modestly polishing with local search; the overhead diluted the benefits from caching and endgame optimization relative to regret-beam constructors.\n- GA-centric search converges slower than regret-beam builders. The Memetic GA with BnB Tail (4.17) leveraged VND and a bounded BnB suffix to reach valid schedules, but it lagged the 4.26\u20134.41 regret-beam family due to slower convergence and weaker construction quality under the same time budgets.\n\n## Implementation Insights\n- What makes the 4.41 best effective:\n  - Best-two insertion cache keyed by (sequence, txn, use_all_pos) plus deterministic anchors and suffix-seeded interior sampling maximizes cache hits and ensures reuse across beam, LNS, and endgame. Since best_two_insertion is only called without focus_idx/k_positions, the cache key remains sound and avoids the incorrect reuse bug seen in the failing 0.0 program.\n  - Endgame BnB is tightly integrated: \u22649 remaining tasks, regret-ordered branching, and reuse inside LNS when destroyed sets are small. This deeper integration aligns with the +0.02 edge over the 4.39 cohort that also employ endgame completion.\n  - Beam selection mixes exploitation (by-cost rank) with exploration (regret quota) and suffix-2 diversity, preventing beam collapse into clones\u2014a pattern repeatedly cited in the 4.39\u20134.37 schedulers.\n  - A compact refinement stack (adjacent swaps, Or-opt 1\u20133, sampled 2-opt) plus ILS/LNS and displacement-based path relinking provides most of the final gains with controlled overhead; similar stacks are credited in txn_sched_beam_lookahead_vnd_lns_pr (4.37), besttwo_endgame_vnd_pr (4.39), and bnb_endgame_pruning (4.39).\n- Robustness patterns that matter:\n  - Deterministic seeding of position sampling and robust repository root discovery prevent flakiness. The 4.41 best includes multiple root fallbacks and deterministic interior sampling, in contrast with the 0.0 failure\u2019s brittle path resolution and nondeterministic search that broke validation.\n  - Exact positions for small sequences and use_all_pos for small remainders improve accuracy where it matters, while sampled positions control cost elsewhere; this trade-off appears across top programs and supports both construction and endgame efficiency.\n\n## Performance Analysis\n- The 4.41 leader confirms the regret-beam + deterministic best-two + exact endgame pattern as best-in-class. Its small edge over the 4.39 group is consistent with tighter endgame reuse during LNS and deterministic best-two reuse during rebuilds.\n- Programs clustering at 4.39 (Regret-beam VND/LNS with caching; Regret-Beam ILS/LNS Transaction Scheduler; bnb_endgame_pruning) share the same core mechanics\u2014memoized best-two insertion, suffix-diverse beams, exact endgame, and layered refinement\u2014indicating the approach\u2019s robustness across implementations.\n- Strengthening endgame and best-two usage shows clear score lifts within the same family. The Hybrid Regret-LNS Transaction Scheduler rose from 4.27 (endgame_branch_and_bound) to 4.37 (endgame_besttwo_and_stronger_2opt) after adding stronger 2-opt and best-two reuse, quantifying the impact of more thorough tail optimization and better insertion oracles.\n- Non-regret constructors trail under the same budgets: GA-based (4.17) and MCTS (3.61) variants lag the 4.26\u20134.41 regret-beam cohort despite endgame and caching, underscoring that regret-driven insertion beams with deterministic best-two memoization and exact endgame completion deliver the most consistent makespan reductions given the available time.",
  "meta_recommendations": "1. Extend best-two memoization to blocks and reuse it in VND and path relinking\n   - Implement best_two_block(base_seq, block, use_all_pos=False, k_positions=None) \u2192 (best_cost, best_pos, second_best_cost) and cache by (tuple(base_seq), tuple(block), use_all_pos, pos_sig), where pos_sig is a deterministic signature of the probed positions (anchors + suffix-seeded interior). Replace the inner loops in try_reinsertion and try_or_opt with a single call to best_two_insertion/best_two_block per (item/block, base), and in path_relink choose the insertion position via best_two_insertion instead of forcing target index. This mirrors the 4.41 pattern, slashes simulator calls during VND/PR, and sharpens regret guidance across neighborhoods.\n\n2. Make the construction beam regret-adaptive, suffix-deterministic, and late-diverse\n   - At each layer, compute regret dispersion over expansions (std/mean of second \u2212 best); if high (>0.6), set high_regret_quota_ratio=0.5 and rank by 0.5*best + 0.5*regret, else keep 0.3 and 0.8*best + 0.2*regret. Seed candidate txn sampling deterministically with rng = random.Random(hash((tuple(seq[-10:]), layer, len(rem))) & 0xffffffff) and, when remaining <= 2\u00d7local_beam_width, widen the beam by +2, switch diversity_suffix_k from 2 to 3, and flip use_all_pos=True for positions. This increases cache hits, prevents beam collapse, and aligns with the top programs\u2019 stable construction behavior.\n\n3. Tighten endgame branch-and-bound with bounded expansions and a small transposition table\n   - Add a node cap ~3000 in endgame_optimal_completion and a transposition table keyed by (frozenset(remaining), tuple(prefix_seq[-3:])) storing the best partial cost seen; prune when revisiting with \u2265 best. Order branches by higher regret then lower best insertion cost, and allow K to rise to 10 so long as the node cap isn\u2019t hit; if the cap is exceeded, fall back to greedy best-two completion for predictability. Reuse this bounded BnB inside LNS when the removed set is small, matching the decisive exact-tail integration seen in the 4.41\u20134.39 cohort.\n\n4. Upgrade VND with true 2-opt segment reversals, don\u2019t-look bits, and best-two\u2013guided reinsertion/Or-opt\n   - Replace the current sampled swap with proper 2-opt segment reversals: sample S=min(200, n) pairs (i<j), evaluate reversing seq[i:j+1], accept first improvement, and maintain don\u2019t-look bits per index, resetting only around improved segments. For reinsertion and Or-opt(2,3), call best_two_insertion/best_two_block once per (item/block) using deterministic pos_sig instead of iterating positions, and stop at first improvement; this keeps the search fast via memo reuse and provides the stronger polishing that lifted similar programs from 4.27 to 4.37.\n\n5. Strengthen LNS and path relinking with structure-aware destroys, regret-biased repairs, and post-PR polish\n   - Add destroy operators beyond random/block: (a) k-regret removal (highest current regret = second \u2212 best), and (b) displacement-biased removal vs the elite best; choose operator and items via suffix-seeded RNG for determinism. During repair, interleave picks by best and by regret (e.g., alternate steps or set regret_prob via dispersion), invoke the bounded endgame BnB when |removed| <= K, and make path relinking bidirectional (source\u2192target and target\u2192source) choosing positions via best_two_insertion; cap moves at min(16, n//6). After each relink, run a quick LNS polish destroying ~8% of items with suffix-3 diversity to extract incremental gains.",
  "meta_recommendations_history": [
    "1. Enhance beam selection with regret-weighted diversity and duplicate pruning\n   - In the expansion ranking, select primarily by cost but include a small quota (e.g., 20\u201330% of beam width) of high-regret candidates even if their cost is slightly worse. Enforce diversity by suffix signature (last-2 elements) instead of only the last element, and keep a per-iteration set of seen sequences (tuple(seq)) to prune duplicates before sorting. This preserves strong selection pressure while broadening exploration where regret signals high opportunity.\n\n2. Add a ruin-and-recreate LNS step using regret-guided reinsertion\n   - Between local_refine and ILS iterations, remove a subset of transactions (e.g., k = 8\u201315 or 5\u201310% of n), chosen either as a random contiguous segment and a few high-variance positions, then rebuild the partial using the existing regret-guided insertion over a small beam. Run 2\u20133 such LNS iterations per best solution found, followed by the existing local_refine. This leverages your strongest constructor to escape deeper local minima than simple segment reversals.\n\n3. Upgrade local search to VND with Or-opt blocks and don\u2019t-look bits (DLB)\n   - Extend reinsertion moves to Or-opt of block sizes 1, 2, and 3 in a deterministic best-improvement pass, then adjacent swaps, then sampled pair swaps, then segment reversals. Maintain DLB: track indices (or blocks) with no improving moves in the last pass and skip them until a neighboring change occurs, which speeds convergence and enables deeper neighborhoods without large runtime. Stop the VND loop only after a full cycle across all neighborhoods with no improvement.\n\n4. Make sampling and beam widths adaptive to construction progress and stagnation\n   - When len(rem) <= T (e.g., T = 2\u00b7local_beam_width), evaluate all candidate transactions and all insertion positions (k_pos_sample = len(seq)+1) and widen local_beam_width by +1\u20132 to avoid endgame myopia. If no improvement in the last two construction layers, temporarily increase k_txn_sample (e.g., +50%) for one layer to diversify. Similarly, scale local_refine sampling counts with n and restart them at higher values after two non-improving ILS perturbations.\n\n5. Strengthen seed diversification with GRASP-style constructed seeds and path relinking\n   - In addition to elite singletons and a few random seeds, generate 2\u20133 GRASP seeds via randomized regret-guided insertion (alpha-greediness: pick among top-m candidates by cost/regret) and pass them through a quick local_refine. After refining the top-2\u20133 solutions from different seeds, perform path relinking: iteratively transform one sequence toward the other using the best-improving move at each step, then refine the intermediate. This recombination has shown strong synergy with diversified starts and rich local search.",
    "1. Make beam lookahead and diversity adaptive to layer regret\n   - In beam_search, replace the fixed 0.7/0.3 lookahead mix with a regret-aware blend: if (max(second_costs) - min(second_costs)) > \u03c4 (e.g., \u03c4 = median regret in the layer), score = 0.5*c1 + 0.5*best_c2; otherwise use 0.8*c1 + 0.2*best_c2. Additionally, when remaining <= 2*beam_width, increase beam_width by +2 and raise diversity_quota from 25% to 40% to avoid myopic endgame convergence. This builds directly on the current lookahead and suffix-2 diversity that have proven effective.\n\n2. Extend VND with sampled 2-opt and non-adjacent pair swaps under DLB\n   - After Or-opt (1\u20133) and adjacent swaps, add two neighborhoods: (a) sampled 2-opt segment reversals over up to S = min(200, n) pairs (i, j) with j - i >= 2; (b) sampled non-adjacent pair swaps over up to S pairs chosen to be at least 2 apart. Use best-improvement with DLB keyed by segment start index (and length bucket) and reset bits only near modified regions. This deepens the local refinement stack that\u2019s been a key differentiator for top performers.\n\n3. Make LNS removals regret/sensitivity-guided, with stagnation escalation\n   - Before choosing scattered removals, score K sampled indices (e.g., K = min(20, n)) by \u201cmove sensitivity\u201d: for each index i, evaluate the variance of eval_cost after moving that element to P sampled positions (e.g., P = 6); select top-k_high (e.g., 30\u201350% of k_remove) by highest variance. Keep one contiguous block as in the current code, and fill the rest with these high-sensitivity positions; if two LNS rounds don\u2019t improve, escalate k_remove by +25% and allow two blocks. This leverages regret/sensitivity signals that improved construction to also guide ruin, increasing escape power.\n\n4. Upgrade path relinking to bidirectional, block-aware relinking with elite diversity control\n   - For each elite pair, perform both A\u2192B and B\u2192A relinking, moving either a single element or the longest consecutive block that matches target order at each step, and keep the best intermediate at each move. After each move, run a single Or-opt(1) pass for quick polishing, then apply vnd_local_search(max_rounds=1) only to the best few intermediates. Maintain elite diversity by enforcing last-3 suffix uniqueness when adding to elites to promote complementary templates for future relinking.\n\n5. Improve insertion-position sampling and reuse best-two computations across phases\n   - Replace purely random interior sampling in sample_positions with stratified picks: always include [0, mid, n, quartiles], plus up to R random interiors (R = pos_sample_cap - fixed points), ensuring deterministic order. Cache best_two_insertions per (tuple(seq), txn) within a construction/LNS episode to reuse when the same prefix recurs during GRASP, beam expansion, and LNS reinsertion; invalidate only when the prefix changes. When len(rem) <= 2*beam_width, evaluate all positions (no sampling) to maximize endgame precision, consistent with observed gains from deterministic sampling and caching.",
    "1. Add reusable best-two insertion caching with stratified position sampling across construction and LNS\n   - Maintain a dict best_two[(tuple(seq), txn)] -> (best_cost, best_pos, second_cost) within a build/LNS episode; reuse it in regret_insertion_build and LNS repair to avoid recomputing per (seq, t). Replace purely random interior positions with a deterministic set: [0, n//4, n//2, 3n//4, n] plus up to R random interiors (fixed order), and when len(rem) <= 2*local_beam_width or len(seq) <= 20, evaluate all positions. This directly mirrors top performers\u2019 gains from precise regret modeling and caching (Gen 21, 17, 16).\n\n2. Make beam selection adaptive to regret dispersion and endgame, with stronger diversity late\n   - During expansion, compute median regret in the layer; if regret spread is high (e.g., max(second-best) \u2212 min(second-best) > median_regret), score = 0.5*best_cost + 0.5*second_best; else 0.8*best_cost + 0.2*second_best. When remaining <= 2*local_beam_width, set local_beam_width += 2, raise high_regret_quota_ratio from 0.3 to 0.4, and increase diversity_suffix_k to 3; switch to all-position evaluation. This follows the effective lookahead + suffix-k diversity patterns and endgame exhaustiveness that pushed Gen 21 to 4.37.\n\n3. Upgrade VND: implement true sampled 2-opt (segment reversal) and non-adjacent pair swaps under DLB\n   - Add a neighborhood that samples up to S = min(200, n) pairs (i, j) with j - i >= 2 and applies segment reversal (true 2-opt), plus a separate sampled swap of non-adjacent pairs (j - i >= 2). Use don\u2019t-look bits per index (and length buckets for 2-opt) to skip stable regions, resetting bits only near improved segments; keep best-improvement passes and limit to 1\u20132 rounds per outer loop. This deepens the local refinement stack in line with high-scoring VND variants (Gen 21/17) and fixes the current \u201c2-opt\u201d that is only a random pair swap.\n\n4. Sensitivity-guided LNS destroys with stagnation escalation and quick polish\n   - Before scattered removals, score K = min(20, n) sampled indices by move sensitivity: for each i, move txn i to P = 6 sampled positions, compute the variance of seq_cost, and pick top \u23080.4\u00b7m\u2309 indices for removal (keep one contiguous block for the rest). If two consecutive LNS attempts fail, increase m by 25% and allow two contiguous blocks; after regret-based repair, run a single light VND pass (reinsertion + one 2-opt sample). This leverages regret/sensitivity signals (as in Gen 21\u2019s construction) to improve ruin-and-recreate effectiveness.\n\n5. Bidirectional, block-aware path relinking with on-the-fly micro-polishing and elite diversity control\n   - For each elite pair, perform both A\u2192B and B\u2192A relinking: at each step move either a single item or the longest consecutive block already matching the target order (choose the move that maximally reduces displacement/Kendall distance), keeping the best intermediate. After each move, run a fast Or-opt(1) pass; apply full vnd_local_search(max_rounds=1) only to the top 2\u20133 intermediates per path. Maintain elite suffix-3 uniqueness and admit improved intermediates to the pool, reflecting the relinking + elite diversity gains seen in Gen 21/29/31.",
    "1. Add reusable best-two insertion memoization with deterministic, stratified position sampling across construction and LNS repair\n   - Maintain best_two_cache[(tuple(seq), t, pos_sig)] -> (best_cost, best_pos, second_cost), where pos_sig = ('all', len(seq)) when evaluating all positions or a deterministic tuple from position_samples; reuse entries in regret_insertion_build and lns_attempt. Replace random positions with a deterministic set: anchors [0, n//4, n//2, 3n//4, n], a small ring around focus_idx (\u00b11..\u00b13 bounded), and a fixed low-discrepancy sequence of interiors; when len(rem) <= 2*local_beam_width or len(seq) <= 20, evaluate all positions.\n\n2. Make beam selection adaptive to regret dispersion and endgame, with stronger suffix diversity late\n   - During expansion, compute dispersion = max(second_best) \u2212 min(second_best) for the layer; if dispersion > median(second_best), rank by 0.5*best_cost + 0.5*second_best, else 0.8*best_cost + 0.2*second_best, and keep a regret quota (e.g., high_regret_quota_ratio 0.3\u21920.45 in endgame). When remaining <= 2*local_beam_width, increase local_beam_width by +2 and diversity_suffix_k from 2\u21923, and force all-position evaluation for higher accuracy.\n\n3. Upgrade VND: implement true sampled 2-opt (segment reversal) and non-adjacent swaps under don\u2019t-look bits\n   - Add a 2-opt neighborhood that samples up to S = min(200, n) pairs (i, j) with j - i >= 2 and applies segment reversal; maintain don\u2019t-look bits per index, resetting only near improved segments and using length buckets to bias larger spans early. Include a separate sampled non-adjacent swap pass; run best-improvement for 1\u20132 outer rounds, preserving existing adjacent swaps and Or-opt(1\u20133).\n\n4. Sensitivity-guided LNS destroys with stagnation escalation and quick polish\n   - Before removal, score K = min(20, n) indices by sensitivity: for each i, move txn i to P = 6 deterministic positions, compute the variance/mean delta of seq_cost, and pick top ceil(0.4\u00b7m) for removal; fill the rest with one contiguous block. If two LNS attempts fail, increase m by 25% and allow two contiguous blocks; after regret-based repair, run a single light polish (reinsertion + Or-opt(1)) using the cached best-two evaluations.\n\n5. Bidirectional, block-aware path relinking with on-the-fly micro-polishing and tighter elite diversity\n   - For each elite pair, perform both A\u2192B and B\u2192A; at each step, move either the single item or the longest consecutive block already matching the target order that maximally reduces displacement/Kendall distance, keeping the best intermediate. After each move, run a fast Or-opt(1) pass; admit top 2\u20133 intermediates (improving) into the elite pool and enforce suffix-3 uniqueness (k=3) to maintain diversity.",
    "1. Add a reusable \u201cbest-two\u201d insertion memo with deterministic position sampling and LRU pruning\n   - Implement best_two_cache[(tuple(seq), t, pos_sig)] -> (best_cost, best_pos, second_cost), where pos_sig is ('all', len(seq)) for exhaustive evaluation or a deterministic tuple from position_samples. Use this cache in construction, local reinsertion/Or-opt(1), LNS repair, and path relinking to avoid repeated simulator calls and propagate regret accuracy. Cap the cache (e.g., 10\u201320k entries) with simple LRU pruning to bound memory, matching the time\u2013memory tradeoff seen in Gen 26 and the best program\u2019s wins from memoization.\n\n2. Make beam selection adaptive to regret dispersion and endgame, with stronger suffix diversity\n   - At each construction layer, compute dispersion over second-best costs; if high, rank by 0.5*best_cost + 0.5*second_best and raise high_regret_quota_ratio from 0.3 up to 0.5, else use 0.8*best_cost + 0.2*second_best. When remaining <= 2*local_beam_width, increase local_beam_width by +2, escalate diversity_suffix_k from 2 to 3, and force all-position evaluation; also form candidate txns as the union of top-k by best and top-k by regret (not purely random). This builds directly on the current best\u2019s regret+diversity beam and improves late-stage accuracy.\n\n3. Upgrade VND with true 2-opt segment reversals and non-adjacent swaps under don\u2019t-look bits\n   - Add a 2-opt neighborhood that samples up to S = min(200, n) pairs (i, j) with j - i >= 2 and applies segment reversal; maintain don\u2019t-look bits and reset only around improved segments to focus effort. Include a separate sampled non-adjacent swap pass and run 1\u20132 outer best-improvement rounds, preserving existing adjacent swaps and Or-opt(1\u20133). This aligns with top performers\u2019 layered refinement stacks and should convert more construction-quality into final gains.\n\n4. Sensitivity-guided LNS destroys with stagnation escalation and quick polish\n   - Before destroy, score K = min(20, n) indices by sensitivity: for each i, temporarily remove txn i and test P = 6 deterministic positions (from position_samples) to compute variance/mean deltas; pick top ceil(0.4\u00b7m) by sensitivity, fill the rest with one contiguous block. If two LNS attempts fail, increase m by 25% and allow two contiguous blocks; after regret-based repair, run a quick polish (reinsertion + Or-opt(1)) using the best-two cache. This leverages regret signals and caching to guide impactful removals while controlling runtime.\n\n5. Bidirectional, block-aware path relinking with micro-polishing and tighter elite diversity\n   - Perform both A\u2192B and B\u2192A relinking; at each step move either the single item or the longest contiguous block (already in target order) that maximally reduces displacement/Kendall distance, then run a fast Or-opt(1) pass. Admit top 2\u20133 improving intermediates into the elite pool and enforce suffix-3 uniqueness (k=3) instead of k=2 to maintain diversity. This extends the current best\u2019s relinking and elite management, which consistently helped avoid local optima in high-scoring variants.",
    "1. Promote a global \u201cbest-two\u201d insertion memo with LRU and add a block variant for Or-opt(2\u20133)\n   - Implement best_two_cache[(tuple(seq), t, pos_sig)] -> (best_cost, best_pos, second_cost) with an OrderedDict LRU cap (e.g., 20k entries), and reuse it in construction, reinsertion (k=1), Or-opt(2,3), LNS repair, and path relinking. Add best_two_block(seq, block, pos_list) to return best/second-best for k=2\u20133 blocks so regret signals drive block reinsertion too. This extends the best program\u2019s memoization and \u201cbest-two\u201d guidance into more neighborhoods, reducing simulator calls while improving regret accuracy.\n\n2. Make the beam regret-adaptive with elite-guided candidate selection and stronger late-stage diversity\n   - At each layer, compute dispersion over second-best costs; if high, raise high_regret_quota_ratio to 0.5 and rank by 0.5*best + 0.5*second; if low, drop to 0.2 and rank by 0.8*best + 0.2*second. Form candidate txns as the union of top-k by best, top-k by regret, and top-k most misaligned with the elite consensus order (median rank), and when remaining <= 2*beam_width increase beam_width by +2 and escalate diversity_suffix_k from 2 to 3 with all-position evaluation. This builds directly on the current best\u2019s regret-beam and elite management to sharpen choices late in construction.\n\n3. Upgrade VND with true 2-opt segment reversals and sampled non-adjacent swaps under don\u2019t-look bits\n   - Add a 2-opt reversal operator: sample up to S = min(200, n) pairs (i, j) with j - i >= 2, reverse seq[i:j+1], accept best-improving moves; also run a separate sampled non-adjacent swap pass. Maintain don\u2019t-look bits per index and reset them only around improved segments to focus effort, keeping the current adjacent swaps, reinsertion, and Or-opt(2\u20133). This aligns with layered refinement wins and should convert more construction quality into final gains.\n\n4. Elite-consensus-guided LNS: destroy misaligned items and repair toward consensus positions\n   - Build a consensus order from the elite (e.g., median rank per txn) and select the destroy set as the top ceil(alpha\u00b7n) by displacement to this consensus (alpha in [0.08, 0.18]), optionally adding one contiguous block around the largest displacement. During repair, bias position_samples with focus_idx = consensus index for each t, use regret-based pick (best vs second-best), then run a quick polish (reinsertion + Or-opt(1)). If two LNS attempts fail, escalate alpha by 25% and allow two disjoint blocks; this leverages elite structure while retaining the best program\u2019s lightweight LNS.\n\n5. Endgame bounded enumeration with memoized branch-and-bound for the last K transactions\n   - When |remaining| <= K (e.g., 8\u20139), switch from greedy insertion to a deterministic DFS that enumerates the remaining insertions, ordering choices by higher regret to prune early and using the global cost_cache to avoid repeated evaluations. Keep a running best bound and stop when expanding a node whose partial choice set cannot beat it; cap the routine by K and a small time budget per run to preserve runtime predictability. This extends the current endgame all-position policy and aims to lock in optimal finishes more often.",
    "1. Add a unified \u201cbest-two\u201d insertion memo with block support and LRU bounds\n   - Implement best_two_cache[(tuple(seq), t, pos_sig)] -> (best_cost, best_pos, second_cost) where pos_sig is a deterministic signature of the position set (e.g., tuple(sorted(pos_list)) truncated or hashed), with an OrderedDict LRU cap around 20k\u201340k entries. Use it in construction, reinsertion (k=1), Or-opt (k=2,3), LNS repair, and path relinking, plus a best_two_block(seq, block, pos_list) variant for blocks. This extends the current global cost cache to directly memoize best-two evaluations, cutting simulator calls and sharpening regret guidance in all neighborhoods.\n\n2. Make the beam regret-adaptive and elite-informed with late-stage suffix-3 diversity\n   - At each construction layer, compute dispersion of regrets (e.g., std/mean); if high (>0.6) set high_regret_quota_ratio=0.5 and rank by 0.5*best + 0.5*second, else use 0.3 and 0.8*best + 0.2*second. Form candidate txns as the union of top-k by best, top-k by regret, and top-k most misaligned to the elite median rank; when remaining <= 2\u00d7beam_width, bump beam_width by +2, switch diversity_suffix_k from 2 to 3, and use all positions. This preserves the best program\u2019s regret-beam strengths while adapting pressure and diversity precisely where the endgame gains matter.\n\n3. Switch to bounded branch-and-bound enumeration for the last K transactions with a transposition table\n   - When |remaining| <= 9, run a deterministic DFS that orders branches by higher regret first, uses the global cost_cache for evaluations, and prunes with a best-so-far bound; cap to ~3000 node expansions to keep runtime predictable. Memoize subproblems with a small transposition table keyed by (frozenset(remaining), tuple(current_seq[-3:])), storing best known partial cost to avoid rework. This pushes the current endgame all-position policy toward optimal finishes more often without heavy overhead.\n\n4. Upgrade VND: true 2-opt segment reversals, don\u2019t-look bits, and best-two\u2013driven reinsertion/Or-opt\n   - Replace the non-adjacent swap pass with sampled 2-opt segment reversals: sample S=min(200, n) pairs (i, j), reverse seq[i:j+1], accept the best-improving move; maintain don\u2019t-look bits per index and reset only around improved segments. Use the best-two memo in reinsertion and Or-opt (2,3) to pick positions via regret, and apply first-improvement within each neighborhood to accelerate convergence. These changes align with layered refinement wins while converting more construction quality into final gains.\n\n5. Strengthen elite management via bidirectional path relinking and targeted post-relink LNS\n   - For each elite partner, perform bidirectional relinking (source\u2192target and target\u2192source), order moves by largest displacement, cap moves at min(16, n//6), and evaluate insertions with the best-two memo; keep the best intermediate solution. Immediately run a quick LNS polish on the relinked solution with small destroy (alpha\u22480.08) focusing on items with the largest residual displacement to the target ranking. Maintain suffix-2 diversity normally, but temporarily raise to suffix-3 if two recent elite insertions share the same suffix-2, improving robustness without heavy overhead.",
    "1. Extend best-two memoization to blocks and unify its keying across neighborhoods\n   - Implement best_two_block(base_seq, block, use_all_pos=False, focus_idx=None, k_positions=None) returning (best_cost, best_pos, second_cost), and cache by (tuple(base_seq), tuple(block), pos_sig) where pos_sig is a deterministic signature of the probed positions (anchors + seeded samples), not just a boolean. Use this in reinsertion and Or-opt(2,3) in VND, and in path relinking when relocating items or short blocks, so each move evaluates only once via the memo rather than many seq_cost calls. This mirrors the top programs\u2019 global best-two reuse and should cut simulator calls while sharpening regret guidance everywhere.\n\n2. Make the construction beam regret-adaptive and elite-informed with late-stage suffix-3 diversity\n   - At each layer, compute regret dispersion (std/mean); if high (>0.6), set high_regret_quota_ratio=0.5 and rank candidates by 0.5*best + 0.5*second, else use 0.3 and 0.8*best + 0.2*second. Form candidate txns as the union of top-k by best, top-k by regret, and top-k most misaligned to the elite median rank; when remaining <= 2\u00d7beam_width, increase beam_width by +2, switch diversity_suffix_k from 2 to 3, and flip to all positions. Seed both position and txn sampling deterministically by the sequence suffix to increase cache hits across runs and phases.\n\n3. Tighten endgame branch-and-bound with bounded expansions and a small transposition table\n   - Add a cap of ~3000 node expansions to endgame_optimal_completion and memoize subproblems by (frozenset(remaining), tuple(prefix_seq[-3:])) storing the best partial cost seen to prune duplicates. Order expansions by higher regret first then lower best insertion cost, and allow K to rise to 10 if within the node cap; if the cap is hit, fall back to greedy best-two completion to remain predictable. Reuse this bounded BnB inside LNS (already done) and return the exact or near-exact completion more consistently without timeouts.\n\n4. Upgrade VND: true 2-opt segment reversals, don\u2019t-look bits, and best-two\u2013guided Or-opt/reinsertion\n   - Replace the current non-adjacent swap with sampled segment reversals: sample S=min(200, n) pairs (i<j), evaluate reversing seq[i:j+1], and maintain don\u2019t-look bits per index; reset bits only around improved segments. For reinsertion and Or-opt(2,3), call best_two_insertion/best_two_block once per (item/block, base) to pick positions via regret rather than iterating many positions; use first-improvement acceptance within each neighborhood to speed convergence. These changes align with the layered VND gains seen in the \u22654.35 cluster while leveraging the best-two cache to keep it fast.\n\n5. Strengthen elite path relinking with bidirectional moves and targeted post-PR LNS\n   - Perform bidirectional relinking (source\u2192target and target\u2192source), order moves by largest displacement, and for each move use best_two_insertion or best_two_block to choose the best position instead of forcing the exact target index; cap moves at min(16, n//6). After each relink path, run a quick LNS polish that removes \u03b1\u22480.08 of items biased to highest residual displacement versus the partner target and repairs via regret; during this polish temporarily raise diversity_suffix_k to 3. This leverages the elite pool more effectively and mirrors the refinements credited in the top-scoring programs.",
    "1. Extend best-two memoization to blocks and reuse it across VND and path relinking\n   - Implement best_two_block(base_seq, block, use_all_pos=False, focus_idx=None, k_positions=None) \u2192 (best_cost, best_pos, second_cost) and cache by (tuple(base_seq), tuple(block), pos_sig), where pos_sig is a deterministic signature of the probed positions (anchors + suffix-seeded interior samples). Replace try_reinsertion and try_or_opt with single calls to best_two_insertion/best_two_block per (item/block, base) instead of iterating positions, and in path_relink choose the best insertion position via best_two_insertion instead of forcing target index. This aligns with the top programs\u2019 global best-two reuse and will cut simulator calls while sharpening regret guidance across neighborhoods.\n\n2. Make the construction beam regret-adaptive, suffix-deterministic, and elite-informed with late suffix-3 diversity\n   - At each layer, compute regret dispersion (std/mean); if high (>0.6), set high_regret_quota_ratio=0.5 and rank by 0.5*best + 0.5*second, else use 0.3 and 0.8*best + 0.2*second. Form candidate txns as the union of top-k by best, top-k by regret, and top-k most misaligned to the elite median rank; when remaining <= 2\u00d7beam_width, increase beam_width by +2, switch diversity_suffix_k from 2 to 3, and flip to all positions. Seed both txn and position sampling deterministically by the sequence suffix (use random.Random(hash(tuple(seq[-10:]) + (layer,)) & 0xffffffff)) to increase cache hits and stability.\n\n3. Tighten endgame branch-and-bound with bounded expansions and a small transposition table\n   - Add a cap of ~3000 node expansions in endgame_optimal_completion and memoize subproblems by (frozenset(remaining), tuple(prefix_seq[-3:])) storing the best partial cost seen to prune duplicates. Order expansions by higher regret then lower best insertion cost, allow K to rise to 10 if within the node cap, and if the cap is hit, fall back to greedy best-two completion to remain predictable. Reuse this bounded BnB inside LNS when the destroyed set is small to secure more exact finishes without timeouts.\n\n4. Upgrade VND: true 2-opt segment reversals, don\u2019t-look bits, and best-two\u2013guided Or-opt/reinsertion\n   - Add a real 2-opt neighborhood that reverses segments: sample S=min(200, n) pairs (i<j), evaluate reversing seq[i:j+1], and accept first improvement; maintain don\u2019t-look bits per index and reset bits only around improved segments. For reinsertion and Or-opt(2,3), call best_two_insertion/best_two_block once per (item/block, base) with deterministic position signatures, replacing inner loops over positions. This mirrors the layered VND gains in the top scorers and leverages the memo to keep it fast.\n\n5. Strengthen LNS and path relinking with structure-aware destroys, regret-biased repairs, and post-PR polish\n   - Add destroy operators beyond random/block: (a) k-regret removal (remove items with highest current regret = second-best \u2212 best), and (b) displacement-biased removal relative to the best elite partner; choose operators via suffix-seeded RNG for determinism. During repair, interleave picks by best and by regret; if the removed set size <= K, invoke the upgraded endgame BnB. Make path relinking bidirectional (source\u2192target and target\u2192source), order moves by largest displacement, choose positions via best_two_insertion/best_two_block, cap moves at min(16, n//6), and after each relink run a quick LNS polish that destroys ~8% of items (suffix-3 diversity on) to extract incremental gains.",
    "1. Extend best-two memoization to blocks and reuse it in VND and path relinking\n   - Implement best_two_block(base_seq, block, use_all_pos=False, k_positions=None) \u2192 (best_cost, best_pos, second_best_cost) and cache by (tuple(base_seq), tuple(block), use_all_pos, pos_sig), where pos_sig is a deterministic signature of the probed positions (anchors + suffix-seeded interior). Replace the inner loops in try_reinsertion and try_or_opt with a single call to best_two_insertion/best_two_block per (item/block, base), and in path_relink choose the insertion position via best_two_insertion instead of forcing target index. This mirrors the 4.41 pattern, slashes simulator calls during VND/PR, and sharpens regret guidance across neighborhoods.\n\n2. Make the construction beam regret-adaptive, suffix-deterministic, and late-diverse\n   - At each layer, compute regret dispersion over expansions (std/mean of second \u2212 best); if high (>0.6), set high_regret_quota_ratio=0.5 and rank by 0.5*best + 0.5*regret, else keep 0.3 and 0.8*best + 0.2*regret. Seed candidate txn sampling deterministically with rng = random.Random(hash((tuple(seq[-10:]), layer, len(rem))) & 0xffffffff) and, when remaining <= 2\u00d7local_beam_width, widen the beam by +2, switch diversity_suffix_k from 2 to 3, and flip use_all_pos=True for positions. This increases cache hits, prevents beam collapse, and aligns with the top programs\u2019 stable construction behavior.\n\n3. Tighten endgame branch-and-bound with bounded expansions and a small transposition table\n   - Add a node cap ~3000 in endgame_optimal_completion and a transposition table keyed by (frozenset(remaining), tuple(prefix_seq[-3:])) storing the best partial cost seen; prune when revisiting with \u2265 best. Order branches by higher regret then lower best insertion cost, and allow K to rise to 10 so long as the node cap isn\u2019t hit; if the cap is exceeded, fall back to greedy best-two completion for predictability. Reuse this bounded BnB inside LNS when the removed set is small, matching the decisive exact-tail integration seen in the 4.41\u20134.39 cohort.\n\n4. Upgrade VND with true 2-opt segment reversals, don\u2019t-look bits, and best-two\u2013guided reinsertion/Or-opt\n   - Replace the current sampled swap with proper 2-opt segment reversals: sample S=min(200, n) pairs (i<j), evaluate reversing seq[i:j+1], accept first improvement, and maintain don\u2019t-look bits per index, resetting only around improved segments. For reinsertion and Or-opt(2,3), call best_two_insertion/best_two_block once per (item/block) using deterministic pos_sig instead of iterating positions, and stop at first improvement; this keeps the search fast via memo reuse and provides the stronger polishing that lifted similar programs from 4.27 to 4.37.\n\n5. Strengthen LNS and path relinking with structure-aware destroys, regret-biased repairs, and post-PR polish\n   - Add destroy operators beyond random/block: (a) k-regret removal (highest current regret = second \u2212 best), and (b) displacement-biased removal vs the elite best; choose operator and items via suffix-seeded RNG for determinism. During repair, interleave picks by best and by regret (e.g., alternate steps or set regret_prob via dispersion), invoke the bounded endgame BnB when |removed| <= K, and make path relinking bidirectional (source\u2192target and target\u2192source) choosing positions via best_two_insertion; cap moves at min(16, n//6). After each relink, run a quick LNS polish destroying ~8% of items with suffix-3 diversity to extract incremental gains."
  ],
  "total_programs_meta_processed": 100
}