<NAME>
endgame_besttwo_and_stronger_2opt
</NAME>

<DESCRIPTION>
I introduce three targeted improvements to reduce makespan:

1) Add a memoized best-two insertion function with deterministic position sampling and a small-sequence exact evaluation. This reuses computed best/second-best costs across construction, LNS, and path relinking and aligns insertions with actual makespan impacts rather than heuristic positions.

2) Add an exact endgame branch-and-bound completion for small remainders (K up to ~9), used both after the beam construction and in LNS when the removed set is small. This secures optimal finishes and avoids poor deterministic appends at the end.

3) Strengthen local search by replacing the 2-opt “swap” with true segment reversal, which better captures non-local improvements in transactional conflicts.

I also slightly refine position sampling to evaluate all positions for small sequences and update path relinking to leverage the best-two insertion instead of forcing a target index. These changes collectively improve accuracy of scheduling decisions without heavy runtime costs and are consistent with the current structure and variables.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def position_samples(seq_len, focus_idx=None, k_positions=None):
        """Sample insertion positions; include anchors and positions near focus_idx if provided."""
        if seq_len <= 1:
            return [0, seq_len]
        k = k_positions if k_positions is not None else k_pos_sample
        pos_set = {0, seq_len, seq_len // 2}
        # Bias positions near the focus index (if provided)
        if focus_idx is not None:
            for d in [-3, -2, -1, 0, 1, 2, 3]:
                p = focus_idx + d
                if 0 <= p <= seq_len:
                    pos_set.add(p)
        # Add random internal positions
        for _ in range(min(k, seq_len + 1)):
            pos_set.add(random.randint(0, seq_len))
        return sorted(pos_set)
=======
    def position_samples(seq_len, focus_idx=None, k_positions=None):
        """Sample insertion positions; include anchors and positions near focus_idx if provided.
        When the sequence is small, evaluate all positions for accuracy."""
        if seq_len <= 1:
            return [0, seq_len]
        k = k_positions if k_positions is not None else k_pos_sample
        # For short sequences, check all positions deterministically
        if seq_len <= 12:
            return list(range(seq_len + 1))
        pos_set = {0, seq_len, seq_len // 2}
        # Bias positions near the focus index (if provided)
        if focus_idx is not None:
            for d in (-3, -2, -1, 0, 1, 2, 3):
                p = focus_idx + d
                if 0 <= p <= seq_len:
                    pos_set.add(p)
        # Add random internal positions
        for _ in range(min(k, seq_len + 1)):
            pos_set.add(random.randint(0, seq_len))
        return sorted(pos_set)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def evaluate_best_two_positions(base_seq, t, pos_list):
        """Return (best_cost, best_pos, second_best_cost) for inserting t into base_seq over pos_list."""
        best = (float('inf'), None)
        second = float('inf')
        for p in pos_list:
            cand = base_seq[:p] + [t] + base_seq[p:]
            c = seq_cost(cand)
            if c < best[0]:
                second = best[0]
                best = (c, p)
            elif c < second:
                second = c
        return best[0], best[1], second
=======
    def evaluate_best_two_positions(base_seq, t, pos_list):
        """Return (best_cost, best_pos, second_best_cost) for inserting t into base_seq over pos_list."""
        best = (float('inf'), None)
        second = float('inf')
        for p in pos_list:
            cand = base_seq[:p] + [t] + base_seq[p:]
            c = seq_cost(cand)
            if c < best[0]:
                second = best[0]
                best = (c, p)
            elif c < second:
                second = c
        return best[0], best[1], second

    # Memoized best-two insertion per (sequence, txn, use_all_pos) with deterministic stratified positions
    best_two_cache = {}
    def best_two_insertion(base_seq, t, use_all_pos=False, focus_idx=None, k_positions=None):
        """
        Compute (best_cost, best_pos, second_best_cost) for inserting txn t into base_seq.
        - If use_all_pos or seq small, evaluate all positions exactly.
        - Else, deterministically sample anchors + a few interior positions (seeded by sequence suffix and t).
        Results are cached by (tuple(base_seq), t, use_all_pos) for reuse across beam, LNS, and PR phases.
        """
        key = (tuple(base_seq), t, bool(use_all_pos))
        if key in best_two_cache:
            return best_two_cache[key]
        L = len(base_seq)
        if use_all_pos or L <= 12:
            pos_list = list(range(L + 1))
        else:
            # Deterministic sampling: anchors + near focus + seeded interior
            pos_set = {0, L, L // 2, (L * 1) // 4, (L * 3) // 4}
            if focus_idx is not None:
                for d in (-3, -2, -1, 0, 1, 2, 3):
                    p = focus_idx + d
                    if 0 <= p <= L:
                        pos_set.add(p)
            cap = k_positions if k_positions is not None else k_pos_sample
            seed = (tuple(base_seq[-min(10, L):]), t, L)
            rng = random.Random(hash(seed) & 0xffffffff)
            for _ in range(min(cap, L + 1)):
                pos_set.add(rng.randint(0, L))
            pos_list = sorted(pos_set)
        res = evaluate_best_two_positions(base_seq, t, pos_list)
        best_two_cache[key] = res
        return res

    # ----------------------------
    # Endgame exact completion (branch-and-bound over last K txns)
    # ----------------------------
    endgame_enum_K = max(6, min(9, endgame_all_pos_threshold + 3))
    endgame_memo = {}
    def endgame_optimal_completion(prefix_seq, rem_set):
        """
        Given a prefix sequence and a small remaining set of txns (|rem_set| <= K),
        enumerate txn orders with best-position insertion to find the minimal-cost completion.
        Uses branch-and-bound with the current best bound and partial-cost pruning.
        Returns (best_cost, best_seq).
        """
        key0 = (tuple(prefix_seq), frozenset(rem_set))
        if key0 in endgame_memo:
            return endgame_memo[key0]

        best_c = float('inf')
        best_s = None

        def dfs(seq, rem):
            nonlocal best_c, best_s
            # Prune by current partial cost
            c_prefix = seq_cost(seq)
            if c_prefix >= best_c:
                return
            if not rem:
                if c_prefix < best_c:
                    best_c = c_prefix
                    best_s = seq[:]
                return
            # Order candidates by high regret first, then by lower best insertion cost
            order = []
            for t in rem:
                b, p, s2 = best_two_insertion(seq, t, use_all_pos=True)
                regret = (s2 - b) if s2 < float('inf') else 0.0
                order.append((-regret, b, t, p))
            order.sort()
            for _, bcost, t, p in order:
                if bcost >= best_c:
                    continue
                new_seq = seq[:p] + [t] + seq[p:]
                new_rem = rem.copy()
                new_rem.remove(t)
                dfs(new_seq, new_rem)

        dfs(prefix_seq[:], set(rem_set))
        if best_s is None:
            # Fallback: deterministic append to avoid None
            seq_complete = prefix_seq[:] + sorted(list(rem_set))
            best_c = seq_cost(seq_complete)
            best_s = seq_complete
        endgame_memo[key0] = (best_c, best_s)
        return best_c, best_s
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
                # Determine position policy (all vs sampled)
                use_all_pos = (len(rem) <= endgame_all_pos_threshold) or (len(seq) <= 18)
                pos_list_all = list(range(len(seq) + 1)) if use_all_pos else position_samples(len(seq))

                # For each candidate transaction, evaluate best and second-best positions
                for t in cand_txns:
                    best_c, best_p, second_c = evaluate_best_two_positions(seq, t, pos_list_all)
                    new_seq = seq[:best_p] + [t] + seq[best_p:]
                    new_rem = rem.copy()
                    new_rem.remove(t)
                    regret = second_c - best_c if second_c < float('inf') else 0.0
                    key = tuple(new_seq)
                    if key in seen_seqs:
                        continue
                    seen_seqs.add(key)
                    expansions.append((new_seq, new_rem, best_c, regret, t))
=======
                # Determine position policy (all vs sampled)
                use_all_pos = (len(rem) <= endgame_all_pos_threshold) or (len(seq) <= 18)

                # For each candidate transaction, evaluate best and second-best positions via cached best-two
                for t in cand_txns:
                    best_c, best_p, second_c = best_two_insertion(seq, t, use_all_pos=use_all_pos)
                    new_seq = seq[:best_p] + [t] + seq[best_p:]
                    new_rem = rem.copy()
                    new_rem.remove(t)
                    regret = second_c - best_c if second_c < float('inf') else 0.0
                    key = tuple(new_seq)
                    if key in seen_seqs:
                        continue
                    seen_seqs.add(key)
                    expansions.append((new_seq, new_rem, best_c, regret, t))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Choose best complete
        best_seq = None
        best_cost = float('inf')
        for seq, rem, cost in beam:
            if rem:
                # append rest deterministically then evaluate
                seq_complete = seq[:] + sorted(list(rem))
                c = seq_cost(seq_complete)
                if c < best_cost:
                    best_cost = c
                    best_seq = seq_complete
            else:
                if cost < best_cost:
                    best_cost = cost
                    best_seq = seq

        return best_seq
=======
        # Choose best complete (use exact endgame when few remain)
        best_seq = None
        best_cost = float('inf')
        for seq, rem, cost in beam:
            if rem:
                if len(rem) <= endgame_enum_K:
                    c, s = endgame_optimal_completion(seq, rem)
                else:
                    # append rest deterministically then evaluate
                    seq_complete = seq[:] + sorted(list(rem))
                    c, s = seq_cost(seq_complete), seq_complete
                if c < best_cost:
                    best_cost, best_seq = c, s
            else:
                if cost < best_cost:
                    best_cost = cost
                    best_seq = seq

        return best_seq
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Repair using regret insertion
        seq_rep = remaining[:]
        rem_set = removed[:]
        while rem_set:
            if len(rem_set) > k_txn_sample:
                cand_txns = random.sample(rem_set, k_txn_sample)
            else:
                cand_txns = rem_set[:]

            best_overall = (float('inf'), None, None)  # cost, txn, new_seq
            best_by_regret = (float('-inf'), None, None)

            for t in cand_txns:
                pos_list = position_samples(len(seq_rep))
                best_c, best_p, second_c = evaluate_best_two_positions(seq_rep, t, pos_list)
                # Track pure best
                if best_c < best_overall[0]:
                    new_seq = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_overall = (best_c, t, new_seq)
                # Track regret
                regret = second_c - best_c if second_c < float('inf') else 0.0
                if regret > best_by_regret[0]:
                    new_seq_r = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_by_regret = (regret, t, new_seq_r)

            pick_regret = (random.random() < regret_prob)
            chosen = best_by_regret if pick_regret and best_by_regret[1] is not None else best_overall
            if chosen[1] is None:
                t = random.choice(rem_set)
                seq_rep = seq_rep + [t]
                rem_set.remove(t)
            else:
                seq_rep = chosen[2]
                rem_set.remove(chosen[1])

        c_rep, s_rep = local_refine(seq_rep)
        return c_rep, s_rep
=======
        # Repair using regret insertion (with exact endgame when small)
        seq_rep = remaining[:]
        rem_set = removed[:]
        # Exact endgame rebuild when small
        if len(rem_set) <= endgame_enum_K:
            c_end, s_end = endgame_optimal_completion(seq_rep, set(rem_set))
            c_rep, s_rep = local_refine(s_end)
            return c_rep, s_rep

        while rem_set:
            if len(rem_set) > k_txn_sample:
                cand_txns = random.sample(rem_set, k_txn_sample)
            else:
                cand_txns = rem_set[:]

            best_overall = (float('inf'), None, None)  # cost, txn, new_seq
            best_by_regret = (float('-inf'), None, None)

            use_all = (len(rem_set) <= endgame_all_pos_threshold) or (len(seq_rep) <= 18)
            for t in cand_txns:
                best_c, best_p, second_c = best_two_insertion(seq_rep, t, use_all_pos=use_all)
                # Track pure best
                if best_c < best_overall[0]:
                    new_seq = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_overall = (best_c, t, new_seq)
                # Track regret
                regret = second_c - best_c if second_c < float('inf') else 0.0
                if regret > best_by_regret[0]:
                    new_seq_r = seq_rep[:best_p] + [t] + seq_rep[best_p:]
                    best_by_regret = (regret, t, new_seq_r)

            pick_regret = (random.random() < regret_prob)
            chosen = best_by_regret if pick_regret and best_by_regret[1] is not None else best_overall
            if chosen[1] is None:
                t = random.choice(rem_set)
                seq_rep = seq_rep + [t]
                rem_set.remove(t)
            else:
                seq_rep = chosen[2]
                rem_set.remove(chosen[1])

        c_rep, s_rep = local_refine(seq_rep)
        return c_rep, s_rep
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        def two_opt_sample_pass(cur_seq, cur_cost):
            tried = 0
            while tried < two_opt_trials:
                i = random.randint(0, n - 2)
                j = random.randint(i + 2, n - 1) if i + 2 < n else None
                tried += 1
                if j is None:
                    continue
                cand = cur_seq[:]
                cand[i], cand[j] = cand[j], cand[i]
                c = seq_cost(cand)
                if c < cur_cost:
                    return True, c, cand
            return False, cur_cost, cur_seq
=======
        def two_opt_sample_pass(cur_seq, cur_cost):
            tried = 0
            while tried < two_opt_trials:
                i = random.randint(0, n - 2)
                j = random.randint(i + 1, n - 1)
                tried += 1
                if j <= i + 1:
                    continue
                # True 2-opt: reverse the segment [i, j]
                cand = cur_seq[:i] + cur_seq[i:j + 1][::-1] + cur_seq[j + 1:]
                c = seq_cost(cand)
                if c < cur_cost:
                    return True, c, cand
            return False, cur_cost, cur_seq
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
            base = s[:idx] + s[idx + 1:]
            # Insert at desired (bounded within current length)
            desired = max(0, min(desired, len(base)))
            cand = base[:desired] + [item] + base[desired:]
            c = seq_cost(cand)
=======
            base = s[:idx] + s[idx + 1:]
            # Choose best insertion around desired using cached best-two
            use_all = (len(base) <= 20)
            best_cand_c, best_pos, _ = best_two_insertion(base, item, use_all_pos=use_all, focus_idx=desired, k_positions=k_pos_sample)
            cand = base[:best_pos] + [item] + base[best_pos:]
            c = best_cand_c
>>>>>>> REPLACE
</DIFF>