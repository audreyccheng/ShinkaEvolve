<NAME>
tune_thresholds_and_dual_source_confidence
</NAME>

<DESCRIPTION>
1. Tweak thresholds: stricter physics check (0.5%) to clamp impossible values faster, but looser hardening (3%) to allow more agreement/averaging for noisy links.
2. Upgrade Confidence Calibration to 'Dual-Source' model: Explicitly factor in the flow quality of the *Remote* router. If the peer value comes from a router with poor flow conservation, confidence in matching that peer is reduced. This improves calibration by penalizing reliance on potentially corrupted neighbors.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02   # 2% relative error considered 'match'
    STRICT_THRESHOLD = 0.01      # 1% for physical impossibility checks
    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active'
    ITERATIONS = 4               # Convergence count
=======
    # --- Configuration ---
    HARDENING_THRESHOLD = 0.03   # 3% relative error considered 'match'
    STRICT_THRESHOLD = 0.005     # 0.5% for physical impossibility checks
    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active'
    ITERATIONS = 4               # Convergence count
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Step 4: Confidence Calibration ---
    result = {}

    # Recalculate Final Flow Quality
    final_router_qual = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imb = abs(sum_rx - sum_tx) / vol
        final_router_qual[r_id] = max(0.0, 1.0 - (imb * 10.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        r_id = s['router']
        flow_q = final_router_qual.get(r_id, 0.5)

        def get_confidence(final, orig, peer_val, flow_q):
            # Error metric
            dist_orig = calc_error(final, orig)

            # Peer match?
            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            # Base confidence logic
            # High confidence if:
            # 1. Matches Peer AND Flow is good (Convergent)
            # 2. Matches Original AND Flow is good (Verified Self)

            conf = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # Repaired
                if matches_peer:
                    # Aligned with peer
                    conf = 0.90 + (0.09 * flow_q) # 0.90 - 0.99
                else:
                    # Repaired away from peer? (e.g. Averaging or Flow forced)
                    if flow_q > 0.9:
                        conf = 0.85
                    else:
                        conf = 0.60
            else:
                # Kept Original
                if peer_val is not None and not matches_peer:
                    # Disagreement.
                    if flow_q > 0.8:
                        conf = 0.95 # Flow validates Self
                    else:
                        conf = 0.75 # Ambiguous
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return conf

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, flow_q)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, flow_q)
=======
    # --- Step 4: Confidence Calibration ---
    result = {}

    # Recalculate Final Flow Quality
    final_router_qual = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imb = abs(sum_rx - sum_tx) / vol
        # Quality: 1.0 = Perfect. Decay to 0.0 at 10% imbalance.
        final_router_qual[r_id] = max(0.0, 1.0 - (imb * 10.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        r_id = s['router']
        remote_r_id = telemetry[if_id].get('remote_router')

        # Flow qualities for Dual-Source Calibration
        local_q = final_router_qual.get(r_id, 0.5)
        remote_q = final_router_qual.get(remote_r_id, 0.5) if remote_r_id else 0.5

        def get_confidence(final, orig, peer_val, l_q, r_q):
            # Error metric
            dist_orig = calc_error(final, orig)

            # Peer match?
            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            # Logic
            conf = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # Aligned with peer.
                    # Confidence = Base + Local Support + Remote Support
                    # If both routers are healthy, confidence is very high (0.99).
                    # If remote is broken, we are less sure about peer value.
                    conf = 0.88 + (0.07 * l_q) + (0.04 * r_q)
                else:
                    # Repaired but NOT matching peer (Flow Arbitration or Averaging)
                    # Relies heavily on Local Flow Quality
                    if l_q > 0.9:
                        conf = 0.85
                    else:
                        conf = 0.60
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Disagreement (Self != Peer)
                    # We kept Self. Only valid if Local Flow strongly supports it.
                    if l_q > 0.9:
                        conf = 0.95
                    elif l_q > 0.7:
                        conf = 0.85
                    else:
                        conf = 0.70 # Ambiguous
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return max(0.0, min(1.0, conf))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, local_q, remote_q)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, local_q, remote_q)
>>>>>>> REPLACE
</DIFF>