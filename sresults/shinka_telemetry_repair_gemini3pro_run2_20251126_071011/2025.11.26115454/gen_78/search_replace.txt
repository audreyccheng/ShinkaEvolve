<NAME>
symmetric_flow_consensus
</NAME>

<DESCRIPTION>
Implements "Symmetric Flow Consensus" which explicitly calculates flow-implied values for both the local and remote routers.
- "Golden Truth" Detection: Identifying values that satisfy flow conservation on both ends of the link simultaneously.
- Solidity Checks: Verifying if a peer's value is consistent with the peer's router balance before trusting it.
- Dominant Quality Override: Allowing a high-quality remote router to override a low-quality local router.
- Improved Confidence Calibration: Continuous scoring based on local and remote router qualities, with penalties for residual imbalance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
Network telemetry repair algorithm that detects and corrects inconsistencies
in network interface telemetry data using topology relationships.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network interface telemetry using Weighted Consensus with Physics Constraints.

    Strategy:
    1. Status Repair:
       - Traffic implies UP.
       - Peer explicitly DOWN + No Traffic implies DOWN.
    2. Rate Repair (Consensus Loop):
       - Candidates: Self, Peer, Flow-Implied.
       - Logic:
         - If Self matches Peer, Average.
         - If Disagreement, check Flow.
         - Physical Constraint: RX cannot exceed Peer TX significantly.
    3. Confidence:
       - Score based on support from Peer and Flow.
    """

    # Constants
    HARDENING_THRESHOLD = 0.02  # 2% difference is considered "agreement"
    NOISE_FLOOR = 10.0          # 10 Mbps floor for error calculation
    ITERATIONS = 2

    state = {}

    # --- Step 1: Initialization & Status Repair ---
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # Robust Status Logic
    for if_id, s in state.items():
        # Check Local Traffic
        has_local_traffic = s['rx'] > 0.1 or s['tx'] > 0.1

        # Check Peer Status/Traffic
        peer_has_traffic = False
        peer_is_down = False

        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['rx'] > 0.1 or p['tx'] > 0.1:
                peer_has_traffic = True
            if p['status'] == 'down':
                peer_is_down = True

        # Decision
        if has_local_traffic or peer_has_traffic:
            s['status'] = 'up'
        elif peer_is_down and not has_local_traffic:
            # Propagate Down if no contradictory evidence
            s['status'] = 'down'

    # Enforce Down Consistency
    for s in state.values():
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 2: Iterative Rate Repair ---

    def calc_error(v1, v2):
        return abs(v1 - v2) / max(v1, v2, NOISE_FLOOR)

    for _ in range(ITERATIONS):
        # Calculate Router Flow Imbalances
        router_net = {}
        for r_id, if_list in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
            router_net[r_id] = sum_rx - sum_tx

        updates = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- RX Repair ---
            # Candidates
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None
            val_flow = max(0.0, val_self - router_net[r_id]) if r_id in router_net else None

            # Selection Logic
            final_rx = val_self

            if val_peer is not None:
                # Check agreement
                err_peer = calc_error(val_self, val_peer)

                if err_peer < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0
                else:
                    # Disagreement.
                    # Physics Check: If Self > Peer, unlikely (unless Peer is broken/down).
                    # If Flow agrees with Peer, definitely Peer.
                    # If Flow agrees with Self, keep Self (maybe Peer is broken).

                    if val_flow is not None:
                        err_self_flow = calc_error(val_self, val_flow)
                        err_peer_flow = calc_error(val_peer, val_flow)

                        if err_peer_flow < err_self_flow:
                            # Peer and Flow align -> Trust Peer
                            final_rx = val_peer
                        elif err_self_flow < err_peer_flow:
                            # Self and Flow align -> Trust Self (ignore Peer)
                            final_rx = val_self
                        else:
                            # Both differ from Flow. Trust Peer (Link Symmetry invariant is R3)
                            final_rx = val_peer
                    else:
                        # No flow info. Trust Peer.
                        final_rx = val_peer

            # --- TX Repair ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None
            val_flow = max(0.0, val_self + router_net[r_id]) if r_id in router_net else None

            final_tx = val_self

            if val_peer is not None:
                err_peer = calc_error(val_self, val_peer)

                if err_peer < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0
                else:
                    if val_flow is not None:
                        err_self_flow = calc_error(val_self, val_flow)
                        err_peer_flow = calc_error(val_peer, val_flow)

                        if err_peer_flow < err_self_flow:
                            final_tx = val_peer
                        elif err_self_flow < err_peer_flow:
                            final_tx = val_self
                        else:
                            final_tx = val_peer
                    else:
                        final_tx = val_peer

            updates[if_id] = {'rx': final_rx, 'tx': final_tx}

        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence Calibration ---
    result = {}

    # Assess router quality (Flow Balance)
    router_balance = {}
    for r_id, if_list in topology.items():
        s_rx = sum(state[i]['rx'] for i in if_list if i in state)
        s_tx = sum(state[i]['tx'] for i in if_list if i in state)
        mx = max(s_rx, s_tx, NOISE_FLOOR)
        # Quality: 1.0 = balanced, 0.0 = >20% imbalance
        imbalance = abs(s_rx - s_tx) / mx
        router_balance[r_id] = max(0.0, 1.0 - (imbalance * 5.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        # Get Final Peer values
        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        flow_qual = router_balance.get(r_id, 0.5)

        def calculate_confidence(final, orig, peer_val, f_qual):
            # Base confidence: 1.0
            conf = 1.0

            # Support Scores
            peer_support = 0.0
            if peer_val is not None:
                # 1.0 if match, decay to 0.0 at 10% error
                e = calc_error(final, peer_val)
                peer_support = max(0.0, 1.0 - (e * 10.0))

            # Flow support is just flow quality
            flow_support = f_qual

            # Did we change it?
            if calc_error(final, orig) > HARDENING_THRESHOLD:
                # We changed it. We need support.
                # Max confidence depends on max support
                support = max(peer_support, flow_support)

                if support > 0.9: conf = 0.95
                elif support > 0.5: conf = 0.8 + (support - 0.5) * 0.3
                else: conf = 0.6

            else:
                # We kept it.
                # If Peer disagrees strongly, reduce confidence
                if peer_val is not None and peer_support < 0.1:
                    # Disagreement.
                    if flow_support > 0.8:
                        # Flow supports us (Self), so we are right.
                        conf = 0.9
                    else:
                        # Ambiguous. Peer disagrees, Flow is bad/ambiguous.
                        conf = 0.7

            return conf

        rx_conf = calculate_confidence(s['rx'], orig_rx, peer_tx, flow_qual)
        tx_conf = calculate_confidence(s['tx'], orig_tx, peer_rx, flow_qual)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
=======
"""
Network telemetry repair algorithm using Symmetric Flow Consensus.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network telemetry using Symmetric Flow Consensus (Golden Truth Verification).

    Strategy:
    1. Status Repair: Infer status from local/remote traffic activity.
    2. Rate Repair (Iterative):
       - Calculate Flow Targets for BOTH Local and Remote routers.
       - Identify "Golden Truth" values: values that satisfy flow conservation
         on both ends of the link simultaneously.
       - Enforce Physics (RX <= Peer TX) strictly for phantom traffic.
       - Arbitrate Loss (RX < Peer TX) based on which value restores flow balance better.
       - Use "Dominant Quality" override: If one router is healthy and the other chaotic,
         trust the healthy one.
    3. Confidence Calibration:
       - Score based on agreement, flow consistency, and router quality.
       - Penalize confidence if final router imbalance remains high.
    """

    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02   # 2% relative error considered 'match'
    STRICT_THRESHOLD = 0.005     # 0.5% tolerance for physical violations
    SOLIDITY_THRESHOLD = 0.015   # 1.5% tolerance for flow verification
    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active'
    ITERATIONS = 5               # Convergence count

    # --- Helper: Dynamic Noise Floor ---
    def get_noise_floor(rate_a, rate_b=0.0):
        mx = max(rate_a, rate_b)
        return max(BASE_NOISE_FLOOR, mx * 0.001)

    # --- Helper: Normalized Error ---
    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # --- Step 2: Robust Status Repair ---
    for if_id, s in state.items():
        # Evidence
        local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR

        peer_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['orig_rx'] > BASE_NOISE_FLOOR or p['orig_tx'] > BASE_NOISE_FLOOR:
                peer_traffic = True
            if p['orig_status'] == 'down':
                peer_is_down = True

        # Decision Matrix
        if local_traffic or peer_traffic:
            s['status'] = 'up'
        elif peer_is_down and not local_traffic:
            s['status'] = 'down'

        # Consistency enforce
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            router_stats[r_id] = {
                'imbalance': imbalance,
                'quality': max(0.0, 1.0 - (abs(imbalance) / vol * 10.0))
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # --- Flow Implied Values (Local) ---
            local_target_rx = None # The RX value that balances Local Router
            local_target_tx = None # The TX value that balances Local Router

            local_q = 0.5
            if local_r in router_stats:
                ls = router_stats[local_r]
                local_q = ls['quality']
                # Balance: SumRX - SumTX = Imb.
                # To fix RX: NewRX = OldRX - Imb
                local_target_rx = max(0.0, s['rx'] - ls['imbalance'])
                # To fix TX: NewTX = OldTX + Imb
                local_target_tx = max(0.0, s['tx'] + ls['imbalance'])

            # --- Flow Implied Values (Remote) ---
            remote_target_peer_tx = None # The Peer TX value that balances Remote Router
            remote_target_peer_rx = None # The Peer RX value that balances Remote Router

            remote_q = 0.5
            if has_peer and remote_r in router_stats:
                rs = router_stats[remote_r]
                remote_q = rs['quality']

                p_tx = state[peer_id]['tx']
                p_rx = state[peer_id]['rx']

                # Peer TX is outgoing on remote.
                # Remote Imb = In - Out.
                # To fix Out: NewOut = OldOut + Imb
                remote_target_peer_tx = max(0.0, p_tx + rs['imbalance'])

                # Peer RX is incoming on remote.
                # To fix In: NewIn = OldIn - Imb
                remote_target_peer_rx = max(0.0, p_rx - rs['imbalance'])

            # --- RX Repair ---
            # Goal: Determine correct RX.
            # Constraints: RX <= Peer TX.
            # Signals: Self RX, Peer TX.
            # Validators: Local Flow (local_target_rx), Remote Flow (remote_target_peer_tx).

            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # 1. Check "Golden Truth" / Solidity
                # Does Peer TX satisfy both its own router AND our router?
                # i.e., is Peer TX close to remote_target_peer_tx AND close to local_target_rx?

                peer_is_remote_solid = False
                if remote_target_peer_tx is not None:
                    if calc_error(val_peer, remote_target_peer_tx) < SOLIDITY_THRESHOLD:
                        peer_is_remote_solid = True

                peer_is_local_solid = False
                if local_target_rx is not None:
                    if calc_error(val_peer, local_target_rx) < SOLIDITY_THRESHOLD:
                        peer_is_local_solid = True

                # 2. Physics Violation (RX > Peer TX)
                # Strict clamp for Phantom Traffic
                if val_self > val_peer * (1.0 + STRICT_THRESHOLD):
                     # Impossible state.
                     # Exception: If Peer is NOT solid remotely, but Self IS solid locally?
                     # Very rare. Assume Peer TX is ceiling.
                     final_rx = val_peer

                # 3. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 4. Disagreement (RX < Peer TX usually)
                else:
                    # Arbitration
                    # If Peer is "Double Solid" (fits both), it's the Golden Truth.
                    if peer_is_remote_solid and peer_is_local_solid:
                        final_rx = val_peer
                    # If Peer is Remote Solid (Source is healthy), and Self is NOT Local Solid -> Trust Peer
                    elif peer_is_remote_solid and calc_error(val_self, local_target_rx) > SOLIDITY_THRESHOLD:
                        final_rx = val_peer
                    # Dominant Quality Override
                    elif remote_q > 0.8 and local_q < 0.4:
                        final_rx = val_peer
                    else:
                        # Fallback to standard flow arbitration
                        d_peer = calc_error(val_peer, local_target_rx) if local_target_rx is not None else 1.0
                        d_self = calc_error(val_self, local_target_rx) if local_target_rx is not None else 1.0

                        if d_peer < d_self:
                            final_rx = val_peer
                        elif d_self < d_peer:
                            final_rx = val_self
                        else:
                            final_rx = val_peer

            # --- TX Repair ---
            # Goal: Determine correct TX.
            # Constraint: TX >= Peer RX.

            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                peer_is_remote_solid = False
                if remote_target_peer_rx is not None:
                    if calc_error(val_peer, remote_target_peer_rx) < SOLIDITY_THRESHOLD:
                        peer_is_remote_solid = True

                # 1. Physics Violation (TX < Peer RX)
                if val_self < val_peer * (1.0 - STRICT_THRESHOLD):
                    final_tx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 3. Disagreement (TX > Peer RX usually)
                else:
                    # If Peer is Double Solid?
                    # Peer RX matching Remote Flow implies Peer RX is valid input to Remote.
                    # Peer RX matching Local Flow (as TX) implies it balances Local.
                    if peer_is_remote_solid and local_target_tx is not None and calc_error(val_peer, local_target_tx) < SOLIDITY_THRESHOLD:
                        final_tx = val_peer
                    elif peer_is_remote_solid and calc_error(val_self, local_target_tx) > SOLIDITY_THRESHOLD:
                        final_tx = val_peer
                    elif remote_q > 0.8 and local_q < 0.4:
                        final_tx = val_peer
                    else:
                        d_peer = calc_error(val_peer, local_target_tx) if local_target_tx is not None else 1.0
                        d_self = calc_error(val_self, local_target_tx) if local_target_tx is not None else 1.0

                        if d_peer < d_self:
                            final_tx = val_peer
                        elif d_self < d_peer:
                            final_tx = val_self
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 4: Confidence Calibration ---
    result = {}

    # Recalculate Final Flow Quality
    final_router_qual = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imb = abs(sum_rx - sum_tx) / vol
        final_router_qual[r_id] = max(0.0, 1.0 - (imb * 10.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        r_id = s['router']
        remote_r_id = s['remote_router']

        l_q = final_router_qual.get(r_id, 0.5)
        r_q = final_router_qual.get(remote_r_id, 0.5) if remote_r_id else 0.5

        def get_confidence(final, orig, peer_val, local_q, remote_q):
            err_orig = calc_error(final, orig)

            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            # Base Score
            if err_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # High confidence: Consensus with Peer.
                    # Boost if Routers are healthy.
                    score = 0.85 + (0.07 * local_q) + (0.07 * remote_q)
                else:
                    # Repaired, but not to Peer.
                    # Flow Arbitration. Relies on Local Q.
                    if local_q > 0.9:
                        score = 0.85
                    else:
                        score = 0.60
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Disagreement.
                    if local_q > 0.9:
                        # Strong Local Flow.
                        if remote_q < 0.7:
                            score = 0.95 # I am solid, you are chaos.
                        else:
                            score = 0.90 # Stalemate
                    elif local_q > 0.7:
                        score = 0.75
                    else:
                        score = 0.60
                else:
                    # Agreement or No Peer
                    score = 1.0

            # Penalize for residual local imbalance
            # If after repair, local router is still bad, our confidence in any value from it should drop
            if local_q < 0.5:
                score *= 0.9

            return max(0.0, min(1.0, score))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, l_q, r_q)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, l_q, r_q)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
>>>>>>> REPLACE
</DIFF>