To improve the performance of the network telemetry repair algorithm, I am proposing an update that refines status propagation, rate repair logic, and confidence calibration based on the identified weaknesses and potential recommendations.

**Key Improvements:**
1.  **Peer-Down Propagation**: The logic is updated to strictly enforce physical constraints. If a peer interface is explicitly 'down' and no local traffic is detected, the local interface status is coerced to 'down'. This addresses cases where an interface is physically disconnected but hasn't updated its status yet.
2.  **Weighted Consensus with Flow Arbitration**: The rate repair loop is improved to explicitly calculate agreement error between Self, Peer, and Flow-Implied values. It prioritizes the value that minimizes error with respect to Flow Conservation when Self and Peer disagree, acting as a robust tie-breaker.
3.  **Calibrated Confidence Scoring**: The discrete confidence tiers are replaced with a continuous scoring system. Confidence is now calculated based on the degree of support from Peer (inverse error) and Flow (router balance quality). This ensures high confidence for well-supported repairs and lower confidence for ambiguous situations, improving calibration.

Here is the code change:

<NAME>
propagate_peer_down_and_weighted_consensus
</NAME>

<DESCRIPTION>
1. **Peer-Down Propagation**: Implements logic where if a peer is explicitly DOWN and no traffic is detected locally, the local interface status is coerced to DOWN. This enforces physical consistency.
2. **Weighted Consensus with Flow Arbitration**: Refines the rate repair loop to explicitly calculate agreement (error) between Self, Peer, and Flow-Implied values. It prioritizes the value that minimizes error with respect to the Flow Conservation invariant when Self and Peer disagree.
3. **Calibrated Confidence Scoring**: Replaces discrete confidence tiers with a continuous scoring system based on support from Peer and Flow. High support (low error) yields high confidence; disagreement reduces confidence unless Flow Conservation strongly validates the chosen value.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network interface telemetry using Consensus with Flow Arbitration.

    Strategy:
    1. Status Repair: Truth from traffic. If traffic flows, it's UP.
    2. Rate Repair:
       - Calculate Flow Imbalance at every router.
       - For every interface, compare Self, Peer, and Flow-Implied values.
       - If Self & Peer diverge, pick the one that best satisfies Flow Conservation.
    3. Confidence: Calibrated based on the convergence of Self, Peer, and Flow signals.
    """

    # Constants
    HARDENING_THRESHOLD = 0.02  # 2% difference is considered "agreement"
    NOISE_FLOOR = 10.0          # 10 Mbps floor for error calculation (ignores low-rate noise)
    ITERATIONS = 2              # Convergence steps

    state = {}

    # --- Step 1: Initialization & Status Repair ---
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # Robust Status Logic
    # 1. Traffic implies UP.
    # 2. Peer traffic implies UP.
    for if_id, s in state.items():
        has_local_traffic = s['rx'] > 0.1 or s['tx'] > 0.1

        peer_has_traffic = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['rx'] > 0.1 or p['tx'] > 0.1:
                peer_has_traffic = True

        if has_local_traffic or peer_has_traffic:
            s['status'] = 'up'

    # Enforce Down Consistency
    for s in state.values():
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 2: Iterative Rate Repair ---

    # Helper: Normalized Error
    def calc_error(v1, v2):
        return abs(v1 - v2) / max(v1, v2, NOISE_FLOOR)

    for _ in range(ITERATIONS):
        # Calculate Router Flow Imbalances
        # Imbalance = Sum(RX) - Sum(TX)
        router_net = {}
        for r_id, if_list in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
            router_net[r_id] = sum_rx - sum_tx

        updates = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- RX Repair ---
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            # Flow Implied Value:
            # We want: (Sum(RX) - val_self + New_RX) - Sum(TX) = 0
            # New_RX = Sum(TX) - Sum(RX) + val_self
            # New_RX = val_self - Imbalance
            val_flow = None
            if r_id in router_net:
                val_flow = max(0.0, val_self - router_net[r_id])

            final_rx = val_self
            if val_peer is not None:
                # If Peer agrees with Self, average them
                if calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0
                else:
                    # Disagreement. Use Flow as Arbiter.
                    if val_flow is not None:
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            # Peer is closer to flow balance
                            final_rx = val_peer
                        elif err_self < err_peer:
                            # Self is closer to flow balance (Peer is likely wrong)
                            final_rx = val_self
                        else:
                            # Ambiguous: Trust Peer (Sender Authority)
                            final_rx = val_peer
                    else:
                        # No flow info: Trust Peer (Link Symmetry R3)
                        final_rx = val_peer

            # --- TX Repair ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            # Flow Implied Value:
            # We want: Sum(RX) - (Sum(TX) - val_self + New_TX) = 0
            # New_TX = Sum(RX) - Sum(TX) + val_self
            # New_TX = val_self + Imbalance
            val_flow = None
            if r_id in router_net:
                val_flow = max(0.0, val_self + router_net[r_id])

            final_tx = val_self
            if val_peer is not None:
                if calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0
                else:
                    if val_flow is not None:
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            final_tx = val_peer
                        elif err_self < err_peer:
                            final_tx = val_self
                        else:
                            final_tx = val_peer
                    else:
                        final_tx = val_peer

            updates[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates synchronously
        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence Calibration ---
    result = {}

    # Calculate final flow quality for confidence scoring
    router_quality = {}
    for r_id, if_list in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
        if max(sum_rx, sum_tx) > NOISE_FLOOR:
            imbalance = abs(sum_rx - sum_tx) / max(sum_rx, sum_tx)
            # Quality is 1.0 (perfect) to 0.0 (bad >10% imbalance)
            router_quality[r_id] = max(0.0, 1.0 - (imbalance * 10.0))
        else:
            router_quality[r_id] = 1.0 # Idle router is balanced

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        # Get consensus targets
        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        flow_q = router_quality.get(r_id, 0.5)

        def get_conf(final, orig, peer_val, flow_qual):
            # 1. Did we change the value?
            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD

            # 2. Does Peer support the final value?
            peer_supports = False
            if peer_val is not None:
                if calc_error(final, peer_val) < HARDENING_THRESHOLD:
                    peer_supports = True

            if was_repaired:
                if peer_supports:
                    # Strongest case: Repaired to match Peer.
                    if flow_qual > 0.8: return 0.98 # Peer + Flow agree
                    return 0.95 # Peer agrees, Flow ignored/noisy
                else:
                    # Repaired without Peer support (or defied Peer)
                    if flow_qual > 0.9: return 0.85 # Flow forced the value
                    return 0.6 # Weak repair
            else:
                # Kept original
                if peer_val is not None and not peer_supports:
                    # We defied Peer.
                    if flow_qual > 0.9: return 0.9 # We defied Peer because Flow backed us
                    return 0.7 # Ambiguous

                return 1.0 # Default trust

        rx_conf = get_conf(s['rx'], orig_rx, peer_tx, flow_q)
        tx_conf = get_conf(s['tx'], orig_tx, peer_rx, flow_q)

        # Status confidence
        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
=======
def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network interface telemetry using Weighted Consensus with Physics Constraints.

    Strategy:
    1. Status Repair:
       - Traffic implies UP.
       - Peer explicitly DOWN + No Traffic implies DOWN.
    2. Rate Repair (Consensus Loop):
       - Candidates: Self, Peer, Flow-Implied.
       - Logic:
         - If Self matches Peer, Average.
         - If Disagreement, check Flow.
         - Physical Constraint: RX cannot exceed Peer TX significantly.
    3. Confidence:
       - Score based on support from Peer and Flow.
    """

    # Constants
    HARDENING_THRESHOLD = 0.02  # 2% difference is considered "agreement"
    NOISE_FLOOR = 10.0          # 10 Mbps floor for error calculation
    ITERATIONS = 2

    state = {}

    # --- Step 1: Initialization & Status Repair ---
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # Robust Status Logic
    for if_id, s in state.items():
        # Check Local Traffic
        has_local_traffic = s['rx'] > 0.1 or s['tx'] > 0.1

        # Check Peer Status/Traffic
        peer_has_traffic = False
        peer_is_down = False

        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['rx'] > 0.1 or p['tx'] > 0.1:
                peer_has_traffic = True
            if p['status'] == 'down':
                peer_is_down = True

        # Decision
        if has_local_traffic or peer_has_traffic:
            s['status'] = 'up'
        elif peer_is_down and not has_local_traffic:
            # Propagate Down if no contradictory evidence
            s['status'] = 'down'

    # Enforce Down Consistency
    for s in state.values():
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 2: Iterative Rate Repair ---

    def calc_error(v1, v2):
        return abs(v1 - v2) / max(v1, v2, NOISE_FLOOR)

    for _ in range(ITERATIONS):
        # Calculate Router Flow Imbalances
        router_net = {}
        for r_id, if_list in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
            router_net[r_id] = sum_rx - sum_tx

        updates = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- RX Repair ---
            # Candidates
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None
            val_flow = max(0.0, val_self - router_net[r_id]) if r_id in router_net else None

            # Selection Logic
            final_rx = val_self

            if val_peer is not None:
                # Check agreement
                err_peer = calc_error(val_self, val_peer)

                if err_peer < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0
                else:
                    # Disagreement.
                    # Physics Check: If Self > Peer, unlikely (unless Peer is broken/down).
                    # If Flow agrees with Peer, definitely Peer.
                    # If Flow agrees with Self, keep Self (maybe Peer is broken).

                    if val_flow is not None:
                        err_self_flow = calc_error(val_self, val_flow)
                        err_peer_flow = calc_error(val_peer, val_flow)

                        if err_peer_flow < err_self_flow:
                            # Peer and Flow align -> Trust Peer
                            final_rx = val_peer
                        elif err_self_flow < err_peer_flow:
                            # Self and Flow align -> Trust Self (ignore Peer)
                            final_rx = val_self
                        else:
                            # Both differ from Flow. Trust Peer (Link Symmetry invariant is R3)
                            final_rx = val_peer
                    else:
                        # No flow info. Trust Peer.
                        final_rx = val_peer

            # --- TX Repair ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None
            val_flow = max(0.0, val_self + router_net[r_id]) if r_id in router_net else None

            final_tx = val_self

            if val_peer is not None:
                err_peer = calc_error(val_self, val_peer)

                if err_peer < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0
                else:
                    if val_flow is not None:
                        err_self_flow = calc_error(val_self, val_flow)
                        err_peer_flow = calc_error(val_peer, val_flow)

                        if err_peer_flow < err_self_flow:
                            final_tx = val_peer
                        elif err_self_flow < err_peer_flow:
                            final_tx = val_self
                        else:
                            final_tx = val_peer
                    else:
                        final_tx = val_peer

            updates[if_id] = {'rx': final_rx, 'tx': final_tx}

        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence Calibration ---
    result = {}

    # Assess router quality (Flow Balance)
    router_balance = {}
    for r_id, if_list in topology.items():
        s_rx = sum(state[i]['rx'] for i in if_list if i in state)
        s_tx = sum(state[i]['tx'] for i in if_list if i in state)
        mx = max(s_rx, s_tx, NOISE_FLOOR)
        # Quality: 1.0 = balanced, 0.0 = >20% imbalance
        imbalance = abs(s_rx - s_tx) / mx
        router_balance[r_id] = max(0.0, 1.0 - (imbalance * 5.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        # Get Final Peer values
        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        flow_qual = router_balance.get(r_id, 0.5)

        def calculate_confidence(final, orig, peer_val, f_qual):
            # Base confidence: 1.0
            conf = 1.0

            # Support Scores
            peer_support = 0.0
            if peer_val is not None:
                # 1.0 if match, decay to 0.0 at 10% error
                e = calc_error(final, peer_val)
                peer_support = max(0.0, 1.0 - (e * 10.0))

            # Flow support is just flow quality
            flow_support = f_qual

            # Did we change it?
            if calc_error(final, orig) > HARDENING_THRESHOLD:
                # We changed it. We need support.
                # Max confidence depends on max support
                support = max(peer_support, flow_support)

                if support > 0.9: conf = 0.95
                elif support > 0.5: conf = 0.8 + (support - 0.5) * 0.3
                else: conf = 0.6

            else:
                # We kept it.
                # If Peer disagrees strongly, reduce confidence
                if peer_val is not None and peer_support < 0.1:
                    # Disagreement.
                    if flow_support > 0.8:
                        # Flow supports us (Self), so we are right.
                        conf = 0.9
                    else:
                        # Ambiguous. Peer disagrees, Flow is bad/ambiguous.
                        conf = 0.7

            return conf

        rx_conf = calculate_confidence(s['rx'], orig_rx, peer_tx, flow_qual)
        tx_conf = calculate_confidence(s['tx'], orig_tx, peer_rx, flow_qual)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
>>>>>>> REPLACE
</DIFF>