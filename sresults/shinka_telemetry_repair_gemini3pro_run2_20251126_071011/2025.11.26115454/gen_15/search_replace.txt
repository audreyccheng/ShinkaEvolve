<NAME>
iterative_flow_repair_calibrated
</NAME>

<DESCRIPTION>
Replaces the single-pass greedy repair with an iterative multi-pass approach (Gauss-Seidel style) to allow flow conservation constraints to propagate across the network. Also introduces a more sophisticated confidence calibration metric that considers both the distinctness of the chosen value (how much better it is than the alternative) and the goodness of fit (how well it satisfies flow conservation). This addresses the 'binary choice' and 'confidence overestimation' issues.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Pass 2: Rate Repair with Symmetry & Flow Conservation

    # Helper: Calculate router flow imbalance (In - Out)
    def get_router_imbalance(router_id):
        if not router_id or router_id not in topology:
            return None
        in_sum = 0.0
        out_sum = 0.0
        for if_id in topology[router_id]:
            if if_id in state:
                in_sum += state[if_id]['rx']
                out_sum += state[if_id]['tx']
        return in_sum - out_sum

    # Iterate over links to fix symmetry
    processed_pairs = set()
    for if_id, s in state.items():
        connected_to = s['orig'].get('connected_to')
        if not connected_to or connected_to not in state:
            continue

        pair_id = tuple(sorted([if_id, connected_to]))
        if pair_id in processed_pairs:
            continue
        processed_pairs.add(pair_id)

        peer = state[connected_to]

        # Skip if both down
        if s['status'] == 'down' and peer['status'] == 'down':
            continue

        # 1. Fix TX vs Peer RX
        tx_val = s['tx']
        peer_rx_val = peer['rx']
        denom = max(tx_val, peer_rx_val, 1.0)

        if abs(tx_val - peer_rx_val) / denom > HARDENING_THRESHOLD:
            # Symmetry violation. Use Flow Conservation to decide.
            # Local router (source of tx)
            r_local = s['orig'].get('local_router')
            imb_local = get_router_imbalance(r_local)

            # Remote router (dest of rx)
            r_remote = peer['orig'].get('local_router')
            imb_remote = get_router_imbalance(r_remote)

            # Cost function: |NewImbalanceLocal| + |NewImbalanceRemote|
            # Target rate v.
            # NewImbLocal(v) = (In - Out) + tx_val - v  (we replace tx_val with v in Out sum)
            # NewImbRemote(v) = (In - Out) - peer_rx_val + v (we replace peer_rx_val with v in In sum)

            def score_candidate(v):
                score = 0.0
                if imb_local is not None:
                    score += abs(imb_local + tx_val - v)
                if imb_remote is not None:
                    score += abs(imb_remote - peer_rx_val + v)
                return score

            score_tx = score_candidate(tx_val)
            score_peer_rx = score_candidate(peer_rx_val)

            if score_tx < score_peer_rx and (imb_local is not None or imb_remote is not None):
                # Trust TX
                peer['rx'] = tx_val
                peer['rx_conf'] = 0.9
                s['tx_conf'] = 1.0
            elif score_peer_rx < score_tx and (imb_local is not None or imb_remote is not None):
                # Trust Peer RX
                s['tx'] = peer_rx_val
                s['tx_conf'] = 0.9
                peer['rx_conf'] = 1.0
            else:
                # Ambiguous or no topology info -> average
                avg = (tx_val + peer_rx_val) / 2.0
                s['tx'] = avg
                peer['rx'] = avg
                s['tx_conf'] = 0.5
                peer['rx_conf'] = 0.5
        else:
             s['tx_conf'] = 1.0
             peer['rx_conf'] = 1.0

        # 2. Fix RX vs Peer TX
        rx_val = s['rx']
        peer_tx_val = peer['tx']
        denom = max(rx_val, peer_tx_val, 1.0)

        if abs(rx_val - peer_tx_val) / denom > HARDENING_THRESHOLD:
            # Symmetry violation
            r_local = s['orig'].get('local_router')
            imb_local = get_router_imbalance(r_local)

            r_remote = peer['orig'].get('local_router')
            imb_remote = get_router_imbalance(r_remote)

            # Target rate v.
            # NewImbLocal(v) = (In - Out) - rx_val + v  (we replace rx_val with v in In sum)
            # NewImbRemote(v) = (In - Out) + peer_tx_val - v (we replace peer_tx_val with v in Out sum)

            def score_candidate_rx(v):
                score = 0.0
                if imb_local is not None:
                    score += abs(imb_local - rx_val + v)
                if imb_remote is not None:
                    score += abs(imb_remote + peer_tx_val - v)
                return score

            score_rx = score_candidate_rx(rx_val)
            score_peer_tx = score_candidate_rx(peer_tx_val)

            if score_rx < score_peer_tx and (imb_local is not None or imb_remote is not None):
                # Trust RX
                peer['tx'] = rx_val
                peer['tx_conf'] = 0.9
                s['rx_conf'] = 1.0
            elif score_peer_tx < score_rx and (imb_local is not None or imb_remote is not None):
                # Trust Peer TX
                s['rx'] = peer_tx_val
                s['rx_conf'] = 0.9
                peer['tx_conf'] = 1.0
            else:
                avg = (rx_val + peer_tx_val) / 2.0
                s['rx'] = avg
                peer['tx'] = avg
                s['rx_conf'] = 0.5
                peer['tx_conf'] = 0.5
        else:
            s['rx_conf'] = 1.0
            peer['tx_conf'] = 1.0
=======
    # Pass 2: Rate Repair with Symmetry & Flow Conservation

    # Helper: Calculate router flow imbalance (In - Out)
    def get_router_imbalance(router_id):
        if not router_id or router_id not in topology:
            return None
        in_sum = 0.0
        out_sum = 0.0
        for if_id in topology[router_id]:
            if if_id in state:
                in_sum += state[if_id]['rx']
                out_sum += state[if_id]['tx']
        return in_sum - out_sum

    # Iterative refinement (Gauss-Seidel style)
    # Allows flow corrections to propagate through the network
    ITERATIONS = 3
    sorted_interfaces = sorted(state.keys())  # Deterministic order

    for iteration in range(ITERATIONS):
        # We track processed PAIRS per iteration to avoid double processing
        processed_pairs = set()

        for if_id in sorted_interfaces:
            s = state[if_id]
            connected_to = s['orig'].get('connected_to')
            if not connected_to or connected_to not in state:
                continue

            pair_id = tuple(sorted([if_id, connected_to]))
            if pair_id in processed_pairs:
                continue
            processed_pairs.add(pair_id)

            peer = state[connected_to]

            # Skip if both down
            if s['status'] == 'down' and peer['status'] == 'down':
                continue

            # --- 1. Fix Direction A: Local TX -> Peer RX ---
            # Candidates
            c_tx = s['tx']
            c_prx = peer['rx']

            # Context
            r_local = s['orig'].get('local_router')
            imb_local = get_router_imbalance(r_local) # Current imbalance including c_tx

            r_remote = peer['orig'].get('local_router')
            imb_remote = get_router_imbalance(r_remote) # Current imbalance including c_prx

            # Scoring Function
            # We want to pick value 'v' that minimizes router imbalances
            # New_Imb_Local = (Old_Imb - c_tx) + v   (Removing old contribution, adding new)
            # New_Imb_Remote = (Old_Imb + c_prx) - v (Removing old contribution (which was negative in imbalance), adding new subtraction)
            # Wait: Imbalance = In - Out.
            # Local TX is Out. Imb = In - Out. So contribution is -TX.
            # New Imb = (Current_Imb - (-c_tx)) + (-v) = Current_Imb + c_tx - v.
            # Remote RX is In. Imb = In - Out. Contribution is +RX.
            # New Imb = (Current_Imb - c_prx) + v.

            def eval_direction_a(v):
                cost = 0.0
                valid_checks = 0
                if imb_local is not None:
                    cost += abs(imb_local + c_tx - v)
                    valid_checks += 1
                if imb_remote is not None:
                    cost += abs(imb_remote - c_prx + v)
                    valid_checks += 1
                return cost, valid_checks

            cost_tx, n_tx = eval_direction_a(c_tx)
            cost_prx, n_prx = eval_direction_a(c_prx)

            # Decision Logic
            best_val = c_tx
            conf = 1.0

            # If signals agree, trust them
            denom = max(c_tx, c_prx, 1.0)
            if abs(c_tx - c_prx) / denom <= HARDENING_THRESHOLD:
                best_val = (c_tx + c_prx) / 2.0
                conf = 1.0
            elif n_tx == 0:
                # No topology info, fallback to average but low confidence
                best_val = (c_tx + c_prx) / 2.0
                conf = 0.5
            else:
                # Topology info available, check costs
                if cost_tx < cost_prx:
                    best_val = c_tx
                    winner_cost = cost_tx
                    loser_cost = cost_prx
                else:
                    best_val = c_prx
                    winner_cost = cost_prx
                    loser_cost = cost_tx

                # Confidence Calibration
                # 1. Distinctness: How much better is the winner?
                # 2. Residual: Is the winner actually good?

                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val, 1.0)

                # Base confidence derived from distinctness
                # If margin is high (distinct choice), high confidence.
                # If residual is high (bad fit), reduce confidence.

                # Sigmoid-like scaling
                distinctness_score = min(1.0, margin * 2.0) # e.g. 50% better -> 1.0
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0) # e.g. 50% error -> 0.0

                conf = 0.5 + 0.45 * distinctness_score * fit_score

            # Apply
            s['tx'] = best_val
            peer['rx'] = best_val
            s['tx_conf'] = conf
            peer['rx_conf'] = conf


            # --- 2. Fix Direction B: Local RX <- Peer TX ---
            c_rx = s['rx']
            c_ptx = peer['tx']

            # Re-fetch imbalances as they might have changed from previous step
            imb_local = get_router_imbalance(r_local)
            imb_remote = get_router_imbalance(r_remote)

            # Local RX is In. Imb = In - Out. Contribution +RX.
            # New Imb = (Current_Imb - c_rx) + v.
            # Remote TX is Out. Imb = In - Out. Contribution -TX.
            # New Imb = (Current_Imb - (-c_ptx)) - v = Current_Imb + c_ptx - v.

            def eval_direction_b(v):
                cost = 0.0
                valid_checks = 0
                if imb_local is not None:
                    cost += abs(imb_local - c_rx + v)
                    valid_checks += 1
                if imb_remote is not None:
                    cost += abs(imb_remote + c_ptx - v)
                    valid_checks += 1
                return cost, valid_checks

            cost_rx, n_rx = eval_direction_b(c_rx)
            cost_ptx, n_ptx = eval_direction_b(c_ptx)

            best_val_b = c_rx
            conf_b = 1.0

            denom_b = max(c_rx, c_ptx, 1.0)
            if abs(c_rx - c_ptx) / denom_b <= HARDENING_THRESHOLD:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 1.0
            elif n_rx == 0:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 0.5
            else:
                if cost_rx < cost_ptx:
                    best_val_b = c_rx
                    winner_cost = cost_rx
                    loser_cost = cost_ptx
                else:
                    best_val_b = c_ptx
                    winner_cost = cost_ptx
                    loser_cost = cost_rx

                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val_b, 1.0)

                distinctness_score = min(1.0, margin * 2.0)
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                conf_b = 0.5 + 0.45 * distinctness_score * fit_score

            s['rx'] = best_val_b
            peer['tx'] = best_val_b
            s['rx_conf'] = conf_b
            peer['tx_conf'] = conf_b
>>>>>>> REPLACE
</DIFF>