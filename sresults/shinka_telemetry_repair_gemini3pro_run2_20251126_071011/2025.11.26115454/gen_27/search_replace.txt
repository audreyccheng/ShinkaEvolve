<NAME>
iterative_constraint_solver
</NAME>

<DESCRIPTION>
Replaces the two-step repair process with a unified iterative constraint solver.
1. Strictly enforces status consistency (Down means zero).
2. Uses an iterative algorithm (Gauss-Seidel style) to solve for link flows that minimize both local measurement deviation and global router flow imbalances.
3. Prioritizes 'Sender' (TX) values as ground truth unless router constraints suggest otherwise.
4. Calculates confidence based on the final residual flow imbalance (fitness of the solution) and original measurement agreement.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Step 1: Link Symmetry & Status Consistency
    for if_id, state in working_state.items():
        orig_data = state['original']
        peer_id = orig_data.get('connected_to')

        if peer_id and peer_id in working_state:
            peer_state = working_state[peer_id]

            # 1a. Status Consistency
            s1 = state['status']
            s2 = peer_state['status']

            # Check for active traffic to resolve status conflicts
            traffic_active = (state['rx'] > 1.0 or state['tx'] > 1.0 or
                              peer_state['rx'] > 1.0 or peer_state['tx'] > 1.0)

            if s1 != s2:
                # Inconsistency found
                if traffic_active:
                    # If traffic flows, link is likely UP
                    state['status'] = 'up'
                    state['status_conf'] = 0.8
                else:
                    # No traffic, likely DOWN
                    state['status'] = 'down'
                    state['status_conf'] = 0.8

            # If status is DOWN, force rates to 0
            if state['status'] == 'down':
                state['rx'] = 0.0
                state['tx'] = 0.0
                state['rx_conf'] = 1.0
                state['tx_conf'] = 1.0
                continue

            # 1b. Rate Symmetry Candidates
            # Use ORIGINAL values for symmetry checks to avoid order-dependence bias
            my_rx = float(orig_data.get('rx_rate', 0.0))
            peer_tx = float(peer_state['original'].get('tx_rate', 0.0))
            denom = max(my_rx, peer_tx, 1.0)

            if abs(my_rx - peer_tx) / denom <= HARDENING_THRESHOLD:
                # Signals agree
                avg_val = (my_rx + peer_tx) / 2.0
                state['rx'] = avg_val
                state['rx_conf'] = 1.0
            else:
                # Signals disagree, keep original but mark uncertain
                state['rx_conf'] = 0.5

            # Compare My TX vs Peer RX
            my_tx = float(orig_data.get('tx_rate', 0.0))
            peer_rx = float(peer_state['original'].get('rx_rate', 0.0))
            denom_tx = max(my_tx, peer_rx, 1.0)

            if abs(my_tx - peer_rx) / denom_tx <= HARDENING_THRESHOLD:
                state['tx'] = (my_tx + peer_rx) / 2.0
                state['tx_conf'] = 1.0
            else:
                state['tx_conf'] = 0.5

    # Step 2: Flow Conservation (Router Level)
    # Use flow conservation to resolve uncertainties (conf=0.5)
    for router_id, if_list in topology.items():
        router_ifs = [i for i in if_list if i in working_state]
        if not router_ifs:
            continue

        total_rx = sum(working_state[i]['rx'] for i in router_ifs)
        total_tx = sum(working_state[i]['tx'] for i in router_ifs)
        imbalance = total_rx - total_tx

        # Only attempt repair if imbalance is significant
        if abs(imbalance) > max(total_rx, total_tx, 1.0) * HARDENING_THRESHOLD:
            best_fix = None
            min_residual = abs(imbalance)

            # Find the best single interface repair that fixes flow conservation
            for i in router_ifs:
                st = working_state[i]
                peer_id = st['original'].get('connected_to')
                if not peer_id or peer_id not in working_state:
                    continue
                peer_st = working_state[peer_id]

                # Check if replacing RX with peer's TX helps (if RX is uncertain)
                if st['rx_conf'] <= 0.5:
                    candidate_rx = peer_st['tx']
                    # New imbalance = (total_rx - old_rx + new_rx) - total_tx
                    #               = imbalance - old_rx + new_rx
                    new_imbalance = imbalance - st['rx'] + candidate_rx
                    if abs(new_imbalance) < min_residual:
                        min_residual = abs(new_imbalance)
                        best_fix = (i, 'rx', candidate_rx)

                # Check if replacing TX with peer's RX helps (if TX is uncertain)
                if st['tx_conf'] <= 0.5:
                    candidate_tx = peer_st['rx']
                    # New imbalance = total_rx - (total_tx - old_tx + new_tx)
                    #               = imbalance + old_tx - new_tx
                    new_imbalance = imbalance + st['tx'] - candidate_tx
                    if abs(new_imbalance) < min_residual:
                        min_residual = abs(new_imbalance)
                        best_fix = (i, 'tx', candidate_tx)

            # Apply the best fix
            if best_fix:
                fid, ftype, fval = best_fix
                working_state[fid][ftype] = fval
                working_state[fid][f'{ftype}_conf'] = 0.9 # High confidence: confirmed by flow conservation

                # Update peer to match for consistency
                peer_id = working_state[fid]['original'].get('connected_to')
                if peer_id:
                    peer_ftype = 'tx' if ftype == 'rx' else 'rx'
                    working_state[peer_id][peer_ftype] = fval
                    working_state[peer_id][f'{peer_ftype}_conf'] = 0.9
=======
    # Step 1: Status Consistency & Initialization
    # We first settle status, as it overrides rates.
    for if_id, state in working_state.items():
        orig_data = state['original']
        peer_id = orig_data.get('connected_to')

        # Default assumption: Trust original values until proven otherwise
        state['rx'] = float(orig_data.get('rx_rate', 0.0))
        state['tx'] = float(orig_data.get('tx_rate', 0.0))

        if peer_id and peer_id in working_state:
            peer_state = working_state[peer_id]
            s1 = state['status']
            s2 = peer_state['status']

            # Status Logic:
            # 1. If disagreement, check traffic.
            # 2. If Peer is DOWN, I cannot be sending/receiving to them physically.

            traffic_active = (state['rx'] > 1.0 or state['tx'] > 1.0 or
                              peer_state['original'].get('rx_rate', 0.0) > 1.0 or
                              peer_state['original'].get('tx_rate', 0.0) > 1.0)

            if s1 != s2:
                if traffic_active:
                    state['status'] = 'up'
                    state['status_conf'] = 0.9
                else:
                    state['status'] = 'down'
                    state['status_conf'] = 0.9

            # If confirmed DOWN, zero out rates immediately
            if state['status'] == 'down':
                state['rx'] = 0.0
                state['tx'] = 0.0
                state['rx_conf'] = 1.0
                state['tx_conf'] = 1.0
                continue

    # Step 2: Iterative Flow & Symmetry Optimization
    # We treat the network as a system of constraints.
    # Variables: Flow on each link (Direction A->B, Direction B->A)
    # Objectives:
    #   1. Minimize (Flow - Measured_Tx_A) and (Flow - Measured_Rx_B)
    #   2. Minimize Router Imbalance (Sum In - Sum Out)

    # We use a greedy iterative approach to propagate constraints.
    ITERATIONS = 4
    sorted_interfaces = sorted(working_state.keys()) # Deterministic order

    # Helper to calculate router imbalance given CURRENT working_state values
    def get_router_imbalance(rid):
        if not rid or rid not in topology: return 0.0
        in_sum = 0.0
        out_sum = 0.0
        for iid in topology[rid]:
            if iid in working_state:
                in_sum += working_state[iid]['rx']
                out_sum += working_state[iid]['tx']
        return in_sum - out_sum

    for _ in range(ITERATIONS):
        # We process by LINK (pair of interfaces) to ensure symmetry
        processed_pairs = set()

        for if_id in sorted_interfaces:
            state = working_state[if_id]
            if state['status'] == 'down': continue

            peer_id = state['original'].get('connected_to')
            if not peer_id or peer_id not in working_state: continue

            pair_key = tuple(sorted([if_id, peer_id]))
            if pair_key in processed_pairs: continue
            processed_pairs.add(pair_key)

            peer_state = working_state[peer_id]
            if peer_state['status'] == 'down': continue

            # --- Direction 1: Local TX -> Peer RX ---
            # We want to find best flow 'f'
            meas_tx = float(state['original'].get('tx_rate', 0.0))
            meas_prx = float(peer_state['original'].get('rx_rate', 0.0))

            # Context: Router Imbalances
            r_local = state['original'].get('local_router')
            r_remote = peer_state['original'].get('local_router')

            # Current contribution to imbalance:
            # Local (Out): currently state['tx']. We want to replace with 'f'.
            # Remote (In): currently peer_state['rx']. We want to replace with 'f'.

            imb_local_base = get_router_imbalance(r_local) + state['tx'] # Remove current tx
            imb_remote_base = get_router_imbalance(r_remote) - peer_state['rx'] # Remove current rx

            candidates = [meas_tx, meas_prx]
            # If close, add average
            if abs(meas_tx - meas_prx) < max(meas_tx, meas_prx, 10.0) * HARDENING_THRESHOLD:
                candidates.append((meas_tx + meas_prx) / 2.0)

            best_f = meas_tx # Default to TX
            min_cost = float('inf')

            for v in candidates:
                cost = 0.0
                # Router Constraints
                if r_local in topology:
                    cost += abs(imb_local_base - v)
                if r_remote in topology:
                    cost += abs(imb_remote_base + v)

                # Tie-breaking: bias slightly towards TX as it's the source
                tie_breaker = 0.0
                if v == meas_tx:
                    tie_breaker = -0.0001

                final_cost = cost + tie_breaker

                if final_cost < min_cost:
                    min_cost = final_cost
                    best_f = v

            # Update State
            state['tx'] = best_f
            peer_state['rx'] = best_f

            # --- Direction 2: Local RX <- Peer TX ---
            # Symmetrically identical logic
            meas_rx = float(state['original'].get('rx_rate', 0.0))
            meas_ptx = float(peer_state['original'].get('tx_rate', 0.0))

            imb_local_base_rx = get_router_imbalance(r_local) - state['rx'] # Remove current rx
            imb_remote_base_tx = get_router_imbalance(r_remote) + peer_state['tx'] # Remove current tx

            cands_2 = [meas_rx, meas_ptx]
            if abs(meas_rx - meas_ptx) < max(meas_rx, meas_ptx, 10.0) * HARDENING_THRESHOLD:
                cands_2.append((meas_rx + meas_ptx) / 2.0)

            best_f2 = meas_ptx # Default to Sender
            min_cost2 = float('inf')

            for v in cands_2:
                cost = 0.0
                if r_local in topology:
                    cost += abs(imb_local_base_rx + v) # In
                if r_remote in topology:
                    cost += abs(imb_remote_base_tx - v) # Out

                tie_breaker = 0.0
                if v == meas_ptx:
                    tie_breaker = -0.0001

                final_cost = cost + tie_breaker

                if final_cost < min_cost2:
                    min_cost2 = final_cost
                    best_f2 = v

            state['rx'] = best_f2
            peer_state['tx'] = best_f2

    # Final Pass: Confidence Calculation
    for if_id, state in working_state.items():
        if state['status'] == 'down': continue

        peer_id = state['original'].get('connected_to')
        peer_state = working_state.get(peer_id) if peer_id else None

        # 1. Router Fit (How bad is the imbalance remaining?)
        rid = state['original'].get('local_router')
        flow_err = abs(get_router_imbalance(rid))

        # Normalize error by total flow on router
        total_flow = 0.0
        if rid and rid in topology:
            for iid in topology[rid]:
                if iid in working_state:
                    total_flow += working_state[iid]['rx'] + working_state[iid]['tx']

        flow_quality = 1.0
        if total_flow > 10.0:
            rel_err = flow_err / total_flow
            # Sigmoid-ish decay
            flow_quality = 1.0 / (1.0 + 20.0 * rel_err)

        # Base confidence driven by flow consistency
        base_conf = 0.5 + 0.5 * flow_quality

        state['rx_conf'] = base_conf
        state['tx_conf'] = base_conf

        # 2. Boost if original measurements agreed (Confirmation)
        if peer_state:
             # Check RX symmetry
             meas_rx = float(state['original'].get('rx_rate', 0.0))
             meas_ptx = float(peer_state['original'].get('tx_rate', 0.0))
             if abs(meas_rx - meas_ptx) / max(meas_rx, meas_ptx, 10.0) < HARDENING_THRESHOLD:
                 state['rx_conf'] = max(state['rx_conf'], 0.95)

             # Check TX symmetry
             meas_tx = float(state['original'].get('tx_rate', 0.0))
             meas_prx = float(peer_state['original'].get('rx_rate', 0.0))
             if abs(meas_tx - meas_prx) / max(meas_tx, meas_prx, 10.0) < HARDENING_THRESHOLD:
                 state['tx_conf'] = max(state['tx_conf'], 0.95)
>>>>>>> REPLACE
</DIFF>