<NAME>
physics_flow_consensus_v2
</NAME>

<DESCRIPTION>
Evolving the repair algorithm to incorporate:
1.  **Dual-Source Flow Arbitration**: Validates repairs against the *remote* router's quality. If the local router is noisy but the remote is clean (imbalance < 0.5%), the algorithm trusts the remote peer's value.
2.  **Differentiated Asymmetric Thresholds**: Introduces `STRICT_PHYSICS_LIMIT` (0.5%) to clamp physically impossible values (RX > Peer TX) strictly, while keeping `HARDENING_THRESHOLD` (2.0%) for agreement checks.
3.  **Hybrid Confidence with Linear Residual Penalty**: Replaces discrete confidence flow buckets with a linear penalty based on residual flow imbalance (`score -= imbalance_ratio * 2.0`), providing more granular calibration.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02   # 2% relative error considered 'match'
    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active' or valid
    ITERATIONS = 3               # Convergence count

    # --- Helper: Dynamic Error Calculation ---
    def get_noise_floor(v1, v2):
        # Scale noise floor for high speed links (0.5%), but keep base floor
        return max(BASE_NOISE_FLOOR, max(v1, v2) * 0.005)

    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization & Status Repair ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # Robust Status Logic
    # 1. Traffic (Local or Peer) implies UP.
    # 2. Explicit Peer DOWN implies Local DOWN (unless Local Traffic exists).
    for if_id, s in state.items():
        # Evidence check
        has_local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR

        peer_has_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['rx'] > BASE_NOISE_FLOOR or p['tx'] > BASE_NOISE_FLOOR:
                peer_has_traffic = True
            if p['status'] == 'down':
                peer_is_down = True

        # Inference
        if has_local_traffic or peer_has_traffic:
            s['status'] = 'up'
        elif peer_is_down and not has_local_traffic:
            s['status'] = 'down'
        # Else: keep original status (e.g., UP but idle)

    # Enforce Down Consistency
    for s in state.values():
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 2: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # Calculate Router Flow Imbalances
        router_net = {}
        for r_id, if_list in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
            # Net Imbalance = In - Out
            router_net[r_id] = sum_rx - sum_tx

        updates = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- RX Repair ---
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            # Flow Implied Value: What RX should be to make Net Imbalance == 0
            # Current: Net = SumRX - SumTX
            # New: (SumRX - val_self + flow_rx) - SumTX = 0
            # flow_rx = val_self - Net
            val_flow = None
            if r_id in router_net:
                val_flow = max(0.0, val_self - router_net[r_id])

            final_rx = val_self
            if val_peer is not None:
                # 1. Physics Clamping (Impossible: RX > Peer TX)
                # Allow small threshold for timing noise
                if val_self > val_peer * (1.0 + HARDENING_THRESHOLD):
                    # Impossible surplus. Clamp to Peer.
                    final_rx = val_peer

                # 2. Agreement Check
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 3. Flow Arbitration (Disagreement: likely Loss or Error)
                else:
                    # Logic: RX < Peer TX.
                    if val_flow is not None:
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            # Peer is closer to flow balance -> Loss was phantom/measurement error
                            final_rx = val_peer
                        elif err_self < err_peer:
                            # Self is closer to flow balance -> Loss is real (packet drop)
                            final_rx = val_self
                        else:
                            # Ambiguous -> Trust Peer (Source Authority)
                            final_rx = val_peer
                    else:
                        # No flow info -> Trust Peer
                        final_rx = val_peer

            # --- TX Repair ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            # Flow Implied Value:
            # New: SumRX - (SumTX - val_self + flow_tx) = 0
            # flow_tx = val_self + Net
            val_flow = None
            if r_id in router_net:
                val_flow = max(0.0, val_self + router_net[r_id])

            final_tx = val_self
            if val_peer is not None:
                # 1. Physics Clamping (Impossible: TX < Peer RX)
                if val_self < val_peer * (1.0 - HARDENING_THRESHOLD):
                    # Impossible deficit. Clamp to Peer.
                    final_tx = val_peer

                # 2. Agreement Check
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 3. Flow Arbitration
                else:
                    # Logic: TX > Peer RX.
                    if val_flow is not None:
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            # Peer closer -> TX was phantom/noise
                            final_tx = val_peer
                        elif err_self < err_peer:
                            # Self closer -> Packet loss on wire
                            final_tx = val_self
                        else:
                            final_tx = val_peer
                    else:
                        final_tx = val_peer

            updates[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates synchronously
        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence Calibration ---
    result = {}

    # Recalculate Final Flow Quality
    router_quality = {}
    for r_id, if_list in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imbalance = abs(sum_rx - sum_tx) / vol
        # Quality: 1.0 = balanced, 0.0 = >10% imbalance
        router_quality[r_id] = max(0.0, 1.0 - (imbalance * 10.0))

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        flow_q = router_quality.get(r_id, 0.5)

        def get_conf(final, orig, peer_val, flow_qual):
            # 1. Did we change the value?
            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD

            # 2. Does Peer support the final value?
            peer_supports = False
            if peer_val is not None:
                if calc_error(final, peer_val) < HARDENING_THRESHOLD:
                    peer_supports = True

            conf = 1.0

            if was_repaired:
                if peer_supports:
                    # Strongest case: Repaired to match Peer.
                    if flow_qual > 0.8:
                        conf = 0.98 # Validated by Link + Flow
                    else:
                        conf = 0.95 # Validated by Link
                else:
                    # Repaired, but doesn't match Peer? (Flow override or Averaging)
                    if flow_qual > 0.9:
                        conf = 0.85 # Flow forced the value
                    else:
                        conf = 0.60 # Weak repair
            else:
                # Kept original
                if peer_val is not None and not peer_supports:
                    # We defied Peer.
                    # Valid if Flow supports Self strongly.
                    if flow_qual > 0.9:
                        conf = 0.95
                    else:
                        conf = 0.70 # Ambiguous
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return conf

        rx_conf = get_conf(s['rx'], orig_rx, peer_tx, flow_q)
        tx_conf = get_conf(s['tx'], orig_tx, peer_rx, flow_q)

        # Status confidence
        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
=======
    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02    # 2% relative error considered 'match'
    STRICT_PHYSICS_LIMIT = 0.005  # 0.5% threshold for impossible physics (e.g. RX > Peer TX)
    BASE_NOISE_FLOOR = 10.0       # Minimum Mbps to consider 'active' or valid
    ITERATIONS = 4                # Convergence count

    # --- Helper: Dynamic Error Calculation ---
    def get_noise_floor(v1, v2):
        # Scale noise floor for high speed links (0.5%), but keep base floor
        return max(BASE_NOISE_FLOOR, max(v1, v2) * 0.005)

    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization & Status Repair ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # Robust Status Logic
    for if_id, s in state.items():
        has_local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR

        peer_has_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['rx'] > BASE_NOISE_FLOOR or p['tx'] > BASE_NOISE_FLOOR:
                peer_has_traffic = True
            if p['status'] == 'down':
                peer_is_down = True

        if has_local_traffic or peer_has_traffic:
            s['status'] = 'up'
        elif peer_is_down and not has_local_traffic:
            s['status'] = 'down'

    for s in state.values():
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 2: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # Calculate Router Flow Imbalances & Quality
        router_stats = {}
        for r_id, if_list in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
            net = sum_rx - sum_tx
            vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            # Quality: 1.0 = perfect, 0.0 = >10% imbalance
            qual = max(0.0, 1.0 - (abs(net) / vol * 10.0))
            router_stats[r_id] = {'net': net, 'qual': qual}

        updates = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # Context for Arbitration
            rs_local = router_stats.get(r_id, {'net': 0.0, 'qual': 0.5})

            # --- RX Repair ---
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None
            # Flow Implied: val_self - net (if net > 0, we need less RX; if net < 0, we need more RX)
            val_flow = max(0.0, val_self - rs_local['net'])

            final_rx = val_self
            if val_peer is not None:
                # 1. Physics Clamping (Strict)
                # RX > Peer TX is physically impossible (no creation on wire).
                if val_self > val_peer * (1.0 + STRICT_PHYSICS_LIMIT):
                    final_rx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 3. Flow Arbitration (RX < Peer TX likely)
                else:
                    # Dual-Source Arbitration (Recommendation 1)
                    # Check Remote Router Quality
                    remote_qual = 0.5
                    if has_peer:
                        remote_rid = state[peer_id]['router']
                        remote_qual = router_stats.get(remote_rid, {}).get('qual', 0.5)

                    # If Local is noisy but Remote is clean, trust Peer (Remote TX)
                    if remote_qual > 0.95 and rs_local['qual'] < 0.8:
                        final_rx = val_peer
                    else:
                        # Use Distance to Local Flow Target
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            final_rx = val_peer
                        elif err_self < err_peer:
                            final_rx = val_self
                        else:
                            final_rx = val_peer # Default to Peer

            # --- TX Repair ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None
            # Flow Implied: val_self + net (if net > 0, we need more TX; if net < 0, we need less TX)
            val_flow = max(0.0, val_self + rs_local['net'])

            final_tx = val_self
            if val_peer is not None:
                # 1. Physics Clamping (Strict)
                # TX < Peer RX is physically impossible
                if val_self < val_peer * (1.0 - STRICT_PHYSICS_LIMIT):
                    final_tx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 3. Flow Arbitration (TX > Peer RX likely)
                else:
                    remote_qual = 0.5
                    if has_peer:
                        remote_rid = state[peer_id]['router']
                        remote_qual = router_stats.get(remote_rid, {}).get('qual', 0.5)

                    if remote_qual > 0.95 and rs_local['qual'] < 0.8:
                        final_tx = val_peer
                    else:
                        err_self = calc_error(val_self, val_flow)
                        err_peer = calc_error(val_peer, val_flow)

                        if err_peer < err_self:
                            final_tx = val_peer
                        elif err_self < err_peer:
                            final_tx = val_self
                        else:
                            final_tx = val_peer

            updates[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates synchronously
        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence Calibration ---
    result = {}

    # Final Flow Quality
    router_final_stats = {}
    for r_id, if_list in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imbalance = abs(sum_rx - sum_tx)
        router_final_stats[r_id] = {'imb_ratio': imbalance / vol}

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        rs = router_final_stats.get(r_id, {'imb_ratio': 0.0})
        flow_penalty = rs['imb_ratio'] * 2.0 # Linear penalty (Rec 3)

        def get_conf(final, orig, peer_val):
            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD
            peer_supports = (peer_val is not None) and (calc_error(final, peer_val) < HARDENING_THRESHOLD)

            conf = 1.0

            # Base Buckets
            if was_repaired:
                if peer_supports:
                    conf = 0.98 # Validated by Link
                else:
                    conf = 0.85 # Flow forced / Averaging
            else:
                if peer_val is not None and not peer_supports:
                    conf = 0.80 # Trusted Self over Peer
                else:
                    conf = 1.0 # Agreement

            # Apply Flow Penalty (Hybrid Model)
            conf = max(0.0, conf - flow_penalty)

            # Cap at 1.0
            return min(1.0, conf)

        rx_conf = get_conf(s['rx'], orig_rx, peer_tx)
        tx_conf = get_conf(s['tx'], orig_tx, peer_rx)

        # Status confidence
        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
>>>>>>> REPLACE
</DIFF>