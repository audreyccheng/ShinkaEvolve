<NAME>
golden_truth_consensus
</NAME>

<DESCRIPTION>
Implement "Golden Truth Consensus" logic which identifies and prioritizes telemetry values that simultaneously satisfy the flow conservation constraints of both the local and remote routers.
Also refines confidence calibration by combining a weighted "Quality" score (Local + Remote) with a linear penalty for residual flow imbalance, providing more granular and accurate confidence estimates.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
Network telemetry repair algorithm using Analytic Flow Consensus.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network telemetry using Analytic Flow Consensus and Physics Constraints.

    Strategy:
    1. Status Repair: Infer status from local/remote traffic activity.
    2. Rate Repair (Iterative):
       - Calculate 'Flow Implied' rate that balances the router.
       - Enforce strict physical constraints (RX <= Peer TX) with tight tolerance (0.5%).
       - Arbitrate loss scenarios (RX < Peer TX) using Flow Implied value.
       - Use 'Solidity' check: if Peer matches Flow Implied, trust it highly.
    3. Confidence Calibration:
       - Hybrid model: Discrete confidence buckets minus linear penalty for residual flow imbalance.
    """

    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02   # 2% relative error considered 'match'
    PHYSICAL_THRESHOLD = 0.005   # 0.5% for physical impossibility checks
    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active'
    ITERATIONS = 4               # Convergence count

    # --- Helper: Dynamic Noise Floor ---
    def get_noise_floor(rate_a, rate_b=0.0):
        # Scale noise floor for high speed links (0.1%), but keep base floor
        mx = max(rate_a, rate_b)
        return max(BASE_NOISE_FLOOR, mx * 0.001)

    # --- Helper: Normalized Error ---
    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # --- Step 2: Robust Status Repair ---
    for if_id, s in state.items():
        # Evidence
        local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR

        peer_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['orig_rx'] > BASE_NOISE_FLOOR or p['orig_tx'] > BASE_NOISE_FLOOR:
                peer_traffic = True
            if p['orig_status'] == 'down':
                peer_is_down = True

        # Decision Matrix
        if local_traffic or peer_traffic:
            s['status'] = 'up'
        elif peer_is_down and not local_traffic:
            s['status'] = 'down'
        # Else: keep original

        # Consistency
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            # Imbalance = RX - TX
            router_stats[r_id] = {
                'imbalance': sum_rx - sum_tx
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- Flow Implied Values ---
            flow_rx = None
            flow_tx = None

            if r_id in router_stats:
                rs = router_stats[r_id]
                # To balance: RX_new = RX_old - Imbalance
                flow_rx = max(0.0, s['rx'] - rs['imbalance'])
                # To balance: TX_new = TX_old + Imbalance
                flow_tx = max(0.0, s['tx'] + rs['imbalance'])

            # --- RX Repair ---
            # Constraint: RX <= Peer TX
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # Solidity Check: Does Peer match Flow?
                solidity_match = False
                if flow_rx is not None:
                    if calc_error(val_peer, flow_rx) < HARDENING_THRESHOLD:
                        solidity_match = True

                # 1. Impossible Case (RX > Peer TX)
                # Strict enforcement of physics
                if val_self > val_peer * (1.0 + PHYSICAL_THRESHOLD):
                    final_rx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 3. Loss Case (RX < Peer TX) or Disagreement
                else:
                    if solidity_match:
                        # Flow confirms Peer (Packet Loss detected, Peer is correct source rate)
                        final_rx = val_peer
                    elif flow_rx is not None:
                        err_self_flow = calc_error(val_self, flow_rx)
                        err_peer_flow = calc_error(val_peer, flow_rx)

                        if err_peer_flow < err_self_flow:
                            # Peer is closer to balancing flow -> Phantom loss
                            final_rx = val_peer
                        elif err_self_flow < err_peer_flow:
                            # Self is closer -> Real loss
                            final_rx = val_self
                        else:
                            final_rx = val_peer
                    else:
                        final_rx = val_peer

            # --- TX Repair ---
            # Constraint: TX >= Peer RX
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                # Solidity Check
                solidity_match = False
                if flow_tx is not None:
                    if calc_error(val_peer, flow_tx) < HARDENING_THRESHOLD:
                        solidity_match = True

                # 1. Impossible Case (TX < Peer RX)
                if val_self < val_peer * (1.0 - PHYSICAL_THRESHOLD):
                     final_tx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 3. Surplus Case (TX > Peer RX) or Disagreement
                else:
                    if solidity_match:
                        # Flow confirms Peer (Phantom TX repaired)
                        final_tx = val_peer
                    elif flow_tx is not None:
                        err_self_flow = calc_error(val_self, flow_tx)
                        err_peer_flow = calc_error(val_peer, flow_tx)

                        if err_peer_flow < err_self_flow:
                            final_tx = val_peer
                        elif err_self_flow < err_peer_flow:
                            final_tx = val_self
                        else:
                            final_tx = val_peer
                    else:
                        final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 4: Confidence Calibration ---
    result = {}

    # Calculate Residual Router Imbalance Ratio
    router_imb_ratio = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        router_imb_ratio[r_id] = abs(sum_rx - sum_tx) / vol

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        r_id = s['router']
        imb_ratio = router_imb_ratio.get(r_id, 0.0)

        def get_confidence(final, orig, peer_val, imb_ratio):
            # Error metric
            dist_orig = calc_error(final, orig)

            # Peer match?
            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            # Discrete Base Buckets
            score = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # Repaired
                if matches_peer:
                    # Aligned with peer (Link Symmetry + Potential Flow Consensus)
                    score = 0.98
                else:
                    # Repaired, but doesn't match Peer (e.g. Averaged or Flow forced Self)
                    # This is lower confidence
                    score = 0.85
            else:
                # Kept Original
                if peer_val is not None and not matches_peer:
                    # Disagreement. Kept Self.
                    # This relies heavily on Flow Validation implicitly
                    score = 0.90
                else:
                    # Agreement or No Peer
                    score = 1.0

            # Linear Penalty for Residual Imbalance
            # If the router is still imbalanced (e.g. 10%), confidence should drop significantly.
            # Penalty Factor: 2.0. So 10% imbalance -> -0.2 confidence.
            penalty = imb_ratio * 2.0
            score -= penalty

            return max(0.0, min(1.0, score))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, imb_ratio)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, imb_ratio)

        # Status confidence
        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
=======
"""
Network telemetry repair algorithm using Golden Truth Consensus.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network telemetry using Golden Truth Consensus.

    Strategy:
    1. Status Repair: Infer status from traffic activity.
    2. Rate Repair (Iterative):
       - Calculate Flow Targets for both Local and Remote routers.
       - Identify 'Golden Values': Values that satisfy both Local and Remote flow constraints simultaneously.
       - Arbitration:
         - Prioritize Golden Values.
         - Enforce Physics (RX <= Peer TX).
         - Use Remote Quality to weight decision between Self and Peer in ambiguous cases.
    3. Confidence Calibration:
       - continuous scoring based on alignment with Peer, Router Quality, and Residual Imbalance.
    """

    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02    # 2% relative error
    PHYSICS_THRESHOLD = 0.005     # 0.5% strict tolerance for physics
    GOLDEN_THRESHOLD = 0.015      # 1.5% tolerance for Golden Truth match
    BASE_NOISE_FLOOR = 10.0       # Minimum Mbps to consider 'active'
    ITERATIONS = 5                # Convergence count

    # --- Helper: Dynamic Noise Floor ---
    def get_noise_floor(rate_a, rate_b=0.0):
        mx = max(rate_a, rate_b)
        return max(BASE_NOISE_FLOOR, mx * 0.001)

    # --- Helper: Normalized Error ---
    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # --- Step 2: Robust Status Repair ---
    for if_id, s in state.items():
        # Evidence
        local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR

        peer_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            if p['orig_rx'] > BASE_NOISE_FLOOR or p['orig_tx'] > BASE_NOISE_FLOOR:
                peer_traffic = True
            if p['orig_status'] == 'down':
                peer_is_down = True

        # Decision Matrix
        if local_traffic or peer_traffic:
            s['status'] = 'up'
        elif peer_is_down and not local_traffic:
            s['status'] = 'down'

        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            router_stats[r_id] = {
                'imbalance': imbalance,
                'quality': max(0.0, 1.0 - (abs(imbalance) / vol * 10.0))
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # Context
            l_stats = router_stats.get(local_r, {'imbalance': 0.0, 'quality': 0.5})
            r_stats = router_stats.get(remote_r, {'imbalance': 0.0, 'quality': 0.5}) if remote_r else None

            # --- RX Repair ---
            # RX should match Peer TX.
            # Local Flow Target for RX: RX_new = RX_curr - Imbalance
            target_rx_local = max(0.0, s['rx'] - l_stats['imbalance'])

            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # 1. Golden Truth Check
                # Does Peer TX satisfy both Local Flow and Remote Flow?
                is_golden = False
                if r_stats:
                    # Remote Flow Target for Peer TX: Peer_TX_new = Peer_TX_curr + Remote_Imbalance
                    # (Note: Peer TX is an OUTPUT for Remote Router)
                    target_tx_remote = max(0.0, val_peer + r_stats['imbalance'])

                    # Check if Peer value satisfies Remote Flow
                    if calc_error(val_peer, target_tx_remote) < GOLDEN_THRESHOLD:
                        # Check if Peer value satisfies Local Flow
                        if calc_error(val_peer, target_rx_local) < GOLDEN_THRESHOLD:
                            is_golden = True

                # 2. Physics Violation (RX > Peer TX)
                if val_self > val_peer * (1.0 + PHYSICS_THRESHOLD):
                    if is_golden:
                        final_rx = val_peer
                    else:
                        # Check if this "surplus" RX is actually needed by Local Flow
                        # If Local Imbalance > 0 (Surplus RX), and we have Surplus RX here, it's likely noise.
                        # If Local Imbalance < 0 (Missing RX), maybe Peer is under-reporting?
                        if l_stats['imbalance'] < 0 and r_stats and r_stats['quality'] < 0.5:
                             # We need RX, Peer is low quality. Trust Self?
                             # But Physics is strong. Only trust Self if error is massive?
                             # Usually Clamp.
                             final_rx = val_peer
                        else:
                             final_rx = val_peer

                # 3. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 4. Disagreement (RX < Peer TX usually)
                else:
                    if is_golden:
                        final_rx = val_peer
                    else:
                        # Arbitration
                        d_peer = calc_error(val_peer, target_rx_local)
                        d_self = calc_error(val_self, target_rx_local)

                        # Weight by Quality
                        # If Remote is high quality, Peer is more reliable.
                        r_q = r_stats['quality'] if r_stats else 0.5
                        l_q = l_stats['quality']

                        # If Peer balances local router better, take it.
                        if d_peer < d_self:
                            final_rx = val_peer
                        elif d_self < d_peer:
                            # Self balances better.
                            # Only keep Self if Local Quality is decent OR Remote is bad.
                            if l_q > 0.3 or r_q < 0.5:
                                final_rx = val_self
                            else:
                                final_rx = val_peer
                        else:
                            final_rx = val_peer

            # --- TX Repair ---
            # TX should match Peer RX.
            # Local Flow Target for TX: TX_new = TX_curr + Imbalance
            target_tx_local = max(0.0, s['tx'] + l_stats['imbalance'])

            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                # 1. Golden Truth
                is_golden = False
                if r_stats:
                    # Remote Flow Target for Peer RX: Peer_RX_new = Peer_RX_curr - Remote_Imbalance
                    target_rx_remote = max(0.0, val_peer - r_stats['imbalance'])
                    if calc_error(val_peer, target_rx_remote) < GOLDEN_THRESHOLD:
                        if calc_error(val_peer, target_tx_local) < GOLDEN_THRESHOLD:
                            is_golden = True

                # 2. Physics (TX < Peer RX) -> Impossible
                if val_self < val_peer * (1.0 - PHYSICS_THRESHOLD):
                     final_tx = val_peer

                # 3. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 4. Disagreement (TX > Peer RX)
                else:
                    if is_golden:
                        final_tx = val_peer
                    else:
                        d_peer = calc_error(val_peer, target_tx_local)
                        d_self = calc_error(val_self, target_tx_local)

                        if d_peer < d_self:
                            final_tx = val_peer
                        elif d_self < d_peer:
                            final_tx = val_self
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 4: Confidence Calibration ---
    result = {}

    # Recalculate Final Stats
    final_router_stats = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imb = abs(sum_rx - sum_tx)
        final_router_stats[r_id] = {
            'quality': max(0.0, 1.0 - (imb / vol * 10.0)),
            'imb_ratio': imb / vol
        }

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        r_id = s['router']
        remote_r_id = s['remote_router']

        l_stat = final_router_stats.get(r_id, {'quality': 0.5, 'imb_ratio': 0.0})
        r_stat = final_router_stats.get(remote_r_id, {'quality': 0.5, 'imb_ratio': 0.0}) if remote_r_id else {'quality': 0.5, 'imb_ratio': 0.0}

        def get_confidence(final, orig, peer_val, l_s, r_s):
            dist_orig = calc_error(final, orig)

            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            # Base Score
            score = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # High confidence: Consensus with Peer.
                    # Boost by Router Qualities
                    # 0.85 base + up to 0.14 boost
                    score = 0.85 + (0.08 * l_s['quality']) + (0.06 * r_s['quality'])
                else:
                    # Repaired vs Peer Agreement (Flow Arbitration)
                    # Relies on Local Quality
                    if l_s['quality'] > 0.9:
                        score = 0.85
                    else:
                        score = 0.60
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Disagreement.
                    # Trusting Self.
                    if l_s['quality'] > 0.9:
                        score = 0.95
                    elif l_s['quality'] > 0.7:
                        score = 0.80
                    else:
                        score = 0.70
                else:
                    score = 1.0

            # Residual Penalty
            # If the router is still imbalanced (e.g. 10%), confidence should drop significantly.
            penalty = l_s['imb_ratio'] * 1.5
            score -= penalty

            return max(0.0, min(1.0, score))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, l_stat, r_stat)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, l_stat, r_stat)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
>>>>>>> REPLACE
</DIFF>