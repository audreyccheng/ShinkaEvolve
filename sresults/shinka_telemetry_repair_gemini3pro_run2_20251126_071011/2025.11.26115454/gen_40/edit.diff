--- a/original.py
+++ b/original.py
@@ -1,330 +1,330 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
-
-Takes interface telemetry data and detects/repairs inconsistencies based on
-network invariants like link symmetry and flow conservation.
 """
 from typing import Dict, Any, Tuple, List
-
-def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
+import math
+
+def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]], 
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
-    Repair network interface telemetry using Triangular Consistency (Self, Peer, Flow).
-
-    Algorithm:
-    1. Status Repair: Enforce consistency between Status and Traffic.
-    2. Rate Repair: Iterative consensus optimization.
-       - For each link, we have three signals: Self, Peer, and Flow-Inferred.
-       - We prefer values that satisfy: Symmetry (Self ~= Peer) AND Flow Conservation.
-       - Arbitration logic handles "Impossible" (RX > Peer TX) vs "Loss" (RX < Peer TX) cases
-         by checking which value minimizes the local router's flow imbalance.
-    3. Confidence Calibration:
-       - Confidence is assigned based on the agreement of the final value with the three signals.
-       - High confidence if multiple independent signals agree (e.g. Peer + Flow).
+    Repair network interface telemetry using Flow Consensus with Physics Clamping.
+    
+    Strategy:
+    1. Status Repair: Infer status from Local AND Peer traffic evidence.
+    2. Rate Repair (Iterative):
+       - Calculate 'Flow Implied' value for each interface to balance routers.
+       - Apply Strict Physics Constraints:
+         - RX cannot exceed Peer TX (Phantom Traffic).
+         - TX cannot be less than Peer RX (Creation on wire).
+       - Arbitrate remaining disagreements (Loss/Noise) using Flow Consensus.
+         - Compare distance of Self/Peer to the Flow Implied target.
+    3. Confidence: Calibration based on repair magnitude, Peer agreement, and Flow Quality.
     """
-
+    
     # --- Configuration ---
-    # Tolerance for measurement noise (approx 2%)
-    HARDENING_THRESHOLD = 0.02
-    # Minimum rate to consider significant (noise floor)
-    MIN_RATE_THRESHOLD = 10.0
-    # Convergence iterations
-    ITERATIONS = 2
-
-    # --- Helper Functions ---
-    def get_diff(v1, v2):
-        """Normalized difference between two rates."""
-        base = max(v1, v2, MIN_RATE_THRESHOLD)
-        return abs(v1 - v2) / base
+    HARDENING_THRESHOLD = 0.02   # 2% relative error considered 'match'
+    BASE_NOISE_FLOOR = 10.0      # Minimum Mbps to consider 'active' or valid
+    ITERATIONS = 3               # Convergence count
+    
+    # --- Helper: Dynamic Error Calculation ---
+    def get_noise_floor(v1, v2):
+        # Scale noise floor for high speed links (0.5%), but keep base floor
+        return max(BASE_NOISE_FLOOR, max(v1, v2) * 0.005)
+
+    def calc_error(v1, v2):
+        nf = get_noise_floor(v1, v2)
+        return abs(v1 - v2) / max(v1, v2, nf)
 
     # --- Step 1: Initialization & Status Repair ---
     state = {}
     for if_id, data in telemetry.items():
         state[if_id] = {
             'rx': float(data.get('rx_rate', 0.0)),
             'tx': float(data.get('tx_rate', 0.0)),
             'status': data.get('interface_status', 'unknown'),
             'peer': data.get('connected_to'),
             'router': data.get('local_router'),
             'orig_rx': float(data.get('rx_rate', 0.0)),
             'orig_tx': float(data.get('tx_rate', 0.0)),
             'orig_status': data.get('interface_status', 'unknown')
         }
-
+        
     # Robust Status Logic
-    # If a port is passing significant traffic, it MUST be UP.
-    # If a port is connected to a DOWN peer, it MUST be DOWN (unless local traffic contradicts).
+    # 1. Traffic (Local or Peer) implies UP.
+    # 2. Explicit Peer DOWN implies Local DOWN (unless Local Traffic exists).
     for if_id, s in state.items():
-        # Check Local Activity
-        is_active = s['rx'] > MIN_RATE_THRESHOLD or s['tx'] > MIN_RATE_THRESHOLD
-
-        # Check Peer Status
-        peer_id = s['peer']
-        peer_down = False
-        if peer_id and peer_id in telemetry:
-            if telemetry[peer_id].get('interface_status') == 'down':
-                peer_down = True
-
-        if is_active:
+        # Evidence check
+        has_local_traffic = s['rx'] > BASE_NOISE_FLOOR or s['tx'] > BASE_NOISE_FLOOR
+        
+        peer_has_traffic = False
+        peer_is_down = False
+        if s['peer'] and s['peer'] in state:
+            p = state[s['peer']]
+            if p['rx'] > BASE_NOISE_FLOOR or p['tx'] > BASE_NOISE_FLOOR:
+                peer_has_traffic = True
+            if p['status'] == 'down':
+                peer_is_down = True
+                
+        # Inference
+        if has_local_traffic or peer_has_traffic:
             s['status'] = 'up'
-        elif peer_down:
+        elif peer_is_down and not has_local_traffic:
             s['status'] = 'down'
-        # Else: keep original status (could be up and idle)
-
-        # Consistency: Down ports have 0 rate
+        # Else: keep original status (e.g., UP but idle)
+
+    # Enforce Down Consistency
+    for s in state.values():
         if s['status'] != 'up':
             s['rx'] = 0.0
             s['tx'] = 0.0
 
     # --- Step 2: Iterative Rate Repair ---
     for _ in range(ITERATIONS):
-        # 1. Calculate Router Flow States
-        # We need this to verify if a proposed repair helps or hurts flow conservation
-        router_flows = {}
-        for r_id, if_ids in topology.items():
-            r_rx = sum(state[i]['rx'] for i in if_ids if i in state)
-            r_tx = sum(state[i]['tx'] for i in if_ids if i in state)
-            # Flow Balance = Total Input - Total Output
-            router_flows[r_id] = {'rx': r_rx, 'tx': r_tx, 'net': r_rx - r_tx}
-
-        next_state_updates = {}
-
+        
+        # Calculate Router Flow Imbalances
+        router_net = {}
+        for r_id, if_list in topology.items():
+            sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
+            sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
+            # Net Imbalance = In - Out
+            router_net[r_id] = sum_rx - sum_tx
+            
+        updates = {}
+        
         for if_id, s in state.items():
             if s['status'] != 'up':
-                next_state_updates[if_id] = {'rx': 0.0, 'tx': 0.0}
+                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                 continue
-
+                
             peer_id = s['peer']
             r_id = s['router']
             has_peer = peer_id and peer_id in state
-
-            curr_rx = s['rx']
-            curr_tx = s['tx']
-
-            # --- Repair RX Rate ---
-            # Signals: Self(curr_rx), Peer(peer_tx), Flow
-            final_rx = curr_rx
-
-            if has_peer:
-                peer_tx = state[peer_id]['tx']
-                diff = get_diff(curr_rx, peer_tx)
-
-                if diff <= HARDENING_THRESHOLD:
-                    # Consensus: Average to reduce noise
-                    final_rx = (curr_rx + peer_tx) / 2.0
+            
+            # --- RX Repair ---
+            val_self = s['rx']
+            val_peer = state[peer_id]['tx'] if has_peer else None
+            
+            # Flow Implied Value: What RX should be to make Net Imbalance == 0
+            # Current: Net = SumRX - SumTX
+            # New: (SumRX - val_self + flow_rx) - SumTX = 0
+            # flow_rx = val_self - Net
+            val_flow = None
+            if r_id in router_net:
+                val_flow = max(0.0, val_self - router_net[r_id])
+            
+            final_rx = val_self
+            if val_peer is not None:
+                # 1. Physics Clamping (Impossible: RX > Peer TX)
+                # Allow small threshold for timing noise
+                if val_self > val_peer * (1.0 + HARDENING_THRESHOLD):
+                    # Impossible surplus. Clamp to Peer.
+                    final_rx = val_peer
+                
+                # 2. Agreement Check
+                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
+                    final_rx = (val_self + val_peer) / 2.0
+                    
+                # 3. Flow Arbitration (Disagreement: likely Loss or Error)
                 else:
-                    # Disagreement. Use Flow to arbitrate.
-                    # We compare the flow imbalance resulting from choosing Self vs Peer.
-                    use_self = True
-
-                    if r_id in router_flows:
-                        f = router_flows[r_id]
-                        # Current Imbalance (using Self)
-                        imb_self = abs(f['net'])
-
-                        # Proposed Imbalance (using Peer)
-                        # New Net = Net - Self_RX + Peer_TX
-                        imb_peer = abs(f['net'] - curr_rx + peer_tx)
-
-                        # If RX > Peer TX (Impossible physics):
-                        # We only keep Self if Flow strongly supports it (Self error << Peer error).
-                        if curr_rx > peer_tx:
-                             # Stricter check: Only keep Self if Peer creates a massive error compared to Self
-                             # Bias term ensures we prefer Peer if errors are comparable.
-                             if imb_peer < imb_self + MIN_RATE_THRESHOLD:
-                                 use_self = False
-
-                        # If RX < Peer TX (Packet Loss?):
-                        # We trust Peer (restore loss) if it helps flow (i.e. we have a deficit).
-                        # We trust Self (real loss) if restoring Peer would create surplus.
+                    # Logic: RX < Peer TX.
+                    if val_flow is not None:
+                        err_self = calc_error(val_self, val_flow)
+                        err_peer = calc_error(val_peer, val_flow)
+                        
+                        if err_peer < err_self:
+                            # Peer is closer to flow balance -> Loss was phantom/measurement error
+                            final_rx = val_peer
+                        elif err_self < err_peer:
+                            # Self is closer to flow balance -> Loss is real (packet drop)
+                            final_rx = val_self
                         else:
-                             if imb_peer < imb_self:
-                                 use_self = False
-
-                    else:
-                        # No topology info.
-                        # If Impossible (RX > Peer TX), trust Peer (Conservative).
-                        if curr_rx > peer_tx: use_self = False
-                        # If Loss (RX < Peer TX), trust Self (Loss is common).
-
-                    final_rx = curr_rx if use_self else peer_tx
-
-            # --- Repair TX Rate ---
-            # Signals: Self(curr_tx), Peer(peer_rx)
-            final_tx = curr_tx
-
-            if has_peer:
-                peer_rx = state[peer_id]['rx']
-                diff = get_diff(curr_tx, peer_rx)
-
-                if diff <= HARDENING_THRESHOLD:
-                    final_tx = (curr_tx + peer_rx) / 2.0
+                            # Ambiguous -> Trust Peer (Source Authority)
+                            final_rx = val_peer
+                    else:
+                        # No flow info -> Trust Peer
+                        final_rx = val_peer
+
+            # --- TX Repair ---
+            val_self = s['tx']
+            val_peer = state[peer_id]['rx'] if has_peer else None
+            
+            # Flow Implied Value:
+            # New: SumRX - (SumTX - val_self + flow_tx) = 0
+            # flow_tx = val_self + Net
+            val_flow = None
+            if r_id in router_net:
+                val_flow = max(0.0, val_self + router_net[r_id])
+                
+            final_tx = val_self
+            if val_peer is not None:
+                # 1. Physics Clamping (Impossible: TX < Peer RX)
+                if val_self < val_peer * (1.0 - HARDENING_THRESHOLD):
+                    # Impossible deficit. Clamp to Peer.
+                    final_tx = val_peer
+                    
+                # 2. Agreement Check
+                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
+                    final_tx = (val_self + val_peer) / 2.0
+                    
+                # 3. Flow Arbitration
                 else:
-                    use_self = True
-                    if r_id in router_flows:
-                        f = router_flows[r_id]
-                        imb_self = abs(f['net'])
-                        # New_Net = Net + Self_TX - Peer_RX
-                        imb_peer = abs(f['net'] + curr_tx - peer_rx)
-
-                        if curr_tx < peer_rx:
-                             # Impossible (TX < Peer RX). Trust Peer usually.
-                             # Only keep Self if Peer makes flow worse.
-                             if imb_peer < imb_self + MIN_RATE_THRESHOLD:
-                                 use_self = False
+                    # Logic: TX > Peer RX.
+                    if val_flow is not None:
+                        err_self = calc_error(val_self, val_flow)
+                        err_peer = calc_error(val_peer, val_flow)
+                        
+                        if err_peer < err_self:
+                            # Peer closer -> TX was phantom/noise
+                            final_tx = val_peer
+                        elif err_self < err_peer:
+                            # Self closer -> Packet loss on wire
+                            final_tx = val_self
                         else:
-                             # TX > Peer RX (Loss on wire).
-                             # If Peer choice reduces imbalance, use Peer (Phantom TX corrected).
-                             if imb_peer < imb_self:
-                                 use_self = False
-                    else:
-                        if curr_tx < peer_rx: use_self = False
-
-                    final_tx = curr_tx if use_self else peer_rx
-
-            next_state_updates[if_id] = {'rx': final_rx, 'tx': final_tx}
-
-        # Apply updates
-        for if_id, vals in next_state_updates.items():
+                            final_tx = val_peer
+                    else:
+                        final_tx = val_peer
+            
+            updates[if_id] = {'rx': final_rx, 'tx': final_tx}
+            
+        # Apply updates synchronously
+        for if_id, vals in updates.items():
             state[if_id]['rx'] = vals['rx']
             state[if_id]['tx'] = vals['tx']
 
     # --- Step 3: Confidence Calibration ---
     result = {}
-
-    # Assess Final Flow Quality per Router
+    
+    # Recalculate Final Flow Quality
     router_quality = {}
-    for r_id, if_ids in topology.items():
-        r_rx = sum(state[i]['rx'] for i in if_ids if i in state)
-        r_tx = sum(state[i]['tx'] for i in if_ids if i in state)
-        mx = max(r_rx, r_tx, MIN_RATE_THRESHOLD)
-        imbalance = abs(r_rx - r_tx) / mx
-        # Linear decay: 0% imb -> 1.0, 10% imb -> 0.5, 20% -> 0.0
-        router_quality[r_id] = max(0.0, 1.0 - (imbalance * 5.0))
-
+    for r_id, if_list in topology.items():
+        sum_rx = sum(state[i]['rx'] for i in if_list if i in state)
+        sum_tx = sum(state[i]['tx'] for i in if_list if i in state)
+        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
+        imbalance = abs(sum_rx - sum_tx) / vol
+        # Quality: 1.0 = balanced, 0.0 = >10% imbalance
+        router_quality[r_id] = max(0.0, 1.0 - (imbalance * 10.0))
+            
     for if_id, s in state.items():
         orig_rx = s['orig_rx']
         orig_tx = s['orig_tx']
-
+        
         peer_id = s['peer']
         has_peer = peer_id and peer_id in state
         r_id = s['router']
-
+        
         peer_tx = state[peer_id]['tx'] if has_peer else None
         peer_rx = state[peer_id]['rx'] if has_peer else None
-
+        
         flow_q = router_quality.get(r_id, 0.5)
-
-        def calculate_confidence(final_val, orig_val, peer_val, is_tx):
-            # 1. Check Agreement
-            agrees_peer = False
+        
+        def get_conf(final, orig, peer_val, flow_qual):
+            # 1. Did we change the value?
+            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD
+            
+            # 2. Does Peer support the final value?
+            peer_supports = False
             if peer_val is not None:
-                if get_diff(final_val, peer_val) < HARDENING_THRESHOLD:
-                    agrees_peer = True
-
-            # 2. Check Change
-            was_changed = get_diff(final_val, orig_val) > HARDENING_THRESHOLD
-
-            # 3. Assign Score
-            if was_changed:
-                # We repaired the value.
-                if agrees_peer:
-                    # Strongest Repair: Matches Peer.
-                    # Boost if Flow also agrees.
-                    if flow_q > 0.9: return 0.98
-                    return 0.95
+                if calc_error(final, peer_val) < HARDENING_THRESHOLD:
+                    peer_supports = True
+            
+            conf = 1.0
+            
+            if was_repaired:
+                if peer_supports:
+                    # Strongest case: Repaired to match Peer.
+                    if flow_qual > 0.8: 
+                        conf = 0.98 # Validated by Link + Flow
+                    else:
+                        conf = 0.95 # Validated by Link
                 else:
-                    # Repaired, but doesn't match Peer?
-                    return 0.8
+                    # Repaired, but doesn't match Peer? (Flow override or Averaging)
+                    if flow_qual > 0.9: 
+                        conf = 0.85 # Flow forced the value
+                    else:
+                        conf = 0.60 # Weak repair
             else:
-                # We kept the value.
-                if peer_val is not None and not agrees_peer:
-                    # Disagreement kept.
-                    if is_tx and final_val > peer_val:
-                        # TX > Peer RX (Loss). Very common.
-                        # If Flow confirms (quality high), we are confident.
-                        if flow_q > 0.9: return 0.95
-                        return 0.85
-                    elif not is_tx and final_val < peer_val:
-                        # RX < Peer TX (Loss).
-                        if flow_q > 0.9: return 0.95
-                        return 0.85
-                    else:
-                        # "Impossible" case kept (e.g. RX > Peer TX).
-                        # Only justified if Flow is perfect.
-                        if flow_q > 0.95: return 0.9
-                        return 0.7 # Suspicious
-
-                # Default / Agreement
-                return 1.0
-
-        rx_conf = calculate_confidence(s['rx'], orig_rx, peer_tx, False)
-        tx_conf = calculate_confidence(s['tx'], orig_tx, peer_rx, True)
-
+                # Kept original
+                if peer_val is not None and not peer_supports:
+                    # We defied Peer.
+                    # Valid if Flow supports Self strongly.
+                    if flow_qual > 0.9: 
+                        conf = 0.95 
+                    else:
+                        conf = 0.70 # Ambiguous
+                else:
+                    # Agreement or No Peer
+                    conf = 1.0
+            
+            return conf
+        
+        rx_conf = get_conf(s['rx'], orig_rx, peer_tx, flow_q)
+        tx_conf = get_conf(s['tx'], orig_tx, peer_rx, flow_q)
+        
+        # Status confidence
         st_conf = 1.0
         if s['status'] != s['orig_status']:
             st_conf = 0.95
-
+            
         result[if_id] = {
             'rx_rate': (orig_rx, s['rx'], rx_conf),
             'tx_rate': (orig_tx, s['tx'], tx_conf),
             'interface_status': (s['orig_status'], s['status'], st_conf),
             'connected_to': telemetry[if_id].get('connected_to'),
             'local_router': telemetry[if_id].get('local_router'),
             'remote_router': telemetry[if_id].get('remote_router')
         }
-
+        
     return result
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")