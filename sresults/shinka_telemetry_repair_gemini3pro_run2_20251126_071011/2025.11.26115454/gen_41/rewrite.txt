# EVOLVE-BLOCK-START
"""
Network telemetry repair algorithm using Dual-Flow Asymmetric Consensus.
"""
from typing import Dict, Any, Tuple, List
import math

def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]], 
                             topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
    """
    Repair network telemetry using Dual-Flow Asymmetric Consensus.
    
    Key Improvements:
    - Checks both Local and Remote router flow balance to validate link values.
    - Distinguishes between 'Impossible' errors (RX > Peer TX) and 'Plausible' loss.
    - Continuous confidence scoring based on residual consistency.
    """
    
    # --- Configuration ---
    HARDENING_THRESHOLD = 0.02    # 2% general matching tolerance
    IMPOSSIBLE_THRESHOLD = 0.01   # 1% strict tolerance for RX > Peer TX
    SOLIDITY_THRESHOLD = 0.01     # 1% tolerance for Flow == Peer matches
    BASE_NOISE_FLOOR = 10.0       # Minimum Mbps to consider 'active' or significant
    ITERATIONS = 4                # Convergence count
    
    # --- Helper: Dynamic Noise Floor ---
    def get_noise_floor(rate_a, rate_b=0.0):
        # Scale noise floor for high speed links (0.1% of max rate)
        # Allows for minor fluctuations on 100G links without triggering 'error'
        mx = max(rate_a, rate_b)
        return max(BASE_NOISE_FLOOR, mx * 0.001)

    # --- Helper: Normalized Error ---
    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)

    # --- Step 1: Initialization ---
    state = {}
    for if_id, data in telemetry.items():
        state[if_id] = {
            'rx': float(data.get('rx_rate', 0.0)),
            'tx': float(data.get('tx_rate', 0.0)),
            'status': data.get('interface_status', 'unknown'),
            'peer': data.get('connected_to'),
            'router': data.get('local_router'),
            'remote_router': data.get('remote_router'),
            'orig_rx': float(data.get('rx_rate', 0.0)),
            'orig_tx': float(data.get('tx_rate', 0.0)),
            'orig_status': data.get('interface_status', 'unknown')
        }

    # --- Step 2: Robust Status Repair ---
    for if_id, s in state.items():
        # Traffic Evidence
        nf = get_noise_floor(s['rx'], s['tx'])
        local_traffic = s['rx'] > nf or s['tx'] > nf
        
        peer_traffic = False
        peer_is_down = False
        if s['peer'] and s['peer'] in state:
            p = state[s['peer']]
            nf_p = get_noise_floor(p['orig_rx'], p['orig_tx'])
            if p['orig_rx'] > nf_p or p['orig_tx'] > nf_p:
                peer_traffic = True
            if p['orig_status'] == 'down':
                peer_is_down = True
        
        # Decision Matrix
        if local_traffic or peer_traffic:
            s['status'] = 'up'
        elif peer_is_down and not local_traffic:
            s['status'] = 'down'
        # Else maintain original status (e.g. 'up' but idle)
        
        # Consistency enforce
        if s['status'] != 'up':
            s['rx'] = 0.0
            s['tx'] = 0.0

    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):
        
        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            # Total volume for normalization
            total_vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            router_stats[r_id] = {
                'sum_rx': sum_rx,
                'sum_tx': sum_tx,
                'imbalance': imbalance,
                'vol': total_vol
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state
            
            # --- Flow Implied Values ---
            # Local Implied: Value that balances Local Router
            # RX Implied = RX - Imbalance (if Imbalance > 0, we have too much RX, so implied is lower)
            # TX Implied = TX + Imbalance (if Imbalance > 0, we have surplus RX, need more TX)
            
            local_flow_rx = None
            local_flow_tx = None
            if local_r in router_stats:
                ls = router_stats[local_r]
                local_flow_rx = max(0.0, s['rx'] - ls['imbalance'])
                local_flow_tx = max(0.0, s['tx'] + ls['imbalance'])

            # Remote Implied: Check consistency of Peer's values with Remote Router
            # If Peer TX is consistent with Remote Flow, it's a stronger signal.
            peer_tx_solid = False
            peer_rx_solid = False
            
            if has_peer and remote_r in router_stats:
                rs = router_stats[remote_r]
                # Peer TX is an outgoing interface on Remote Router.
                # Remote Imbalance = SumRX - SumTX.
                # Peer TX Implied = Peer TX + Remote Imbalance.
                p_tx = state[peer_id]['tx']
                p_tx_implied = max(0.0, p_tx + rs['imbalance'])
                if calc_error(p_tx, p_tx_implied) < SOLIDITY_THRESHOLD:
                    peer_tx_solid = True
                
                # Peer RX is incoming on Remote Router.
                # Peer RX Implied = Peer RX - Remote Imbalance.
                p_rx = state[peer_id]['rx']
                p_rx_implied = max(0.0, p_rx - rs['imbalance'])
                if calc_error(p_rx, p_rx_implied) < SOLIDITY_THRESHOLD:
                    peer_rx_solid = True

            # --- RX Repair ---
            # Constraint: RX <= Peer TX
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None
            
            final_rx = val_self
            
            if val_peer is not None:
                # 1. Impossible Case (RX > Peer TX) - Strict Threshold
                if val_self > val_peer * (1.0 + IMPOSSIBLE_THRESHOLD):
                    # Must clamp, unless local flow demands high RX strongly (unlikely to be valid phantom traffic)
                    # We trust the link limit.
                    final_rx = val_peer
                
                # 2. Agreement or Plausible Loss
                else:
                    # Check "Solidity" - Does Peer TX match Local Flow Requirement?
                    # This is the "N-1 Trusted Links" pattern
                    matches_local_flow = False
                    if local_flow_rx is not None:
                         if calc_error(val_peer, local_flow_rx) < SOLIDITY_THRESHOLD:
                             matches_local_flow = True
                    
                    if matches_local_flow:
                        # Golden Truth: Peer TX fits perfectly into Local Flow.
                        final_rx = val_peer
                    else:
                        # Ambiguous / Loss Case
                        # If val_self < val_peer, could be Real Loss or Measurement Error.
                        # Arbitration: Who is closer to Local Flow?
                        if local_flow_rx is not None:
                            err_self_flow = calc_error(val_self, local_flow_rx)
                            err_peer_flow = calc_error(val_peer, local_flow_rx)
                            
                            if err_peer_flow < err_self_flow:
                                # Flow suggests Peer value is better (Measurement Error in Self)
                                final_rx = val_peer
                            elif err_self_flow < err_peer_flow:
                                # Flow suggests Self value is better (Real Loss confirmed)
                                final_rx = val_self
                            else:
                                # Tie-breaker: Trust Peer if it is Solid on Remote side
                                if peer_tx_solid:
                                    final_rx = val_peer
                                else:
                                    # Fallback: Trust Peer (Link Symmetry)
                                    final_rx = val_peer
                        else:
                            final_rx = val_peer

            # --- TX Repair ---
            # Constraint: TX >= Peer RX
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None
            
            final_tx = val_self
            
            if val_peer is not None:
                # 1. Impossible Case (TX < Peer RX) - Strict Threshold
                if val_self < val_peer * (1.0 - IMPOSSIBLE_THRESHOLD):
                    final_tx = val_peer
                
                # 2. Agreement or Phantom TX
                else:
                    matches_local_flow = False
                    if local_flow_tx is not None:
                        if calc_error(val_peer, local_flow_tx) < SOLIDITY_THRESHOLD:
                            matches_local_flow = True
                            
                    if matches_local_flow:
                        final_tx = val_peer
                    else:
                        if local_flow_tx is not None:
                            err_self_flow = calc_error(val_self, local_flow_tx)
                            err_peer_flow = calc_error(val_peer, local_flow_tx)
                            
                            if err_peer_flow < err_self_flow:
                                # Flow suggests Peer value (lower) is better -> Phantom TX in Self
                                final_tx = val_peer
                            elif err_self_flow < err_peer_flow:
                                # Flow suggests Self value (higher) is better -> Peer Loss confirmed
                                final_tx = val_self
                            else:
                                # Tie-breaker
                                if peer_rx_solid:
                                    final_tx = val_peer
                                else:
                                    final_tx = val_peer
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 4: Confidence Calibration ---
    result = {}
    
    # Final Flow Quality Calculation
    final_router_imbalance = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        # Ratio of imbalance
        final_router_imbalance[r_id] = abs(sum_rx - sum_tx) / vol

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']
        
        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']
        
        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None
        
        flow_imb = final_router_imbalance.get(r_id, 0.0)

        def get_confidence(final, orig, peer_val, flow_imb):
            # Continuous Confidence Scoring
            
            # Base confidence
            conf = 1.0
            
            # 1. Flow Penalty
            # If the router is imbalanced, confidence in all its interfaces drops
            # Penalty scales: 0% imb -> 0 penalty. 10% imb -> 0.2 penalty.
            conf -= (flow_imb * 2.0)
            
            # 2. Repair Check
            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD
            
            # 3. Peer Agreement Check
            peer_agree = False
            if peer_val is not None:
                peer_dist = calc_error(final, peer_val)
                if peer_dist < HARDENING_THRESHOLD:
                    peer_agree = True
            
            if was_repaired:
                if peer_agree:
                    # Repaired and matched Peer. Good.
                    # Max confidence constrained by Flow Imbalance already applied.
                    pass 
                else:
                    # Repaired but disagrees with Peer? (e.g. Flow Arbitration picked Self, or Averaging)
                    # Significant penalty unless Flow is PERFECT
                    if flow_imb < 0.005: # < 0.5% imbalance
                        conf -= 0.1
                    else:
                        conf -= 0.3
            else:
                # Kept Original
                if peer_val is not None and not peer_agree:
                    # Disagreement with Peer, but we kept Self.
                    # Valid only if Flow supports Self (Flow Imbalance is low)
                    # If Flow is high, we likely made a mistake trusting Self.
                    if flow_imb > 0.02: # > 2% imbalance
                        conf -= 0.2
            
            return max(0.0, min(1.0, conf))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, flow_imb)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, flow_imb)
        
        # Status confidence
        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }

    return result
# EVOLVE-BLOCK-END