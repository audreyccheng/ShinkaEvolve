<NAME>
solid_flow_confidence_and_status_boost
</NAME>
<DESCRIPTION>
1. Implement "Solidity" check for confidence scoring (Recommendation 2). Instead of solely relying on global residual error (which penalizes a good link connected to a noisy neighbor), we check if the repaired value satisfies flow conservation perfectly at *either* the local or remote router. If one side is "solid" (near-zero imbalance), we boost confidence to 0.9. If both are solid, 1.0. This accounts for the "N-1 Trusted Links" pattern where one reliable neighbor can validate the data.
2. Boost status confidence if rate repair is highly confident. If flow conservation confirms the rates, the status is implicitly confirmed.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
                # Confidence Calibration
                # 1. Distinctness: How much better is the winner?
                # 2. Residual: Is the winner actually good?

                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val, 1.0)

                # Base confidence derived from distinctness
                # If margin is high (distinct choice), high confidence.
                # If residual is high (bad fit), reduce confidence.

                # Sigmoid-like scaling
                distinctness_score = min(1.0, margin * 2.0) # e.g. 50% better -> 1.0
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0) # e.g. 50% error -> 0.0

                conf = 0.5 + 0.45 * distinctness_score * fit_score

            # Apply
            s['tx'] = best_val
=======
                # Confidence Calibration
                # Check for "Solidity" (Recommendation 2):
                # If the chosen value results in perfect balance at one router,
                # it is highly trustworthy even if the other router is noisy.

                w_cost_local = 0.0
                w_cost_remote = 0.0
                if imb_local is not None:
                    w_cost_local = abs(imb_local + c_tx - best_val)
                if imb_remote is not None:
                    w_cost_remote = abs(imb_remote - c_prx + best_val)

                err_local = w_cost_local / max(best_val, 1.0)
                err_remote = w_cost_remote / max(best_val, 1.0)

                is_solid_local = (err_local < HARDENING_THRESHOLD) and (imb_local is not None)
                is_solid_remote = (err_remote < HARDENING_THRESHOLD) and (imb_remote is not None)

                if is_solid_local and is_solid_remote:
                    conf = 1.0
                elif is_solid_local or is_solid_remote:
                    conf = 0.9
                else:
                    # Fallback to standard scoring
                    margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                    residual_ratio = winner_cost / max(best_val, 1.0)

                    distinctness_score = min(1.0, margin * 2.0)
                    fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                    conf = 0.5 + 0.45 * distinctness_score * fit_score

            # Apply
            s['tx'] = best_val
>>>>>>> REPLACE
<<<<<<< SEARCH
                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val_b, 1.0)

                distinctness_score = min(1.0, margin * 2.0)
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                conf_b = 0.5 + 0.45 * distinctness_score * fit_score

            s['rx'] = best_val_b
=======
                # Confidence Calibration (B)
                w_cost_local = 0.0
                w_cost_remote = 0.0
                if imb_local is not None:
                    w_cost_local = abs(imb_local - c_rx + best_val_b)
                if imb_remote is not None:
                    w_cost_remote = abs(imb_remote + c_ptx - best_val_b)

                err_local = w_cost_local / max(best_val_b, 1.0)
                err_remote = w_cost_remote / max(best_val_b, 1.0)

                is_solid_local = (err_local < HARDENING_THRESHOLD) and (imb_local is not None)
                is_solid_remote = (err_remote < HARDENING_THRESHOLD) and (imb_remote is not None)

                if is_solid_local and is_solid_remote:
                    conf_b = 1.0
                elif is_solid_local or is_solid_remote:
                    conf_b = 0.9
                else:
                    margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                    residual_ratio = winner_cost / max(best_val_b, 1.0)

                    distinctness_score = min(1.0, margin * 2.0)
                    fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                    conf_b = 0.5 + 0.45 * distinctness_score * fit_score

            s['rx'] = best_val_b
>>>>>>> REPLACE
<<<<<<< SEARCH
    # Assemble result
    result = {}
    for if_id, s in state.items():
        orig = s['orig']
        result[if_id] = {
            'rx_rate': (orig.get('rx_rate', 0.0), s['rx'], s['rx_conf']),
            'tx_rate': (orig.get('tx_rate', 0.0), s['tx'], s['tx_conf']),
            'interface_status': (orig.get('interface_status', 'unknown'), s['status'], s['status_conf']),
            'connected_to': orig.get('connected_to'),
            'local_router': orig.get('local_router'),
            'remote_router': orig.get('remote_router')
        }
=======
    # Assemble result
    result = {}
    for if_id, s in state.items():
        orig = s['orig']

        # If we are very confident about rates, we should be confident about status
        if s['rx_conf'] > 0.8 and s['tx_conf'] > 0.8:
            s['status_conf'] = max(s['status_conf'], 0.95)

        result[if_id] = {
            'rx_rate': (orig.get('rx_rate', 0.0), s['rx'], s['rx_conf']),
            'tx_rate': (orig.get('tx_rate', 0.0), s['tx'], s['tx_conf']),
            'interface_status': (orig.get('interface_status', 'unknown'), s['status'], s['status_conf']),
            'connected_to': orig.get('connected_to'),
            'local_router': orig.get('local_router'),
            'remote_router': orig.get('remote_router')
        }
>>>>>>> REPLACE
</DIFF>