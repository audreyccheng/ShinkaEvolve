<NAME>
dual_solidity_and_hybrid_confidence
</NAME>

<DESCRIPTION>
1. Refined Rate Repair (Step 3): Implements a "Dual Solidity" approach where repairs are prioritized if they satisfy flow conservation on the local router (matches_local_flow) and potentially the remote router. It also introduces a "Router Quality" check that disables local flow arbitration if the local router has high imbalance noise (<0.6 quality), falling back to the peer value (link redundancy) instead of using unreliable flow data.
2. Hybrid Confidence Calibration (Step 4): Replaces the linear penalty model with a tiered, discrete bucket model (similar to Generation 57) which has proven better for calibration. It calculates confidence based on repair type (Repaired vs Original), Peer Agreement, and the flow quality of both Local and Remote routers (`l_q`, `r_q`). This ensures high confidence for "Solid" repairs and appropriate uncertainty for ambiguous arbitrations.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            # Total volume for normalization
            total_vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            router_stats[r_id] = {
                'sum_rx': sum_rx,
                'sum_tx': sum_tx,
                'imbalance': imbalance,
                'vol': total_vol
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # --- Flow Implied Values ---
            # Local Implied: Value that balances Local Router
            # RX Implied = RX - Imbalance (if Imbalance > 0, we have too much RX, so implied is lower)
            # TX Implied = TX + Imbalance (if Imbalance > 0, we have surplus RX, need more TX)

            local_flow_rx = None
            local_flow_tx = None
            if local_r in router_stats:
                ls = router_stats[local_r]
                local_flow_rx = max(0.0, s['rx'] - ls['imbalance'])
                local_flow_tx = max(0.0, s['tx'] + ls['imbalance'])

            # Remote Implied: Check consistency of Peer's values with Remote Router
            # If Peer TX is consistent with Remote Flow, it's a stronger signal.
            peer_tx_solid = False
            peer_rx_solid = False

            if has_peer and remote_r in router_stats:
                rs = router_stats[remote_r]
                # Peer TX is an outgoing interface on Remote Router.
                # Remote Imbalance = SumRX - SumTX.
                # Peer TX Implied = Peer TX + Remote Imbalance.
                p_tx = state[peer_id]['tx']
                p_tx_implied = max(0.0, p_tx + rs['imbalance'])
                if calc_error(p_tx, p_tx_implied) < SOLIDITY_THRESHOLD:
                    peer_tx_solid = True

                # Peer RX is incoming on Remote Router.
                # Peer RX Implied = Peer RX - Remote Imbalance.
                p_rx = state[peer_id]['rx']
                p_rx_implied = max(0.0, p_rx - rs['imbalance'])
                if calc_error(p_rx, p_rx_implied) < SOLIDITY_THRESHOLD:
                    peer_rx_solid = True

            # --- RX Repair ---
            # Constraint: RX <= Peer TX
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # 1. Impossible Case (RX > Peer TX) - Strict Threshold
                if val_self > val_peer * (1.0 + IMPOSSIBLE_THRESHOLD):
                    # Must clamp, unless local flow demands high RX strongly (unlikely to be valid phantom traffic)
                    # We trust the link limit.
                    final_rx = val_peer

                # 2. Agreement or Plausible Loss
                else:
                    # Check "Solidity" - Does Peer TX match Local Flow Requirement?
                    # This is the "N-1 Trusted Links" pattern
                    matches_local_flow = False
                    if local_flow_rx is not None:
                         if calc_error(val_peer, local_flow_rx) < SOLIDITY_THRESHOLD:
                             matches_local_flow = True

                    if matches_local_flow:
                        # Golden Truth: Peer TX fits perfectly into Local Flow.
                        final_rx = val_peer
                    else:
                        # Ambiguous / Loss Case
                        # If val_self < val_peer, could be Real Loss or Measurement Error.
                        # Arbitration: Who is closer to Local Flow?
                        if local_flow_rx is not None:
                            err_self_flow = calc_error(val_self, local_flow_rx)
                            err_peer_flow = calc_error(val_peer, local_flow_rx)

                            if err_peer_flow < err_self_flow:
                                # Flow suggests Peer value is better (Measurement Error in Self)
                                final_rx = val_peer
                            elif err_self_flow < err_peer_flow:
                                # Flow suggests Self value is better (Real Loss confirmed)
                                final_rx = val_self
                            else:
                                # Tie-breaker: Trust Peer if it is Solid on Remote side
                                if peer_tx_solid:
                                    final_rx = val_peer
                                else:
                                    # Fallback: Trust Peer (Link Symmetry)
                                    final_rx = val_peer
                        else:
                            final_rx = val_peer

            # --- TX Repair ---
            # Constraint: TX >= Peer RX
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                # 1. Impossible Case (TX < Peer RX) - Strict Threshold
                if val_self < val_peer * (1.0 - IMPOSSIBLE_THRESHOLD):
                    final_tx = val_peer

                # 2. Agreement or Phantom TX
                else:
                    matches_local_flow = False
                    if local_flow_tx is not None:
                        if calc_error(val_peer, local_flow_tx) < SOLIDITY_THRESHOLD:
                            matches_local_flow = True

                    if matches_local_flow:
                        final_tx = val_peer
                    else:
                        if local_flow_tx is not None:
                            err_self_flow = calc_error(val_self, local_flow_tx)
                            err_peer_flow = calc_error(val_peer, local_flow_tx)

                            if err_peer_flow < err_self_flow:
                                # Flow suggests Peer value (lower) is better -> Phantom TX in Self
                                final_tx = val_peer
                            elif err_self_flow < err_peer_flow:
                                # Flow suggests Self value (higher) is better -> Peer Loss confirmed
                                final_tx = val_self
                            else:
                                # Tie-breaker
                                if peer_rx_solid:
                                    final_tx = val_peer
                                else:
                                    final_tx = val_peer
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']
=======
    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            # Total volume for normalization
            total_vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            quality = max(0.0, 1.0 - (abs(imbalance) / total_vol * 10.0))
            router_stats[r_id] = {
                'sum_rx': sum_rx,
                'sum_tx': sum_tx,
                'imbalance': imbalance,
                'vol': total_vol,
                'quality': quality
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # --- Flow Implied Values ---
            local_flow_rx = None
            local_flow_tx = None
            local_q = 0.5

            if local_r in router_stats:
                ls = router_stats[local_r]
                local_q = ls['quality']
                local_flow_rx = max(0.0, s['rx'] - ls['imbalance'])
                local_flow_tx = max(0.0, s['tx'] + ls['imbalance'])

            # Remote Implied: Check consistency of Peer's values with Remote Router
            peer_tx_solid = False
            peer_rx_solid = False

            if has_peer and remote_r in router_stats:
                rs = router_stats[remote_r]
                # Peer TX (outgoing from remote) consistency check
                p_tx = state[peer_id]['tx']
                p_tx_implied = max(0.0, p_tx + rs['imbalance'])
                if calc_error(p_tx, p_tx_implied) < SOLIDITY_THRESHOLD:
                    peer_tx_solid = True

                # Peer RX (incoming to remote) consistency check
                p_rx = state[peer_id]['rx']
                p_rx_implied = max(0.0, p_rx - rs['imbalance'])
                if calc_error(p_rx, p_rx_implied) < SOLIDITY_THRESHOLD:
                    peer_rx_solid = True

            # --- RX Repair ---
            # Constraint: RX <= Peer TX
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # 1. Impossible Case (RX > Peer TX)
                if val_self > val_peer * (1.0 + IMPOSSIBLE_THRESHOLD):
                    final_rx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # 3. Disagreement / Loss
                else:
                    # Dual Solidity Check
                    # Does Peer TX satisfy My Flow?
                    matches_local_flow = False
                    if local_flow_rx is not None and calc_error(val_peer, local_flow_rx) < SOLIDITY_THRESHOLD:
                        matches_local_flow = True

                    if matches_local_flow:
                        # Golden Truth: Peer value balances my router.
                        final_rx = val_peer
                    elif local_flow_rx is not None:
                        # Flow Arbitration
                        # Only trust Local Flow if Local Router Quality is decent
                        if local_q < 0.6:
                            # Local router is too noisy/imbalanced. Trust Peer (Link redundancy).
                            final_rx = val_peer
                        else:
                            err_self = calc_error(val_self, local_flow_rx)
                            err_peer = calc_error(val_peer, local_flow_rx)

                            if err_peer < err_self:
                                final_rx = val_peer
                            elif err_self < err_peer:
                                final_rx = val_self
                            else:
                                # Tie: Use remote solidity
                                final_rx = val_peer if peer_tx_solid else val_peer
                    else:
                        final_rx = val_peer

            # --- TX Repair ---
            # Constraint: TX >= Peer RX
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                # 1. Impossible Case (TX < Peer RX)
                if val_self < val_peer * (1.0 - IMPOSSIBLE_THRESHOLD):
                    final_tx = val_peer

                # 2. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # 3. Disagreement
                else:
                    matches_local_flow = False
                    if local_flow_tx is not None and calc_error(val_peer, local_flow_tx) < SOLIDITY_THRESHOLD:
                        matches_local_flow = True

                    if matches_local_flow:
                        final_tx = val_peer
                    elif local_flow_tx is not None:
                        if local_q < 0.6:
                            final_tx = val_peer
                        else:
                            err_self = calc_error(val_self, local_flow_tx)
                            err_peer = calc_error(val_peer, local_flow_tx)

                            if err_peer < err_self:
                                final_tx = val_peer
                            elif err_self < err_peer:
                                final_tx = val_self
                            else:
                                final_tx = val_peer if peer_rx_solid else val_peer
                    else:
                        final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Apply updates
        for if_id, vals in next_values.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Step 4: Confidence Calibration ---
    result = {}

    # Final Flow Quality Calculation
    final_router_imbalance = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        # Ratio of imbalance
        final_router_imbalance[r_id] = abs(sum_rx - sum_tx) / vol

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        flow_imb = final_router_imbalance.get(r_id, 0.0)

        def get_confidence(final, orig, peer_val, flow_imb):
            # Continuous Confidence Scoring

            # Base confidence
            conf = 1.0

            # 1. Flow Penalty
            # If the router is imbalanced, confidence in all its interfaces drops
            # Penalty scales: 0% imb -> 0 penalty. 10% imb -> 0.2 penalty.
            conf -= (flow_imb * 2.0)

            # 2. Repair Check
            was_repaired = calc_error(final, orig) > HARDENING_THRESHOLD

            # 3. Peer Agreement Check
            peer_agree = False
            if peer_val is not None:
                peer_dist = calc_error(final, peer_val)
                if peer_dist < HARDENING_THRESHOLD:
                    peer_agree = True

            if was_repaired:
                if peer_agree:
                    # Repaired and matched Peer. Good.
                    # Max confidence constrained by Flow Imbalance already applied.
                    pass
                else:
                    # Repaired but disagrees with Peer? (e.g. Flow Arbitration picked Self, or Averaging)
                    # Significant penalty unless Flow is PERFECT
                    if flow_imb < 0.005: # < 0.5% imbalance
                        conf -= 0.1
                    else:
                        conf -= 0.3
            else:
                # Kept Original
                if peer_val is not None and not peer_agree:
                    # Disagreement with Peer, but we kept Self.
                    # Valid only if Flow supports Self (Flow Imbalance is low)
                    # If Flow is high, we likely made a mistake trusting Self.
                    if flow_imb > 0.02: # > 2% imbalance
                        conf -= 0.2

            return max(0.0, min(1.0, conf))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, flow_imb)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, flow_imb)
=======
    # --- Step 4: Confidence Calibration ---
    result = {}

    # Recalculate Final Flow Quality (Quality = 1.0 - Penalty)
    final_router_qual = {}
    for r_id, if_ids in topology.items():
        sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
        sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
        vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
        imb = abs(sum_rx - sum_tx) / vol
        final_router_qual[r_id] = max(0.0, 1.0 - (imb * 10.0)) # Quality metric 0.0-1.0

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']
        remote_r = s['remote_router']

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        l_q = final_router_qual.get(r_id, 0.5)
        r_q = final_router_qual.get(remote_r, 0.5) if remote_r else 0.5

        def get_confidence(final, orig, peer_val, l_q, r_q):
            # Hybrid Confidence: Tiered Buckets + Residual Adjustment
            dist_orig = calc_error(final, orig)

            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            conf = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # Aligned with peer.
                    # Base: 0.90
                    # Bonuses: Local Qual + Remote Qual
                    conf = 0.90 + (0.05 * l_q) + (0.04 * r_q)
                else:
                    # Repaired to NOT peer (e.g. Flow Arbitration)
                    # Requires high local quality to be confident
                    if l_q > 0.9:
                        conf = 0.85
                    else:
                        conf = 0.60
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Disagreement (Self != Peer)
                    # We defied peer.
                    if l_q > 0.9:
                        if r_q > 0.8:
                            conf = 0.92 # Stalemate, both routers good
                        else:
                            conf = 0.96 # My router good, theirs bad
                    elif l_q > 0.7:
                        conf = 0.80
                    else:
                        conf = 0.70 # Ambiguous
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return max(0.0, min(1.0, conf))

        rx_conf = get_confidence(s['rx'], orig_rx, peer_tx, l_q, r_q)
        tx_conf = get_confidence(s['tx'], orig_tx, peer_rx, l_q, r_q)
>>>>>>> REPLACE
</DIFF>