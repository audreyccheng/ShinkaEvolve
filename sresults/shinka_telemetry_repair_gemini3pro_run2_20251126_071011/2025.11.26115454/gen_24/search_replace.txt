To improve the performance of the network telemetry repair algorithm, I will implement **Asymmetry-Aware Rate Repair** and **Flow-Contextualized Confidence**.

The current implementation treats rate mismatches symmetrically, averaging or arbitrating discrepancies. However, network physics dictates asymmetry:
1.  **RX Constraint**: A local interface physically cannot receive more bytes than the peer sent (`rx > peer_tx` is impossible). This suggests `rx` is an over-counting error, requiring repair downwards to `peer_tx`.
2.  **TX Loss**: A local interface can send more bytes than the peer receives (`tx > peer_rx` is valid packet loss). This suggests `tx` might be correct even if it mismatches `peer_rx`, provided the local router has enough incoming traffic to justify that `tx` rate.

The new algorithm will:
1.  **Enforce RX Ceilings**: Treat `peer_tx` as a hard ceiling for `rx`, unless flow conservation explicitly requires the surplus `rx` to balance the router (indicating `peer_tx` is the broken sensor).
2.  **Validate TX Loss**: Allow `tx > peer_rx` if the router has a "Surplus" flow state (more incoming than outgoing traffic), confirming the traffic exists to be sent. Otherwise, repair `tx` down to `peer_rx` (phantom traffic).
3.  **Refine Confidence**: Assign higher confidence when preserving values that represent valid packet loss scenarios supported by flow data.

<NAME>
asymmetry_flow_repair
</NAME>

<DESCRIPTION>
Refines the repair logic to respect physical network constraints (Asymmetry) and improves confidence calibration.
1.  **Asymmetry**: Distinguishes between impossible states (RX > Peer TX) and possible states (TX > Peer RX due to loss).
    -   RX Repair: Prioritizes Peer TX unless Flow strongly validates local RX surplus.
    -   TX Repair: Allows TX > Peer RX (loss) if Flow supports the outgoing rate; otherwise repairs to Peer RX.
2.  **Flow Logic**: Uses the router's flow balance (Surplus vs Deficit) to explicitly validate whether a high rate is "supported" by incoming traffic.
3.  **Confidence**: Updates calibration to reflect the nature of the repair (e.g., high confidence when preserving a valid "lossy" state supported by flow).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 2: Iterative Rate Repair ---
    # Helper to calculate normalized difference
    def get_diff(v1, v2):
        return abs(v1 - v2) / max(v1, v2, MIN_RATE_THRESHOLD)

    for _ in range(ITERATIONS):
        # Snapshot for simultaneous updates
        next_state = {}

        # Calculate Router Flow States
        # Map: router_id -> {rx_sum, tx_sum}
        router_flows = {}
        for r_id, if_ids in topology.items():
            r_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            r_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            router_flows[r_id] = {'rx': r_rx, 'tx': r_tx}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_state[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            # --- RX Repair ---
            # Strategy: Default to Peer TX. Veto if Flow Imbalance spikes.
            curr_rx = s['rx']

            if has_peer:
                peer_tx = state[peer_id]['tx']
                if get_diff(curr_rx, peer_tx) <= HARDENING_THRESHOLD:
                    # Agree
                    final_rx = (curr_rx + peer_tx) / 2.0
                else:
                    # Disagree. Proposed repair is Peer TX.
                    proposal = peer_tx

                    # Flow Veto Check
                    veto = False
                    if r_id in router_flows:
                        f = router_flows[r_id]
                        current_imbalance = abs(f['rx'] - f['tx'])

                        # Calculate imbalance if we switch RX to proposal
                        # New_Router_RX = Old_Router_RX - Curr_RX + Proposal
                        new_r_rx = f['rx'] - curr_rx + proposal
                        proposed_imbalance = abs(new_r_rx - f['tx'])

                        # Veto if proposal makes flow significantly worse while current is okay-ish
                        # or if proposal is just clearly worse than current
                        if proposed_imbalance > current_imbalance + MIN_RATE_THRESHOLD:
                             veto = True

                    final_rx = curr_rx if veto else proposal
            else:
                final_rx = curr_rx

            # --- TX Repair ---
            # Strategy: Default to Peer RX. Veto if Flow Imbalance spikes.
            curr_tx = s['tx']

            if has_peer:
                peer_rx = state[peer_id]['rx']
                if get_diff(curr_tx, peer_rx) <= HARDENING_THRESHOLD:
                    final_tx = (curr_tx + peer_rx) / 2.0
                else:
                    proposal = peer_rx

                    # Flow Veto Check
                    veto = False
                    if r_id in router_flows:
                        f = router_flows[r_id]
                        current_imbalance = abs(f['rx'] - f['tx'])

                        # Calculate imbalance if we switch TX to proposal
                        # New_Router_TX = Old_Router_TX - Curr_TX + Proposal
                        new_r_tx = f['tx'] - curr_tx + proposal
                        proposed_imbalance = abs(f['rx'] - new_r_tx)

                        if proposed_imbalance > current_imbalance + MIN_RATE_THRESHOLD:
                             veto = True

                    final_tx = curr_tx if veto else proposal
            else:
                final_tx = curr_tx

            next_state[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Update State
        for if_id, vals in next_state.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence & Result ---
    result = {}
    for if_id, orig_data in telemetry.items():
        s = state[if_id]
        orig_rx = float(orig_data.get('rx_rate', 0.0))
        orig_tx = float(orig_data.get('tx_rate', 0.0))

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        # Check Flow Balance Final Status
        flow_balanced = False
        if r_id in topology:
             # Re-sum with final values
             final_rx_sum = sum(state[i]['rx'] for i in topology[r_id] if i in state)
             final_tx_sum = sum(state[i]['tx'] for i in topology[r_id] if i in state)
             if get_diff(final_rx_sum, final_tx_sum) < 0.05: # 5% flow tolerance
                 flow_balanced = True

        def calculate_confidence(orig, final, peer_val):
            # 1. Did we change it?
            if get_diff(orig, final) < HARDENING_THRESHOLD:
                # We kept the original (mostly)
                # If Peer disagrees heavily and Flow is bad, we might be wrong to keep it.
                # But generally keeping original = 1.0 confidence unless specific red flags.

                # Case: Peer Disagrees, but we kept Self because Flow Vetoed Peer.
                if peer_val is not None and get_diff(final, peer_val) > HARDENING_THRESHOLD:
                    if flow_balanced: return 0.9  # Confident because Flow supports us
                    return 0.7 # Ambiguous (Peer wrong, Flow wrong/unbalanced)

                return 1.0

            # 2. We changed it.
            # Likely matched Peer.
            matches_peer = False
            if peer_val is not None:
                matches_peer = get_diff(final, peer_val) < HARDENING_THRESHOLD

            if matches_peer:
                if flow_balanced: return 0.95 # Perfect consensus
                return 0.9 # Strong Peer signal

            # We changed it but NOT to peer? (Maybe averaging or flow forcing?)
            return 0.7

        rx_conf = calculate_confidence(orig_rx, s['rx'], state[peer_id]['tx'] if has_peer else None)
        tx_conf = calculate_confidence(orig_tx, s['tx'], state[peer_id]['rx'] if has_peer else None)
=======
    # --- Step 2: Iterative Rate Repair ---
    # Helper to calculate normalized difference
    def get_diff(v1, v2):
        return abs(v1 - v2) / max(v1, v2, MIN_RATE_THRESHOLD)

    for _ in range(ITERATIONS):
        next_state = {}

        # Calculate Router Flow States
        router_flows = {}
        for r_id, if_ids in topology.items():
            r_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            r_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            router_flows[r_id] = {'rx': r_rx, 'tx': r_tx}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_state[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            curr_rx = s['rx']
            curr_tx = s['tx']

            # --- RX Repair ---
            # Constraint: RX <= Peer TX (Physical).
            final_rx = curr_rx
            if has_peer:
                peer_tx = state[peer_id]['tx']
                diff = get_diff(curr_rx, peer_tx)

                if diff <= HARDENING_THRESHOLD:
                     final_rx = (curr_rx + peer_tx) / 2.0
                else:
                    # Disagreement.
                    # If RX > Peer TX (Impossible), prefer Peer TX unless Flow demands RX.
                    if curr_rx > peer_tx * (1.0 + HARDENING_THRESHOLD):
                        keep_self = False
                        if r_id in router_flows:
                            # If we have a deficit (TX > RX), keeping high RX helps balance.
                            # If we have surplus (RX > TX), keeping high RX hurts.
                            f = router_flows[r_id]
                            if f['tx'] > f['rx']: keep_self = True

                        final_rx = curr_rx if keep_self else peer_tx
                    else:
                        # RX < Peer TX (Possible Loss or Error).
                        # Use Flow to Arbitrate.
                        use_peer = True
                        if r_id in router_flows:
                            f = router_flows[r_id]
                            # Current Imbalance (with curr_rx)
                            imb_curr = abs(f['rx'] - f['tx'])
                            # Proposed Imbalance (with peer_tx) -> Total RX increases
                            imb_peer = abs((f['rx'] - curr_rx + peer_tx) - f['tx'])
                            if imb_curr < imb_peer:
                                use_peer = False

                        final_rx = peer_tx if use_peer else curr_rx

            # --- TX Repair ---
            # Constraint: TX >= Peer RX (Physical).
            final_tx = curr_tx
            if has_peer:
                peer_rx = state[peer_id]['rx']
                diff = get_diff(curr_tx, peer_rx)

                if diff <= HARDENING_THRESHOLD:
                    final_tx = (curr_tx + peer_rx) / 2.0
                else:
                    # Disagreement.
                    # If TX < Peer RX (Impossible), must repair up to Peer RX.
                    if curr_tx < peer_rx * (1.0 - HARDENING_THRESHOLD):
                        final_tx = peer_rx
                    else:
                        # TX > Peer RX (Packet Loss?).
                        # Only keep high TX if Flow supports it (we have enough RX to send this).
                        keep_self = False
                        if r_id in router_flows:
                            f = router_flows[r_id]
                            # Surplus (RX >= TX) supports high TX.
                            # Deficit (TX > RX) suggests TX is too high (phantom traffic).
                            if f['rx'] >= f['tx']:
                                keep_self = True
                            else:
                                # Check if lowering TX to Peer RX improves balance
                                imb_curr = abs(f['rx'] - f['tx'])
                                imb_peer = abs(f['rx'] - (f['tx'] - curr_tx + peer_rx))
                                if imb_curr < imb_peer:
                                    keep_self = True

                        final_tx = curr_tx if keep_self else peer_rx

            next_state[if_id] = {'rx': final_rx, 'tx': final_tx}

        # Update State
        for if_id, vals in next_state.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']

    # --- Step 3: Confidence & Result ---
    result = {}
    for if_id, orig_data in telemetry.items():
        s = state[if_id]
        orig_rx = float(orig_data.get('rx_rate', 0.0))
        orig_tx = float(orig_data.get('tx_rate', 0.0))

        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']

        # Check Flow Balance
        flow_balanced = False
        if r_id in topology:
             final_rx_sum = sum(state[i]['rx'] for i in topology[r_id] if i in state)
             final_tx_sum = sum(state[i]['tx'] for i in topology[r_id] if i in state)
             if get_diff(final_rx_sum, final_tx_sum) < 0.05:
                 flow_balanced = True

        def calculate_confidence(orig, final, peer_val, is_tx):
            # Error distances
            err_orig = get_diff(final, orig)
            err_peer = get_diff(final, peer_val) if peer_val is not None else 0.0

            # 1. We trusted Original (approx)
            if err_orig < HARDENING_THRESHOLD:
                if peer_val is not None and err_peer > HARDENING_THRESHOLD:
                    # Disagreement with Peer
                    if is_tx and final > peer_val:
                         # TX > Peer RX (Loss). Valid if Flow supports.
                         return 0.95 if flow_balanced else 0.8
                    elif not is_tx and final < peer_val:
                         # RX < Peer TX (Loss). Valid if Flow supports.
                         return 0.95 if flow_balanced else 0.8
                    else:
                         # "Impossible" state kept (e.g. RX > Peer TX).
                         # Only likely if Peer sensor is broken.
                         return 0.85
                return 1.0

            # 2. We Repaired
            # If we matched Peer
            if peer_val is not None and err_peer < HARDENING_THRESHOLD:
                return 0.95

            # If we didn't match Peer (e.g. flow arbitration selected something else or averaged)
            return 0.8

        rx_conf = calculate_confidence(orig_rx, s['rx'], state[peer_id]['tx'] if has_peer else None, False)
        tx_conf = calculate_confidence(orig_tx, s['tx'], state[peer_id]['rx'] if has_peer else None, True)
>>>>>>> REPLACE
</DIFF>