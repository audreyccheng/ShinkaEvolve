<NAME>
golden_truth_logic
</NAME>
<DESCRIPTION>
Implement "Golden Truth" verification and Quality Dominance arbitration.
- Adds `quality` calculation to the in-loop router stats.
- Calculates `local_target` and `remote_target` flow-implied values.
- Checks if a "Golden Value" exists that balances both routers.
- Prioritizes Golden Value > Physics > Agreement > Quality Arbitration > Flow Error Arbitration.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            imbalance = sum_rx - sum_tx
            router_stats[r_id] = {
                'imbalance': imbalance
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # --- Flow Implied Values (Local) ---
            # RX_new = RX_old - Imbalance
            # TX_new = TX_old + Imbalance
            local_flow_rx = None
            local_flow_tx = None
            if local_r in router_stats:
                ls = router_stats[local_r]
                local_flow_rx = max(0.0, s['rx'] - ls['imbalance'])
                local_flow_tx = max(0.0, s['tx'] + ls['imbalance'])

            # --- Remote Solidity Check ---
            # Does the Peer's current value satisfy the Remote Router's flow balance?
            peer_tx_solid = False
            peer_rx_solid = False

            if has_peer and remote_r in router_stats:
                rs = router_stats[remote_r]
                # Peer TX (Remote Out) should equal Peer TX + Remote Imbalance (SumRX - SumTX)
                # If Remote Imbalance is 0, Peer TX is solid.

                # Check TX Solidity (Peer TX is Source for Local RX)
                p_tx = state[peer_id]['tx']
                p_tx_implied = max(0.0, p_tx + rs['imbalance'])
                if calc_error(p_tx, p_tx_implied) < SOLIDITY_THRESHOLD:
                    peer_tx_solid = True

                # Check RX Solidity (Peer RX is Sink for Local TX)
                p_rx = state[peer_id]['rx']
                p_rx_implied = max(0.0, p_rx - rs['imbalance'])
                if calc_error(p_rx, p_rx_implied) < SOLIDITY_THRESHOLD:
                    peer_rx_solid = True

            # --- RX Repair ---
            # Constraint: RX <= Peer TX
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else None

            final_rx = val_self

            if val_peer is not None:
                # 1. Physics Violation (RX > Peer TX)
                if val_self > val_peer * (1.0 + PHYSICS_THRESHOLD):
                    final_rx = val_peer

                # 2. Agreement or Plausible Loss
                else:
                    # Check Local Solidity: Does Peer match Local Flow?
                    matches_local_flow = False
                    if local_flow_rx is not None:
                         if calc_error(val_peer, local_flow_rx) < SOLIDITY_THRESHOLD:
                             matches_local_flow = True

                    if matches_local_flow:
                        final_rx = val_peer
                    elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                        # Agreement
                        final_rx = (val_self + val_peer) / 2.0
                    else:
                        # Disagreement / Loss
                        if local_flow_rx is not None:
                            err_self_flow = calc_error(val_self, local_flow_rx)
                            err_peer_flow = calc_error(val_peer, local_flow_rx)

                            if err_peer_flow < err_self_flow:
                                final_rx = val_peer
                            elif err_self_flow < err_peer_flow:
                                final_rx = val_self
                            else:
                                # Tie-breaker: Trust Peer if Remote is Solid
                                if peer_tx_solid:
                                    final_rx = val_peer
                                else:
                                    final_rx = val_peer
                        else:
                            final_rx = val_peer

            # --- TX Repair ---
            # Constraint: TX >= Peer RX
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else None

            final_tx = val_self

            if val_peer is not None:
                # 1. Physics Violation (TX < Peer RX)
                if val_self < val_peer * (1.0 - PHYSICS_THRESHOLD):
                    final_tx = val_peer

                # 2. Agreement
                else:
                    matches_local_flow = False
                    if local_flow_tx is not None:
                        if calc_error(val_peer, local_flow_tx) < SOLIDITY_THRESHOLD:
                            matches_local_flow = True

                    if matches_local_flow:
                        final_tx = val_peer
                    elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                        final_tx = (val_self + val_peer) / 2.0
                    else:
                        if local_flow_tx is not None:
                            err_self_flow = calc_error(val_self, local_flow_tx)
                            err_peer_flow = calc_error(val_peer, local_flow_tx)

                            if err_peer_flow < err_self_flow:
                                final_tx = val_peer
                            elif err_self_flow < err_peer_flow:
                                final_tx = val_self
                            else:
                                if peer_rx_solid:
                                    final_tx = val_peer
                                else:
                                    final_tx = val_peer
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}
=======
    # --- Step 3: Iterative Rate Repair ---
    for _ in range(ITERATIONS):

        # 3.1: Pre-calculate Router Flow States
        router_stats = {}
        for r_id, if_ids in topology.items():
            sum_rx = sum(state[i]['rx'] for i in if_ids if i in state)
            sum_tx = sum(state[i]['tx'] for i in if_ids if i in state)
            vol = max(sum_rx, sum_tx, BASE_NOISE_FLOOR)
            imbalance = sum_rx - sum_tx
            quality = max(0.0, 1.0 - (abs(imbalance) / vol * 10.0))
            router_stats[r_id] = {
                'imbalance': imbalance,
                'quality': quality
            }

        next_values = {}

        for if_id, s in state.items():
            if s['status'] != 'up':
                next_values[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            local_r = s['router']
            remote_r = s['remote_router']
            has_peer = peer_id and peer_id in state

            # --- Gather Context ---
            ls = router_stats.get(local_r, {'imbalance': 0.0, 'quality': 0.5})
            rs = router_stats.get(remote_r, {'imbalance': 0.0, 'quality': 0.5}) if remote_r else {'imbalance': 0.0, 'quality': 0.5}

            # --- Calculate Targets ---
            # 1. Local Implied Target (Value that balances Local Router)
            local_target_rx = max(0.0, s['rx'] - ls['imbalance'])
            local_target_tx = max(0.0, s['tx'] + ls['imbalance'])

            # 2. Remote Implied Target (Value at PEER that balances Remote Router)
            # Note: We need to translate this to Local Perspective.
            remote_target_tx_peer = 0.0 # Maps to Local RX
            remote_target_rx_peer = 0.0 # Maps to Local TX

            if has_peer:
                p_tx = state[peer_id]['tx']
                p_rx = state[peer_id]['rx']
                # Remote Imbalance = Rx - Tx.
                # To fix: Tx_new = Tx_old + Imbalance.
                remote_target_tx_peer = max(0.0, p_tx + rs['imbalance'])
                # To fix: Rx_new = Rx_old - Imbalance.
                remote_target_rx_peer = max(0.0, p_rx - rs['imbalance'])

            # --- RX Repair (Local RX vs Peer TX) ---
            val_self = s['rx']
            val_peer = state[peer_id]['tx'] if has_peer else 0.0

            final_rx = val_self

            if has_peer:
                # A. Golden Truth: Do Local and Remote targets agree?
                golden_rx = None
                if calc_error(local_target_rx, remote_target_tx_peer) < HARDENING_THRESHOLD:
                    golden_rx = (local_target_rx + remote_target_tx_peer) / 2.0

                if golden_rx is not None:
                    final_rx = golden_rx

                # B. Physics Violation (RX > Peer TX)
                elif val_self > val_peer * (1.0 + PHYSICS_THRESHOLD):
                     final_rx = val_peer

                # C. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_rx = (val_self + val_peer) / 2.0

                # D. Arbitration (Disagreement)
                else:
                    # Quality Dominance
                    if rs['quality'] > ls['quality'] + 0.3:
                         final_rx = val_peer
                    elif ls['quality'] > rs['quality'] + 0.3:
                         final_rx = val_self
                    else:
                        # Flow Error Minimization
                        err_self = calc_error(val_self, local_target_rx)
                        err_peer = calc_error(val_peer, local_target_rx)
                        if err_peer < err_self:
                             final_rx = val_peer
                        elif err_self < err_peer:
                             final_rx = val_self
                        else:
                             final_rx = val_peer

            # --- TX Repair (Local TX vs Peer RX) ---
            val_self = s['tx']
            val_peer = state[peer_id]['rx'] if has_peer else 0.0

            final_tx = val_self

            if has_peer:
                # A. Golden Truth
                golden_tx = None
                if calc_error(local_target_tx, remote_target_rx_peer) < HARDENING_THRESHOLD:
                    golden_tx = (local_target_tx + remote_target_rx_peer) / 2.0

                if golden_tx is not None:
                    final_tx = golden_tx

                # B. Physics Violation (TX < Peer RX)
                elif val_self < val_peer * (1.0 - PHYSICS_THRESHOLD):
                    final_tx = val_peer

                # C. Agreement
                elif calc_error(val_self, val_peer) < HARDENING_THRESHOLD:
                    final_tx = (val_self + val_peer) / 2.0

                # D. Arbitration
                else:
                    if rs['quality'] > ls['quality'] + 0.3:
                        final_tx = val_peer
                    elif ls['quality'] > rs['quality'] + 0.3:
                        final_tx = val_self
                    else:
                        err_self = calc_error(val_self, local_target_tx)
                        err_peer = calc_error(val_peer, local_target_tx)
                        if err_peer < err_self:
                            final_tx = val_peer
                        elif err_self < err_peer:
                            final_tx = val_self
                        else:
                            final_tx = val_peer

            next_values[if_id] = {'rx': final_rx, 'tx': final_tx}
>>>>>>> REPLACE
</DIFF>

<NAME>
calibration_residual_penalty
</NAME>
<DESCRIPTION>
Refine confidence calibration to include a residual penalty based on final router imbalance. This avoids overconfidence when the algorithm fails to fully balance a router.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
        def get_confidence(final, orig, peer_val, l_q, r_q):
            dist_orig = calc_error(final, orig)

            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            conf = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # Aligned with peer. Confirmed by Link.
                    # Boost confidence based on Router Qualities.
                    # If Local is good, it fits our flow. If Remote is good, Peer is reliable.
                    conf = 0.85 + (0.08 * l_q) + (0.06 * r_q)
                else:
                    # Repaired to Local Flow Target (likely).
                    # Heavy reliance on Local Quality.
                    if l_q > 0.9:
                        conf = 0.85
                    else:
                        conf = 0.60
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Disagreement. We trust Self.
                    if l_q > 0.9:
                        # Self is strong.
                        if r_q > 0.8:
                            # Remote also strong -> Stalemate
                            conf = 0.90
                        else:
                            # Remote weak -> We are likely correct
                            conf = 0.95
                    elif l_q > 0.7:
                        conf = 0.80
                    else:
                        conf = 0.70 # Ambiguous
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return max(0.0, min(1.0, conf))
=======
        def get_confidence(final, orig, peer_val, l_q, r_q):
            dist_orig = calc_error(final, orig)

            matches_peer = False
            if peer_val is not None and calc_error(final, peer_val) < HARDENING_THRESHOLD:
                matches_peer = True

            conf = 1.0

            if dist_orig > HARDENING_THRESHOLD:
                # REPAIRED
                if matches_peer:
                    # Best case: Link Consensus + Flow Support
                    # Base 0.90
                    conf = 0.90 + (0.05 * l_q) + (0.04 * r_q)
                else:
                    # Repaired but no peer match (Arbitration)
                    # Relies on Local Quality
                    conf = 0.70 + (0.20 * l_q)
            else:
                # KEPT ORIGINAL
                if peer_val is not None and not matches_peer:
                    # Conflict: We defied Peer.
                    # Trustworthiness depends on Local Quality vs Remote Quality
                    if l_q > 0.9:
                        if r_q > 0.9:
                            conf = 0.85 # Stalemate
                        else:
                            conf = 0.95 # Strong Local, Weak Remote
                    elif l_q > 0.7:
                        conf = 0.80
                    else:
                        conf = 0.60 # Weak Local support
                else:
                    # Agreement or No Peer
                    conf = 1.0

            # Residual Penalty: If Local Router is still unbalanced, decrease confidence
            # If l_q is 1.0, penalty is 0. If l_q is 0.5, penalty is significant.
            penalty = (1.0 - l_q) * 0.2
            conf -= penalty

            return max(0.0, min(1.0, conf))
>>>>>>> REPLACE
</DIFF>