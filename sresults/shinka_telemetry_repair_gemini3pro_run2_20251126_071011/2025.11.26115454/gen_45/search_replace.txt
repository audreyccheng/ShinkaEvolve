<NAME>
restore_solidity_check
</NAME>

<DESCRIPTION>
Re-introduce the "solidity" check for confidence calibration. This logic boosts confidence to 0.9 or 1.0 if the chosen repair value results in perfect (or near-perfect) flow conservation at one or both connected routers. This helps identifying correct repairs in mixed-noise environments where one router might be reliable while the other is not. This was a key feature in the highest performing prior version.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # Decision Logic
            best_val = c_tx
            conf = 1.0

            # If signals agree, trust them
            denom = max(c_tx, c_prx, 1.0)
            if abs(c_tx - c_prx) / denom <= HARDENING_THRESHOLD:
                best_val = (c_tx + c_prx) / 2.0
                conf = 1.0
            elif n_tx == 0:
                # No topology info, fallback to average but low confidence
                best_val = (c_tx + c_prx) / 2.0
                conf = 0.5
            else:
                # Topology info available, check costs
                if cost_tx < cost_prx:
                    best_val = c_tx
                    winner_cost = cost_tx
                    loser_cost = cost_prx
                else:
                    best_val = c_prx
                    winner_cost = cost_prx
                    loser_cost = cost_tx

                # Confidence Calibration
                # 1. Distinctness: How much better is the winner?
                # 2. Residual: Is the winner actually good?

                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val, 1.0)

                # Base confidence derived from distinctness
                # If margin is high (distinct choice), high confidence.
                # If residual is high (bad fit), reduce confidence.

                # Sigmoid-like scaling
                distinctness_score = min(1.0, margin * 2.0) # e.g. 50% better -> 1.0
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0) # e.g. 50% error -> 0.0

                conf = 0.5 + 0.45 * distinctness_score * fit_score
=======
            # Decision Logic
            best_val = c_tx
            conf = 1.0

            # If signals agree, trust them
            denom = max(c_tx, c_prx, 1.0)
            if abs(c_tx - c_prx) / denom <= HARDENING_THRESHOLD:
                best_val = (c_tx + c_prx) / 2.0
                conf = 1.0
            elif n_tx == 0:
                # No topology info, fallback to average but low confidence
                best_val = (c_tx + c_prx) / 2.0
                conf = 0.5
            else:
                # Topology info available, check costs
                if cost_tx < cost_prx:
                    best_val = c_tx
                    winner_cost = cost_tx
                    loser_cost = cost_prx
                else:
                    best_val = c_prx
                    winner_cost = cost_prx
                    loser_cost = cost_tx

                # Confidence Calibration with Solidity Check
                # Calculate how well the chosen value fits each router individually
                w_cost_local = 0.0
                w_cost_remote = 0.0
                if imb_local is not None:
                    w_cost_local = abs(imb_local + c_tx - best_val)
                if imb_remote is not None:
                    w_cost_remote = abs(imb_remote - c_prx + best_val)

                # Normalize errors by the link rate
                # If the residual imbalance is small compared to the link rate,
                # this link fits the puzzle perfectly at that router.
                err_local = w_cost_local / max(best_val, 1.0)
                err_remote = w_cost_remote / max(best_val, 1.0)

                is_solid_local = (err_local < HARDENING_THRESHOLD) and (imb_local is not None)
                is_solid_remote = (err_remote < HARDENING_THRESHOLD) and (imb_remote is not None)

                if is_solid_local and is_solid_remote:
                    conf = 1.0
                elif is_solid_local or is_solid_remote:
                    conf = 0.9
                else:
                    # Fallback to standard scoring
                    margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                    residual_ratio = winner_cost / max(best_val, 1.0)

                    distinctness_score = min(1.0, margin * 2.0)
                    fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                    conf = 0.5 + 0.45 * distinctness_score * fit_score
>>>>>>> REPLACE
<<<<<<< SEARCH
            best_val_b = c_rx
            conf_b = 1.0

            denom_b = max(c_rx, c_ptx, 1.0)
            if abs(c_rx - c_ptx) / denom_b <= HARDENING_THRESHOLD:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 1.0
            elif n_rx == 0:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 0.5
            else:
                if cost_rx < cost_ptx:
                    best_val_b = c_rx
                    winner_cost = cost_rx
                    loser_cost = cost_ptx
                else:
                    best_val_b = c_ptx
                    winner_cost = cost_ptx
                    loser_cost = cost_rx

                margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                residual_ratio = winner_cost / max(best_val_b, 1.0)

                distinctness_score = min(1.0, margin * 2.0)
                fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                conf_b = 0.5 + 0.45 * distinctness_score * fit_score
=======
            best_val_b = c_rx
            conf_b = 1.0

            denom_b = max(c_rx, c_ptx, 1.0)
            if abs(c_rx - c_ptx) / denom_b <= HARDENING_THRESHOLD:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 1.0
            elif n_rx == 0:
                best_val_b = (c_rx + c_ptx) / 2.0
                conf_b = 0.5
            else:
                if cost_rx < cost_ptx:
                    best_val_b = c_rx
                    winner_cost = cost_rx
                    loser_cost = cost_ptx
                else:
                    best_val_b = c_ptx
                    winner_cost = cost_ptx
                    loser_cost = cost_rx

                # Confidence Calibration with Solidity Check
                w_cost_local = 0.0
                w_cost_remote = 0.0
                if imb_local is not None:
                    w_cost_local = abs(imb_local - c_rx + best_val_b)
                if imb_remote is not None:
                    w_cost_remote = abs(imb_remote + c_ptx - best_val_b)

                err_local = w_cost_local / max(best_val_b, 1.0)
                err_remote = w_cost_remote / max(best_val_b, 1.0)

                is_solid_local = (err_local < HARDENING_THRESHOLD) and (imb_local is not None)
                is_solid_remote = (err_remote < HARDENING_THRESHOLD) and (imb_remote is not None)

                if is_solid_local and is_solid_remote:
                    conf_b = 1.0
                elif is_solid_local or is_solid_remote:
                    conf_b = 0.9
                else:
                    margin = (loser_cost - winner_cost) / max(winner_cost + loser_cost, 1.0)
                    residual_ratio = winner_cost / max(best_val_b, 1.0)

                    distinctness_score = min(1.0, margin * 2.0)
                    fit_score = max(0.0, 1.0 - residual_ratio * 2.0)

                    conf_b = 0.5 + 0.45 * distinctness_score * fit_score
>>>>>>> REPLACE
</DIFF>