The following edits enhance the network telemetry repair algorithm by implementing "Solidity Checks" within the rate repair process and refining confidence calibration.

1.  **Dynamic Noise Floor**: Replaces static noise floor with a dynamic one that scales with link speed (0.1% of rate), preventing over-sensitivity on high-bandwidth links while maintaining a base floor for idle links.
2.  **Solidity & Flow Rate Repair**: Introduces a "Solidity Check" where the algorithm calculates the exact rate required to balance the local router ("Flow Implied" rate). If the Peer's measurement matches this inferred rate, it is treated as a high-confidence truth, effectively using the router's flow conservation as a cryptographic-like lock to validate the neighbor's signal.
3.  **Continuous Confidence Calibration**: Updates confidence scoring to be continuous rather than discrete, scaling based on flow quality and the precision of the repair (e.g., exact matches to peer+flow get higher scores than approximate averages).

<NAME>
dynamic_noise_floor
</NAME>

<DESCRIPTION>
Add a helper function to calculate dynamic noise floor based on signal magnitude, scaling for high-bandwidth links while maintaining a minimum floor for idle links. Update constants.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Constants ---
    HARDENING_THRESHOLD = 0.02   # 2% tolerance
    NOISE_FLOOR = 10.0           # Ignore variations below 10 Mbps
    ITERATIONS = 3               # Allow convergence

    # --- Helper Functions ---
    def safe_get(d, key, default):
        val = d.get(key)
        return float(val) if val is not None else default

    def calc_error(v1, v2):
        return abs(v1 - v2) / max(v1, v2, NOISE_FLOOR)
=======
    # --- Constants ---
    HARDENING_THRESHOLD = 0.02   # 2% tolerance
    BASE_NOISE_FLOOR = 10.0      # Ignore variations below 10 Mbps
    ITERATIONS = 4               # Allow convergence

    # --- Helper Functions ---
    def safe_get(d, key, default):
        val = d.get(key)
        return float(val) if val is not None else default

    def get_noise_floor(v1, v2=0.0):
        # Scale noise floor: max(10Mbps, 0.1% of rate)
        # This prevents tiny % errors on 100Gbps links from looking like matches if they are actually noise,
        # but primarily prevents over-sensitivity.
        # Actually, for repair, we want to treat small relative differences as noise.
        mx = max(v1, v2)
        return max(BASE_NOISE_FLOOR, mx * 0.001)

    def calc_error(v1, v2):
        nf = get_noise_floor(v1, v2)
        return abs(v1 - v2) / max(v1, v2, nf)
>>>>>>> REPLACE
</DIFF>

<NAME>
update_status_logic
</NAME>

<DESCRIPTION>
Update status logic to use the new dynamic noise floor helper.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Robust Status Inference
    for if_id, s in state.items():
        peer_id = s['peer']

        # Check Traffic
        local_traffic = s['rx'] > NOISE_FLOOR or s['tx'] > NOISE_FLOOR

        peer_down = False
        peer_traffic = False
        if peer_id and peer_id in telemetry:
            p = telemetry[peer_id]
            if p.get('interface_status') == 'down':
                peer_down = True
            if safe_get(p, 'rx_rate', 0.0) > NOISE_FLOOR or safe_get(p, 'tx_rate', 0.0) > NOISE_FLOOR:
                peer_traffic = True
=======
    # Robust Status Inference
    for if_id, s in state.items():
        peer_id = s['peer']

        # Check Traffic
        nf_local = get_noise_floor(s['rx'], s['tx'])
        local_traffic = s['rx'] > nf_local or s['tx'] > nf_local

        peer_down = False
        peer_traffic = False
        if peer_id and peer_id in telemetry:
            p = telemetry[peer_id]
            if p.get('interface_status') == 'down':
                peer_down = True

            p_rx = safe_get(p, 'rx_rate', 0.0)
            p_tx = safe_get(p, 'tx_rate', 0.0)
            nf_peer = get_noise_floor(p_rx, p_tx)

            if p_rx > nf_peer or p_tx > nf_peer:
                peer_traffic = True
>>>>>>> REPLACE
</DIFF>

<NAME>
rate_repair_dual_flow
</NAME>

<DESCRIPTION>
Implement iterative rate repair using "Solidity Check" and dual-source flow validation.
It calculates "Flow Implied" values for local interfaces and compares them with Peer values.
If Peer value strongly aligns with Local Flow requirement (Solidity), it overrides local measurement.
Handles "Impossible" (RX > Peer TX) and "Plausible" (RX < Peer TX) cases with different heuristics.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 2: Rate Repair Iterations ---
    for _ in range(ITERATIONS):
        # 2.1 Calculate Flow Balance per Router
        router_flow = {}
        for r_id, if_list in topology.items():
            r_rx = sum(state[i]['rx'] for i in if_list if i in state)
            r_tx = sum(state[i]['tx'] for i in if_list if i in state)
            # Flow Balance = RX - TX. Positive = Accumulation/Drop? Negative = Creation?
            # Ideal is 0.
            router_flow[r_id] = r_rx - r_tx

        updates = {}
        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            curr_rx = s['rx']
            curr_tx = s['tx']

            # Retrieve Peer Values (Use current state for fastest convergence)
            peer_tx = state[peer_id]['tx'] if has_peer else None
            peer_rx = state[peer_id]['rx'] if has_peer else None

            # --- RX Repair Strategy ---
            # Ideal: RX_self == TX_peer
            # Constraint: RX_self <= TX_peer

            next_rx = curr_rx
            if peer_tx is not None:
                err = calc_error(curr_rx, peer_tx)
                if err < HARDENING_THRESHOLD:
                    next_rx = (curr_rx + peer_tx) / 2.0
                else:
                    # Disagreement
                    if curr_rx > peer_tx:
                        # Impossible (I received more than they sent).
                        # Only valid if Flow demands High RX.
                        # Check flow: If we lower RX to PeerTX, does flow error increase?
                        if r_id in router_flow:
                            # Current Imbalance = Flow
                            # Proposed Imbalance = Flow - curr_rx + peer_tx (RX decreases, so Net decreases)
                            # If Flow is negative (TX > RX), reducing RX makes it worse.
                            # If Flow is positive (RX > TX), reducing RX helps.
                            net = router_flow[r_id]
                            # Simple heuristic: Does Peer TX minimize abs(net)?
                            # Error with Self: abs(net)
                            # Error with Peer: abs(net - curr_rx + peer_tx)
                            if abs(net - curr_rx + peer_tx) < abs(net):
                                next_rx = peer_tx # Peer is better for flow
                            else:
                                # Self is better for flow?
                                # But Self is physically impossible (RX > PeerTX).
                                # Trust Physics over Flow (Flow might be messy due to other links).
                                # Use Peer TX, but maybe soften if flow is strongly opposed?
                                # Let's stick to Physics.
                                next_rx = peer_tx
                        else:
                            next_rx = peer_tx
                    else:
                        # curr_rx < peer_tx (Possible Loss).
                        # Check Flow: Do we need more RX?
                        if r_id in router_flow:
                            net = router_flow[r_id]
                            # If net < 0 (TX > RX), we are creating packets. We need more RX.
                            # If increasing RX to PeerTX helps balance:
                            if abs(net - curr_rx + peer_tx) < abs(net):
                                next_rx = peer_tx # Assume it was error/loss we should count
                            else:
                                next_rx = curr_rx # Keep loss (it balances flow)
                        else:
                            # No flow info. Assume Loss is real?
                            # Or repair to Peer TX?
                            # Usually assume loss is real (keep Self).
                            # But if error is huge, maybe repair?
                            # Let's keep Self for loss scenarios without flow evidence.
                            next_rx = curr_rx

            # --- TX Repair Strategy ---
            # Ideal: TX_self == RX_peer
            # Constraint: TX_self >= RX_peer

            next_tx = curr_tx
            if peer_rx is not None:
                err = calc_error(curr_tx, peer_rx)
                if err < HARDENING_THRESHOLD:
                    next_tx = (curr_tx + peer_rx) / 2.0
                else:
                    if curr_tx < peer_rx:
                        # Impossible (I sent less than they received).
                        # Must repair upwards.
                        next_tx = peer_rx
                    else:
                        # curr_tx > peer_rx (Possible Loss).
                        # Check Flow: Do we need less TX?
                        if r_id in router_flow:
                            net = router_flow[r_id]
                            # TX is output.
                            # If net > 0 (RX > TX), we are dropping at router.
                            # If net < 0 (TX > RX), we are creating. High TX is suspect.

                            # Error with Self: abs(net)
                            # Error with Peer: abs(net + curr_tx - peer_rx) (TX decreases, net increases)

                            if abs(net + curr_tx - peer_rx) < abs(net):
                                next_tx = peer_rx # Lowering TX helps balance
                            else:
                                next_tx = curr_tx # Keeping High TX helps balance
                        else:
                            next_tx = curr_tx

            updates[if_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply updates
        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']
=======
    # --- Step 2: Rate Repair Iterations ---
    for _ in range(ITERATIONS):
        # 2.1 Calculate Flow Balance per Router
        router_stats = {}
        for r_id, if_list in topology.items():
            r_rx = sum(state[i]['rx'] for i in if_list if i in state)
            r_tx = sum(state[i]['tx'] for i in if_list if i in state)
            # Imbalance = RX - TX
            router_stats[r_id] = {
                'rx': r_rx,
                'tx': r_tx,
                'imb': r_rx - r_tx,
                'vol': max(r_rx, r_tx, BASE_NOISE_FLOOR)
            }

        updates = {}
        for if_id, s in state.items():
            if s['status'] != 'up':
                updates[if_id] = {'rx': 0.0, 'tx': 0.0}
                continue

            peer_id = s['peer']
            r_id = s['router']
            has_peer = peer_id and peer_id in state

            curr_rx = s['rx']
            curr_tx = s['tx']

            peer_tx = state[peer_id]['tx'] if has_peer else None
            peer_rx = state[peer_id]['rx'] if has_peer else None

            # Calculate "Flow Implied" values
            # Flow Implied RX: Value that makes Local Router Imbalance = 0
            # Imbalance = SumRX - SumTX.
            # Want: (SumRX - curr_rx + new_rx) - SumTX = 0
            # new_rx = SumTX - SumRX + curr_rx = curr_rx - Imbalance
            flow_implied_rx = None
            if r_id in router_stats:
                flow_implied_rx = max(0.0, curr_rx - router_stats[r_id]['imb'])

            # Flow Implied TX:
            # Want: SumRX - (SumTX - curr_tx + new_tx) = 0
            # new_tx = SumRX - SumTX + curr_tx = curr_tx + Imbalance
            flow_implied_tx = None
            if r_id in router_stats:
                flow_implied_tx = max(0.0, curr_tx + router_stats[r_id]['imb'])

            # --- RX Repair ---
            # Priority:
            # 1. Peer TX (Source of Truth for Link).
            # 2. Local RX (Measurement).
            # 3. Flow Implied RX (Context).

            next_rx = curr_rx
            if peer_tx is not None:
                # Check for "Solidity" - Does Peer TX match Local Flow Implied?
                solidity_match = False
                if flow_implied_rx is not None:
                    if calc_error(peer_tx, flow_implied_rx) < HARDENING_THRESHOLD:
                        solidity_match = True

                # Check Bounds
                if curr_rx > peer_tx * (1.0 + HARDENING_THRESHOLD):
                    # Impossible (RX > Peer TX).
                    # Repair to Peer TX unless solidity says otherwise (unlikely).
                    next_rx = peer_tx
                elif curr_rx < peer_tx * (1.0 - HARDENING_THRESHOLD):
                    # RX < Peer TX (Possible Loss).
                    # If Peer TX matches Flow Implied -> Repair (Loss is phantom/error).
                    if solidity_match:
                         next_rx = peer_tx
                    else:
                        # Flow doesn't strongly confirm Peer.
                        # Check which is closer to Flow Target.
                        if flow_implied_rx is not None:
                            err_peer = calc_error(peer_tx, flow_implied_rx)
                            err_self = calc_error(curr_rx, flow_implied_rx)
                            if err_peer < err_self:
                                next_rx = peer_tx
                            else:
                                next_rx = curr_rx
                        else:
                             # No flow info. Default to trusting measurement (Packet Loss is real).
                             next_rx = curr_rx
                else:
                    # Agreement
                    next_rx = (curr_rx + peer_tx) / 2.0

            # --- TX Repair ---
            next_tx = curr_tx
            if peer_rx is not None:
                # Solidity Check
                solidity_match = False
                if flow_implied_tx is not None:
                    if calc_error(peer_rx, flow_implied_tx) < HARDENING_THRESHOLD:
                        solidity_match = True

                if curr_tx < peer_rx * (1.0 - HARDENING_THRESHOLD):
                    # Impossible (TX < Peer RX).
                    # Must repair up.
                    next_tx = peer_rx
                elif curr_tx > peer_rx * (1.0 + HARDENING_THRESHOLD):
                    # TX > Peer RX (Possible Loss downstream).
                    # If Peer RX matches Flow Implied -> Repair (TX is phantom).
                    if solidity_match:
                        next_tx = peer_rx
                    else:
                        # Which is closer to Flow?
                        if flow_implied_tx is not None:
                            err_peer = calc_error(peer_rx, flow_implied_tx)
                            err_self = calc_error(curr_tx, flow_implied_tx)
                            if err_peer < err_self:
                                next_tx = peer_rx
                            else:
                                next_tx = curr_tx
                        else:
                            next_tx = curr_tx
                else:
                    next_tx = (curr_tx + peer_rx) / 2.0

            updates[if_id] = {'rx': next_rx, 'tx': next_tx}

        # Apply updates
        for if_id, vals in updates.items():
            state[if_id]['rx'] = vals['rx']
            state[if_id]['tx'] = vals['tx']
>>>>>>> REPLACE
</DIFF>

<NAME>
calibrate_confidence_continuous
</NAME>

<DESCRIPTION>
Update confidence calibration to use continuous scoring based on flow quality and agreement, instead of discrete buckets.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Step 3: Confidence Calibration ---
    result = {}

    # Assess Final Flow Quality
    router_scores = {}
    for r_id, if_list in topology.items():
        r_rx = sum(state[i]['rx'] for i in if_list if i in state)
        r_tx = sum(state[i]['tx'] for i in if_list if i in state)
        mx = max(r_rx, r_tx, NOISE_FLOOR)
        imb = abs(r_rx - r_tx) / mx
        # Score: 1.0 = good, 0.0 = bad (>10% imbalance)
        router_scores[r_id] = max(0.0, 1.0 - imb * 10.0)

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']
        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']
        flow_score = router_scores.get(r_id, 0.5)

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        def get_conf(final, orig, peer_val, flow_q):
            # 1. Did we change significant value?
            is_changed = calc_error(final, orig) > HARDENING_THRESHOLD

            # 2. Agreement with Peer
            peer_agrees = False
            if peer_val is not None:
                if calc_error(final, peer_val) < HARDENING_THRESHOLD:
                    peer_agrees = True

            # Base Confidence
            conf = 1.0

            if is_changed:
                if peer_agrees:
                    # Supported repair
                    conf = 0.90 + (0.09 * flow_q) # 0.90 to 0.99
                else:
                    # Unsupported repair (e.g. flow forced, or impossible constraint forced)
                    if flow_q > 0.8:
                        conf = 0.85
                    else:
                        conf = 0.60
            else:
                # Kept Original
                if peer_val is not None and not peer_agrees:
                    # Disagreement remains (e.g. trusted Loss)
                    if flow_q > 0.8:
                        conf = 0.95 # Flow confirms our value
                    else:
                        conf = 0.80 # Ambiguous
                else:
                    conf = 1.0

            return conf

        rx_conf = get_conf(s['rx'], orig_rx, peer_tx, flow_score)
        tx_conf = get_conf(s['tx'], orig_tx, peer_rx, flow_score)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }
=======
    # --- Step 3: Confidence Calibration ---
    result = {}

    # Assess Final Flow Quality
    router_scores = {}
    for r_id, if_list in topology.items():
        r_rx = sum(state[i]['rx'] for i in if_list if i in state)
        r_tx = sum(state[i]['tx'] for i in if_list if i in state)
        mx = max(r_rx, r_tx, BASE_NOISE_FLOOR)
        imb = abs(r_rx - r_tx) / mx
        # Score: 1.0 = good, 0.0 = bad (>10% imbalance)
        router_scores[r_id] = max(0.0, 1.0 - imb * 10.0)

    for if_id, s in state.items():
        orig_rx = s['orig_rx']
        orig_tx = s['orig_tx']
        peer_id = s['peer']
        has_peer = peer_id and peer_id in state
        r_id = s['router']
        flow_score = router_scores.get(r_id, 0.5)

        peer_tx = state[peer_id]['tx'] if has_peer else None
        peer_rx = state[peer_id]['rx'] if has_peer else None

        def get_conf(final, orig, peer_val, flow_q):
            # Error distances
            err_orig = calc_error(final, orig)
            err_peer = calc_error(final, peer_val) if peer_val is not None else 0.0

            # Base logic: Start at 1.0, penalize for unverified changes or residual disagreement
            conf = 1.0

            if err_orig > HARDENING_THRESHOLD:
                # We Repaired
                # Penalty for repairing away from measurement
                # But reward if we matched Peer or Flow

                if peer_val is not None and err_peer < HARDENING_THRESHOLD:
                     # Matched Peer. High confidence.
                     # Scale by flow quality: If flow is bad, maybe Peer is also wrong?
                     # range 0.90 - 0.99
                     conf = 0.9 + (0.09 * flow_q)
                else:
                     # Repaired but NOT matching Peer? (e.g. Averaging or Flow Arbitration)
                     # Or No Peer.
                     # This is risky.
                     if flow_q > 0.8:
                         # Flow supports this value strongly
                         conf = 0.85
                     else:
                         # Very shaky
                         conf = 0.6
            else:
                # We kept Original
                if peer_val is not None and err_peer > HARDENING_THRESHOLD:
                    # Disagreement with Peer
                    # We trusted Self over Peer.
                    if flow_q > 0.8:
                        # Flow confirms Self
                        conf = 0.95
                    else:
                        # Ambiguous
                        conf = 0.75
                else:
                    # Agreement or No Peer
                    conf = 1.0

            return conf

        rx_conf = get_conf(s['rx'], orig_rx, peer_tx, flow_score)
        tx_conf = get_conf(s['tx'], orig_tx, peer_rx, flow_score)

        st_conf = 1.0
        if s['status'] != s['orig_status']:
            st_conf = 0.95

        result[if_id] = {
            'rx_rate': (orig_rx, s['rx'], rx_conf),
            'tx_rate': (orig_tx, s['tx'], tx_conf),
            'interface_status': (s['orig_status'], s['status'], st_conf),
            'connected_to': telemetry[if_id].get('connected_to'),
            'local_router': telemetry[if_id].get('local_router'),
            'remote_router': telemetry[if_id].get('remote_router')
        }
>>>>>>> REPLACE
</DIFF>