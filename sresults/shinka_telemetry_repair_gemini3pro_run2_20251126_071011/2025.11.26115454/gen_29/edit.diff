--- a/original.py
+++ b/original.py
@@ -1,241 +1,335 @@
 # EVOLVE-BLOCK-START
 """
 Network telemetry repair algorithm that detects and corrects inconsistencies
 in network interface telemetry data using topology relationships.
 
 Takes interface telemetry data and detects/repairs inconsistencies based on
 network invariants like link symmetry and flow conservation.
 """
 from typing import Dict, Any, Tuple, List
+import math
 
 
 def repair_network_telemetry(telemetry: Dict[str, Dict[str, Any]],
                              topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Repair network interface telemetry by detecting and correcting inconsistencies.
 
     Core principle: Use network invariants to validate and repair telemetry:
     1. Link Symmetry (R3): my_tx_rate â‰ˆ their_rx_rate for connected interfaces
     2. Flow Conservation (R1): Sum(incoming traffic) = Sum(outgoing traffic) at each router
     3. Interface Consistency: Status should be consistent across connected pairs
 
     Args:
         telemetry: Dictionary where key is interface_id and value contains:
             - interface_status: "up" or "down"
             - rx_rate: receive rate in Mbps
             - tx_rate: transmit rate in Mbps
             - connected_to: interface_id this interface connects to
             - local_router: router_id this interface belongs to
             - remote_router: router_id on the other side
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary with same structure but telemetry values become tuples of:
         (original_value, repaired_value, confidence_score)
         where confidence ranges from 0.0 (very uncertain) to 1.0 (very confident)
     """
 
     HARDENING_THRESHOLD = 0.02
-
-    # Initialize working state with originals
+    NOISE_FLOOR = 5.0  # Mbps
+
+    # Initialize working state
     state = {}
     for if_id, data in telemetry.items():
         state[if_id] = {
             'rx': float(data.get('rx_rate', 0.0)),
             'tx': float(data.get('tx_rate', 0.0)),
             'status': data.get('interface_status', 'unknown'),
-            'rx_conf': 1.0,
-            'tx_conf': 1.0,
-            'status_conf': 1.0,
-            'orig': data
+            'orig': data,
+            # Placeholders for confidence
+            'rx_conf': 0.0,
+            'tx_conf': 0.0,
+            'status_conf': 0.0
         }
 
-    # Pass 1: Fix Status Consistency
+    # Helper: Check traffic presence
+    def has_traffic(s):
+        return s['rx'] > 0.1 or s['tx'] > 0.1
+
+    # 1. Status Resolution (Peer Dominance + Traffic Awareness)
     for if_id, s in state.items():
         peer_id = s['orig'].get('connected_to')
-        if peer_id and peer_id in state:
-            peer = state[peer_id]
-            # If mismatch, use traffic to infer truth
-            if s['status'] != peer['status']:
-                traffic_active = max(s['rx'], s['tx'], peer['rx'], peer['tx']) > 1.0
-                if traffic_active:
-                    s['status'] = 'up'
-                    s['status_conf'] = 0.9
-                else:
-                    s['status'] = 'down'
-                    s['status_conf'] = 0.8
-
-    # Enforce DOWN means zero rates
+        peer = state.get(peer_id)
+        
+        s_stat = s['status']
+        p_stat = peer['status'] if peer else 'unknown'
+        
+        traffic_here = has_traffic(s)
+        traffic_there = has_traffic(peer) if peer else False
+        
+        # Conflict Resolution
+        if s_stat == 'down' and p_stat == 'down':
+            final_status = 'down'
+            conf = 1.0
+        elif (s_stat == 'down' or p_stat == 'down') and not (traffic_here or traffic_there):
+            # One says down, no traffic -> Assume Down
+            final_status = 'down'
+            conf = 0.9
+        else:
+            # Either both Up, or conflict with Traffic -> Assume Up
+            final_status = 'up'
+            if s_stat != p_stat:
+                conf = 0.8
+            else:
+                conf = 1.0
+                
+        s['new_status'] = final_status
+        s['status_conf'] = conf
+        
+    # Apply Status & Enforce Zero Rates
     for s in state.values():
+        s['status'] = s.pop('new_status')
         if s['status'] == 'down':
             s['rx'] = 0.0
             s['tx'] = 0.0
+            
+    # 2. Iterative Rate Solver (Gauss-Seidel)
+    
+    def get_router_balance_error(rid, current_state):
+        if not rid or rid not in topology: return 0.0
+        in_sum = 0.0
+        out_sum = 0.0
+        for iid in topology[rid]:
+            if iid in current_state:
+                in_sum += current_state[iid]['rx']
+                out_sum += current_state[iid]['tx']
+        return in_sum - out_sum
+
+    ITERATIONS = 5
+    sorted_ifs = sorted(state.keys())
+    
+    for _ in range(ITERATIONS):
+        processed_links = set()
+        
+        for if_id in sorted_ifs:
+            s = state[if_id]
+            if s['status'] == 'down': continue
+            
+            peer_id = s['orig'].get('connected_to')
+            if not peer_id or peer_id not in state: continue
+            
+            # Process each link only once (use min ID as key)
+            link_key = tuple(sorted([if_id, peer_id]))
+            if link_key in processed_links: continue
+            processed_links.add(link_key)
+            
+            # Identify Sender (TX) and Receiver (RX) for Direction 1
+            # We process both directions. 
+            # Direction 1: if_id (TX) -> peer_id (RX)
+            
+            def solve_flow(src_node, dst_node, src_meas, dst_meas, current_flow):
+                r_src = src_node['orig'].get('local_router')
+                r_dst = dst_node['orig'].get('local_router')
+                
+                # Calculate targets based on flow conservation
+                # Target = (Sum_Other_Out - Sum_Other_In) for the missing link
+                # Imb = In - Out.
+                # Src (Outflow): Imb = In - (Out_rest + f) => f = In - Out_rest - Imb_target(0)
+                # Dst (Inflow): Imb = (In_rest + f) - Out => f = Out - In_rest
+                
+                # Get current imbalance
+                imb_src = get_router_balance_error(r_src, state)
+                # Remove current flow from calculation to get "Rest"
+                # src_node['tx'] is current flow
+                # imb_src = In - (Out_rest + current_flow)
+                # In - Out_rest = imb_src + current_flow
+                target_src = imb_src + current_flow
+                
+                imb_dst = get_router_balance_error(r_dst, state)
+                # dst_node['rx'] is current flow
+                # imb_dst = (In_rest + current_flow) - Out
+                # Out - In_rest = current_flow - imb_dst
+                target_dst = current_flow - imb_dst
+                
+                # Candidates
+                candidates = {src_meas, dst_meas, current_flow}
+                if r_src in topology: candidates.add(max(0.0, target_src))
+                if r_dst in topology: candidates.add(max(0.0, target_dst))
+                
+                # Evaluate
+                best_f = current_flow
+                min_cost = float('inf')
+                
+                for f in candidates:
+                    cost = 0.0
+                    
+                    # 1. Fidelity (Bias towards TX as per recommendation)
+                    # "Repair RX to Peer TX" implies we trust TX more.
+                    cost += 1.2 * abs(f - src_meas)
+                    cost += 0.8 * abs(f - dst_meas)
+                    
+                    # 2. Flow Conservation (High weight)
+                    if r_src in topology:
+                        cost += 2.0 * abs(f - target_src)
+                    if r_dst in topology:
+                        cost += 2.0 * abs(f - target_dst)
+                        
+                    if cost < min_cost:
+                        min_cost = cost
+                        best_f = f
+                
+                return best_f
+
+            p = state[peer_id]
+            if p['status'] == 'down': continue
+            
+            # Direction 1: if_id(TX) -> p(RX)
+            f1 = solve_flow(s, p, 
+                            float(s['orig'].get('tx_rate', 0.0)), 
+                            float(p['orig'].get('rx_rate', 0.0)), 
+                            s['tx'])
+            s['tx'] = f1
+            p['rx'] = f1
+            
+            # Direction 2: p(TX) -> if_id(RX)
+            f2 = solve_flow(p, s,
+                            float(p['orig'].get('tx_rate', 0.0)),
+                            float(s['orig'].get('rx_rate', 0.0)),
+                            p['tx'])
+            p['tx'] = f2
+            s['rx'] = f2
+
+    # 3. Confidence Calculation
+    for if_id, s in state.items():
+        if s['status'] == 'down':
             s['rx_conf'] = 1.0
             s['tx_conf'] = 1.0
-
-    # Pass 2: Fix Rates using Symmetry & Flow Conservation
-    # We iterate over interfaces and check for symmetry violations
-    for if_id, s in state.items():
-        if s['status'] == 'down':
             continue
-
-        peer_id = s['orig'].get('connected_to')
-        if not peer_id or peer_id not in state:
-            continue
-        peer = state[peer_id]
-
-        # --- Check RX (should match Peer TX) ---
-        diff_rx = abs(s['rx'] - peer['tx'])
-        denom_rx = max(s['rx'], peer['tx'], 1.0)
-
-        if diff_rx / denom_rx > HARDENING_THRESHOLD:
-            # Symmetry Violation. Try to use Flow Conservation to pick winner.
-            local_router = s['orig'].get('local_router')
-            use_peer = True # Default fallback
-
-            # Calculate target RX for this interface to balance local router
-            if local_router and local_router in topology:
-                sum_tx_all = 0.0
-                sum_rx_other = 0.0
-                valid_topology = True
-
-                for rid in topology[local_router]:
-                    if rid not in state:
-                        valid_topology = False; break
-                    sum_tx_all += state[rid]['tx']
-                    if rid != if_id:
-                        sum_rx_other += state[rid]['rx']
-
-                if valid_topology:
-                    target_rx = max(0.0, sum_tx_all - sum_rx_other)
-                    dist_local = abs(s['rx'] - target_rx)
-                    dist_peer = abs(peer['tx'] - target_rx)
-
-                    if dist_local < dist_peer:
-                        use_peer = False
-                        # We trust local, but it disagrees with peer.
-                        # Confidence low unless very close to target
-                        match_q = dist_local / max(target_rx, 1.0)
-                        s['rx_conf'] = max(0.5, 1.0 - match_q)
+            
+        orig = s['orig']
+        
+        def calc_conf(rate_type, val):
+            meas = float(orig.get(f'{rate_type}_rate', 0.0))
+            denom = max(val, NOISE_FLOOR)
+            
+            # 1. Measurement Agreement
+            meas_err = abs(val - meas) / denom
+            
+            # 2. Flow Agreement
+            rid = orig.get('local_router')
+            flow_err = 0.0
+            has_topo = False
+            if rid and rid in topology:
+                has_topo = True
+                imb = abs(get_router_balance_error(rid, state))
+                total_flow = sum(state[k]['rx']+state[k]['tx'] for k in topology[rid] if k in state)
+                flow_err = imb / max(total_flow, NOISE_FLOOR)
+            
+            # Base logic
+            if meas_err < HARDENING_THRESHOLD:
+                # We kept the original value (or close to it)
+                # High confidence unless flow is terrible
+                base_conf = 1.0
+            else:
+                # We changed the value
+                if has_topo:
+                    if flow_err < HARDENING_THRESHOLD:
+                        # Changed it, but Flow confirms it -> High Confidence
+                        base_conf = 0.95
                     else:
-                        use_peer = True
-                        # We trust peer because it balances flow
-                        match_q = dist_peer / max(target_rx, 1.0)
-                        # Boost confidence if flow conservation confirms it
-                        s['rx_conf'] = max(0.8, 1.0 - match_q)
+                        # Changed it, and Flow still bad -> Low Confidence
+                        base_conf = 0.5
                 else:
-                    # No topology validation possible, fallback to peer + diff penalty
-                    s['rx_conf'] = max(0.0, 1.0 - (diff_rx / denom_rx))
-            else:
-                 s['rx_conf'] = max(0.0, 1.0 - (diff_rx / denom_rx))
-
-            if use_peer:
-                s['rx'] = peer['tx']
-
-        # --- Check TX (should match Peer RX) ---
-        diff_tx = abs(s['tx'] - peer['rx'])
-        denom_tx = max(s['tx'], peer['rx'], 1.0)
-
-        if diff_tx / denom_tx > HARDENING_THRESHOLD:
-            local_router = s['orig'].get('local_router')
-            use_peer = True
-
-            # Target TX = Sum(RX_all) - Sum(TX_other)
-            if local_router and local_router in topology:
-                sum_rx_all = 0.0
-                sum_tx_other = 0.0
-                valid_topology = True
-
-                for rid in topology[local_router]:
-                    if rid not in state:
-                        valid_topology = False; break
-                    sum_rx_all += state[rid]['rx']
-                    if rid != if_id:
-                        sum_tx_other += state[rid]['tx']
-
-                if valid_topology:
-                    target_tx = max(0.0, sum_rx_all - sum_tx_other)
-                    dist_local = abs(s['tx'] - target_tx)
-                    dist_peer = abs(peer['rx'] - target_tx)
-
-                    if dist_local < dist_peer:
-                        use_peer = False
-                        match_q = dist_local / max(target_tx, 1.0)
-                        s['tx_conf'] = max(0.5, 1.0 - match_q)
+                    # No topology, changed based on peer?
+                    peer_id = orig.get('connected_to')
+                    peer_val = 0.0
+                    if peer_id and peer_id in state:
+                        peer_type = 'tx' if rate_type == 'rx' else 'rx'
+                        peer_val = float(state[peer_id]['orig'].get(f'{peer_type}_rate', 0.0))
+                    
+                    peer_err = abs(val - peer_val) / denom
+                    if peer_err < HARDENING_THRESHOLD:
+                        # Matches peer -> Good
+                        base_conf = 0.8
                     else:
-                        use_peer = True
-                        match_q = dist_peer / max(target_tx, 1.0)
-                        s['tx_conf'] = max(0.8, 1.0 - match_q)
-                else:
-                    s['tx_conf'] = max(0.0, 1.0 - (diff_tx / denom_tx))
-            else:
-                s['tx_conf'] = max(0.0, 1.0 - (diff_tx / denom_tx))
-
-            if use_peer:
-                s['tx'] = peer['rx']
-
-    # Final result construction
+                        base_conf = 0.6
+            
+            # Sigmoid Decay for Flow Error
+            # Even if we are confident, significant flow error should degrade it
+            if has_topo:
+                # decay = 1 / (1 + k * error)
+                # If error is 0.05 (5%), conf drops significantly
+                decay = 1.0 / (1.0 + 15.0 * flow_err)
+                base_conf = base_conf * decay
+                
+            return base_conf
+
+        s['rx_conf'] = calc_conf('rx', s['rx'])
+        s['tx_conf'] = calc_conf('tx', s['tx'])
+
+    # Final Output
     result = {}
     for if_id, s in state.items():
         result[if_id] = {
             'rx_rate': (s['orig'].get('rx_rate', 0.0), s['rx'], s['rx_conf']),
             'tx_rate': (s['orig'].get('tx_rate', 0.0), s['tx'], s['tx_conf']),
             'interface_status': (s['orig'].get('interface_status', 'unknown'), s['status'], s['status_conf']),
             'connected_to': s['orig'].get('connected_to'),
             'local_router': s['orig'].get('local_router'),
             'remote_router': s['orig'].get('remote_router')
         }
 
     return result
 
 # EVOLVE-BLOCK-END
 
 
 def run_repair(telemetry: Dict[str, Dict[str, Any]], topology: Dict[str, List[str]]) -> Dict[str, Dict[str, Tuple]]:
     """
     Main entry point that will be called by the evaluator.
 
     Args:
         telemetry: Network interface telemetry data
         topology: Dictionary where key is router_id and value contains a list of interface_ids
 
     Returns:
         Dictionary containing repaired results with confidence scores
     """
     return repair_network_telemetry(telemetry, topology)
 
 
 if __name__ == "__main__":
     # Simple test case
     test_telemetry = {
         'if1_to_if2': {
             'interface_status': 'up',
             'rx_rate': 100.0,
             'tx_rate': 95.0,
             'connected_to': 'if2_to_if1',
             'local_router': 'router1',
             'remote_router': 'router2'
         },
         'if2_to_if1': {
             'interface_status': 'up',
             'rx_rate': 95.0,  # Should match if1's TX
             'tx_rate': 100.0,  # Should match if1's RX
             'connected_to': 'if1_to_if2',
             'local_router': 'router2',
             'remote_router': 'router1'
         }
     }
 
     test_topology = {
         'router1': ['if1_to_if2'],
         'router2': ['if2_to_if1']
     }
 
     result = run_repair(test_telemetry, test_topology)
 
     print("Repair results:")
     for if_id, data in result.items():
         print(f"\n{if_id}:")
         print(f"  RX: {data['rx_rate']}")
         print(f"  TX: {data['tx_rate']}")
         print(f"  Status: {data['interface_status']}")
