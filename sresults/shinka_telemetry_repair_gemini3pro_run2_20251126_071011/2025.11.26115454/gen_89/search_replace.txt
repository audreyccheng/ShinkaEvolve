<NAME>
optimize_repair_and_calibration
</NAME>

<DESCRIPTION>
1. Relax "Golden Truth" locking: Lower the reliability threshold required to lock values when flow targets from both endpoints agree. This allows the algorithm to anchor on consistent solutions earlier, even if neighbor confidence (which is initialized low) hasn't fully converged yet.
2. Improve Calibration: Switch to a "Best Evidence" strategy for confidence scoring. Instead of penalizing confidence based on the total error of both connected routers (which unfairly punishes a correct link connected to a broken router), use the maximum score derived from either endpoint. Also implements steeper penalties for residual errors to better differentiate between high-quality repairs and uncertain guesses.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                if is_golden and (rel_loc > 0.5 and rel_rem > 0.5):
                    # Strong signal: The network context demands this value
                    best_val = (target_local + target_remote) / 2.0
                    s['locked_tx'] = True
                    peer['locked_rx'] = True
=======
                # If targets agree perfectly, it's a strong signal regardless of neighbor confidence
                if is_golden and (rel_loc > 0.1 or rel_rem > 0.1):
                    # Strong signal: The network context demands this value
                    best_val = (target_local + target_remote) / 2.0
                    s['locked_tx'] = True
                    peer['locked_rx'] = True
>>>>>>> REPLACE
<<<<<<< SEARCH
                if is_golden and (rel_loc > 0.5 and rel_rem > 0.5):
                    best_val_b = (target_local + target_remote) / 2.0
                    s['locked_rx'] = True
                    peer['locked_tx'] = True
=======
                if is_golden and (rel_loc > 0.1 or rel_rem > 0.1):
                    best_val_b = (target_local + target_remote) / 2.0
                    s['locked_rx'] = True
                    peer['locked_tx'] = True
>>>>>>> REPLACE
<<<<<<< SEARCH
    # --- Final Confidence Calibration ---
    # We assess how "solid" the solution is based on residual imbalances
    for if_id, s in state.items():
        if s['status'] == 'down': continue

        peer_id = s['orig'].get('connected_to')
        if not peer_id or peer_id not in state: continue
        peer = state[peer_id]

        def calibrate_conf(val, r_source, r_dest, is_locked):
            if is_locked: return 1.0

            # Get residuals
            imb_src, _, flow_src = get_router_metrics(r_source)
            imb_dst, _, flow_dst = get_router_metrics(r_dest)

            # Normalized error
            err_src = abs(imb_src) / flow_src
            err_dst = abs(imb_dst) / flow_dst

            # Tiered Confidence
            # If at least one router is perfectly balanced, confidence is high
            base = 0.5
            if err_src < HARDENING_THRESHOLD and err_dst < HARDENING_THRESHOLD:
                base = 0.95
            elif err_src < HARDENING_THRESHOLD:
                base = 0.85
            elif err_dst < HARDENING_THRESHOLD:
                base = 0.85

            # Penalize based on total residual error
            # If error is high, reduce confidence
            penalty = min(0.5, (err_src + err_dst) * 2.0)

            return max(0.0, min(1.0, base - penalty))

        # Update TX Confidence
        s['tx_conf'] = calibrate_conf(s['tx'], s['orig'].get('local_router'), peer['orig'].get('local_router'), s['locked_tx'])
        peer['rx_conf'] = s['tx_conf']

        # Update RX Confidence
        s['rx_conf'] = calibrate_conf(s['rx'], peer['orig'].get('local_router'), s['orig'].get('local_router'), s['locked_rx'])
        peer['tx_conf'] = s['rx_conf']
=======
    # --- Final Confidence Calibration ---
    # We assess how "solid" the solution is based on residual imbalances
    for if_id, s in state.items():
        if s['status'] == 'down': continue

        peer_id = s['orig'].get('connected_to')
        if not peer_id or peer_id not in state: continue
        peer = state[peer_id]

        def calibrate_conf(val, r_source, r_dest, is_locked):
            if is_locked: return 1.0

            # Get residuals
            imb_src, _, flow_src = get_router_metrics(r_source)
            imb_dst, _, flow_dst = get_router_metrics(r_dest)

            # Normalized error
            err_src = abs(imb_src) / flow_src
            err_dst = abs(imb_dst) / flow_dst

            # "Best Evidence" Strategy:
            # If either the source or destination router is perfectly balanced,
            # we have strong evidence that this link's value is correct.
            # We don't want to penalize a link just because one of its neighbors is garbage.

            def get_score(err):
                if err < HARDENING_THRESHOLD:
                    return 0.95
                elif err < HARDENING_THRESHOLD * 2:
                    return 0.8
                else:
                    # Steeper decay for calibration
                    return max(0.0, 0.7 - err * 3.0)

            score_src = get_score(err_src)
            score_dst = get_score(err_dst)

            # Boost if both sides agree
            if score_src > 0.8 and score_dst > 0.8:
                return 1.0

            # Trust the best side, but maintain a floor for non-terrible measurements
            return max(score_src, score_dst, 0.4)

        # Update TX Confidence
        s['tx_conf'] = calibrate_conf(s['tx'], s['orig'].get('local_router'), peer['orig'].get('local_router'), s['locked_tx'])
        peer['rx_conf'] = s['tx_conf']

        # Update RX Confidence
        s['rx_conf'] = calibrate_conf(s['rx'], peer['orig'].get('local_router'), s['orig'].get('local_router'), s['locked_rx'])
        peer['tx_conf'] = s['rx_conf']
>>>>>>> REPLACE
</DIFF>