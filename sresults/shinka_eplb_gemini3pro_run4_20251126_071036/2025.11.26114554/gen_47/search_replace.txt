<NAME>
target_aware_greedy
</NAME>

<DESCRIPTION>
Implement "Target-Aware Best Fit" heuristic in both the initial randomized greedy construction and the LNS refinement steps.

Currently, the algorithm uses a "Min Load" (Best Fit) strategy, placing items in the lightest valid bin. This can lead to filling bins prematurely with small items or failing to reserve space for medium items effectively. The new strategy minimizes `(current_load + item_weight - average_load)^2`, encouraging bins to fill towards the target average.

I mix this strategy with the existing Min Load strategy (alternating attempts) to diversify the search space. This helps escape local optima where one heuristic fails but the other might succeed.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 1. Randomized Greedy Construction
        for attempt in range(NUM_RESTARTS):
            # Candidate order generation
            if attempt == 0:
                indices = sorted_indices_base
            else:
                # Add noise and resort. Noise factor 0.1 means weights vary by +/- 5%
                noise_scale = 0.1
                noisy_w = [w * (1.0 + (random.random() - 0.5) * noise_scale) for w in w_list]
                indices = sorted(range(num_groups), key=lambda x: noisy_w[x], reverse=True)

            current_assignment = [[] for _ in range(num_packs)]
            current_loads = [0.0] * num_packs
            current_counts = [0] * num_packs

            # Pack items
            for g_idx in indices:
                w = w_list[g_idx]

                # Best Fit: Find pack with min load among those with space
                best_p = -1
                min_load = float('inf')

                # Linear scan is fast enough for small num_packs (e.g. < 64)
                # Optimized logic: unroll slightly or just iterate
                for p in range(num_packs):
                    if current_counts[p] < groups_per_pack:
                        if current_loads[p] < min_load:
                            min_load = current_loads[p]
                            best_p = p

                current_assignment[best_p].append(g_idx)
                current_loads[best_p] += w
                current_counts[best_p] += 1

            max_l = max(current_loads)
=======
        # 1. Randomized Greedy Construction
        avg_weight = sum(w_list) / num_packs

        for attempt in range(NUM_RESTARTS):
            # Candidate order generation
            if attempt == 0:
                indices = sorted_indices_base
            else:
                # Add noise and resort. Noise factor 0.1 means weights vary by +/- 5%
                noise_scale = 0.1
                noisy_w = [w * (1.0 + (random.random() - 0.5) * noise_scale) for w in w_list]
                indices = sorted(range(num_groups), key=lambda x: noisy_w[x], reverse=True)

            current_assignment = [[] for _ in range(num_packs)]
            current_loads = [0.0] * num_packs
            current_counts = [0] * num_packs

            use_target_aware = (attempt % 2 != 0)

            # Pack items
            for g_idx in indices:
                w = w_list[g_idx]

                best_p = -1
                best_val = float('inf')

                if use_target_aware:
                    # Target-Aware: Minimize squared deviation from average
                    for p in range(num_packs):
                        if current_counts[p] < groups_per_pack:
                            val = (current_loads[p] + w - avg_weight) ** 2
                            if val < best_val:
                                best_val = val
                                best_p = p
                else:
                    # Best Fit: Find pack with min load among those with space
                    for p in range(num_packs):
                        if current_counts[p] < groups_per_pack:
                            val = current_loads[p]
                            if val < best_val:
                                best_val = val
                                best_p = p

                current_assignment[best_p].append(g_idx)
                current_loads[best_p] += w
                current_counts[best_p] += 1

            max_l = max(current_loads)
>>>>>>> REPLACE
<<<<<<< SEARCH
                # Small randomized search on subset (1 deterministic + 4 randomized)
                for sub_attempt in range(5):
                    if sub_attempt > 0:
                         # Jitter weights slightly to break ties/order
                         temp_items = sorted(items, key=lambda x: w_list[x] * (1.0 + (random.random()-0.5)*0.1), reverse=True)
                    else:
                        temp_items = items

                    sub_p = {p: [] for p in target_packs}
                    sub_w = {p: 0.0 for p in target_packs}
                    sub_c = {p: 0 for p in target_packs}

                    # Simple Greedy Loop for 3 packs
                    possible = True
                    for item in temp_items:
                        w = w_list[item]
                        # Find valid pack with min weight among targets
                        best_p = -1
                        min_val = float('inf')
                        for p in target_packs:
                            if sub_c[p] < groups_per_pack:
                                if sub_w[p] < min_val:
                                    min_val = sub_w[p]
                                    best_p = p

                        if best_p == -1:
                            possible = False; break

                        sub_p[best_p].append(item)
                        sub_w[best_p] += w
                        sub_c[best_p] += 1
=======
                # Small randomized search on subset (1 deterministic + 4 randomized)
                sub_total_weight = sum(w_list[i] for i in items)
                sub_avg = sub_total_weight / len(target_packs)

                for sub_attempt in range(5):
                    if sub_attempt > 0:
                         # Jitter weights slightly to break ties/order
                         temp_items = sorted(items, key=lambda x: w_list[x] * (1.0 + (random.random()-0.5)*0.1), reverse=True)
                    else:
                        temp_items = items

                    sub_p = {p: [] for p in target_packs}
                    sub_w = {p: 0.0 for p in target_packs}
                    sub_c = {p: 0 for p in target_packs}

                    use_target_aware_sub = (sub_attempt % 2 != 0)

                    # Greedy Loop for 3 packs
                    possible = True
                    for item in temp_items:
                        w = w_list[item]

                        best_p = -1
                        best_val = float('inf')

                        if use_target_aware_sub:
                             for p in target_packs:
                                if sub_c[p] < groups_per_pack:
                                    val = (sub_w[p] + w - sub_avg) ** 2
                                    if val < best_val:
                                        best_val = val
                                        best_p = p
                        else:
                            for p in target_packs:
                                if sub_c[p] < groups_per_pack:
                                    val = sub_w[p]
                                    if val < best_val:
                                        best_val = val
                                        best_p = p

                        if best_p == -1:
                            possible = False; break

                        sub_p[best_p].append(item)
                        sub_w[best_p] += w
                        sub_c[best_p] += 1
>>>>>>> REPLACE
</DIFF>