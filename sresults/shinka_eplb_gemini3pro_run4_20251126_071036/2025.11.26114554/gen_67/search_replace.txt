To improve the load balancing performance (balancedness score) while maintaining high speed, I propose replacing the deterministic "Strategy A" (which only attempts to repack the heaviest and lightest packs using a single greedy pass) with a **Randomized Pairwise Repack** strategy.

This new strategy:
1.  **Broadens the Search**: Instead of only pairing the heaviest pack (`max_p`) with the lightest pack, it iterates through all lighter packs as candidate partners. This allows the algorithm to offload weight from `max_p` to *any* pack that can accommodate it, reducing the global peak load more effectively.
2.  **Escapes Local Optima**: For each candidate pair, it runs multiple repacking attemptsâ€”one deterministic LPT (Longest Processing Time) and several randomized variants (where weights are perturbed by noise before sorting). This randomized greedy approach effectively solves the 2-Partition problem with cardinality constraints better than a single deterministic pass, finding "2-for-1" or complex exchanges that simple swapping or sorting misses.

This change leverages the available CPU budget (speed score 1.0) to perform more intensive local search, directly targeting the bottlenecks identified in the global insights.

<NAME>
randomized_repack_refinement
</NAME>

<DESCRIPTION>
Improves the refinement phase by replacing the deterministic "Strategy A" (Max-Min repack) with a "Randomized Pairwise Repack" strategy.
The new strategy:
1. Iterates through candidate partner packs (all lighter packs) to pair with the heaviest pack (`max_p`).
2. For each pair, it pools the items and attempts to redistribute them into the two packs using a constrained greedy heuristic.
3. It performs multiple restarts (1 deterministic + 5 randomized) for each pair to escape local optima that simple sorting might miss.
4. It accepts a new distribution if it strictly reduces the maximum load of the pair (which is the global max), or reduces the load difference without increasing the max.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                # Strategy A: Merge and Repack (Best Fit Decreasing for 2 bins)
                # This breaks local optima that single swaps cannot fix by completely
                # redistributing items between the heaviest and lightest packs.
                improved_via_repack = False
                if groups_per_pack > 1:
                    p1, p2 = max_p, min_p

                    # Gather all items from both packs
                    combined_items = current_packs[p1] + current_packs[p2]
                    combined_weights = [row_weight_list[idx] for idx in combined_items]

                    # Sort descending
                    combined = sorted(zip(combined_items, combined_weights), key=lambda x: x[1], reverse=True)

                    # Re-distribute using constrained LPT
                    new_p1, new_p2 = [], []
                    w_p1, w_p2 = 0.0, 0.0

                    for item, w in combined:
                        # Try to add to the lighter bin if it has space
                        can_1 = len(new_p1) < groups_per_pack
                        can_2 = len(new_p2) < groups_per_pack

                        if can_1 and can_2:
                            if w_p1 <= w_p2:
                                new_p1.append(item)
                                w_p1 += w
                            else:
                                new_p2.append(item)
                                w_p2 += w
                        elif can_1:
                            new_p1.append(item)
                            w_p1 += w
                        else:
                            new_p2.append(item)
                            w_p2 += w

                    new_diff = abs(w_p1 - w_p2)
                    current_pair_diff = pack_weights[p1] - pack_weights[p2]

                    # If we improved the local balance significantly, apply it
                    if new_diff < current_pair_diff - 1e-5:
                        current_packs[p1] = new_p1
                        pack_weights[p1] = w_p1
                        current_packs[p2] = new_p2
                        pack_weights[p2] = w_p2
                        improved_via_repack = True

                if improved_via_repack:
                    continue
=======
                # Strategy A: Randomized Merge and Repack
                # Try to repack the heaviest pack with lighter packs to offload weight.
                # We try multiple packs and randomized orders to escape local optima.
                improved_via_repack = False
                if groups_per_pack > 1:
                    # Try repacking max_p with other packs, preferring lighter ones.
                    # We check all lighter packs to maximize chance of finding a good partner.
                    candidates = sorted_pack_indices[1:]

                    for partner_p in candidates:
                        p1, p2 = max_p, partner_p

                        # Gather items
                        combined_items = current_packs[p1] + current_packs[p2]
                        combined_weights = [row_weight_list[idx] for idx in combined_items]
                        items_with_weights = list(zip(combined_items, combined_weights))

                        current_pair_max = max(pack_weights[p1], pack_weights[p2])
                        current_pair_diff = abs(pack_weights[p1] - pack_weights[p2])

                        best_repack = None
                        best_repack_max = current_pair_max
                        best_repack_diff = current_pair_diff

                        # Try Deterministic LPT + Randomized variants
                        # 1 Deterministic + 5 Randomized
                        seeds = [None] + [random.random() for _ in range(5)]

                        for seed in seeds:
                            if seed is None:
                                # Deterministic LPT
                                combined = sorted(items_with_weights, key=lambda x: x[1], reverse=True)
                            else:
                                # Randomized LPT with multiplicative noise
                                combined = sorted(items_with_weights, key=lambda x: x[1] * (0.8 + 0.4 * random.random()), reverse=True)

                            # Greedy construct (Constrained LPT)
                            t_p1, t_p2 = [], []
                            t_w1, t_w2 = 0.0, 0.0

                            for item, w in combined:
                                can_1 = len(t_p1) < groups_per_pack
                                can_2 = len(t_p2) < groups_per_pack

                                if can_1 and can_2:
                                    if t_w1 <= t_w2:
                                        t_p1.append(item)
                                        t_w1 += w
                                    else:
                                        t_p2.append(item)
                                        t_w2 += w
                                elif can_1:
                                    t_p1.append(item)
                                    t_w1 += w
                                else:
                                    t_p2.append(item)
                                    t_w2 += w

                            t_max = max(t_w1, t_w2)
                            t_diff = abs(t_w1 - t_w2)

                            # Acceptance criteria:
                            # Strictly reduce the local peak load OR (maintain peak and reduce diff)
                            if t_max < best_repack_max - 1e-6:
                                best_repack_max = t_max
                                best_repack_diff = t_diff
                                best_repack = (t_p1, t_w1, t_p2, t_w2)
                            elif abs(t_max - best_repack_max) < 1e-6 and t_diff < best_repack_diff - 1e-6:
                                best_repack_diff = t_diff
                                best_repack = (t_p1, t_w1, t_p2, t_w2)

                        if best_repack:
                            # Apply the best found repack
                            new_p1, new_w1, new_p2, new_w2 = best_repack
                            current_packs[p1] = new_p1
                            pack_weights[p1] = new_w1
                            current_packs[p2] = new_p2
                            pack_weights[p2] = new_w2
                            improved_via_repack = True
                            break # Restart the outer refinement loop to re-evaluate global max/min

                if improved_via_repack:
                    continue
>>>>>>> REPLACE
</DIFF>