<NAME>
three_way_swap
</NAME>

<DESCRIPTION>
Implement 3-way cyclic swaps in the `refine_swaps` routine.
The current pairwise swap logic sometimes reaches a local optimum where no direct exchange between the heaviest and lightest pack is beneficial.
A 3-way swap ($u \in Max \to Mid, v \in Mid \to Min, w \in Min \to Max$) enables rebalancing by using an intermediate pack as a buffer.
The implementation checks for beneficial 3-way swaps if pairwise swaps fail, using binary search to efficiently find matching items in the intermediate pack.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Helper: Optimized Pairwise Swap
        def refine_swaps(curr_packs, curr_weights, max_iter=20):
            for _ in range(max_iter):
                # Identify min and max packs
                min_p, max_p = 0, 0
                min_val, max_val = curr_weights[0], curr_weights[0]

                # Simple scan is fast for small num_packs
                for p in range(1, num_packs):
                    w = curr_weights[p]
                    if w < min_val:
                        min_val = w
                        min_p = p
                    elif w > max_val:
                        max_val = w
                        max_p = p

                diff = max_val - min_val
                if diff < 1e-6:
                    break

                target_delta = diff / 2.0
                best_swap = None
                best_gap = diff

                # Prepare light pack items for binary search: (weight, index_in_pack)
                # This makes finding the best swap O(C log C) instead of O(C^2)
                min_items = []
                for idx_in_pack, global_idx in enumerate(curr_packs[min_p]):
                    min_items.append((row_weights[global_idx], idx_in_pack))
                min_items.sort(key=lambda x: x[0])
                min_ws = [x[0] for x in min_items]

                found_swap = False

                # Iterate heavy pack items
                for idx_u, u in enumerate(curr_packs[max_p]):
                    w_u = row_weights[u]
                    # We look for v such that w_u - w_v approx target_delta
                    # w_v approx w_u - target_delta
                    target_v = w_u - target_delta

                    # Binary search
                    pos = bisect.bisect_left(min_ws, target_v)

                    # Check candidates around pos
                    candidates = []
                    if pos < len(min_ws): candidates.append(pos)
                    if pos > 0: candidates.append(pos - 1)

                    for c_idx in candidates:
                        w_v = min_ws[c_idx]
                        delta = w_u - w_v

                        if 0 < delta < diff: # Valid reduction
                            gap = abs(delta - target_delta)
                            if gap < best_gap:
                                best_gap = gap
                                idx_v = min_items[c_idx][1]
                                best_swap = (idx_u, idx_v, delta)
                                if gap < 1e-6:
                                    found_swap = True
                                    break
                    if found_swap: break

                if best_swap:
                    idx_u, idx_v, delta = best_swap
                    u = curr_packs[max_p][idx_u]
                    v = curr_packs[min_p][idx_v]

                    curr_packs[max_p][idx_u] = v
                    curr_packs[min_p][idx_v] = u
                    curr_weights[max_p] -= delta
                    curr_weights[min_p] += delta
                else:
                    break
=======
        # Helper: Optimized Pairwise Swap with 3-Way Fallback
        def refine_swaps(curr_packs, curr_weights, max_iter=20):
            for _ in range(max_iter):
                # Identify min and max packs
                min_p, max_p = 0, 0
                min_val, max_val = curr_weights[0], curr_weights[0]

                for p in range(1, num_packs):
                    w = curr_weights[p]
                    if w < min_val:
                        min_val = w
                        min_p = p
                    elif w > max_val:
                        max_val = w
                        max_p = p

                diff = max_val - min_val
                if diff < 1e-6:
                    break

                target_delta = diff / 2.0
                best_swap = None
                best_gap = diff
                found_swap = False

                # Prepare light pack items for binary search: (weight, index_in_pack)
                min_items = []
                for idx_in_pack, global_idx in enumerate(curr_packs[min_p]):
                    min_items.append((row_weights[global_idx], idx_in_pack))
                min_items.sort(key=lambda x: x[0])
                min_ws = [x[0] for x in min_items]

                # 1. Try Pairwise Swap
                for idx_u, u in enumerate(curr_packs[max_p]):
                    w_u = row_weights[u]
                    target_v = w_u - target_delta

                    pos = bisect.bisect_left(min_ws, target_v)
                    candidates = []
                    if pos < len(min_ws): candidates.append(pos)
                    if pos > 0: candidates.append(pos - 1)

                    for c_idx in candidates:
                        w_v = min_ws[c_idx]
                        delta = w_u - w_v

                        if 0 < delta < diff:
                            gap = abs(delta - target_delta)
                            if gap < best_gap:
                                best_gap = gap
                                idx_v = min_items[c_idx][1]
                                best_swap = (idx_u, idx_v, delta)
                                if gap < 1e-6:
                                    found_swap = True
                                    break
                    if found_swap: break

                if best_swap:
                    idx_u, idx_v, delta = best_swap
                    u = curr_packs[max_p][idx_u]
                    v = curr_packs[min_p][idx_v]

                    curr_packs[max_p][idx_u] = v
                    curr_packs[min_p][idx_v] = u
                    curr_weights[max_p] -= delta
                    curr_weights[min_p] += delta
                    continue

                # 2. Try 3-Way Cyclic Swap: Max -> Mid -> Min -> Max
                found_3way = False
                best_3way = None

                max_items = [(row_weights[u], idx) for idx, u in enumerate(curr_packs[max_p])]
                max_items.sort(key=lambda x: x[0], reverse=True)

                mid_candidates = [p for p in range(num_packs) if p != max_p and p != min_p]
                # Randomize to avoid stuck loops if multiple identical mid packs
                if len(mid_candidates) > 5:
                    rng.shuffle(mid_candidates)
                    mid_candidates = mid_candidates[:5]

                for mid_p in mid_candidates:
                    w_mid = curr_weights[mid_p]
                    mid_pack_items = [(row_weights[x], idx) for idx, x in enumerate(curr_packs[mid_p])]
                    mid_pack_items.sort(key=lambda x: x[0])
                    mid_ws = [x[0] for x in mid_pack_items]

                    # Maximize improvement: iterate items from max and min
                    for w_u, idx_u in max_items:
                        for w_w, idx_w in min_items:
                            if w_u <= w_w: break # Max must give more than it takes

                            # We want to maintain Mid: w_v approx w_u
                            pos = bisect.bisect_left(mid_ws, w_u)
                            cands = []
                            if pos < len(mid_ws): cands.append(pos)
                            if pos > 0: cands.append(pos - 1)

                            for c_idx in cands:
                                w_v = mid_ws[c_idx]
                                idx_v = mid_pack_items[c_idx][1]

                                new_max_w = max_val - w_u + w_w
                                new_min_w = min_val - w_w + w_v
                                new_mid_w = w_mid - w_v + w_u

                                # Check if spread reduces without creating new outliers
                                if (new_max_w < max_val - 1e-6 and
                                    new_min_w > min_val + 1e-6 and
                                    new_mid_w < max_val and
                                    new_mid_w > min_val):
                                    best_3way = (idx_u, idx_v, idx_w, mid_p)
                                    found_3way = True
                                    break
                            if found_3way: break
                        if found_3way: break
                    if found_3way: break

                if found_3way:
                    idx_u, idx_v, idx_w, mid_p = best_3way
                    u = curr_packs[max_p][idx_u]
                    v = curr_packs[mid_p][idx_v]
                    w = curr_packs[min_p][idx_w]

                    curr_packs[max_p][idx_u] = w
                    curr_packs[mid_p][idx_v] = u
                    curr_packs[min_p][idx_w] = v

                    w_u, w_v, w_w = row_weights[u], row_weights[v], row_weights[w]
                    curr_weights[max_p] += (w_w - w_u)
                    curr_weights[mid_p] += (w_u - w_v)
                    curr_weights[min_p] += (w_v - w_w)
                else:
                    break
>>>>>>> REPLACE
</DIFF>