<NAME>
pooled_repartition
</NAME>

<DESCRIPTION>
Improved the refinement logic in `balanced_packing`. Replaced the previous refinement strategy (which relied on binary-search-assisted pairwise swaps and a complex 3-way cyclic swap) with a more robust "Pooled 2-Pack Repartitioning" strategy.

This new strategy identifies the heaviest and lightest packs, pools their items, and re-partitions them using a constrained greedy heuristic (Min-Load insertion with cardinality limits). It compares this re-partitioning against the best possible single-item swap and applies the one that yields the largest reduction in load difference. This effectively allows multi-item swaps (e.g., swapping 2 small items for 1 large item) that pairwise checks miss, and is computationally efficient for the typical small pack sizes found in this problem.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Helper: Optimized Pairwise Swap with 3-Way Fallback
        def refine_swaps(curr_packs, curr_weights, max_iter=20):
            for _ in range(max_iter):
                # Identify min and max packs
                min_p, max_p = 0, 0
                min_val, max_val = curr_weights[0], curr_weights[0]

                for p in range(1, num_packs):
                    w = curr_weights[p]
                    if w < min_val:
                        min_val = w
                        min_p = p
                    elif w > max_val:
                        max_val = w
                        max_p = p

                diff = max_val - min_val
                if diff < 1e-6:
                    break

                target_delta = diff / 2.0
                best_swap = None
                best_gap = diff
                found_swap = False

                # Prepare light pack items for binary search: (weight, index_in_pack)
                min_items = []
                for idx_in_pack, global_idx in enumerate(curr_packs[min_p]):
                    min_items.append((row_weights[global_idx], idx_in_pack))
                min_items.sort(key=lambda x: x[0])
                min_ws = [x[0] for x in min_items]

                # 1. Try Pairwise Swap
                for idx_u, u in enumerate(curr_packs[max_p]):
                    w_u = row_weights[u]
                    target_v = w_u - target_delta

                    pos = bisect.bisect_left(min_ws, target_v)
                    candidates = []
                    if pos < len(min_ws): candidates.append(pos)
                    if pos > 0: candidates.append(pos - 1)

                    for c_idx in candidates:
                        w_v = min_ws[c_idx]
                        delta = w_u - w_v

                        if 0 < delta < diff:
                            gap = abs(delta - target_delta)
                            if gap < best_gap:
                                best_gap = gap
                                idx_v = min_items[c_idx][1]
                                best_swap = (idx_u, idx_v, delta)
                                if gap < 1e-6:
                                    found_swap = True
                                    break
                    if found_swap: break

                if best_swap:
                    idx_u, idx_v, delta = best_swap
                    u = curr_packs[max_p][idx_u]
                    v = curr_packs[min_p][idx_v]

                    curr_packs[max_p][idx_u] = v
                    curr_packs[min_p][idx_v] = u
                    curr_weights[max_p] -= delta
                    curr_weights[min_p] += delta
                    continue

                # 2. Try 3-Way Cyclic Swap: Max -> Mid -> Min -> Max
                found_3way = False
                best_3way = None

                max_items = [(row_weights[u], idx) for idx, u in enumerate(curr_packs[max_p])]
                max_items.sort(key=lambda x: x[0], reverse=True)

                mid_candidates = [p for p in range(num_packs) if p != max_p and p != min_p]
                # Randomize to avoid stuck loops if multiple identical mid packs
                if len(mid_candidates) > 5:
                    rng.shuffle(mid_candidates)
                    mid_candidates = mid_candidates[:5]

                for mid_p in mid_candidates:
                    w_mid = curr_weights[mid_p]
                    mid_pack_items = [(row_weights[x], idx) for idx, x in enumerate(curr_packs[mid_p])]
                    mid_pack_items.sort(key=lambda x: x[0])
                    mid_ws = [x[0] for x in mid_pack_items]

                    # Maximize improvement: iterate items from max and min
                    for w_u, idx_u in max_items:
                        for w_w, idx_w in min_items:
                            if w_u <= w_w: break # Max must give more than it takes

                            # We want to maintain Mid: w_v approx w_u
                            pos = bisect.bisect_left(mid_ws, w_u)
                            cands = []
                            if pos < len(mid_ws): cands.append(pos)
                            if pos > 0: cands.append(pos - 1)

                            for c_idx in cands:
                                w_v = mid_ws[c_idx]
                                idx_v = mid_pack_items[c_idx][1]

                                new_max_w = max_val - w_u + w_w
                                new_min_w = min_val - w_w + w_v
                                new_mid_w = w_mid - w_v + w_u

                                # Check if spread reduces without creating new outliers
                                if (new_max_w < max_val - 1e-6 and
                                    new_min_w > min_val + 1e-6 and
                                    new_mid_w < max_val and
                                    new_mid_w > min_val):
                                    best_3way = (idx_u, idx_v, idx_w, mid_p)
                                    found_3way = True
                                    break
                            if found_3way: break
                        if found_3way: break
                    if found_3way: break

                if found_3way:
                    idx_u, idx_v, idx_w, mid_p = best_3way
                    u = curr_packs[max_p][idx_u]
                    v = curr_packs[mid_p][idx_v]
                    w = curr_packs[min_p][idx_w]

                    curr_packs[max_p][idx_u] = w
                    curr_packs[mid_p][idx_v] = u
                    curr_packs[min_p][idx_w] = v

                    w_u, w_v, w_w = row_weights[u], row_weights[v], row_weights[w]
                    curr_weights[max_p] += (w_w - w_u)
                    curr_weights[mid_p] += (w_u - w_v)
                    curr_weights[min_p] += (w_v - w_w)
                else:
                    break
=======
    # Helper: Refinement using Pooled 2-Partitioning and Pairwise Swaps
    def refine_swaps(curr_packs, curr_weights, max_iter=20):
        for _ in range(max_iter):
            # Identify min and max packs
            min_p, max_p = 0, 0
            min_val, max_val = curr_weights[0], curr_weights[0]

            for p in range(1, num_packs):
                w = curr_weights[p]
                if w < min_val:
                    min_val = w
                    min_p = p
                elif w > max_val:
                    max_val = w
                    max_p = p

            diff = max_val - min_val
            if diff < 1e-6:
                break

            # We aim to rebalance max_p and min_p
            p1, p2 = max_p, min_p
            items1, items2 = curr_packs[p1], curr_packs[p2]

            # --- Strategy A: Best Pairwise Swap ---
            best_swap = None
            best_swap_gain = 0.0

            # Pre-fetch weights to avoid lookups in inner loop
            w1 = [row_weights[idx] for idx in items1]
            w2 = [row_weights[idx] for idx in items2]

            for i, u_w in enumerate(w1):
                for j, v_w in enumerate(w2):
                    delta = u_w - v_w
                    # Only consider swaps that transfer weight from Max to Min
                    # and do not flip the imbalance beyond the current difference
                    if 0 < delta < diff:
                        # Gain is how much the difference (diff) is reduced
                        # New diff ~= |(max - delta) - (min + delta)| = |diff - 2*delta|
                        # Reduction = diff - |diff - 2*delta|
                        gain = diff - abs(diff - 2 * delta)
                        if gain > best_swap_gain:
                            best_swap_gain = gain
                            best_swap = (i, j, delta)
                            # Early exit if "perfect"
                            if abs(gain - diff) < 1e-6: break
                if best_swap and abs(best_swap_gain - diff) < 1e-6: break

            # --- Strategy B: Pooled Greedy Partitioning ---
            # Pool items and re-distribute them to A and B to balance weights
            pool_indices = items1 + items2
            pool_weights = w1 + w2
            pool = sorted(zip(pool_indices, pool_weights), key=lambda x: x[1], reverse=True)

            new_w1, new_w2 = 0.0, 0.0
            new_items1, new_items2 = [], []

            for idx, w in pool:
                # Assign to lighter pack if capacity allows
                cap1 = len(new_items1) < groups_per_pack
                cap2 = len(new_items2) < groups_per_pack

                if cap1 and cap2:
                    if new_w1 <= new_w2:
                        new_items1.append(idx)
                        new_w1 += w
                    else:
                        new_items2.append(idx)
                        new_w2 += w
                elif cap1:
                    new_items1.append(idx)
                    new_w1 += w
                else:
                    new_items2.append(idx)
                    new_w2 += w

            new_local_diff = abs(new_w1 - new_w2)
            repart_gain = diff - new_local_diff

            # Apply the best strategy
            # Prefer Repartition slightly as it reshuffles structure
            applied = False
            if repart_gain > 1e-6 and repart_gain >= best_swap_gain - 1e-6:
                curr_packs[p1] = new_items1
                curr_packs[p2] = new_items2
                curr_weights[p1] = new_w1
                curr_weights[p2] = new_w2
                applied = True
            elif best_swap and best_swap_gain > 1e-6:
                i, j, delta = best_swap
                u = curr_packs[p1][i]
                v = curr_packs[p2][j]

                curr_packs[p1][i] = v
                curr_packs[p2][j] = u
                curr_weights[p1] -= delta
                curr_weights[p2] += delta
                applied = True

            if not applied:
                break
>>>>>>> REPLACE
</DIFF>