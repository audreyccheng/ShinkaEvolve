<NAME>
iterative_2bin_repartitioning
</NAME>

<DESCRIPTION>
Replace the limited 1-item and 2-item swap logic with a more general "Iterative 2-Bin Repartitioning" strategy. In each refinement step, we select the heaviest and lightest packs (and occasionally random pairs to escape local optima) and pool their items. We then use a randomized greedy heuristic (Repeated LPT with noise) to redistribute the pooled items between the two packs to minimize their weight difference. This allows for moving an arbitrary number of items between packs to achieve better balance, effectively generalizing swaps to k-items and utilizing the CPU time more effectively.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # 2. Refinement Phase
            for step in range(max_refine_steps):
                # Identify max and min packs
                min_p = 0
                max_p = 0
                min_val = pack_weights[0]
                max_val = pack_weights[0]

                for p in range(1, num_packs):
                    val = pack_weights[p]
                    if val < min_val:
                        min_val = val
                        min_p = p
                    elif val > max_val:
                        max_val = val
                        max_p = p

                diff = max_val - min_val
                if diff < 1e-6:
                    break

                target = diff / 2.0

                # Strategies:
                # 1. Try 1-item swap
                # 2. Try 2-item swap (if 1-item is not good enough)

                best_move = None # ('1', idx_u, idx_v, delta) or ('2', (u1, u2), (v1, v2), delta)
                best_gap = diff

                # --- Strategy 1: 1-item Swap ---
                items_max = current_packs[max_p]
                items_min = current_packs[min_p]

                for idx_u, u in enumerate(items_max):
                    w_u = row_weight_list[u]
                    for idx_v, v in enumerate(items_min):
                        w_v = row_weight_list[v]
                        delta = w_u - w_v
                        if 0 < delta < diff:
                            gap = abs(delta - target)
                            if gap < best_gap:
                                best_gap = gap
                                best_move = ('1', idx_u, idx_v, delta)
                                if gap < 1e-5: break
                    if best_gap < 1e-5: break

                # --- Strategy 2: 2-item Swap ---
                # Only try if 1-item swap didn't close the gap well (e.g. gap > 10% of diff)
                # and we have enough items.
                if (best_gap > 0.1 * diff) and (groups_per_pack >= 2):

                    # Generate pair sums
                    # Max pack pairs
                    max_pairs = []
                    for idx1 in range(len(items_max)):
                        for idx2 in range(idx1 + 1, len(items_max)):
                            s = row_weight_list[items_max[idx1]] + row_weight_list[items_max[idx2]]
                            max_pairs.append((s, idx1, idx2))
                    max_pairs.sort(key=lambda x: x[0])

                    # Min pack pairs
                    min_pairs = []
                    for idx1 in range(len(items_min)):
                        for idx2 in range(idx1 + 1, len(items_min)):
                            s = row_weight_list[items_min[idx1]] + row_weight_list[items_min[idx2]]
                            min_pairs.append((s, idx1, idx2))
                    min_pairs.sort(key=lambda x: x[0])

                    # Two pointer search
                    i_max = 0
                    i_min = 0
                    n_max = len(max_pairs)
                    n_min = len(min_pairs)

                    while i_max < n_max and i_min < n_min:
                        s_max, u1, u2 = max_pairs[i_max]
                        s_min, v1, v2 = min_pairs[i_min]

                        delta = s_max - s_min

                        if delta <= 0:
                            # Need larger delta, increase s_max
                            i_max += 1
                            continue

                        if delta >= diff:
                            # Delta too large, increase s_min to reduce delta
                            i_min += 1
                            continue

                        # Valid delta range (0 < delta < diff)
                        gap = abs(delta - target)
                        if gap < best_gap:
                            best_gap = gap
                            best_move = ('2', (u1, u2), (v1, v2), delta)
                            if gap < 1e-5: break

                        # Advance pointers based on comparison to target
                        if delta < target:
                            i_max += 1
                        else:
                            i_min += 1

                # Execute best move
                if best_move:
                    mode = best_move[0]
                    if mode == '1':
                        _, idx_u, idx_v, delta = best_move
                        u = current_packs[max_p][idx_u]
                        v = current_packs[min_p][idx_v]
                        current_packs[max_p][idx_u] = v
                        current_packs[min_p][idx_v] = u
                    else:
                        _, (u1, u2), (v1, v2), delta = best_move
                        # Retrieve items
                        item_u1 = current_packs[max_p][u1]
                        item_u2 = current_packs[max_p][u2]
                        item_v1 = current_packs[min_p][v1]
                        item_v2 = current_packs[min_p][v2]

                        # Swap. Careful with indices changing?
                        # We used indices from the start of the loop.
                        # Direct assignment is safe if indices are distinct.
                        current_packs[max_p][u1] = item_v1
                        current_packs[max_p][u2] = item_v2
                        current_packs[min_p][v1] = item_u1
                        current_packs[min_p][v2] = item_u2

                    pack_weights[max_p] -= delta
                    pack_weights[min_p] += delta
                else:
                    break
=======
            # 2. Refinement Phase: Iterative 2-Bin Repartitioning
            for step in range(max_refine_steps):
                # Identify max and min packs
                min_p = 0
                max_p = 0
                min_val = pack_weights[0]
                max_val = pack_weights[0]

                # Randomized selection occasionally to escape local optima
                if step > 0 and step % 5 == 0:
                    p1 = random.randint(0, num_packs - 1)
                    p2 = random.randint(0, num_packs - 2)
                    if p2 >= p1: p2 += 1
                    max_p, min_p = p1, p2
                    max_val, min_val = pack_weights[max_p], pack_weights[min_p]
                else:
                    for p in range(1, num_packs):
                        val = pack_weights[p]
                        if val < min_val:
                            min_val = val
                            min_p = p
                        elif val > max_val:
                            max_val = val
                            max_p = p

                diff = abs(max_val - min_val)
                if diff < 1e-6:
                    if step % 5 != 0:
                        break
                    else:
                        continue

                # Pool items from both packs
                pool = current_packs[max_p] + current_packs[min_p]
                pool_weights = [row_weight_list[x] for x in pool]
                total_pool = sum(pool_weights)
                target_half = total_pool / 2.0
                K = groups_per_pack

                # Record current best state for this pair
                # We want to minimize deviation from target_half
                best_dev = abs(pack_weights[max_p] - target_half)
                best_assignment = None # Will store set_A indices relative to pool

                pool_indices = list(range(len(pool)))

                # Heuristic: Repeated Randomized Greedy
                # We want to partition pool into A and B of size K
                sub_trials = 30
                for sub in range(sub_trials):
                    # Sort with noise
                    if sub == 0:
                        # Deterministic LPT first
                        sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i], reverse=True)
                    else:
                        # Add noise to weights
                        noise = [random.uniform(0.8, 1.2) for _ in pool]
                        sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i] * noise[i], reverse=True)

                    w_A = 0.0
                    w_B = 0.0
                    cnt_A = 0
                    cnt_B = 0
                    set_A_local = []

                    # Greedy assignment
                    for idx in sorted_idx:
                        w = pool_weights[idx]
                        can_A = cnt_A < K
                        can_B = cnt_B < K

                        if can_A and can_B:
                            # Put in the lighter bin so far
                            if w_A <= w_B:
                                w_A += w
                                cnt_A += 1
                                set_A_local.append(idx)
                            else:
                                w_B += w
                                cnt_B += 1
                        elif can_A:
                            w_A += w
                            cnt_A += 1
                            set_A_local.append(idx)
                        else: # can_B
                            w_B += w
                            cnt_B += 1

                    dev = abs(w_A - target_half)
                    if dev < best_dev:
                        best_dev = dev
                        best_assignment = set_A_local
                        if dev < 1e-6: break

                # Apply improvement if found
                if best_assignment is not None:
                    set_A_indices = set(best_assignment)
                    new_max = [pool[i] for i in best_assignment]
                    new_min = [pool[i] for i in pool_indices if i not in set_A_indices]

                    current_packs[max_p] = new_max
                    current_packs[min_p] = new_min
                    pack_weights[max_p] = sum(row_weight_list[x] for x in new_max)
                    pack_weights[min_p] = sum(row_weight_list[x] for x in new_min)
                else:
                    # No improvement found for this pair
                    if step % 5 != 0:
                        break
>>>>>>> REPLACE
</DIFF>