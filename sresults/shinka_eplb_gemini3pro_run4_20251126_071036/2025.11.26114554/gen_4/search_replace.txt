<NAME>
vectorized_local_search
</NAME>

<DESCRIPTION>
Optimizes the local search refinement step in `balanced_packing`.
1.  **Broader Search Space**: Instead of restricting swaps to the heaviest and lightest packs, the new algorithm attempts to swap items from the heaviest pack with *any* other pack if it reduces the overall load variance. This helps escape local optima.
2.  **Vectorization**: Uses PyTorch vector operations to evaluate all possible swaps between two packs simultaneously, replacing the slow nested Python loops. This significantly improves performance given the larger search space.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Refinement: Local Search (Swap)
        # Try to swap items between heaviest and lightest packs to reduce variance
        for _ in range(20):
            min_pack = min(range(num_packs), key=pack_weights.__getitem__)
            max_pack = max(range(num_packs), key=pack_weights.__getitem__)

            if min_pack == max_pack:
                break

            diff = pack_weights[max_pack] - pack_weights[min_pack]
            if diff < 1e-6:
                break

            best_swap = None
            best_reduction = 0.0

            # Identify best swap between max_pack and min_pack
            for u in pack_contents[max_pack]:
                w_u = weight_cpu[i, u].item()
                for v in pack_contents[min_pack]:
                    w_v = weight_cpu[i, v].item()

                    delta = w_u - w_v
                    if 0 < delta < diff:
                        # We want to maximize reduction of the gap
                        reduction = diff - abs(diff - 2 * delta)
                        if reduction > best_reduction:
                            best_reduction = reduction
                            best_swap = (u, v, delta)

            if best_swap:
                u, v, delta = best_swap
                # Perform swap
                pack_contents[max_pack].remove(u)
                pack_contents[max_pack].append(v)
                pack_contents[min_pack].remove(v)
                pack_contents[min_pack].append(u)

                pack_weights[max_pack] -= delta
                pack_weights[min_pack] += delta
                pack_index[i, u] = min_pack
                pack_index[i, v] = max_pack
            else:
                break
=======
        # Refinement: Local Search (Swap)
        # Try to swap items between heaviest pack and any other pack to reduce variance
        for _ in range(20):
            max_pack = max(range(num_packs), key=pack_weights.__getitem__)
            max_w = pack_weights[max_pack]

            best_swap = None
            best_gain = 0.0

            u_indices = pack_contents[max_pack]
            w_u = weight_cpu[i, u_indices]

            for p in range(num_packs):
                if p == max_pack:
                    continue

                diff = max_w - pack_weights[p]
                if diff < 1e-6:
                    continue

                v_indices = pack_contents[p]
                w_v = weight_cpu[i, v_indices]

                # Matrix of potential deltas: shape [len(u), len(v)]
                # delta = w_u - w_v. We want 0 < delta < diff to reduce max_pack and increase p without overshooting
                deltas = w_u.unsqueeze(1) - w_v.unsqueeze(0)

                # gain = delta * (diff - delta) is maximized when delta is close to diff/2
                # This corresponds to minimizing the sum of squares of the two packs
                mask = (deltas > 1e-6) & (deltas < diff)

                if not mask.any():
                    continue

                gains = deltas * (diff - deltas)
                gains = torch.where(mask, gains, torch.tensor(-1.0, device=gains.device))

                max_gain, max_idx = gains.flatten().max(0)

                if max_gain > best_gain:
                    best_gain = max_gain.item()
                    flat_idx = max_idx.item()
                    idx_u = flat_idx // len(v_indices)
                    idx_v = flat_idx % len(v_indices)
                    best_swap = (max_pack, p, u_indices[idx_u], v_indices[idx_v], deltas.flatten()[flat_idx].item())

            if best_swap:
                p_src, p_dst, u, v, delta = best_swap

                pack_contents[p_src].remove(u)
                pack_contents[p_src].append(v)
                pack_contents[p_dst].remove(v)
                pack_contents[p_dst].append(u)

                pack_weights[p_src] -= delta
                pack_weights[p_dst] += delta
                pack_index[i, u] = p_dst
                pack_index[i, v] = p_src
            else:
                break
>>>>>>> REPLACE
</DIFF>