<NAME>
aggressive_refinement
</NAME>

<DESCRIPTION>
Enhance the refinement phase in `balanced_packing` to use an aggressive iterative improvement strategy. Instead of a single pass or limited swapping, the algorithm now sorts packs and attempts to offload weight from the heaviest packs to any lighter packs. Critically, it restarts the sorting and search process immediately after any successful swap, ensuring that the algorithm always targets the current largest bottlenecks (Greedy Hill Climbing). The iteration limit is increased to 100 to allow for deeper convergence.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 2. Refinement: Pairwise swapping between all pack pairs
        for _ in range(20):
            found_improvement = False
            # Sort packs by weight descending
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)

            for i1 in range(num_packs):
                p1 = sorted_packs[i1]
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    diff = pack_weights[p1] - pack_weights[p2]
                    if diff < 1e-6: break

                    target = diff / 2.0
                    best_swap = None
                    best_gap = diff

                    # Try to swap item u from heavier pack p1 with item v from lighter pack p2
                    for idx_u, u in enumerate(current_packs[p1]):
                        w_u = row_weight[u]
                        for idx_v, v in enumerate(current_packs[p2]):
                            w_v = row_weight[v]
                            delta = w_u - w_v
                            if 0 < delta < diff:
                                gap = abs(delta - target)
                                if gap < best_gap:
                                    best_gap = gap
                                    best_swap = (idx_u, idx_v, delta)
                                    if gap < 1e-5: break
                        if best_swap and best_gap < 1e-5: break

                    if best_swap:
                        idx_u, idx_v, delta = best_swap
                        u = current_packs[p1][idx_u]
                        v = current_packs[p2][idx_v]
                        current_packs[p1][idx_u] = v
                        current_packs[p2][idx_v] = u
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break
                if found_improvement: break
            if not found_improvement:
                break
=======
        # 2. Refinement: Iterative Pairwise Swapping
        # We iterate to constantly reduce the load of the heaviest packs.
        # We restart the search after every swap to ensure we are always
        # addressing the largest imbalances (Greedy Hill Climbing).
        for _ in range(100):
            found_improvement = False
            # Sort packs by weight descending
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)

            # Try to offload from heaviest packs to lighter packs
            for i1 in range(num_packs):
                p1 = sorted_packs[i1]

                # Compare p1 against all lighter packs, starting from the lightest
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    diff = pack_weights[p1] - pack_weights[p2]
                    if diff < 1e-6:
                        # If difference is negligible, no swap can help (and subsequent packs are closer)
                        break

                    target = diff / 2.0
                    best_swap = None
                    best_gap = diff

                    # Find best swap (u in p1, v in p2) to close the gap
                    # We want w_u - w_v approx target
                    for idx_u, u in enumerate(current_packs[p1]):
                        w_u = row_weight[u]
                        for idx_v, v in enumerate(current_packs[p2]):
                            w_v = row_weight[v]
                            delta = w_u - w_v

                            # Only consider swaps that strictly reduce the gap
                            # (w_u > w_v) and don't overshoot excessively (delta < diff)
                            if 0 < delta < diff:
                                gap = abs(delta - target)
                                if gap < best_gap:
                                    best_gap = gap
                                    best_swap = (idx_u, idx_v, delta)
                                    if gap < 1e-6: break # Perfect swap
                        if best_swap and best_gap < 1e-6: break

                    if best_swap:
                        idx_u, idx_v, delta = best_swap
                        u = current_packs[p1][idx_u]
                        v = current_packs[p2][idx_v]

                        current_packs[p1][idx_u] = v
                        current_packs[p2][idx_v] = u
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break

                if found_improvement:
                    break # Restart outer loop (resort packs)

            if not found_improvement:
                break
>>>>>>> REPLACE

</DIFF>