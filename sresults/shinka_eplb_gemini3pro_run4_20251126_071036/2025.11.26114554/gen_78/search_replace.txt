<NAME>
pooled_repartition_refinement
</NAME>

<DESCRIPTION>
I replace the pairwise swap refinement in `balanced_packing` with a "Pooled Repartitioning" strategy.

The previous algorithm used pairwise swaps between the heaviest and lightest packs. This often gets stuck in local optima where no single pair of items can be swapped to improve balance, even though a multi-item rearrangement could.

The new approach iteratively identifies the heaviest and lightest packs, pools their items together, and then attempts to re-distribute them into two new packs using a greedy heuristic. We try both a deterministic LPT (Longest Processing Time) re-partitioning and several randomized greedy re-partitionings (shuffled order). If any of these re-partitionings yields a smaller difference between the two packs than the current configuration, we update the packs. This effectively allows for complex multi-item swaps (e.g., exchanging 1 large item for 2 small ones) while respecting the cardinality constraint, leading to significantly better balance with low computational overhead.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 2. Refinement: Pairwise swapping
        # Try to swap items between the heaviest and lightest packs to balance load.
        for _ in range(20):
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)
            found_improvement = False

            for i1 in range(num_packs):
                p1 = sorted_packs[i1]
                # Compare against lighter packs
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    diff = pack_weights[p1] - pack_weights[p2]
                    if diff < 1e-6:
                        break # Since packs are sorted, subsequent diffs will be smaller

                    target = diff / 2.0
                    best_swap = None
                    best_gap = diff

                    # Find best swap: u from p1, v from p2 such that w_u - w_v approx target
                    for idx_u, (u, w_u) in enumerate(current_packs[p1]):
                        for idx_v, (v, w_v) in enumerate(current_packs[p2]):
                            delta = w_u - w_v
                            # We need w_u > w_v to reduce diff
                            if 0 < delta < diff:
                                gap = abs(delta - target)
                                if gap < best_gap:
                                    best_gap = gap
                                    # Store swap details: indices and the actual values to swap
                                    best_swap = (idx_u, idx_v, delta, v, w_v, u, w_u)
                                    if gap < 1e-5: break
                        if best_swap and best_gap < 1e-5: break

                    if best_swap:
                        idx_u, idx_v, delta, val_v, weight_v, val_u, weight_u = best_swap

                        # Apply swap
                        current_packs[p1][idx_u] = (val_v, weight_v)
                        current_packs[p2][idx_v] = (val_u, weight_u)
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break # Break inner loop to re-sort packs

                if found_improvement: break

            if not found_improvement:
                break
=======
        # 2. Refinement: Pooled Repartitioning
        # Identify heaviest and lightest packs, pool their items, and re-distribute.
        # This helps escape local optima that simple pairwise swaps cannot.
        for _ in range(50):
            max_p = max(range(num_packs), key=pack_weights.__getitem__)
            min_p = min(range(num_packs), key=pack_weights.__getitem__)

            max_w = pack_weights[max_p]
            min_w = pack_weights[min_p]
            diff = max_w - min_w

            if diff < 1e-6:
                break

            # Pool items from the two packs
            items = current_packs[max_p] + current_packs[min_p]

            # Strategies: LPT (Sorted) and Randomized Greedy (Shuffled)
            candidates = []

            # 1. Standard LPT: Sort descending by weight
            candidates.append(sorted(items, key=lambda x: x[1], reverse=True))

            # 2. Shuffled Greedy: Random order (3 attempts)
            for _ in range(3):
                cand = list(items)
                random.shuffle(cand)
                candidates.append(cand)

            best_diff_local = diff
            improved = False
            best_sol = None # (p1_new, w1_new, p2_new, w2_new)

            for cand_items in candidates:
                p1_new = []
                p2_new = []
                w1_new = 0.0
                w2_new = 0.0

                # Greedy fill
                for item in cand_items:
                    w = item[1]
                    # Assign to lighter bin if capacity allows
                    cap1 = len(p1_new) < groups_per_pack
                    cap2 = len(p2_new) < groups_per_pack

                    if cap1 and cap2:
                        if w1_new <= w2_new:
                            p1_new.append(item)
                            w1_new += w
                        else:
                            p2_new.append(item)
                            w2_new += w
                    elif cap1:
                        p1_new.append(item)
                        w1_new += w
                    elif cap2:
                        p2_new.append(item)
                        w2_new += w

                # Check result
                diff_local = abs(w1_new - w2_new)
                if diff_local < best_diff_local:
                    best_diff_local = diff_local
                    best_sol = (p1_new, w1_new, p2_new, w2_new)
                    improved = True
                    if diff_local < 1e-6: break

            if improved:
                current_packs[max_p], current_packs[min_p] = best_sol[0], best_sol[2]
                pack_weights[max_p], pack_weights[min_p] = best_sol[1], best_sol[3]
            else:
                # If we cannot improve the worst pair, we stop this layer's refinement
                break
>>>>>>> REPLACE
</DIFF>