# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Hierarchical Expert Load Balancer with Greedy Packing**
- **Implementation**: The algorithm employs a hierarchical strategy that packs expert groups onto nodes and physical experts onto GPUs using a greedy sort-and-fill heuristic. It dynamically replicates high-load experts to distribute processing while maintaining node locality to optimize for network topology.
- **Performance**: It achieves maximum efficiency in execution speed (1.0) but yields a low balancedness score (0.31), leading to a combined score of 0.66.
- **Feedback**: While the execution is rapid and structurally correct regarding node constraints, the greedy packing logic produces suboptimal load distributions; employing more advanced partitioning or iterative refinement could significantly improve load balance.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Hierarchical Expert Load Balancer with Greedy-Swap Packing**
- **Implementation**: Implements a hierarchical load balancing strategy using a greedy LPT initialization followed by a pairwise swap local search to optimize fixed-cardinality bin packing on CPU.
- **Performance**: The solution is extremely fast (speed score 1.0) but achieves suboptimal load distribution (balancedness score 0.31), yielding a combined score of 0.66.
- **Feedback**: While the CPU-based greedy approach minimizes runtime overhead, the simple swap heuristic limits the algorithm's ability to escape local optima, suggesting a need for a more robust partitioning solver to improve balance.
**Program Identifier:** Generation 1 - Patch Name refine_packing - Correct Program: True

**Program Name: Vectorized Sort-and-Zigzag Hierarchical Load Balancer**
- **Implementation**: The solution implements a hierarchical load balancer using a vectorized Sort-and-Zigzag packing algorithm for node and GPU assignment, coupled with proportional replication logic via tensor scatter-gather operations.
- **Performance**: The program received a score of 0.0, indicating it failed to pass functional validation tests.
- **Feedback**: The `zigzag_pack` function enforces strict divisibility constraints (asserting items modulo bins equals zero) which causes failures on non-uniform inputs, and the complex vectorized index reconstruction likely produces incorrect physical-to-logical mappings.
**Program Identifier:** Generation 2 - Patch Name vectorized_zigzag_eplb - Correct Program: False

**Program Name: Hierarchical EPLB with Greedy Packing and CPU Optimization**
- **Implementation**: The algorithm employs a greedy strategy with swap-based refinement for bin packing, moving tensors to the CPU during iterative steps to eliminate GPU synchronization overhead.
- **Performance**: It achieves excellent speed (1.0) but moderate load balancing effectiveness (0.31), resulting in a combined score of 0.66.
- **Feedback**: Moving scalar operations to the CPU successfully maximizes speed, but the current packing heuristic struggles to achieve high balancedness compared to more complex optimization approaches.
**Program Identifier:** Generation 3 - Patch Name optimize_balanced_packing_with_swap - Correct Program: True

**Program Name: Hierarchical EPLB with LPT and Local Search**
- **Implementation**: The solution implements a hierarchical balancing strategy using a greedy Longest Processing Time (LPT) algorithm followed by a local search that iteratively swaps items between the heaviest pack and others to minimize variance.
- **Performance**: It achieved a combined score of 0.66, excelling in speed (1.0) but lagging in balancedness (0.31).
- **Feedback**: The perfect speed score confirms the efficiency of the greedy approach, but the low balancedness indicates that the limited local swap logic is insufficient for optimizing highly skewed expert distributions effectively compared to more complex solvers.
**Program Identifier:** Generation 4 - Patch Name vectorized_local_search - Correct Program: True

**Program Name: Hierarchical Expert Load Balancer with Greedy Swap Refinement**
- **Implementation**: This approach utilizes a hierarchical strategy to distribute expert groups across nodes and GPUs, employing a greedy bin-packing algorithm optimized with CPU-based list operations and pairwise swap refinement.
- **Performance**: The solution maximizes execution speed (score 1.0) but achieves only moderate load balancing (score 0.31), resulting in a combined score of 0.66.
- **Feedback**: The implementation's conversion of tensors to CPU lists ensures rapid execution, though the greedy packing with limited local search (20 iterations) limits the algorithm's ability to find globally optimal load distributions.
**Program Identifier:** Generation 5 - Patch Name improved_balanced_packing_refinement - Correct Program: True

**Program Name: Vectorized Greedy Packing with Local Search for Expert Balancing**
- **Implementation**: The algorithm uses a greedy Modified Longest Processing Time (LPT) approach for initial assignment, followed by a vectorized local search that swaps items between the heaviest pack and others using tensor operations to minimize maximum load.
- **Performance**: It achieved a combined score of 0.66, with perfect speed (1.0) but poor balancedness (0.31).
- **Feedback**: While the vectorized swap logic and CPU-based scalar access ensure high throughput, the low balancedness score indicates the heuristic struggles to escape local optima, suggesting the need for more iterations or a more robust global optimization strategy.
**Program Identifier:** Generation 6 - Patch Name improved_balanced_packing_local_search - Correct Program: True

**Program Name: Hierarchical EPLB with CPU Greedy Init and Vectorized Refinement**
- **Implementation**: Implements a hierarchical load balancer using a CPU-based Longest Processing Time (LPT) greedy initialization followed by a vectorized local search that iteratively swaps experts to reduce maximum load.
- **Performance**: Achieved a perfect speed score (1.0) but a moderate balancedness score of 0.31, prioritizing runtime efficiency.
- **Feedback**: The hybrid approach of performing sequential sorting/packing on the CPU and vectorized refinement on the GPU effectively minimizes overhead, though the balancedness score indicates potential room for more aggressive optimization logic.
**Program Identifier:** Generation 7 - Patch Name vectorized_eplb_v2 - Correct Program: True

**Program Name: DeepSeek EPLB Hierarchical Load Balancer with CPU-Offloaded Greedy Packing**
- **Implementation**: The algorithm utilizes a hierarchical approach that first greedily packs expert groups onto nodes and then refinedly packs physical experts onto GPUs, offloading sequential sorting and swapping logic to the CPU to minimize overhead.
- **Performance**: The program achieved a perfect speed score of 1.00 but a lower balancedness score of 0.31, resulting in a combined score of 0.66.
- **Feedback**: The decision to perform iterative packing operations on the CPU proved highly effective for runtime speed, though the greedy heuristic with pairwise swapping yielded only moderate load balancing quality.
**Program Identifier:** Generation 8 - Patch Name optimize_balanced_packing_logic - Correct Program: True

**Program Name: Hierarchical EPLB with CPU-Based Greedy LPT and Refinement**
- **Implementation**: The solution implements a hierarchical load balancer using a `balanced_packing` algorithm that runs on the CPU, combining a greedy Longest Processing Time (LPT) initialization with a swap-based local search refinement phase.
- **Performance**: The program achieved a perfect speed score of 1.00 but a lower balancedness score of 0.31, leading to a combined score of 0.66.
- **Feedback**: The decision to offload sequential packing logic to the CPU and limit refinement iterations maximized execution speed, but the trade-off was a less optimal load distribution compared to more computationally intensive approaches.
**Program Identifier:** Generation 9 - Patch Name eplb_greedy_refine_opt - Correct Program: True

**Program Name: CPU-Optimized Hierarchical Expert Load Balancer**
- **Implementation**: The solution employs a Longest Processing Time (LPT) greedy packing algorithm with pairwise swap refinement, executing sequential operations on the CPU to eliminate GPU kernel launch overheads.
- **Performance**: The program achieved a perfect speed score of 1.0 and a balancedness score of 0.31.
- **Feedback**: Moving sequential, iterative packing logic to the CPU was a key optimization that maximized execution speed, although the resulting load balance suggests potential for more sophisticated swapping heuristics.
**Program Identifier:** Generation 10 - Patch Name eplb_opt_greedy_inc - Correct Program: True

**Program Name: Randomized Greedy CPU-Based Expert Load Balancer**
- **Implementation**: The algorithm moves weights to CPU to avoid synchronization overhead and uses a multi-restart randomized greedy strategy supplemented by a local search refinement phase that attempts to swap experts between the heaviest and lightest packs.
- **Performance**: It achieves a perfect speed score (1.0) but a modest balancedness score (0.31), resulting in a combined score of 0.66.
- **Feedback**: While the implementation is computationally efficient due to CPU offloading and simple heuristics, the randomized greedy approach with limited local swaps produces suboptimal load distributions compared to more robust packing algorithms.
**Program Identifier:** Generation 11 - Patch Name randomized_greedy_restarts - Correct Program: True

**Program Name: Hybrid Greedy Packing with Vectorized Local Search**
- **Implementation**: The algorithm employs CPU-based deterministic and perturbed greedy strategies for initial packing, followed by a vectorized local search refinement that optimizes swaps between the heaviest pack and others. It supports hierarchical load balancing by recursively packing groups to nodes and then experts to GPUs using this packing primitive.
- **Performance**: The solution achieved a combined score of 0.66, maximizing speed (1.0) while attaining a balancedness score of 0.31 across evaluated workloads.
- **Feedback**: The use of vectorized operations and CPU offloading ensures minimal overhead resulting in perfect speed, though the balancedness score suggests that the local search depth or heuristic complexity could be increased to further improve packing quality.
**Program Identifier:** Generation 12 - Patch Name multi_start_balanced_packing - Correct Program: True

**Program Name: Greedy EPLB with Iterative Pairwise Swapping Refinement**
- **Implementation**: The algorithm utilizes a greedy initial packing of sorted weights followed by an iterative refinement stage that performs pairwise swaps between packs to reduce load disparities, operating purely on CPU lists for efficiency.
- **Performance**: The solution yields a combined score of 0.66, delivering perfect speed (1.0) but only moderate load balancing (0.31).
- **Feedback**: While moving operations to the CPU ensures high execution speed, the greedy strategy combined with simple local swapping struggles to find global optima, resulting in suboptimal balancedness scores.
**Program Identifier:** Generation 13 - Patch Name aggressive_refinement - Correct Program: True

**Program Name: Randomized LPT with Vectorized Local Search for EPLB**
- **Implementation**: Utilizes a randomized greedy Longest Processing Time (LPT) heuristic with multiple restarts, refined by a vectorized local search that swaps experts between the most heavily loaded pack and others to minimize maximum load.
- **Performance**: Achieved a combined score of 0.66, excelling in execution speed (1.0) while maintaining moderate balancedness (0.31).
- **Feedback**: The vectorized swap implementation ensures high throughput, but the lower balancedness score suggests that more aggressive optimization or higher restart counts could improve the final packing quality.
**Program Identifier:** Generation 14 - Patch Name randomized_restarts_packing - Correct Program: True

**Program Name: Hierarchical EPLB with Greedy LPT and Pairwise Swap Refinement**
- **Implementation**: The algorithm employs a CPU-based greedy Longest Processing Time (LPT) strategy refined by iterative pairwise swapping for packing, alongside a vectorized greedy method for expert replication.
- **Performance**: Achieved a perfect speed score of 1.0 and a balancedness score of 0.31, resulting in a combined score of 0.66.
- **Feedback**: Offloading the sequential packing logic to CPU lists proved highly effective for speed by eliminating GPU synchronization overheads. However, the local search heuristic trades optimal load balancing for execution speed, limiting the final balancedness score compared to global optimization solvers.
**Program Identifier:** Generation 15 - Patch Name greedy_allpairs_descent_load_balancer - Correct Program: True

**Program Name: Randomized LPT with Local Search for Expert Load Balancing**
- **Implementation**: The `balanced_packing` function employs a randomized Greedy LPT heuristic with 50 restarts and weight perturbation, refined by a swap-based local search on the CPU to minimize maximum load.
- **Performance**: Achieves a combined score of 0.66, maximizing speed (1.0) while attaining a balancedness score of 0.31.
- **Feedback**: Offloading the iterative heuristic to the CPU effectively prevents GPU synchronization overhead, ensuring high throughput. However, the moderate balancedness score indicates that the local search, limited to single swaps among the heaviest packs, may require more complex moves (e.g., multi-item swaps) to handle highly skewed distributions better.
**Program Identifier:** Generation 16 - Patch Name improved_balanced_packing_restarts_and_refinement - Correct Program: True

**Program Name:** CPU-Based Randomized Greedy EPLB with Local Search
- **Implementation**: The solution utilizes a CPU-based randomized greedy strategy that sorts experts by weight (LPT) with noise perturbation across multiple restarts, followed by an iterative local search that refines the assignment by swapping items from the heaviest pack.
- **Performance**: The program achieves a perfect speed score (1.0) but a low balancedness score (0.31), resulting in a combined score of 0.66.
- **Feedback**: While offloading sequential logic to the CPU maximizes execution speed, the randomized greedy heuristic with simple local swaps produces suboptimal packing quality compared to more robust optimization techniques.
**Program Identifier:** Generation 17 - Patch Name randomized_greedy_with_restarts - Correct Program: True

**Program Name: Randomized Greedy LPT Packing with Local Search Refinement**
- **Implementation**: The algorithm utilizes a multi-restart randomized greedy LPT strategy on the CPU, followed by a steepest descent local search that iteratively swaps items from the heaviest pack to lighter ones to minimize load difference.
- **Performance**: It achieved a combined score of 0.66, characterized by maximum execution speed (1.0) but a modest balancedness score (0.31).
- **Feedback**: While the implementation is highly efficient due to CPU offloading and vectorized operations, the low balancedness score suggests that the randomized greedy approach with limited local swaps struggles to escape local optima for complex weight distributions.
**Program Identifier:** Generation 18 - Patch Name iterative_descent_packing - Correct Program: True

**Program Name: CPU-Optimized Randomized LPT with Local Search Refinement**
- **Implementation**: The algorithm offloads computation to the CPU, utilizing a randomized Longest Processing Time (LPT) greedy strategy with multiple restarts, followed by a pairwise swap local search to refine bin weights.
- **Performance**: It achieved a perfect speed score of 1.00 but a lower balancedness score of 0.31, resulting in a combined score of 0.66.
- **Feedback**: The implementation is exceptionally fast due to CPU processing and limited iterations, but the greedy heuristic with local search struggles to find optimal packings for complex distributions compared to more exhaustive methods.
**Program Identifier:** Generation 19 - Patch Name randomized_greedy_packing_eplb - Correct Program: True

**Program Name: Hybrid EPLB with ZigZag Packing and Greedy Local Search**
- **Implementation**: This approach combines ZigZag packing and projected Best-Fit heuristics to generate initial candidates, followed by an iterative refinement phase that swaps tasks between maximum and minimum load processors to reduce variance.
- **Performance**: The solution maximizes speed (1.0) with a total score of 0.66, though the balancedness score (0.31) indicates moderate packing efficiency.
- **Feedback**: The implementation is highly efficient computationally, but the greedy swap mechanism limits the exploration of the solution space, preventing higher balancedness scores on complex workload distributions.
**Program Identifier:** Generation 20 - Patch Name projected_zigzag_packing - Correct Program: True

**Program Name: Randomized Greedy with Large Neighborhood Search for Expert Balancing**
- **Implementation**: The solution implements a randomized greedy packing strategy (LPT with noise) followed by a Large Neighborhood Search (LNS) refinement on the CPU to iteratively repack the heaviest, lightest, and random bins.
- **Performance**: It achieves a perfect speed score (1.0) and a balancedness score of 0.31, resulting in a combined score of 0.66.
- **Feedback**: Offloading the sequential iterative logic to the CPU successfully eliminates GPU kernel overheads, while the LNS mechanism effectively targets specific areas of imbalance to improve solution quality efficiently.
**Program Identifier:** Generation 21 - Patch Name lns_refinement_balanced_packing - Correct Program: True

**Program Name: Randomized Greedy LPT with Vectorized Swap and Pairwise Refinement**
- **Implementation**: Utilizes a multi-start randomized greedy strategy followed by vectorized 2-opt swaps and a pairwise "ruin and recreate" refinement that re-partitions the heaviest and lightest packs to minimize load variance.
- **Performance**: Achieved a combined score of 0.66, maximizing speed (1.0) while attaining a balancedness score of 0.31.
- **Feedback**: The vectorization of swap gain calculations significantly boosts speed, yet the randomized heuristic struggles to achieve high balancedness compared to more computationally intensive exact methods.
**Program Identifier:** Generation 22 - Patch Name pairwise_rebalancing_and_restarts - Correct Program: True

**Program Name: Hierarchical EPLB with Greedy Packing and Pairwise Swapping**
- **Implementation**: Implements a hierarchical load balancer using a CPU-optimized greedy assignment strategy followed by an iterative pairwise swapping heuristic to refine expert distribution across nodes and GPUs.
- **Performance**: Achieved a combined score of 0.66, excelling in speed (1.0) but receiving a lower balancedness score (0.31).
- **Feedback**: The implementation prioritizes execution speed effectively via CPU offloading and greedy heuristics, but the local search refinement is currently insufficient to achieve high load balancedness for the evaluated workloads.
**Program Identifier:** Generation 23 - Patch Name randomized_restarts_and_optimized_replication - Correct Program: True

**Program Name: Hybrid CPU-Greedy with Vectorized GPU LNS Refinement**
- **Implementation**: The solution combines a fast CPU-based randomized greedy initialization with a GPU-accelerated refinement phase using vectorized pairwise swaps and 3-pack Large Neighborhood Search (LNS).
- **Performance**: Achieved a perfect speed score (1.0) but a low balancedness score (0.31), resulting in a combined score of 0.66.
- **Feedback**: While computationally efficient, the low balancedness score indicates that the local search heuristics (swaps and LNS) are insufficient to escape local optima found by the greedy initialization; deeper search or more aggressive perturbation is required.
**Program Identifier:** Generation 24 - Patch Name iterative_refinement_lns_retry - Correct Program: True

**Program Name: Hybrid Greedy LPT with Vectorized Swap and LNS Refinement**
- **Implementation**: The solution utilizes multiple perturbed LPT candidates for initialization and refines the packing using vectorized 1-swaps and a 3-pack Large Neighborhood Search (LNS).
- **Performance**: It achieved a perfect speed score of 1.00 and a balancedness score of 0.31.
- **Feedback**: The use of vectorized operations and CPU-based list handling ensures maximum speed, but the lower balancedness score indicates that the local search depth or heuristic complexity may need tuning for better load distribution.
**Program Identifier:** Generation 25 - Patch Name iterative_refinement_lns - Correct Program: True

**Program Name: Cyclic LNS Load Balancer with Vectorized Swaps**
- **Implementation**: Implements a multi-stage heuristic combining randomized greedy initialization with restarts, vectorized pairwise swaps to reduce peak loads, and a 3-way Large Neighborhood Search (Ruin & Recreate) for local refinement.
- **Performance**: Achieved a combined score of 0.66, delivering perfect speed (1.0) but achieving only moderate load balancedness (0.31).
- **Feedback**: The algorithm effectively leverages vectorization to maintain high throughput, though the heuristic approach sacrifices some packing quality for execution speed compared to more exhaustive solvers.
**Program Identifier:** Generation 26 - Patch Name cyclic_lns_balancer - Correct Program: True

**Program Name: Hybrid Greedy LPT with LNS and Pairwise Swaps Load Balancer**
- **Implementation**: The algorithm employs a multi-stage heuristic on CPU, combining randomized greedy LPT initialization with 3-pack Large Neighborhood Search (LNS) and pairwise item swaps to refine load distribution, alongside heap-based expert replication.
- **Performance**: It achieves a combined score of 0.66, characterized by excellent speed (1.0) but limited balancedness (0.31).
- **Feedback**: The implementation prioritizes execution speed effectively, but the relatively low balancedness suggests the local search heuristics (LNS and swaps) struggle to escape local optima or manage complex weight distributions effectively.
**Program Identifier:** Generation 27 - Patch Name iterative_lns_packing - Correct Program: True

**Program Name: Cyclic Large Neighborhood Search Load Balancer**
- **Implementation**: The algorithm employs a multi-stage heuristic starting with randomized greedy initialization, followed by vectorized pairwise swapping, 3-way cyclic exchanges, and a "ruin and recreate" Large Neighborhood Search (LNS) on 3-pack subsets.
- **Performance**: The solution achieved a combined score of 0.66, characterized by perfect execution speed (1.0) but a lower balancedness score (~0.31).
- **Feedback**: The use of vectorized operations and CPU-based scalar logic ensured the algorithm remained extremely fast, but the moderate balancedness score suggests the heuristics may settle into local optima too quickly on difficult distributions.
**Program Identifier:** Generation 28 - Patch Name three_way_cycle_lns_enhanced - Correct Program: True

**Program Name: Cardinality-Constrained EPLB with LNS and Binary Search**
- **Implementation**: The algorithm uses a CPU-based solver combining Greedy LPT initialization with an optimized pairwise swap refinement using binary search and a Large Neighborhood Search (Ruin & Recreate) meta-heuristic.
- **Performance**: The program achieves a perfect speed score (1.0) but a moderate balancedness score (0.31), resulting in a combined score of 0.66.
- **Feedback**: While the binary search optimization ensures high throughput, the moderate balancedness suggests the LNS heuristic struggles to fully optimize distributions under strict cardinality constraints.
**Program Identifier:** Generation 29 - Patch Name eplb_lns_bisect - Correct Program: True

**Program Name: Multi-Strategy Greedy Packing with Cyclic Swap Refinement**
- **Implementation**: The solution utilizes three CPU-based heuristics (ZigZag, Projected Best-Fit, and Randomized LPT) to generate initial candidates, followed by an iterative refinement phase employing pairwise and 3-way cyclic swaps to minimize maximum load.
- **Performance**: Achieved a combined score of 0.66, excelling in execution speed (1.0) with a balancedness score of 0.31.
- **Feedback**: Offloading scalar logic to the CPU avoids GPU launch overheads, while the combination of diverse initialization strategies and targeted local search (swaps) ensures extremely low latency without sacrificing too much solution quality.
**Program Identifier:** Generation 30 - Patch Name refined_3way_swap_and_restarts - Correct Program: True

**Program Name: Target-Aware Packing with LNS**
- **Implementation**: The solution implements a "Target-Aware Best-Fit Decreasing" algorithm on CPU using Python lists, followed by a Large Neighborhood Search (Ruin and
**Program Identifier:** Generation 31 - Patch Name lns_repacking_heuristic - Correct Program: False

**Program Name: Hybrid Beam Search and Vectorized Local Search Load Balancer**
- **Implementation**: The solution employs an LPT-based Beam Search (width 8) for initial packing, followed by a vectorized local search that iteratively attempts to swap items from the heaviest pack to reduce maximum load.
- **Performance**: Achieved a combined score of 0.66, with perfect speed (1.0) but moderate balancedness (0.31).
- **Feedback**: While the vectorized refinement ensures high throughput, the restricted swap logic (only targeting the max-load bin) and narrow beam width limit the algorithm's ability to achieve optimal load distribution.
**Program Identifier:** Generation 32 - Patch Name beam_search_init - Correct Program: True

**Program Name: Randomized Greedy and LNS Expert Load Balancer**
- **Implementation**: The `balanced_packing` function utilizes a randomized greedy strategy with restarts for initial assignment, followed by Large Neighborhood Search (LNS) on the CPU to iteratively refine the heaviest and lightest packs.
- **Performance**: Achieved a combined score of 0.66, distinguishing itself with a perfect speed score (1.00) but a relatively low balancedness score (0.31).
- **Feedback**: While the heuristic approach is highly efficient computationally, the low balancedness indicates suboptimal load distribution; stronger global optimization techniques or more aggressive refinement steps are needed to improve packing quality.
**Program Identifier:** Generation 33 - Patch Name lns_repack - Correct Program: True

**Program Name: Randomized Greedy Packing with Local Search Refinement**
- **Implementation**: The solution employs a multi-restart greedy strategy that adds noise to weight sorting for diversity, followed by a heuristic swap refinement phase that attempts to offload tasks from the heaviest to lightest packs to minimize load spread.
- **Performance**: The program excels in execution speed (1.0) but achieves only moderate load balancing effectiveness (0.31), leading to a combined score of 0.66.
- **Feedback**: The implementation prioritizes computational efficiency through simple heuristics and CPU processing, which successfully minimizes overhead but leaves room for improvement in handling complex, skewed load distributions compared to more intensive optimization solvers.
**Program Identifier:** Generation 34 - Patch Name randomized_greedy_packing - Correct Program: True

**Program Name: Hierarchical Expert Parallelism Load Balancer with Local Search**
- **Implementation**: Uses a custom `balanced_packing` algorithm combining greedy initialization, vectorized local search for swapping items, and randomized pairwise re-packing to optimize load distribution across expert groups and nodes.
- **Performance**: Achieved a combined score of 0.0, failing to pass validation tests.
- **Feedback**: The complex multi-stage packing implementation likely introduced logic errors or state inconsistencies, causing the solver to produce invalid assignments despite the sophisticated optimization attempts.
**Program Identifier:** Generation 35 - Patch Name add_lns_refinement - Correct Program: False

**Program Name: CPU-Offloaded Greedy Packing with Randomized Swap Refinement**
- **Implementation**: The solution moves sequential packing logic to the CPU, employing a descending-sort greedy assignment followed by randomized swap-based local search to balance expert loads.
- **Performance**: It achieves a perfect speed score (1.0) due to efficient CPU execution, but a lower balancedness score (0.31), resulting in a 0.66 combined score.
- **Feedback**: The implementation excels in speed by avoiding GPU overheads for sequential logic, though the heuristic packing approach struggles to achieve high load uniformity compared to more complex solvers.
**Program Identifier:** Generation 36 - Patch Name opt_packing_and_repl - Correct Program: True

**Program Name: Randomized Greedy Packing with Vectorized Swap and K-Way LNS**
- **Implementation**: Features a randomized LPT initialization followed by a refinement loop using vectorized pairwise swaps on the heaviest pack and a K-way Ruin-and-Recreate strategy.
- **Performance**: Achieves maximum speed (1.0) with a combined score of 0.66, though balancedness (0.31) remains limited.
- **Feedback**: The implementation prioritizes computational efficiency through vectorization and restricted iteration counts, but this trade-off limits the solver's ability to escape local optima and achieve tighter load balancing.
**Program Identifier:** Generation 38 - Patch Name eplb_hybrid_lns_vectorized - Correct Program: True

**Program Name: Greedy LPT with Cyclic Swaps and Large Neighborhood Search**
- **Implementation**: Features a CPU-based solver utilizing Greedy LPT initialization, refined by efficient pairwise and 3-way cyclic swaps with binary search, and a stochastic Large Neighborhood Search (Ruin & Recreate) mechanism.
- **Performance**: Achieves a combined score of 0.66, driven by a perfect speed score (1.0) and a balancedness score of 0.31.
- **Feedback**: The approach effectively balances implementation complexity and execution time, but the resulting load balance leaves room for improvement, suggesting the need for more exhaustive search strategies given the available time budget.
**Program Identifier:** Generation 39 - Patch Name three_way_swap - Correct Program: True

**Program Name: Iterated Local Search with Greedy Initialization for Load Balancing**
- **Implementation**: The solution employs a Greedy Longest Processing Time (LPT) initialization followed by an Iterated Local Search (ILS) on the CPU that perturbs solutions via random swaps and explicitly targets reducing the load gap between the heaviest and lightest packs.
- **Performance**: It achieves a perfect speed score (1.00) but a modest balancedness score (0.31), yielding a combined score of 0.66.
- **Feedback**: While the approach is extremely fast due to the efficient greedy heuristic and limited search iterations, the local search strategy struggles to escape local optima effectively, resulting in suboptimal load distribution compared to more exhaustive methods.
**Program Identifier:** Generation 40 - Patch Name ils_balanced_packing - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

# Analysis of Program Evaluation Results

## Successful Algorithmic Patterns
- **CPU-Native Scalar Manipulation**: The **Current Best Program** and successful variants (Gen 30, 36, 40) explicitly convert tensors to Python lists (`weight.tolist()`, `current_packs` lists) for the packing logic. This approach consistently yields a **Speed Score of 1.0**, confirming that for the problem's scale, Python's scalar operations on CPU are superior to GPU kernel launch overheads or vectorized tensor operations.
- **Greedy LPT Initialization**: The "Longest Processing Time" sort remains the critical foundation. Programs like **Gen 32**, **Gen 39**, and the **Current Best Program** sort groups descending by weight before assignment. This heuristic establishes a strong baseline packing that subsequent refinement steps struggle to significantly improve, indicating it resolves the bulk of the optimization problem immediately.
- **Bounded Deterministic Refinement**: The **Current Best Program** utilizes a fixed `range(20)` loop performing pairwise swaps between the heaviest and lightest packs. This simple, deterministic local search matches the performance of complex "3-way cyclic swaps" (**Gen 30**, **Gen 39**) and "Large Neighborhood Search" (**Gen 33**, **Gen 38**), achieving the same balancedness (0.31) with minimal code complexity.

## Ineffective Approaches
- **Complex Meta-Heuristics (LNS/Ruin-and-Recreate)**: Implementations attempting Large Neighborhood Search (LNS) or extensive repacking (**Gen 31**, **Gen 33**, **Gen 38**) failed to improve the balancedness score beyond 0.31. **Gen 31** and **Gen 35** specifically failed validation, suggesting that the complexity of maintaining state consistency during "ruin and recreate" steps increases the risk of logic errors without yielding performance gains.
- **Vectorized Refinement**: Attempts to vectorize the swap logic (**Gen 32**, **Gen 38**) to process swaps in batches maintained the speed score of 1.0 but provided no uplift in balancedness. The evaluation indicates that the overhead of setting up vectorized masks and operations offers no advantage over simple O(N) scalar loops for this specific problem size.
- **Stochastic Search**: Adding noise or randomization to the greedy initialization or swap selection (**Gen 34**, **Gen 36**) proved ineffective. The balancedness score remained frozen at 0.31 across all randomized variants, implying the optimization landscape is not multimodal in a way that stochastic restarts can exploit; the limitation appears structural.

## Implementation Insights
- **Incremental State Tracking**: The **Current Best Program** maintains a `pack_weights` list of floats that is updated in-place (`pack_weights[max_p] -= delta`) during swaps. This avoids the cost of re-calculating sums over the packs at every iteration, a technique that contributes to the high efficiency relative to implementations that might re-aggregate tensor views.
- **Constructive Constraint Enforcement**: The **Current Best Program** enforces the cardinality constraint (maximum groups per pack) strictly during the initial greedy phase via a simple check: `if len(current_packs[p]) < groups_per_pack`. This guarantees validity by construction, whereas failed approaches like **Gen 35** likely attempted to repair invalid states or used complex mapping logic that violated these bounds.
- **Targeted Pairwise Swapping**: The refinement logic in the **Current Best Program** specifically iterates only through items in the `max_p` and `min_p` packs to find a swap that reduces the specific load gap `diff`. This targeted reduction (`target = diff / 2.0`) is far more efficient than global search strategies employed in less successful generations.

## Performance Analysis
- **The 0.31 Balancedness Plateau**: A striking pattern across **Gen 30 through Gen 40** is the identical balancedness score of ~0.311077. Whether using Greedy LPT, Beam Search (**Gen 32**), or LNS (**Gen 38**), the solver hits this exact value. This strongly suggests the imbalance is dictated by a specific large, indivisible item (likely a specific expert group) that forces the maximum load, rendering further fine-grained optimization futile.
- **Speed Score Saturation**: All correct programs achieved a **Speed Score of 1.0**. This confirms that the time budget is permissive enough that even Python-based loops on CPU (as seen in the **Current Best Program**) are non-bottlenecks. Optimization efforts focused purely on speed (like vectorization in **Gen 32**) are currently yielding diminishing returns.
- **Correctness vs. Complexity Trade-off**: High-complexity approaches had a higher failure rate (e.g., **Gen 31**, **Gen 35** failed) compared to the simpler greedy-plus-swap approaches. Since complex methods yielded no score advantage, the optimal strategy is the simplest one that maintains the 0.66 score, represented by the **Current Best Program**.

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the global insights and the performance of the Current Best Program, here are 5 actionable recommendations for future program mutations:

1.  **Implement Target-Aware "Best Fit" Initialization**: The current greedy logic assigns items to the *least loaded* pack (`min(pack_weights)`), which levels the bottom but ignores the goal. Change the selection criteria to assign the current item to the valid pack where the new weight is closest to the **target average** (`abs(current_weight + item_weight - total_weight/num_packs)`). This "Best Fit" strategy preserves capacity in smaller bins for appropriate future items rather than prematurely filling them.

2.  **Introduce 3-Way Cyclic Swaps**: The balancedness plateau at 0.31 suggests pairwise swaps are stuck in local optima. Implement a scalar loop that searches for items $a \in \text{MaxPack}, b \in \text{MinPack}, c \in \text{RandomPack}$ to perform a cyclic rotation ($a \to \text{Min}, b \to \text{Random}, c \to \text{Max}$). This allows weight transfers that are impossible with zero-sum 2-way exchanges, utilizing the ample CPU time budget (Speed Score 1.0).

3.  **Optimal Two-Bin Re-partitioning**: Instead of swapping single items between the heaviest ($P_{max}$) and lightest ($P_{min}$) packs, implement a routine that **pools all items from both packs** and re-distributes them. Use a local "Best Fit Decreasing" or "Multi-Way Partitioning" heuristic to split these pooled items back into two valid packs. This effectively solves the sub-problem of minimizing the difference between $P_{max}$ and $P_{min}$ more comprehensively than iterative single swaps.

4.  **Beam Search for Heaviest Items**: Since the placement of the largest "expert groups" dictates the final imbalance, replace the greedy loop for the top ~10 heaviest items with a **Beam Search** (width 4-8). This maintains multiple partial packing states during the most critical decisions, preventing the algorithm from getting locked into a structurally imbalanced configuration that later swaps cannot fix.

5.  **Exhaustive Solver for Small-Scale Inputs**: The insights point to the "Group-to-Node" packing (where $N$ and $M$ are small) as a primary source of imbalance. Add a check: if `num_groups < 30`, bypass the greedy/swap logic and use a **recursive Branch-and-Bound** or **exhaustive DFS** solver. The computational cost is trivial for small inputs, but finding the mathematical optimum at this high level can break the 0.31 plateau that propagates to lower levels.