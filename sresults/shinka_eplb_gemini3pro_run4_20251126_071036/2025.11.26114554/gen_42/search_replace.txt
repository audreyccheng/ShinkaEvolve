<NAME>
balanced_packing_merge_repack
</NAME>

<DESCRIPTION>
Introduces a "Merge & Repack" strategy within the refinement phase of the `balanced_packing` function. This heuristic targets the two most imbalanced packs (heaviest and lightest), pools their items, and redistributes them using a constrained Longest Processing Time (LPT) greedy approach. This helps escape local optima that simple pairwise swaps cannot resolve, efficiently effectively reducing the load imbalance between the extreme packs.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def balanced_packing(weight: torch.Tensor,
                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:
    """
    Pack n weighted objects to m packs, such that each bin contains exactly
    n/m objects and the weights of all packs are as balanced as possible.

    Parameters:
        weight: [X, n], the weight of each item
        num_packs: number of packs

    Returns:
        pack_index: [X, n], the pack index of each item
        rank_in_pack: [X, n], the rank of the item in the pack
    """
    num_layers, num_groups = weight.shape
    assert num_groups % num_packs == 0
    groups_per_pack = num_groups // num_packs

    # Handle trivial case
    if groups_per_pack == 1:
        pack_index = torch.arange(num_groups,
                                  dtype=torch.int64,
                                  device=weight.device).expand(num_layers, -1)
        rank_in_pack = torch.zeros_like(pack_index)
        return pack_index, rank_in_pack

    # Optimization: perform sequential packing logic on CPU to avoid GPU overhead
    weight_cpu = weight.to("cpu", dtype=torch.float32)
    pack_index = torch.empty((num_layers, num_groups), dtype=torch.int64, device="cpu")
    rank_in_pack = torch.empty((num_layers, num_groups), dtype=torch.int64, device="cpu")

    # Configuration for restarts
    # 1 deterministic run + 2 randomized runs gave good balance/speed trade-off
    num_restarts = 3

    for i in range(num_layers):
        row_weight = weight_cpu[i]
        row_weight_list = row_weight.tolist()

        best_diff = float('inf')
        best_packs = None

        # Base indices for deterministic LPT (sorted descending)
        base_indices = torch.argsort(row_weight, descending=True).tolist()

        for attempt in range(num_restarts):
            # 1. Initialization Strategy
            if attempt == 0:
                # Deterministic LPT
                indices = base_indices
            else:
                # Randomized LPT: Add multiplicative noise to weights for sorting
                # This alters the greedy assignment order slightly
                noise = torch.rand(num_groups, device="cpu") * 0.2 + 0.9
                indices = torch.argsort(row_weight * noise, descending=True).tolist()

            # 2. Greedy Packing
            # Assign items to the lightest pack that has space
            current_packs = [[] for _ in range(num_packs)]
            pack_weights = [0.0] * num_packs

            for group_idx in indices:
                w = row_weight_list[group_idx]

                # Find best pack (min weight with capacity)
                best_p = -1
                min_val = float('inf')
                for p in range(num_packs):
                    if len(current_packs[p]) < groups_per_pack:
                        if pack_weights[p] < min_val:
                            min_val = pack_weights[p]
                            best_p = p

                current_packs[best_p].append(group_idx)
                pack_weights[best_p] += w

            # 3. Refinement Phase (Local Search)
            # Iteratively swap items between heavy and light packs
            for _ in range(20): # Iteration limit
                # Sort packs by weight to easily pick heavy/light pairs
                # We store indices to track which pack is which
                sorted_pack_indices = sorted(range(num_packs),
                                             key=pack_weights.__getitem__,
                                             reverse=True)

                found_swap = False

                # Try to move weight from heavier packs to lighter packs
                for i1 in range(num_packs):
                    p1 = sorted_pack_indices[i1]
                    for i2 in range(num_packs - 1, i1, -1):
                        p2 = sorted_pack_indices[i2]

                        diff = pack_weights[p1] - pack_weights[p2]
                        if diff < 1e-6:
                            break

                        target = diff / 2.0
                        best_swap = None
                        best_gap = diff

                        # Find swap (u, v) such that w_u - w_v is close to target
                        # w_u from pack p1, w_v from pack p2
                        for idx_u, u in enumerate(current_packs[p1]):
                            w_u = row_weight_list[u]
                            for idx_v, v in enumerate(current_packs[p2]):
                                w_v = row_weight_list[v]

                                delta = w_u - w_v
                                if 0 < delta < diff:
                                    gap = abs(delta - target)
                                    if gap < best_gap:
                                        best_gap = gap
                                        best_swap = (idx_u, idx_v, delta)
                                        if gap < 1e-5: break
                            if best_swap and best_gap < 1e-5: break

                        if best_swap:
                            idx_u, idx_v, delta = best_swap
                            u = current_packs[p1][idx_u]
                            v = current_packs[p2][idx_v]

                            current_packs[p1][idx_u] = v
                            current_packs[p2][idx_v] = u
                            pack_weights[p1] -= delta
                            pack_weights[p2] += delta
                            found_swap = True
                            break # Break inner loops to resort packs
                    if found_swap: break

                if not found_swap:
                    break

            # 4. Check if this is the best solution so far
            current_diff = max(pack_weights) - min(pack_weights)
            if current_diff < best_diff:
                best_diff = current_diff
                # Deep copy current packing
                best_packs = [list(p) for p in current_packs]
                if best_diff < 1e-6:
                    break # Optimal found

        # Fill result tensors
        for p in range(num_packs):
            for r, g in enumerate(best_packs[p]):
                pack_index[i, g] = p
                rank_in_pack[i, g] = r

    return pack_index.to(weight.device), rank_in_pack.to(weight.device)
=======
def balanced_packing(weight: torch.Tensor,
                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:
    """
    Pack n weighted objects to m packs, such that each bin contains exactly
    n/m objects and the weights of all packs are as balanced as possible.

    Parameters:
        weight: [X, n], the weight of each item
        num_packs: number of packs

    Returns:
        pack_index: [X, n], the pack index of each item
        rank_in_pack: [X, n], the rank of the item in the pack
    """
    num_layers, num_groups = weight.shape
    assert num_groups % num_packs == 0
    groups_per_pack = num_groups // num_packs

    # Handle trivial case
    if groups_per_pack == 1:
        pack_index = torch.arange(num_groups,
                                  dtype=torch.int64,
                                  device=weight.device).expand(num_layers, -1)
        rank_in_pack = torch.zeros_like(pack_index)
        return pack_index, rank_in_pack

    # Optimization: perform sequential packing logic on CPU to avoid GPU overhead
    weight_cpu = weight.to("cpu", dtype=torch.float32)
    pack_index = torch.empty((num_layers, num_groups), dtype=torch.int64, device="cpu")
    rank_in_pack = torch.empty((num_layers, num_groups), dtype=torch.int64, device="cpu")

    # Configuration for restarts
    # 1 deterministic run + 2 randomized runs gave good balance/speed trade-off
    num_restarts = 3

    for i in range(num_layers):
        row_weight = weight_cpu[i]
        row_weight_list = row_weight.tolist()

        best_diff = float('inf')
        best_packs = None

        # Base indices for deterministic LPT (sorted descending)
        base_indices = torch.argsort(row_weight, descending=True).tolist()

        for attempt in range(num_restarts):
            # 1. Initialization Strategy
            if attempt == 0:
                # Deterministic LPT
                indices = base_indices
            else:
                # Randomized LPT
                noise = torch.rand(num_groups, device="cpu") * 0.2 + 0.9
                indices = torch.argsort(row_weight * noise, descending=True).tolist()

            # 2. Greedy Packing
            current_packs = [[] for _ in range(num_packs)]
            pack_weights = [0.0] * num_packs

            for group_idx in indices:
                w = row_weight_list[group_idx]

                # Find best pack (min weight with capacity)
                best_p = -1
                min_val = float('inf')
                for p in range(num_packs):
                    if len(current_packs[p]) < groups_per_pack:
                        if pack_weights[p] < min_val:
                            min_val = pack_weights[p]
                            best_p = p

                current_packs[best_p].append(group_idx)
                pack_weights[best_p] += w

            # 3. Refinement Phase (Local Search)
            # Iteratively swap items between heavy and light packs
            for _ in range(20): # Iteration limit
                # Sort packs by weight
                sorted_pack_indices = sorted(range(num_packs),
                                             key=pack_weights.__getitem__,
                                             reverse=True)

                max_p = sorted_pack_indices[0]
                min_p = sorted_pack_indices[-1]
                diff = pack_weights[max_p] - pack_weights[min_p]

                if diff < 1e-6:
                    break

                # Strategy A: Merge and Repack (Best Fit Decreasing for 2 bins)
                # This breaks local optima that single swaps cannot fix by completely
                # redistributing items between the heaviest and lightest packs.
                improved_via_repack = False
                if groups_per_pack > 1:
                    p1, p2 = max_p, min_p

                    # Gather all items from both packs
                    combined_items = current_packs[p1] + current_packs[p2]
                    combined_weights = [row_weight_list[idx] for idx in combined_items]

                    # Sort descending
                    combined = sorted(zip(combined_items, combined_weights), key=lambda x: x[1], reverse=True)

                    # Re-distribute using constrained LPT
                    new_p1, new_p2 = [], []
                    w_p1, w_p2 = 0.0, 0.0

                    for item, w in combined:
                        # Try to add to the lighter bin if it has space
                        can_1 = len(new_p1) < groups_per_pack
                        can_2 = len(new_p2) < groups_per_pack

                        if can_1 and can_2:
                            if w_p1 <= w_p2:
                                new_p1.append(item)
                                w_p1 += w
                            else:
                                new_p2.append(item)
                                w_p2 += w
                        elif can_1:
                            new_p1.append(item)
                            w_p1 += w
                        else:
                            new_p2.append(item)
                            w_p2 += w

                    new_diff = abs(w_p1 - w_p2)
                    current_pair_diff = pack_weights[p1] - pack_weights[p2]

                    # If we improved the local balance significantly, apply it
                    if new_diff < current_pair_diff - 1e-5:
                        current_packs[p1] = new_p1
                        pack_weights[p1] = w_p1
                        current_packs[p2] = new_p2
                        pack_weights[p2] = w_p2
                        improved_via_repack = True

                if improved_via_repack:
                    continue

                # Strategy B: Single Swap Descent
                found_swap = False
                for i1 in range(num_packs):
                    p1 = sorted_pack_indices[i1]
                    for i2 in range(num_packs - 1, i1, -1):
                        p2 = sorted_pack_indices[i2]

                        diff_pair = pack_weights[p1] - pack_weights[p2]
                        if diff_pair < 1e-6: break

                        target = diff_pair / 2.0
                        best_swap = None
                        best_gap = diff_pair

                        # Find swap (u, v)
                        for idx_u, u in enumerate(current_packs[p1]):
                            w_u = row_weight_list[u]
                            for idx_v, v in enumerate(current_packs[p2]):
                                w_v = row_weight_list[v]

                                delta = w_u - w_v
                                if 0 < delta < diff_pair:
                                    gap = abs(delta - target)
                                    if gap < best_gap:
                                        best_gap = gap
                                        best_swap = (idx_u, idx_v, delta)
                                        if gap < 1e-5: break
                            if best_swap and best_gap < 1e-5: break

                        if best_swap:
                            idx_u, idx_v, delta = best_swap
                            u = current_packs[p1][idx_u]
                            v = current_packs[p2][idx_v]

                            current_packs[p1][idx_u] = v
                            current_packs[p2][idx_v] = u
                            pack_weights[p1] -= delta
                            pack_weights[p2] += delta
                            found_swap = True
                            break
                    if found_swap: break

                if not found_swap:
                    break

            # 4. Check if this is the best solution so far
            current_diff = max(pack_weights) - min(pack_weights)
            if current_diff < best_diff:
                best_diff = current_diff
                best_packs = [list(p) for p in current_packs]
                if best_diff < 1e-6:
                    break

        # Fill result tensors
        for p in range(num_packs):
            for r, g in enumerate(best_packs[p]):
                pack_index[i, g] = p
                rank_in_pack[i, g] = r

    return pack_index.to(weight.device), rank_in_pack.to(weight.device)
>>>>>>> REPLACE
</DIFF>