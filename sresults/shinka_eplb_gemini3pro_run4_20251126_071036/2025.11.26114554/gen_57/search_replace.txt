<NAME>
iterative_swaps_refinement
</NAME>

<DESCRIPTION>
Replaces the randomized greedy refinement strategies with deterministic, iterative local search methods (Hill Climbing).
1. Replaces the "Pairwise Rebalancing" (which used ruin-and-recreate) with "Pairwise Steepest Descent Swaps". This checks all item pairs between two packs and performs the swap that minimizes the load difference. This is much more precise for fine-tuning.
2. Replaces the "LNS" (3-way ruin-and-recreate) with "3-Way Cyclic Exchange". This looks for cycles u->B, v->C, w->A that improve balance. This helps resolve "jammed" states where no 2-way swap yields improvement.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 2. Refinement: Pairwise Rebalancing (Heavier Pack vs Others)
        # We try to rebalance the heaviest pack with the lightest pack (and random others).
        # We pool items from both and re-partition them using randomized greedy.

        NUM_PAIRWISE_ITER = 30
        for _ in range(NUM_PAIRWISE_ITER):
            # Identify packs sorted by weight
            sorted_by_w = sorted(range(num_packs), key=lambda x: pack_weights[x])
            max_p = sorted_by_w[-1]
            min_p = sorted_by_w[0]

            if pack_weights[max_p] - pack_weights[min_p] < 1e-6:
                break

            # Candidates to pair with max_p: Min pack, and maybe a random one
            candidates = [min_p]
            if num_packs > 2:
                # Add a few random candidates to help escape local optima
                for _ in range(2):
                    r = random.randint(0, num_packs - 1)
                    if r != max_p and r not in candidates:
                        candidates.append(r)

            improved_any = False
            for other_p in candidates:
                # Current max of the pair
                old_pair_max = max(pack_weights[max_p], pack_weights[other_p])
                old_pair_ss = pack_weights[max_p]**2 + pack_weights[other_p]**2

                items = packs[max_p] + packs[other_p]

                # Try to re-partition items into two sets of size groups_per_pack
                best_split = None
                best_split_max = old_pair_max
                best_split_ss = old_pair_ss

                # Strategies: Deterministic LPT, then Randomized LPTs
                # Pre-sort items LPT
                items_desc = sorted(items, key=lambda x: w_list[x], reverse=True)

                # Small sub-problem restarts
                SUB_RESTARTS = 20

                for attempt in range(SUB_RESTARTS):
                    if attempt == 0:
                        current_items = items_desc
                    else:
                        # Perturbed weights
                        noise = [random.uniform(0.85, 1.15) for _ in range(len(items))]
                        # Sort by perturbed weight
                        current_items = sorted(items, key=lambda x: w_list[x] * noise[items.index(x)], reverse=True)

                    # Greedy Fill for 2 bins
                    bin_a = []
                    bin_b = []
                    w_a = 0.0
                    w_b = 0.0

                    for item in current_items:
                        w = w_list[item]
                        # Put in lighter bin if space allows
                        can_a = len(bin_a) < groups_per_pack
                        can_b = len(bin_b) < groups_per_pack

                        if can_a and can_b:
                            if w_a < w_b:
                                bin_a.append(item); w_a += w
                            else:
                                bin_b.append(item); w_b += w
                        elif can_a:
                            bin_a.append(item); w_a += w
                        elif can_b:
                            bin_b.append(item); w_b += w
                        else:
                            # Should not happen if sizes match
                            pass

                    cur_max = max(w_a, w_b)
                    cur_ss = w_a**2 + w_b**2

                    if cur_max < best_split_max - 1e-6:
                        best_split_max = cur_max
                        best_split_ss = cur_ss
                        best_split = (bin_a, bin_b, w_a, w_b)
                    elif abs(cur_max - best_split_max) < 1e-6 and cur_ss < best_split_ss - 1e-6:
                        best_split_max = cur_max
                        best_split_ss = cur_ss
                        best_split = (bin_a, bin_b, w_a, w_b)

                if best_split:
                    packs[max_p] = best_split[0]
                    packs[other_p] = best_split[1]
                    pack_weights[max_p] = best_split[2]
                    pack_weights[other_p] = best_split[3]
                    improved_any = True
                    break # Restart outer loop to identify new max

            if not improved_any:
                break
=======
        # 2. Refinement: Pairwise Swap (Hill Climbing)
        # Iteratively swap items between the heaviest pack and others to minimize load difference.
        MAX_REFINE_STEPS = 50

        for _ in range(MAX_REFINE_STEPS):
            # Identify max and min packs
            max_p = -1; min_p = -1
            max_w = -1.0; min_w = float('inf')

            for p_idx, pw in enumerate(pack_weights):
                if pw > max_w: max_w = pw; max_p = p_idx
                if pw < min_w: min_w = pw; min_p = p_idx

            if max_w - min_w < 1e-6:
                break

            # Candidates to pair with max_p
            targets = [min_p]
            if num_packs > 2:
                for _ in range(2):
                    r = random.randint(0, num_packs - 1)
                    if r != max_p and r not in targets:
                        targets.append(r)

            improved_iter = False

            for other_p in targets:
                diff = pack_weights[max_p] - pack_weights[other_p]

                best_swap = None
                best_err = diff

                pack_a_items = packs[max_p]
                pack_b_items = packs[other_p]

                found_better = False

                # Check all pairs for optimal swap
                for idx_a, item_a in enumerate(pack_a_items):
                    w_a = w_list[item_a]
                    for idx_b, item_b in enumerate(pack_b_items):
                        w_b = w_list[item_b]

                        delta = w_a - w_b
                        # New diff magnitude if swapped: |diff - 2*delta|
                        new_diff_val = abs(diff - 2 * delta)

                        if new_diff_val < best_err - 1e-6:
                            best_err = new_diff_val
                            best_swap = (idx_a, idx_b, delta)
                            found_better = True

                if found_better:
                    idx_a, idx_b, delta = best_swap
                    item_a = packs[max_p][idx_a]
                    item_b = packs[other_p][idx_b]

                    packs[max_p][idx_a] = item_b
                    packs[other_p][idx_b] = item_a

                    pack_weights[max_p] -= delta
                    pack_weights[other_p] += delta
                    improved_iter = True
                    break

            if not improved_iter:
                break
>>>>>>> REPLACE
<<<<<<< SEARCH
        # 3. Refinement: Enhanced LNS (Ruin & Recreate)
        if num_packs >= 3:
            for _ in range(NUM_LNS_ITER):
                sorted_p = sorted(range(num_packs), key=pack_weights.__getitem__, reverse=True)
                p_max = sorted_p[0]
                p_min = sorted_p[-1]

                if pack_weights[p_max] - pack_weights[p_min] < 1e-6: break

                # Pick 3rd pack: Mix of Top, Bottom, and Random
                if _ % 3 == 0: p_mid = sorted_p[1]
                elif _ % 3 == 1: p_mid = sorted_p[random.randint(1, num_packs-1)]
                else: p_mid = sorted_p[random.randint(1, num_packs-1)]

                if p_mid == p_max or p_mid == p_min:
                    candidates = [x for x in all_packs if x != p_max and x != p_min]
                    if not candidates: break
                    p_mid = random.choice(candidates)

                target_packs = [p_max, p_min, p_mid]

                items = []
                for p in target_packs:
                    items.extend(packs[p])

                best_sub_res = None

                # Try LPT, Jittered LPT, and Random Shuffle
                strategies = ['lpt', 'lpt_noise', 'shuffle', 'shuffle']

                curr_local_max = max(pack_weights[p] for p in target_packs)
                curr_local_ss = sum(pack_weights[p]**2 for p in target_packs)

                for strat in strategies:
                    if strat == 'lpt':
                        temp_items = sorted(items, key=lambda x: w_list[x], reverse=True)
                    elif strat == 'lpt_noise':
                        temp_items = sorted(items, key=lambda x: w_list[x] * (1.0 + (random.random()-0.5)*0.1), reverse=True)
                    else:
                        temp_items = list(items)
                        random.shuffle(temp_items)

                    sub_p = {p: [] for p in target_packs}
                    sub_w = {p: 0.0 for p in target_packs}
                    sub_c = {p: 0 for p in target_packs}

                    possible = True
                    for item in temp_items:
                        w = w_list[item]
                        best_p = -1
                        min_val = float('inf')
                        # Best fit
                        for p in target_packs:
                            if sub_c[p] < groups_per_pack:
                                if sub_w[p] < min_val:
                                    min_val = sub_w[p]
                                    best_p = p
                        if best_p == -1:
                            possible = False; break
                        sub_p[best_p].append(item)
                        sub_w[best_p] += w
                        sub_c[best_p] += 1

                    if possible:
                        new_max = max(sub_w.values())
                        new_ss = sum(v**2 for v in sub_w.values())

                        if new_max < curr_local_max - 1e-6:
                            curr_local_max = new_max
                            curr_local_ss = new_ss
                            best_sub_res = (sub_p, sub_w)
                        elif abs(new_max - curr_local_max) < 1e-6 and new_ss < curr_local_ss - 1e-6:
                            curr_local_ss = new_ss
                            best_sub_res = (sub_p, sub_w)

                if best_sub_res:
                    s_p, s_w = best_sub_res
                    for p in target_packs:
                        packs[p] = s_p[p]
                        pack_weights[p] = s_w[p]
=======
        # 3. Refinement: 3-Way Cyclic Exchange
        if num_packs >= 3 and groups_per_pack <= 32:
            for _ in range(20):
                max_p = -1; max_w = -1.0
                for p_idx, pw in enumerate(pack_weights):
                    if pw > max_w: max_w = pw; max_p = p_idx

                others = []
                for _ in range(10):
                    r = random.randint(0, num_packs - 1)
                    if r != max_p and r not in others:
                        others.append(r)
                    if len(others) == 2: break

                if len(others) < 2: break

                pA = max_p; pB = others[0]; pC = others[1]
                wA = pack_weights[pA]; wB = pack_weights[pB]; wC = pack_weights[pC]

                current_max = max(wA, wB, wC)
                current_ss = wA**2 + wB**2 + wC**2

                best_cycle = None
                itemsA = packs[pA]; itemsB = packs[pB]; itemsC = packs[pC]

                # Check Cycle 1: A->B, B->C,