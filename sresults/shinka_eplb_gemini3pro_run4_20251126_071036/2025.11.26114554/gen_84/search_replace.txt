<NAME>
pool_solver_local_search
</NAME>

<DESCRIPTION>
Enhance the heuristic pool partitioner in `balanced_packing` by adding a Local Search (swap-based refinement) phase. Currently, for large K, the algorithm uses randomized greedy construction which may miss easy improvements. The new logic iterates through all pairs of items between the two partitions and performs swaps if they reduce the weight difference. This allows the solver to fine-tune the randomized constructions, leading to better balancedness with fewer restarts. I reduced `sub_trials` from 30 to 15 to compensate for the added computational cost of the swap search.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
                else:
                    # Heuristic Solver
                    pool_indices = list(range(pool_len))
                    sub_trials = 30
                    for sub in range(sub_trials):
                        if sub == 0:
                            sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i], reverse=True)
                        else:
                            noise = [random.uniform(0.8, 1.2) for _ in pool]
                            sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i] * noise[i], reverse=True)

                        w_A, w_B = 0.0, 0.0
                        cnt_A, cnt_B = 0, 0
                        set_A_local = []

                        for idx in sorted_idx:
                            w = pool_weights[idx]
                            if cnt_A < K and cnt_B < K:
                                if w_A <= w_B:
                                    w_A += w
                                    cnt_A += 1
                                    set_A_local.append(idx)
                                else:
                                    w_B += w
                                    cnt_B += 1
                            elif cnt_A < K:
                                w_A += w
                                cnt_A += 1
                                set_A_local.append(idx)
                            else:
                                w_B += w
                                cnt_B += 1

                        dev = abs(w_A - target_half)
                        if dev < best_dev - 1e-6:
                            best_dev = dev
                            best_assignment = set_A_local
                            if dev < 1e-6: break
=======
                else:
                    # Heuristic Solver with Local Search
                    pool_indices = list(range(pool_len))
                    sub_trials = 15
                    for sub in range(sub_trials):
                        # 1. Randomized Greedy Construction
                        if sub == 0:
                            sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i], reverse=True)
                        else:
                            noise = [random.uniform(0.8, 1.2) for _ in pool]
                            sorted_idx = sorted(pool_indices, key=lambda i: pool_weights[i] * noise[i], reverse=True)

                        w_A, w_B = 0.0, 0.0
                        cnt_A, cnt_B = 0, 0
                        set_A_local = []
                        set_B_local = []

                        for idx in sorted_idx:
                            w = pool_weights[idx]
                            if cnt_A < K and cnt_B < K:
                                if w_A <= w_B:
                                    w_A += w
                                    cnt_A += 1
                                    set_A_local.append(idx)
                                else:
                                    w_B += w
                                    cnt_B += 1
                                    set_B_local.append(idx)
                            elif cnt_A < K:
                                w_A += w
                                cnt_A += 1
                                set_A_local.append(idx)
                            else:
                                w_B += w
                                cnt_B += 1
                                set_B_local.append(idx)

                        # 2. Local Search (Swap)
                        # Iteratively improve the partition by swapping pairs
                        curr_diff = w_A - w_B

                        while True:
                            # We want to reduce |curr_diff|.
                            # Swap a (from A) and b (from B).
                            # New diff = (w_A - wa + wb) - (w_B - wb + wa)
                            #          = w_A - w_B - 2*wa + 2*wb
                            #          = curr_diff - 2*(wa - wb)

                            if abs(curr_diff) < 1e-6: break

                            best_swap_gain = 0.0
                            best_pair = None

                            # O(K^2) scan
                            for i_a, idx_a in enumerate(set_A_local):
                                wa = pool_weights[idx_a]
                                for i_b, idx_b in enumerate(set_B_local):
                                    wb = pool_weights[idx_b]

                                    change = 2.0 * (wa - wb)
                                    new_diff = curr_diff - change

                                    # gain = reduction in absolute difference
                                    gain = abs(curr_diff) - abs(new_diff)

                                    if gain > best_swap_gain + 1e-6:
                                        best_swap_gain = gain
                                        best_pair = (i_a, i_b, change, new_diff)

                            if best_pair:
                                i_a, i_b, change, new_diff = best_pair
                                # Apply swap
                                val_a = set_A_local[i_a]
                                val_b = set_B_local[i_b]
                                set_A_local[i_a] = val_b
                                set_B_local[i_b] = val_a

                                curr_diff = new_diff
                                w_A = w_A - pool_weights[val_a] + pool_weights[val_b]
                            else:
                                break

                        dev = abs(w_A - target_half)
                        if dev < best_dev - 1e-6:
                            best_dev = dev
                            best_assignment = list(set_A_local)
                            if dev < 1e-6: break
>>>>>>> REPLACE
</DIFF>