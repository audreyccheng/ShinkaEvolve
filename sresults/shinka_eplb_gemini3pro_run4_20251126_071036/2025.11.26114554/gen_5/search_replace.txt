<NAME>
improved_balanced_packing_refinement
</NAME>

<DESCRIPTION>
Optimized the `balanced_packing` function by moving weight processing to CPU/lists for faster iteration and implementing a robust pairwise refinement strategy. The refinement step now iteratively sorts packs by weight and attempts to swap items between heavier and lighter packs to minimize load variance, rather than just targeting the global min and max.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def balanced_packing(weight: torch.Tensor,
                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:
    """
    Pack n weighted objects to m packs, such that each bin contains exactly
    n/m objects and the weights of all packs are as balanced as possible.

    Parameters:
        weight: [X, n], the weight of each item
        num_packs: number of packs

    Returns:
        pack_index: [X, n], the pack index of each item
        rank_in_pack: [X, n], the rank of the item in the pack
    """
    num_layers, num_groups = weight.shape
    assert num_groups % num_packs == 0
    groups_per_pack = num_groups // num_packs

    if groups_per_pack == 1:
        pack_index = torch.arange(weight.size(-1),
                                  dtype=torch.int64,
                                  device=weight.device).expand(weight.shape)
        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)
        return pack_index, rank_in_pack

    indices = weight.float().sort(-1, descending=True).indices.cpu()
    pack_index = torch.full_like(weight,
                                 fill_value=-1,
                                 dtype=torch.int64,
                                 device="cpu")
    rank_in_pack = torch.full_like(pack_index, fill_value=-1)
    for i in range(num_layers):
        pack_weights = [0] * num_packs
        pack_items = [0] * num_packs
        for group in indices[i]:
            pack = min(
                (i
                 for i in range(num_packs) if pack_items[i] < groups_per_pack),
                key=pack_weights.__getitem__,
            )
            assert pack_items[pack] < groups_per_pack
            pack_index[i, group] = pack
            rank_in_pack[i, group] = pack_items[pack]
            pack_weights[pack] += weight[i, group]
            pack_items[pack] += 1
    return pack_index, rank_in_pack
=======
def balanced_packing(weight: torch.Tensor,
                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:
    """
    Pack n weighted objects to m packs, such that each bin contains exactly
    n/m objects and the weights of all packs are as balanced as possible.

    Parameters:
        weight: [X, n], the weight of each item
        num_packs: number of packs

    Returns:
        pack_index: [X, n], the pack index of each item
        rank_in_pack: [X, n], the rank of the item in the pack
    """
    num_layers, num_groups = weight.shape
    assert num_groups % num_packs == 0
    groups_per_pack = num_groups // num_packs

    if groups_per_pack == 1:
        pack_index = torch.arange(weight.size(-1),
                                  dtype=torch.int64,
                                  device=weight.device).expand(weight.shape)
        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)
        return pack_index, rank_in_pack

    # Optimization: Move weights to CPU and convert to list for faster access
    weight_cpu = weight.to("cpu", dtype=torch.float32)
    indices = weight_cpu.sort(-1, descending=True).indices.tolist()
    weight_list = weight_cpu.tolist()

    pack_index = torch.empty_like(weight, dtype=torch.int64, device="cpu")
    rank_in_pack = torch.empty_like(weight, dtype=torch.int64, device="cpu")

    for i in range(num_layers):
        row_weight = weight_list[i]
        current_packs = [[] for _ in range(num_packs)]
        pack_weights = [0.0] * num_packs

        # 1. Greedy packing
        for group in indices[i]:
            w = row_weight[group]
            best_pack = -1
            min_val = float('inf')
            for p in range(num_packs):
                if len(current_packs[p]) < groups_per_pack:
                    if pack_weights[p] < min_val:
                        min_val = pack_weights[p]
                        best_pack = p
            current_packs[best_pack].append(group)
            pack_weights[best_pack] += w

        # 2. Refinement: Pairwise swapping
        for _ in range(20):
            found_improvement = False
            # Sort packs by weight descending
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)

            for i1 in range(num_packs):
                p1 = sorted_packs[i1]
                # Check against lighter packs
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    diff = pack_weights[p1] - pack_weights[p2]
                    if diff < 1e-6: break

                    target = diff / 2.0
                    best_swap = None
                    best_gap = diff

                    # Try to swap item u from heavier pack with item v from lighter pack
                    for idx_u, u in enumerate(current_packs[p1]):
                        w_u = row_weight[u]
                        for idx_v, v in enumerate(current_packs[p2]):
                            w_v = row_weight[v]
                            delta = w_u - w_v
                            if 0 < delta < diff:
                                gap = abs(delta - target)
                                if gap < best_gap:
                                    best_gap = gap
                                    best_swap = (idx_u, idx_v, delta)
                                    if gap < 1e-5: break
                        if best_swap and best_gap < 1e-5: break

                    if best_swap:
                        idx_u, idx_v, delta = best_swap
                        u = current_packs[p1][idx_u]
                        v = current_packs[p2][idx_v]
                        current_packs[p1][idx_u] = v
                        current_packs[p2][idx_v] = u
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break
                if found_improvement: break

            if not found_improvement:
                break

        # 3. Fill result tensors
        for p in range(num_packs):
            for r, g in enumerate(current_packs[p]):
                pack_index[i, g] = p
                rank_in_pack[i, g] = r

    return pack_index, rank_in_pack
>>>>>>> REPLACE
</DIFF>