<NAME>
pooled_repartition_and_swap
</NAME>

<DESCRIPTION>
Improve the `balanced_packing` function's refinement phase by introducing a "Pooled Greedy Repartitioning" strategy alongside the existing pairwise swapping.

For each pair of packs considered during refinement (specifically a heavy pack and a lighter pack):
1.  **Greedy Repartitioning**: The items from both packs are combined, sorted by weight, and re-distributed into two new packs using a greedy "least loaded" heuristic. This can effectively perform multi-item swaps (e.g., exchanging two small items for one large item) that pairwise swapping misses.
2.  **Single Item Swap**: The original logic of finding the best single item swap is retained.

The algorithm evaluates both strategies and applies the one that results in the smallest load difference between the two packs (provided it improves upon the current state). This hybrid approach combines the structural optimization of greedy reconstruction with the fine-grained adjustments of swapping, helping the algorithm escape local optima more effectively.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # 2. Refinement: Pairwise swapping
        # Try to swap items between the heaviest and lightest packs to balance load.
        for _ in range(20):
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)
            found_improvement = False

            for i1 in range(num_packs):
                p1 = sorted_packs[i1]
                # Compare against lighter packs
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    diff = pack_weights[p1] - pack_weights[p2]
                    if diff < 1e-6:
                        break # Since packs are sorted, subsequent diffs will be smaller

                    target = diff / 2.0
                    best_swap = None
                    best_gap = diff

                    # Find best swap: u from p1, v from p2 such that w_u - w_v approx target
                    for idx_u, (u, w_u) in enumerate(current_packs[p1]):
                        for idx_v, (v, w_v) in enumerate(current_packs[p2]):
                            delta = w_u - w_v
                            # We need w_u > w_v to reduce diff
                            if 0 < delta < diff:
                                gap = abs(delta - target)
                                if gap < best_gap:
                                    best_gap = gap
                                    # Store swap details: indices and the actual values to swap
                                    best_swap = (idx_u, idx_v, delta, v, w_v, u, w_u)
                                    if gap < 1e-5: break
                        if best_swap and best_gap < 1e-5: break

                    if best_swap:
                        idx_u, idx_v, delta, val_v, weight_v, val_u, weight_u = best_swap

                        # Apply swap
                        current_packs[p1][idx_u] = (val_v, weight_v)
                        current_packs[p2][idx_v] = (val_u, weight_u)
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break # Break inner loop to re-sort packs

                if found_improvement: break
=======
        # 2. Refinement: Pairwise balancing (Swap or Repartition)
        # Try to improve balance between heaviest and lighter packs.
        # We consider both single-item swaps and full greedy re-partitioning of the two packs.
        for _ in range(20):
            sorted_packs = sorted(range(num_packs),
                                  key=pack_weights.__getitem__,
                                  reverse=True)
            found_improvement = False

            for i1 in range(num_packs):
                p1 = sorted_packs[i1]
                # Compare against lighter packs (starting from lightest)
                for i2 in range(num_packs - 1, i1, -1):
                    p2 = sorted_packs[i2]

                    current_diff = pack_weights[p1] - pack_weights[p2]
                    if current_diff < 1e-6:
                        break

                    # Strategy A: Greedy Repartitioning
                    # Combine items, sort, and fill two bins greedily.
                    # This handles multi-item moves implicitly.
                    p1_items = current_packs[p1]
                    p2_items = current_packs[p2]

                    combined_items = p1_items + p2_items
                    # Sort by weight descending
                    combined_items.sort(key=lambda x: x[1], reverse=True)

                    # Simulation of Greedy Packing
                    sim_w1 = 0.0
                    sim_w2 = 0.0
                    sim_p1 = []
                    sim_p2 = []
                    cap = groups_per_pack

                    possible_repartition = True
                    for item in combined_items:
                        # Try to add to lighter simulated pack
                        if len(sim_p1) < cap and len(sim_p2) < cap:
                            if sim_w1 <= sim_w2:
                                sim_p1.append(item)
                                sim_w1 += item[1]
                            else:
                                sim_p2.append(item)
                                sim_w2 += item[1]
                        elif len(sim_p1) < cap:
                            sim_p1.append(item)
                            sim_w1 += item[1]
                        elif len(sim_p2) < cap:
                            sim_p2.append(item)
                            sim_w2 += item[1]
                        else:
                            # Should not happen if sizes match
                            possible_repartition = False
                            break

                    best_diff = current_diff
                    best_action = None # ('repartition', p1_list, p2_list, w1, w2) or ('swap', ...)

                    if possible_repartition:
                        new_diff_repart = abs(sim_w1 - sim_w2)
                        if new_diff_repart < best_diff - 1e-6:
                            best_diff = new_diff_repart
                            best_action = ('repartition', sim_p1, sim_p2, sim_w1, sim_w2)

                    # Strategy B: Single Item Swap (Original Logic)
                    # Sometimes better than greedy if greedy gets stuck.
                    target = current_diff / 2.0

                    found_better_swap = False
                    best_swap_tuple = None

                    for idx_u, (u, w_u) in enumerate(p1_items):
                        for idx_v, (v, w_v) in enumerate(p2_items):
                            delta = w_u - w_v
                            if 0 < delta < current_diff:
                                gap = abs(delta - target)
                                # Check if this swap results in a diff smaller than best_diff
                                # New diff would be |(W1 - delta) - (W2 + delta)| = 2 * gap
                                if 2 * gap < best_diff - 1e-6:
                                    best_diff = 2 * gap
                                    best_swap_tuple = (idx_u, idx_v, delta, v, w_v, u, w_u)
                                    found_better_swap = True
                                    if gap < 1e-5: break
                        if found_better_swap and best_diff < 1e-5: break

                    # Execute Best Action
                    if found_better_swap:
                        idx_u, idx_v, delta, val_v, weight_v, val_u, weight_u = best_swap_tuple
                        current_packs[p1][idx_u] = (val_v, weight_v)
                        current_packs[p2][idx_v] = (val_u, weight_u)
                        pack_weights[p1] -= delta
                        pack_weights[p2] += delta
                        found_improvement = True
                        break
                    elif best_action and best_action[0] == 'repartition':
                        _, new_p1, new_p2, new_w1, new_w2 = best_action
                        current_packs[p1] = new_p1
                        current_packs[p2] = new_p2
                        pack_weights[p1] = new_w1
                        pack_weights[p2] = new_w2
                        found_improvement = True
                        break

                if found_improvement: break
>>>>>>> REPLACE
</DIFF>