<NAME>
refined_3way_swap_and_restarts
</NAME>

<DESCRIPTION>
Introduces two significant improvements to the expert load balancing algorithm:
1.  **Randomized LPT Restarts**: Adds 5 randomized restart candidates to the initial packing phase. By perturbing the weights slightly before sorting, the greedy LPT heuristic explores different packing configurations, helping to escape local optima determined by the initial sort order.
2.  **3-Way Cyclic Swap Refinement**: Enhances the local search phase. When simple pairwise swaps ($A \leftrightarrow B$) cannot improve the maximum load (e.g., due to item granularity), the algorithm attempts 3-way cyclic swaps ($P_{max} \to P_{mid} \to P_{min} \to P_{max}$). This allows moving a heavy item from the max-load pack to a medium pack, shifting a medium item to the min-load pack, and returning a small item to the max-load pack, effectively reducing the max load when pairwise swaps fail.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # --- Evaluation and Refinement ---
        best_diff_global = float('inf')
        best_packing_global = None

        for packs_init, loads_init in candidates:
            # Create a working copy
            current_packs = [list(p) for p in packs_init]
            current_loads = list(loads_init)

            # Iterative Improvement
            # We specifically target the MAX load pack to reduce it.
            max_iter = 20
            for _ in range(max_iter):
                # Identify Min and Max packs
                min_p = 0
                max_p = 0
                min_v = current_loads[0]
                max_v = current_loads[0]

                for p in range(1, num_packs):
                    v = current_loads[p]
                    if v < min_v:
                        min_v = v
                        min_p = p
                    if v > max_v:
                        max_v = v
                        max_p = p

                diff = max_v - min_v
                if diff < 1e-6:
                    break

                # We want to swap u (from max_p) with v (from other_p)
                # Goal: reduce max_v.
                # Ideally, we swap with min_p to also raise min_v (reduce range both ends).

                best_swap = None

                # 1. Try swapping with Min Pack (Most efficient for range reduction)
                target_delta = diff / 2.0
                best_gap_sq = diff * diff

                p1 = max_p
                p2 = min_p

                # Check items to find u in max_p and v in min_p
                for i1, (u, w_u) in enumerate(current_packs[p1]):
                    for i2, (v, w_v) in enumerate(current_packs[p2]):
                        delta = w_u - w_v
                        # We need w_u > w_v (delta > 0) to reduce max
                        if 0 < delta < diff:
                            gap = abs(delta - target_delta)
                            if gap * gap < best_gap_sq:
                                best_gap_sq = gap * gap
                                best_swap = (p1, p2, i1, i2, delta, u, w_u, v, w_v)
                                if gap < 1e-5: break # Perfect swap
                    if best_swap and best_gap_sq < 1e-10: break

                # 2. If no good swap with Min, try Any Pack that allows reduction of Max
                # A good swap with Min is usually one that brings us close to target.
                # If the best swap with min is still poor (e.g. barely reduces max), look elsewhere.
                if best_swap is None:
                    # We iterate all other packs. We just want ANY valid reduction of Max.
                    # Sort others by load ascending (lighter first)
                    other_packs = sorted([p for p in range(num_packs) if p != max_p],
                                         key=lambda k: current_loads[k])

                    for p_other in other_packs:
                        # Maximum allowed weight increase for p_other is strictly less than what makes it reach old max_v
                        # We want: current_loads[p_other] + delta < max_v
                        # So: delta < max_v - current_loads[p_other]
                        limit = max_v - current_loads[p_other]
                        if limit < 1e-6: continue

                        local_best = None
                        local_max_delta = -1.0 # We want max delta to reduce max_p as much as possible

                        for i1, (u, w_u) in enumerate(current_packs[max_p]):
                            for i2, (v, w_v) in enumerate(current_packs[p_other]):
                                delta = w_u - w_v
                                if 0 < delta < limit:
                                    # Valid swap. Does it reduce max_p more?
                                    if delta > local_max_delta:
                                        local_max_delta = delta
                                        local_best = (max_p, p_other, i1, i2, delta, u, w_u, v, w_v)

                        if local_best:
                            best_swap = local_best
                            break # Take the first valid swap with a lighter bin (Greedy on bin order)

                if best_swap:
                    p_from, p_to, i_from, i_to, delta, u_idx, u_w, v_idx, v_w = best_swap
                    current_packs[p_from][i_from] = (v_idx, v_w)
                    current_packs[p_to][i_to] = (u_idx, u_w)
                    current_loads[p_from] -= delta
                    current_loads[p_to] += delta
                else:
                    break # No moves possible to alleviate Max Load

            # Check final score for this candidate
            final_max = max(current_loads)
            final_min = min(current_loads)
            final_diff = final_max - final_min

            if final_diff < best_diff_global:
                best_diff_global = final_diff
                best_packing_global = current_packs
                if best_diff_global < 1e-6:
                    break # Optimal
=======
        # --- Strategy 3: Randomized LPT Restarts ---
        # Generate a few variations to escape initial deterministic local optima.
        for _ in range(5):
            # Perturb weights slightly to change sort order
            noise = torch.rand(num_groups, device="cpu") * 0.05 + 0.975 # +/- 2.5%
            noisy_items = []
            for k in range(num_groups):
                orig_idx, orig_w = items[k]
                noisy_items.append((orig_idx, orig_w, orig_w * noise[k].item()))

            # Sort by noisy weight
            noisy_items.sort(key=lambda x: x[2], reverse=True)

            packs_rnd = [[] for _ in range(num_packs)]
            loads_rnd = [0.0] * num_packs

            # Simple LPT with noisy order
            for idx, w, _ in noisy_items:
                # Assign to least loaded pack with space
                best_p = -1
                min_load = float('inf')
                for p in range(num_packs):
                    if len(packs_rnd[p]) < groups_per_pack:
                        if loads_rnd[p] < min_load:
                            min_load = loads_rnd[p]
                            best_p = p
                packs_rnd[best_p].append((idx, w))
                loads_rnd[best_p] += w
            candidates.append((packs_rnd, loads_rnd))

        # --- Evaluation and Refinement ---
        best_diff_global = float('inf')
        best_packing_global = None

        for packs_init, loads_init in candidates:
            # Create a working copy
            current_packs = [list(p) for p in packs_init]
            current_loads = list(loads_init)

            # Iterative Improvement
            max_iter = 50
            for _ in range(max_iter):
                # Identify Min and Max packs
                min_p = 0
                max_p = 0
                min_v = current_loads[0]
                max_v = current_loads[0]

                for p in range(1, num_packs):
                    v = current_loads[p]
                    if v < min_v:
                        min_v = v
                        min_p = p
                    if v > max_v:
                        max_v = v
                        max_p = p

                diff = max_v - min_v
                if diff < 1e-6:
                    break

                # --- 1. Pairwise Swap Refinement ---
                best_swap = None

                # A. Swap with Min Pack (Target reduction)
                target_delta = diff / 2.0
                best_gap_sq = diff * diff

                p1 = max_p
                p2 = min_p

                for i1, (u, w_u) in enumerate(current_packs[p1]):
                    for i2, (v, w_v) in enumerate(current_packs[p2]):
                        delta = w_u - w_v
                        # We need w_u > w_v to reduce max
                        if 0 < delta < diff:
                            gap = abs(delta - target_delta)
                            if gap * gap < best_gap_sq:
                                best_gap_sq = gap * gap
                                best_swap = (p1, p2, i1, i2, delta, u, w_u, v, w_v)
                                if gap < 1e-6: break
                    if best_swap and best_gap_sq < 1e-12: break

                # B. Swap with Any Pack (Greedy reduction)
                if best_swap is None:
                    other_packs = sorted([p for p in range(num_packs) if p != max_p],
                                         key=lambda k: current_loads[k])
                    for p_other in other_packs:
                        limit = max_v - current_loads[p_other]
                        if limit < 1e-6: continue

                        local_max_delta = -1.0
                        local_best = None

                        for i1, (u, w_u) in enumerate(current_packs[max_p]):
                            for i2, (v, w_v) in enumerate(current_packs[p_other]):
                                delta = w_u - w_v
                                if 0 < delta < limit:
                                    if delta > local_max_delta:
                                        local_max_delta = delta
                                        local_best = (max_p, p_other, i1, i2, delta, u, w_u, v, w_v)
                        if local_best:
                            best_swap = local_best
                            break

                if best_swap:
                    p_from, p_to, i_from, i_to, delta, u_idx, u_w, v_idx, v_w = best_swap
                    current_packs[p_from][i_from] = (v_idx, v_w)
                    current_packs[p_to][i_to] = (u_idx, u_w)
                    current_loads[p_from] -= delta
                    current_loads[p_to] += delta
                    continue

                # --- 2. 3-Way Cyclic Swap Refinement ---
                # Try Max -> Mid -> Min -> Max
                found_3way = False
                mid_candidates = sorted([p for p in range(num_packs) if p != max_p and p != min_p],
                                      key=lambda k: current_loads[k])

                limit_min = max_v - current_loads[min_p]

                for p_mid in mid_candidates:
                    limit_mid = max_v - current_loads[p_mid]

                    for i_u, (u, w_u) in enumerate(current_packs[max_p]):
                        for i_w, (w, w_w) in enumerate(current_packs[min_p]):
                            if w_u <= w_w: continue

                            min_v = w_u - limit_mid
                            for i_v, (v, w_v) in enumerate(current_packs[p_mid]):
                                if w_v > min_v:
                                    if w_v - w_w >= limit_min: continue

                                    current_packs[max_p][i_u] = (w, w_w)
                                    current_loads[max_p] -= (w_u - w_w)
                                    current_packs[min_p][i_w] = (v, w_v)
                                    current_loads[min_p] += (w_v - w_w)
                                    current_packs[p_mid][i_v] = (u, w_u)
                                    current_loads[p_mid] += (w_u - w_v)
                                    found_3way = True
                                    break
                            if found_3way: break
                        if found_3way: break
                    if found_3way: break

                if not found_3way:
                    break

            # Check final score for this candidate
            final_max = max(current_loads)
            final_min = min(current_loads)
            final_diff = final_max - final_min

            if final_diff < best_diff_global:
                best_diff_global = final_diff
                best_packing_global = current_packs
                if best_diff_global < 1e-6:
                    break # Optimal
>>>>>>> REPLACE
</DIFF>