{
  "unprocessed_programs": [],
  "meta_summary": "**Program Name: Greedy KVPR Minimization via Rate-SLO Ratio**\n- **Implementation**: The algorithm sorts models descending by their request rate divided by SLO and assigns each to the GPU with the lowest current KV cache pressure ratio (weighted rate divided by remaining memory).\n- **Performance**: Achieved a high combined score of 21.89 with a 100% success rate, efficiently minimizing the maximum KV cache pressure.\n- **Feedback**: Sorting by the intensity metric ($r_j/s_j$) prior to placement ensures that resource-heavy models are distributed optimally early on, preventing bottlenecks.\n**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True\n\n**Program Name: Binary Search with First Fit Decreasing Packing**\n- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search to find the optimal threshold, validating candidates via First Fit Decreasing (FFD) packing based on a derived \"virtual size\" metric.\n- **Performance**: It achieved a combined score of 26.23 with a 100% success rate and negligible execution time.\n- **Feedback**: The approach effectively transforms the continuous minimax optimization problem into a discrete packing feasibility check, allowing the FFD heuristic to efficiently balance loads while strictly adhering to physical memory constraints.\n**Program Identifier:** Generation 1 - Patch Name bisect_kvpr_packing - Correct Program: True\n\n**Program Name: Greedy Size-Sorted KVPR Minimization**\n- **Implementation**: The solution sorts models by size and load in descending order, then assigns each model to the GPU that results in the minimum local KV cache pressure ratio. It dynamically updates the remaining memory and accumulated request load for each GPU to inform subsequent placement decisions.\n- **Performance**: The approach performed exceptionally well, achieving a combined score of 20.43 with a perfect success rate and negligible execution time.\n- **Feedback**: Sorting large models first proved critical for adhering to memory constraints, while the greedy local minimization step successfully balanced the ratio of request load to available memory across devices to minimize pressure.\n**Program Identifier:** Generation 2 - Patch Name greedy_kvpr_projection - Correct Program: True\n\n**Program Name: Binary Search with Multi-Strategy Packing and Local Search**\n- **Implementation**: The solution employs binary search on target pressure using multiple bin packing heuristics (FFD, BFD) on transformed constraints, followed by a local search refinement step to rebalance bottleneck GPUs.\n- **Performance**: It achieves a high combined score of 26.23 with a 100% success rate and negligible execution time.\n- **Feedback**: The use of diverse packing strategies improves feasibility detection during binary search, while the greedy local search effectively reduces peak pressure by smoothing load imbalances.\n**Program Identifier:** Generation 3 - Patch Name bisect_pack_refine - Correct Program: True\n\n**Program Name: Multi-Strategy Binary Search Packing with Iterated Local Search**\n- **Implementation**: This algorithm employs binary search over the target pressure using First-Fit Decreasing on both virtual and physical dimensions to construct an initial solution, followed by an Iterated Local Search that utilizes bottleneck-targeted moves, swaps, and random perturbations.\n- **Performance**: The solution achieves a strong combined score of 26.26 with a 100% success rate and exceptional speed (0.006s).\n- **Feedback**: The use of multiple sorting strategies during the construction phase creates a high-quality baseline, while the perturbation mechanism in the local search effectively escapes local optima to minimize peak pressure without significantly increasing runtime.\n**Program Identifier:** Generation 4 - Patch Name bs_multi_pack_ils - Correct Program: True\n\n**Program Name: Binary Search with Multi-Strategy Packing and Local Search Refinement**\n- **Implementation**: This approach minimizes maximum KV cache pressure by binary searching on a target ratio, transforming the constraint into a bin packing problem solved via multiple heuristics (FFD, BFD) on virtual sizes. A post-processing local search iteratively moves or swaps models from the highest-pressure GPU to further optimize the result.\n- **Performance**: The algorithm achieved a strong combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: Transforming the non-linear objective into a variable-size bin packing problem allowed for efficient approximation, while the multi-heuristic feasibility check and local search refinement ensured a high-quality, balanced distribution.\n**Program Identifier:** Generation 5 - Patch Name improved_packing_and_local_search - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Pressure Relief Local Search**\n- **Implementation**: Uses binary search with multiple First-Fit Decreasing heuristics (sorting by virtual size, physical size, load, density) to construct a tight initial packing, followed by iterated local search that targets bottleneck GPUs for moves/swaps and uses forced random moves to escape local optima.\n- **Performance**: Achieved a combined score of 26.23 with a metric of 25.233, 100% success rate, and 0.005s execution time.\n- **Feedback**: The multi-strategy construction phase ensures a valid starting point even under tight constraints, while the \"pressure relief\" logic in the local search effectively targets and reduces the maximum KV cache pressure.\n**Program Identifier:** Generation 6 - Patch Name iterative_pressure_relief - Correct Program: True\n\n**Program Name: Greedy KVPR Minimization with Size-Descending Sort**\n- **Implementation**: The algorithm sorts models by size in descending order and iteratively assigns each to the GPU that results in the lowest immediate KV cache pressure ratio (KVPR). It tracks remaining memory and cumulative load per GPU to dynamically calculate the cost of each potential placement.\n- **Performance**: The solution achieved a high combined score of 20.43 with a 100% success rate and negligible execution time.\n- **Feedback**: Prioritizing large models first effectively minimizes memory fragmentation, while the greedy assignment strategy successfully balances the load relative to remaining capacity, preventing pressure spikes on individual GPUs.\n**Program Identifier:** Generation 7 - Patch Name greedy_resultant_kvpr_size_sort - Correct Program: True\n\n**Program Name: Hybrid Robust Packing with Adaptive Iterated Local Search**\n- **Implementation**: Initializes utilizing binary search across four distinct First-Fit Decreasing sorting heuristics (Virtual/Physical size, Load, Density), then refines via Hill Climbing with targeted moves, swaps, and adaptive perturbation kicks on bottleneck GPUs.\n- **Performance**: Achieves a strong combined score of 26.23 with extremely fast execution (0.038s), though the 84% success rate indicates occasional inability to find valid initial placements.\n- **Feedback**: The use of multiple sorting strategies creates robust starting solutions, and the bottleneck-focused local search effectively minimizes peak pressure, but the packing logic occasionally fails on tighter constraints.\n**Program Identifier:** Generation 8 - Patch Name hybrid_robust_packing_adaptive_ils - Correct Program: True\n\n**Program Name: Greedy Resultant KVPR Minimization**\n- **Implementation**: The algorithm sorts models by load intensity and iteratively assigns them to the GPU that minimizes the projected KV cache pressure (load divided by remaining memory) for that specific assignment.\n- **Performance**: Achieved a high combined score of 22.67 with a max KVPR inverse score of 21.670 and a perfect success rate.\n- **Feedback**: Calculating the specific impact on the KVPR metric for every potential placement allows the greedy approach to effectively minimize global maximum pressure, significantly outperforming simple load-balancing or bin-packing heuristics.\n**Program Identifier:** Generation 9 - Patch Name projected_kvpr_load_sort - Correct Program: True\n\n**Program Name: Multi-Strategy Packing with Iterated Local Search**\n- **Implementation**: This approach combines binary search over four distinct bin-packing heuristics (FFD/BFD on virtual and physical sizes) to generate a high-quality initial placement, followed by an Iterated Local Search that utilizes greedy moves, swaps, and random perturbations to refine the bottleneck GPU.\n- **Performance**: It achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.009s).\n- **Feedback**: The use of multiple packing strategies ensures a robust initial solution across different constraint landscapes, while the local search effectively fine-tunes load balancing, offering an excellent trade-off between speed and placement quality.\n**Program Identifier:** Generation 10 - Patch Name hybrid_ils_multipack_placement - Correct Program: True\n\n**Program Name: Hybrid Packing Search with Ruin & Recreate Refinement**\n- **Implementation**: The algorithm employs a binary search for the minimum max KVPR using five distinct FFD/BFD packing heuristics (sorted by virtual size, physical size, or density), followed by Simulated Annealing with a \"Ruin & Recreate\" operator to break bottlenecks.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.007s).\n- **Feedback**: The combination of multiple packing heuristics ensures a robust initial solution, while the targeted destruction and reconstruction of bottleneck assignments in the annealing phase effectively minimizes peak pressure where standard swaps might fail.\n**Program Identifier:** Generation 11 - Patch Name hybrid_bfd_ruin_recreate - Correct Program: True\n\n**Program Name: Binary Search with Transformed Best Fit Decreasing**\n- **Implementation**: The algorithm minimizes maximum KV pressure by binary searching on a target pressure $K$, transforming the non-linear objective into a linear Bin Packing feasibility check (item size $w + K \\cdot s$) solved using a Best Fit Decreasing heuristic.\n- **Performance**: The solution achieved a combined score of 26.23 (KVPR metric: 25.233) with a 100% success rate and negligible execution time.\n- **Feedback**: Converting the fractional minimax objective into a parameterized linear packing constraint proved highly effective, allowing standard greedy packing heuristics to reliably find near-optimal pressure distributions.\n**Program Identifier:** Generation 12 - Patch Name binary_search_packing - Correct Program: True\n\n**Program Name: Binary Search Packing with Local Search Refinement**\n- **Implementation**: The algorithm minimizes KV cache pressure by transforming the non-linear objective into a linear bin-packing feasibility check within a binary search, utilizing multiple Best-Fit sorting strategies. It initializes with density-based heuristics and concludes with a hill-climbing local search that iteratively moves or swaps models from the highest-pressure bottleneck GPU.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and exceptional speed (0.001s).\n- **Feedback**: The linearization of the fractional pressure constraint enables the effective use of standard bin-packing heuristics, while the multi-strategy approach and local search refinement significantly improve solution quality by avoiding local optima.\n**Program Identifier:** Generation 13 - Patch Name binary_search_multi_strategy_packing_with_local_refinement - Correct Program: True\n\n**Program Name: Multi-Strategy Packing with Iterated Local Search**\n- **Implementation**: Utilizes binary search with six bin-packing heuristics (FFD/BFD on virtual/physical size and load) to find an initial bound, followed by iterated local search employing greedy moves, swaps, and ruin-and-recreate perturbations.\n- **Performance**: Achieved a high combined score of 26.23 and a metric of 25.233 with 100% success rate and fast execution (0.016s).\n- **Feedback**: The diverse packing strategies ensure feasibility under tight constraints, while the local search's perturbation mechanism effectively breaks bottlenecks to minimize maximum cache pressure.\n**Program Identifier:** Generation 14 - Patch Name robust_ils_with_ruin_recreate - Correct Program: True\n\n**Program Name: Binary Search Packing with Simulated Annealing Refinement**\n- **Implementation**: Utilizes binary search over pressure constraints with multi-strategy BFD/FFD packing (sorting by virtual size, physical size, and density) followed by Simulated Annealing with variance-based tie-breaking for final refinement.\n- **Performance**: Achieved a combined score of 26.23 with a 100% success rate and negligible execution time (0.002s).\n- **Feedback**: The use of diverse packing heuristics ensures a high-quality initial placement, and the variance-aware annealing effectively balances loads; however, the extremely fast runtime suggests the annealing iterations could be increased for further optimization gains.\n**Program Identifier:** Generation 15 - Patch Name binary_bfd_sa - Correct Program: True\n\n**Program Name: Binary Search Packing with Ruin-and-Recreate Local Search**\n- **Implementation**: Transforms the non-linear objective into a linear bin packing problem via binary search, utilizing multiple sorting heuristics (FFD/BFD) for feasibility checks and refining the result with Ruin-and-Recreate Iterated Local Search.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and fast execution (0.009s).\n- **Feedback**: The linearization of the objective allows for efficient global bounds checking, while the multi-heuristic packing and perturbation phases effectively balance loads across GPUs to escape local optima.\n**Program Identifier:** Generation 16 - Patch Name robust_bfd_ils_ruin - Correct Program: True\n\n**Program Name: Robust Binary Search with Heuristics and Variance-Penalized Annealing**\n- **Implementation**: Utilizes binary search over the pressure threshold with multiple packing heuristics (FFD/BFD on various sort keys) to find a strong initial state, followed by simulated annealing using variance as a tie-breaker.\n- **Performance**: Achieved a combined score of 26.26 with a max KVPR score of 25.26 and 0.003s execution time.\n- **Feedback**: The multi-heuristic feasibility check ensures tight packing for the initial solution, and the bottleneck-biased annealing efficiently resolves remaining imbalances.\n**Program Identifier:** Generation 17 - Patch Name robust_packing_sa - Correct Program: True\n\n**Program Name: Multi-Strategy Binary Search Packing with Local Search Refinement**\n- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search on the objective value, checking feasibility via Best-Fit Decreasing with four distinct sorting strategies (including density and virtual size). It concludes with a hill-climbing local search that iteratively moves or swaps models from the bottleneck GPU to finer-tune the distribution.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).\n- **Feedback**: The multi-strategy approach during the feasibility check prevents the packer from getting stuck in local optima, while the post-processing local search effectively corrects minor imbalances that heuristic packing might miss.\n**Program Identifier:** Generation 18 - Patch Name improve_strategies_and_localsearch - Correct Program: True\n\n**Program Name: Robust Multi-Heuristic Packing with Iterated Local Search**\n- **Implementation**: Uses binary search with six diverse FFD/BFD packing heuristics (sorted by virtual size, physical size, and load) to find an initial solution, followed by iterated local search utilizing steepest descent and random perturbations.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and rapid execution time (0.026s).\n- **Feedback**: The combination of multiple packing strategies ensures a high-quality initialization for binary search, while the random kick mechanism in the local search phase effectively mitigates stagnation in local optima.\n**Program Identifier:** Generation 19 - Patch Name hybrid_packing_ils - Correct Program: True\n\n**Program Name: Binary Search Packing with Multi-Strategy Sorting and Local Refinement**\n- **Implementation**: The algorithm utilizes binary search on the fractional objective to linearize constraints, solving the resulting bin packing problem via best-fit with multiple sorting strategies (density, size, load). A post-processing local search iteratively rebalances bottleneck GPUs by optimizing pairs to further reduce pressure.\n- **Performance**: The approach yielded a high score of 26.23 with a 100% success rate and exceptional speed (0.001s).\n- **Feedback**: Linearly transforming the pressure constraint allows effective use of standard bin packing heuristics, while the multi-strategy approach and local refinement ensure the solution avoids local optima common in greedy algorithms.\n**Program Identifier:** Generation 20 - Patch Name pairwise_rebalance_search - Correct Program: True\n\n**Program Name: Binary Search with Transformed Constraints and Iterated Local Search**\n- **Implementation**: The algorithm employs binary search on the pressure target by transforming the fractional objective into a linear constraint, checking feasibility via multi-strategy Best-Fit packing. It refines the solution using Iterated Local Search (ILS) with bottleneck-focused move/swap operations and a ruin-and-recreate perturbation mechanism.\n- **Performance**: The solution achieved a high combined score of 26.23 (max_kvpr: 25.233) with a 100% success rate and rapid execution (0.015s).\n- **Feedback**: Linearly transforming the non-linear pressure constraint enables the effective use of standard packing heuristics, while the local search phase significantly improves the worst-case GPU utilization by iteratively relieving bottlenecks.\n**Program Identifier:** Generation 21 - Patch Name ils_ruin_recreate - Correct Program: True\n\n**Program Name: Linearized Binary Search with Variable Neighborhood Descent**\n- **Implementation**: The solution transforms the fractional KV pressure objective into a linear constraint to perform a binary search using multiple Best Fit heuristics, followed by Variable Neighborhood Descent using move, swap, and pairwise-shuffle operators on the bottleneck GPU.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution time (0.001s).\n- **Feedback**: Linearly transforming the pressure constraint allows for a robust initial placement via standard bin packing algorithms, while the targeted ruin-and-recreate local search effectively escapes local optima to further minimize the maximum pressure.\n**Program Identifier:** Generation 22 - Patch Name binary_search_vnd_rebalance - Correct Program: True\n\n**Program Name: Binary Search with Linearized Constraints and Variance-Aware Local Search**\n- **Implementation**: Uses binary search on the objective by transforming the non-linear pressure formula into linear constraints, employing multiple best-fit strategies, and refines the result using local search with variance reduction.\n- **Performance**: Achieved a high combined score of 26.23 with 100% success rate and fast execution (0.022s).\n- **Feedback**: The linearization of the objective enabled robust binary search bounds, while using sum-of-squares tie-breaking during local search was critical for fine-tuning load balance across GPUs.\n**Program Identifier:** Generation 23 - Patch Name local_search_variance_tiebreaking - Correct Program: True\n\n**Program Name: Multi-Strategy Binary Search with Guided Iterated Local Search**\n- **Implementation**: Uses binary search over virtual capacity with varied sorting strategies (FFD/BFD) for initialization, refined by bottleneck-targeted moves, swaps, and a multi-GPU ruin-and-recreate local search.\n- **Performance**: Achieved a combined score of 26.23 with 100% success rate and extremely fast execution (0.007s).\n- **Feedback**: The approach effectively balances load by specifically targeting the highest-pressure GPU during refinement, while the multi-heuristic initialization ensures robust feasibility handling even in tight constraints.\n**Program Identifier:** Generation 24 - Patch Name multistrategy_binsearch_guided_ils - Correct Program: True\n\n**Program Name: Robust Binary Search with Ruin and Recreate LNS Refinement**\n- **Implementation**: Uses binary search with multi-heuristic Best Fit Decreasing packing for initialization, followed by Large Neighborhood Search via \"Ruin and Recreate\" to optimize bottlenecks.\n- **Performance**: Achieved a combined score of 26.26 with 100% success and very fast execution (0.03s).\n- **Feedback**: The multi-heuristic packing initialization provides a strong starting point, and the targeted Ruin and Recreate strategy efficiently smooths out pressure spikes across GPUs.\n**Program Identifier:** Generation 25 - Patch Name robust_lns_packing - Correct Program: True\n\n**Program Name: Binary Search with Multi-Heuristic Packing and Simulated Annealing**\n- **Implementation**: Utilizes binary search to minimize max KV pressure by checking feasibility with multiple packing heuristics (FFD/BFD on various sort keys), intended to be refined by a simulated annealing local search.\n- **Performance**: Score: 0.00 (Failed); the program fails execution due to a runtime error.\n- **Feedback**: The main function calls an undefined `_large_neighborhood_search` instead of the implemented `_simulated_annealing`, causing a crash; fixing this naming error is essential to evaluate the otherwise sophisticated packing logic.\n**Program Identifier:** Generation 26 - Patch Name lns_refinement - Correct Program: False\n\n**Program Name: Binary Search Packing with LNS Refinement**\n- **Implementation**: The algorithm utilizes binary search to minimize KV cache pressure, employing Best-Fit Decreasing with multiple sorting heuristics (density, virtual size) to verify feasibility at each step. A post-processing Large Neighborhood Search (Ruin and Recreate) iteratively refines the solution by targeting and re-optimizing the bottleneck GPU.\n- **Performance**: The solution achieved a combined score of 26.26 with a 100% success rate and extremely fast execution (0.023s).\n- **Feedback**: The approach effectively linearizes the pressure constraint into a virtual bin packing problem, allowing robust standard heuristics to find valid solutions quickly, while LNS successfully reduces the maximum pressure in tight configurations.\n**Program Identifier:** Generation 27 - Patch Name binary_search_bfd_lns_recreate - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Simulated Annealing**\n- **Implementation**: The solution employs binary search over the KVPR target using multi-heuristic bin packing (FFD/BFD) for initialization, followed by a simulated annealing refinement stage to balance loads.\n- **Performance**: Achieved a score of 0.00 with 0% success rate due to a runtime error.\n- **Feedback**: The program crashes because it calls an undefined function `_large_neighborhood_search` instead of the implemented `_simulated_annealing_refinement`; fixing this naming mismatch is required for functionality.\n**Program Identifier:** Generation 28 - Patch Name lns_ruin_recreate - Correct Program: False\n\n**Program Name: Robust Binary Search with Multi-Strategy Packing and Local Search**\n- **Implementation**: This approach combines a binary search for the pressure bound using four sorting heuristics and Best/First-Fit packing with an Iterated Local Search (Ruin & Recreate) for refinement. The local search specifically targets the bottleneck GPU to redistribute load using a greedy best-fit strategy with stochastic acceptance.\n- **Performance**: The algorithm achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution time (0.006s).\n- **Feedback**: The use of multiple sorting heuristics during the construction phase ensures robust feasibility detection across varied inputs. The subsequent local search effectively optimizes the specific KV pressure metric by escaping local optima through plateau traversal and random walks.\n**Program Identifier:** Generation 29 - Patch Name robust_binary_search_with_ils - Correct Program: True\n\n**Program Name: Hybrid Robust Binary Search with Large Neighborhood Search**\n- **Implementation**: The algorithm utilizes binary search on virtual item sizes ($load + K \\times size$) with multi-strategy BFD/FFD packing for initialization, followed by bottleneck-targeted Large Neighborhood Search using move, swap, and ruin-recreate operations.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and exceptional speed (0.008s).\n- **Feedback**: The multi-strategy packing ensures robust initial feasibility, while the hybrid LNS effectively targets high-pressure GPUs to refine the solution without significant computational overhead.\n**Program Identifier:** Generation 30 - Patch Name hybrid_robust_lns - Correct Program: True\n\n**Program Name: Binary Search Packing with Variance-Reducing Local Search**\n- **Implementation**: Solves the non-linear objective by binary searching on pressure targets using multiple best-fit packing strategies, refined by iterated local search with variance reduction tie-breaking.\n- **Performance**: Achieved a combined score of 26.26 with 100% success rate and negligible execution time (0.016s).\n- **Feedback**: The transformation to a linear packing problem via binary search provides a strong initialization, while the variance-aware local search effectively eliminates bottleneck outliers.\n**Program Identifier:** Generation 31 - Patch Name best_fit_descent_variance - Correct Program: True\n\n**Program Name: Robust BFD Binary Search with Best-Improvement ILS**\n- **Implementation**: Combines binary search using multi-heuristic Best-Fit Decreasing for initialization with Iterated Local Search employing best-improvement descent and variance-based tie-breaking for refinement.\n- **Performance**: Achieves a high score of 26.23 with extremely fast execution (0.045s) and a 100% success rate.\n- **Feedback**: The use of multiple sorting heuristics ensures valid initial placements, while variance tie-breaking in the local search effectively balances pressure distribution beyond simple peak minimization.\n**Program Identifier:** Generation 32 - Patch Name robust_bfd_search_best_improvement_ils - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent ILS**\n- **Implementation**: The algorithm initializes placements via binary search using Best-Fit Decreasing with multiple sorting heuristics, then refines the solution using steepest descent local search with variance-based tie-breaking and random \"burst kicks\" to escape local optima.\n- **Performance**: It achieved a high combined score of 26.26 with a 100% success rate and extremely fast execution time (0.018s).\n- **Feedback**: The use of multiple sorting heuristics ensures a high-quality initial configuration, while the variance-aware descent and burst kicks effectively resolve bottleneck GPUs without getting trapped in local minima.\n**Program Identifier:** Generation 33 - Patch Name bfd_packing_steepest_descent_ils - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with Iterated Local Search**\n- **Implementation**: Utilizes binary search on a transformed linear packing constraint with multi-strategy heuristics, followed by iterated local search employing variance-minimizing swaps and randomized multi-GPU repacking perturbations.\n- **Performance**: Achieved a combined score of 26.26 with a 100% success rate and efficient execution (0.038s).\n- **Feedback**: The approach effectively linearizes the non-linear KVPR objective for initial packing, while the descent-based refinement with burst kicks robustly optimizes the bottleneck GPU.\n**Program Identifier:** Generation 34 - Patch Name randomized_bs_and_perturbation - Correct Program: True\n\n**Program Name: Hybrid Binary Packing with Ruin-Recreate Local Search**\n- **Implementation**: The algorithm employs binary search over a virtual capacity parameter using Best-Fit Decreasing with multiple sorting heuristics, followed by an Iterated Local Search that utilizes steepest descent moves/swaps and a targeted ruin-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and efficient execution time of 0.141s.\n- **Feedback**: The \"virtual size\" formulation effectively balances memory and load constraints during initialization, while the ruin-and-recreate strategy targeting bottleneck GPUs allows the solver to escape local optima that simple local swaps cannot resolve.\n**Program Identifier:** Generation 35 - Patch Name hybrid_packing_lns - Correct Program: True\n\n**Program Name: Binary Search with Multi-Strategy Packing and Variance-Aware Local Search**\n- **Implementation**: Solves the non-linear placement problem by binary searching on a linearized constraint using diverse packing heuristics, refined by an iterated local search with best-improvement descent and sum-of-squares tie-breaking.\n- **Performance**: Achieved a top-tier score of 26.26 with high efficiency (0.032s) and 100% reliability.\n- **Feedback**: The use of multiple sorting strategies during the binary search phase effectively creates a robust starting point, while the variance-minimizing tie-breaker in the local search phase helps flatten pressure spikes across GPUs.\n**Program Identifier:** Generation 36 - Patch Name best_improvement_ils_variance - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent and Burst Kicks**\n- **Implementation**: Initializes via binary search on KV pressure using multi-heuristic Best Fit Decreasing, followed by steepest descent local search targeting bottleneck GPUs with random burst kicks for escape.\n- **Performance**: Achieved a high score of 26.26 and optimal KVPR of 25.256 with rapid execution (0.053s).\n- **Feedback**: Multiple sorting heuristics during initialization provide a strong starting point, while the variance-aware local search effectively balances load across GPUs.\n**Program Identifier:** Generation 37 - Patch Name robust_bfd_steepest_ils - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Ruin and Recreate Refinement**\n- **Implementation**: Utilizes binary search on pressure bounds with multiple sorting heuristics and bin packing algorithms (BFD, FFD) to determine feasibility. The solution is further optimized using Iterated Local Search with a \"Ruin and Recreate\" mechanism to redistribute load from bottleneck GPUs.\n- **Performance**: Achieved a combined score of 26.26 with 100% success rate and 0.006s execution time.\n- **Feedback**: The use of diverse sorting strategies significantly improves the binary search's ability to find tight lower bounds, while the local search effectively smooths out pressure spikes.\n**Program Identifier:** Generation 38 - Patch Name steepest_descent_variance_ils - Correct Program: True\n\n**Program Name: BFD Binary Search with Best-Improvement LNS**\n- **Implementation**: Uses binary search coupled with Best-Fit Decreasing packing across multiple sorting heuristics to establish an initial bound, followed by Iterated Local Search (ILS) with best-improvement moves and ruin-recreate perturbation.\n- **Performance**: Achieves a strong score of 26.26 with 100% success rate and rapid execution (0.048s).\n- **Feedback**: The multi-heuristic initialization provides a high-quality starting point, while the variance-aware local search effectively smooths bottlenecks, preventing the solver from getting stuck in poor local optima.\n**Program Identifier:** Generation 39 - Patch Name bfd_binary_search_best_descent_lns - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Variance-Aware Iterated Local Search**\n- **Implementation**: Utilizes binary search over pressure bounds with multi-heuristic BFD/FFD packing (sorting by virtual size, physical size, or density) to find an initial solution, followed by an Iterated Local Search that optimizes moves and swaps using variance reduction for tie-breaking.\n- **Performance**: Achieved an excellent combined score of 26.26 with a perfect success rate and minimal execution time (0.012s).\n- **Feedback**: The combination of diverse sorting strategies in the packing phase ensures robust feasibility, while the variance-minimizing logic in the local search effectively smooths out pressure spikes across GPUs to lower the maximum bottleneck.\n**Program Identifier:** Generation 40 - Patch Name robust_ils_bfd - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with LNS Refinement**\n- **Implementation**: The algorithm initializes using a binary search for the optimal pressure bound, employing Best Fit Decreasing with multiple sorting strategies (density, virtual size, physical size) to check feasibility. It refines this solution via Large Neighborhood Search (LNS) that targets bottleneck GPUs with moves/swaps and uses a randomized \"burst kick\" perturbation to escape local optima.\n- **Performance**: The solution achieved a high combined score of 26.26 and a 100% success rate with extremely fast execution (0.017s).\n- **Feedback**: The multi-strategy initialization provides a high-quality starting point, while the focus on variance reduction and bottleneck relief in the LNS phase effectively smoothes load distribution. The randomized perturbation strategy allows the solver to robustly handle edge cases without significant computational overhead.\n**Program Identifier:** Generation 41 - Patch Name hybrid_binary_lns_placement - Correct Program: True\n\n**Program Name: Multi-Strategy Binary Search with Bottleneck-Aware ILS**\n- **Implementation**: Combines binary search on transformed constraints using multiple Best Fit strategies for initialization with an Iterated Local Search that employs bottleneck-focused moves/swaps and a selective perturbation mechanism to repack specific GPUs.\n- **Performance**: Achieved a combined score of 26.26 with a 100% success rate and extremely low latency (0.075s).\n- **Feedback**: The linearization of the non-linear objective during binary search provides a strong initial solution, while the targeted perturbation strategy effectively escapes local optima where simple swaps fail.\n**Program Identifier:** Generation 42 - Patch Name binary_search_ils_smart_perturb - Correct Program: True\n\n**Program Name: Binary Search BFD with Lexicographical Descent**\n- **Implementation**: Utilizes binary search on target pressure with Best Fit Descending to generate an initial placement, followed by a local search that lexicographically minimizes the pressure vector using bottleneck-focused moves, swaps, and random perturbations.\n- **Performance**: The algorithm achieved a high combined score of 26.26 with 100% success rate and low latency (0.015s).\n- **Feedback**: The strategy of converting the fractional pressure objective into a linear bin-packing constraint during initialization proved highly effective, while lexicographical optimization ensured robust load balancing across the cluster.\n**Program Identifier:** Generation 43 - Patch Name lexicographical_descent_placement - Correct Program: True\n\n**Program Name: Robust Binary Search with VNS and Variance-Based Refinement**\n- **Implementation**: Initializes using binary search over load factors with multiple packing heuristics (BFD/FFD), then refines via Variable Neighborhood Search using variance-reducing swaps and ruin-and-recreate kicks.\n- **Performance**: Achieves a strong score of 26.23 with 100% success rate and minimal execution time (0.016s).\n- **Feedback**: The multi-strategy feasibility check provides high-quality initial bounds, while secondary variance reduction in local search effectively balances loads across GPUs to minimize peak pressure.\n**Program Identifier:** Generation 44 - Patch Name vns_variance_tiebreaking - Correct Program: True\n\n**Program Name: Binary Search Packing with Bottleneck-Focused Local Search**\n- **Implementation**: The algorithm linearizes the non-linear pressure constraint into an \"effective size\" metric to perform binary search initialization using multi-strategy Best Fit Decreasing. It refines this solution using Iterated Local Search that specifically targets the highest-pressure GPU with swap/move operations and a partial ruin-and-recreate perturbation strategy.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and extremely low latency (0.040s).\n- **Feedback**: The algebraic transformation of the objective function ($w + K \\cdot s$) enabled a highly effective initialization relative to standard heuristics. Focusing local search moves exclusively on the bottleneck GPU (highest KVPR) proved to be a computationally efficient strategy for minimizing the maximum objective.\n**Program Identifier:** Generation 45 - Patch Name replace_vnd_with_ils - Correct Program: True\n\n**Program Name: Robust Binary Search with Variance-Smoothing Iterated Local Search**\n- **Implementation**: Utilizes binary search with multi-heuristic Best-Fit Decreasing for initialization, followed by an iterated local search that reduces load variance and employs random burst kicks to escape local optima.\n- **Performance**: Achieved a combined score of 26.26 with a perfect success rate and fast execution (0.011s).\n- **Feedback**: The approach effectively balances initial packing quality with fine-grained optimization, using variance smoothing to guide the search when the primary objective plateaus.\n**Program Identifier:** Generation 46 - Patch Name binary_search_bfd_variance_descent - Correct Program: True\n\n**Program Name: Randomized Binary Search Packing with Variance-Aware ILS**\n- **Implementation**: Combines randomized Best-Fit Decreasing binary search to find a tight initial layout, refined by Iterated Local Search minimizing peak pressure and load variance using moves and swaps.\n- **Performance**: Achieved a combined score of 26.26 with 100% success rate and fast execution (0.020s).\n- **Feedback**: Random shuffling during the packing feasibility check improves robustness for tight constraints, while minimizing load variance helps the local search escape plateaus in peak pressure optimization.\n**Program Identifier:** Generation 47 - Patch Name randomized_binary_packing_ils - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with LNS Refinement**\n- **Implementation**: The algorithm initializes utilizing binary search with multi-strategy Best Fit Decreasing to find a bounding pressure, then refines the solution via Large Neighborhood Search (LNS) using targeted moves, swaps, and randomized ruin-and-recreate perturbations on bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and rapid execution time (0.044s).\n- **Feedback**: The two-phase approach effectively balances global load distribution constraints with local optimization, where the targeted ruin-and-recreate strategy proved essential for escaping local optima and minimizing maximum pressure.\n**Program Identifier:** Generation 48 - Patch Name smart_perturbation_with_trials - Correct Program: True\n\n**Program Name: Binary Search BFD with Variance-Smoothing Iterated Local Search**\n- **Implementation**: Uses binary search with multi-heuristic Best-Fit Decreasing for initial packing, followed by Iterated Local Search that employs variance reduction for tie-breaking and random burst perturbations to escape local optima.\n- **Performance**: Achieved a high combined score of 26.26 with 100% success rate and fast execution (0.053s).\n- **Feedback**: The variance-smoothing strategy effectively flattens load distribution to minimize peak pressure, while the multi-heuristic packing ensures robust initial feasible solutions.\n**Program Identifier:** Generation 49 - Patch Name randomized_packing_and_swap_kicks - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with Bottleneck-Focused Local Search**\n- **Implementation**: Computes initial placement via binary search over pressure targets using multiple sorting strategies, then refines it using iterated local search with bottleneck-targeted moves, swaps, and ruin-recreate perturbations.\n- **Performance**: Achieves excellent load balancing with a score of 26.26 and 0.026s execution time.\n- **Feedback**: The multi-strategy initialization provides a strong starting point, while the focused local search effectively reduces peak pressure by redistributing load from the most constrained GPU.\n**Program Identifier:** Generation 50 - Patch Name bfd_binary_search_ils_ruin_recreate - Correct Program: True\n\n**Program Name: Binary Search Initialization with Guided Variable Neighborhood Descent**\n- **Implementation**: This solution initializes placement using a binary search over a load-size trade-off parameter with multiple sorting strategies, followed by a Variable Neighborhood Descent targeting the bottleneck GPU. The refinement phase employs shift and swap moves to minimize maximum pressure and utilizes a randomized \"burst perturbation\" on the bottleneck and least-loaded GPUs to escape local optima.\n- **Performance**: The algorithm achieved a high combined score of 26.26 and a 100% success rate with very fast execution (0.037s).\n- **Feedback**: The multi-strategy initialization ensures a high-quality starting point, while the secondary objective of minimizing the sum of squared pressures effectively smooths load distribution when maximum pressure cannot be directly reduced.\n**Program Identifier:** Generation 51 - Patch Name guided_vnd_packing - Correct Program: True\n\n**Program Name:** Hybrid Binary Search with Bottleneck-Targeted Iterated Local Search\n- **Implementation:** This approach initializes via binary search over pressure thresholds using multiple sorting heuristics (density, virtual size), followed by an Iterated Local Search that specifically targets the bottleneck GPU with moves, swaps, and randomized destructive repacking.\n- **Performance:** The algorithm achieved a strong combined score of 26.26 with a 100% success rate and low latency (0.074s).\n- **Feedback:** The multi-strategy binary search initialization provides a high-quality starting solution, while the bottleneck-focused perturbation logic effectively escapes local optima to further minimize maximum pressure.\n**Program Identifier:** Generation 52 - Patch Name robust_init_and_kick - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Burst-Kick Local Search**\n- **Implementation**: Solves the fractional objective via binary search using multi-heuristic Best-Fit Decreasing, refined by steepest descent local search with variance reduction and random burst perturbations to escape optima.\n- **Performance**: Achieved a score of 26.26 with 100% success rate and 0.022s execution time.\n- **Feedback**: The transformation of the non-linear pressure objective into a linear bin packing problem combined with variance-aware refinement proved highly effective for load balancing.\n**Program Identifier:** Generation 53 - Patch Name burst_ils_bfd - Correct Program: True\n\n**Program Name: Binary Search Packing with Smart-Perturbation Iterated Local Search**\n- **Implementation**: Combines binary search using transformed Best-Fit constraints for initialization with an Iterated Local Search that utilizes bottleneck-focused swaps and a multi-strategy \"burst kick\" perturbation to repack victim GPUs.\n- **Performance**: Achieved a high combined score of 26.26 with 100% success rate and fast execution (0.278s).\n- **Feedback**: The hybrid approach effectively balances global constraint satisfaction with local refinement, efficiently escaping local optima through the randomized perturbation strategy while maintaining low latency.\n**Program Identifier:** Generation 54 - Patch Name improved_ils_perturbation - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent ILS**\n- **Implementation**: The solution employs binary search over KV cache pressure using multiple Best-Fit Decreasing sorting heuristics (size, density, load) to generate robust initial placements. This is refined by a steepest descent algorithm with \"burst kick\" ruin-and-recreate perturbations to escape local optima.\n- **Performance**: Achieved a combined score of 26.26 with 100% success rate and low execution time (0.042s).\n- **Feedback**: The combination of diverse sorting strategies ensures feasibility across varied inputs, while the aggressive local search effectively balances load to minimize the maximum KV cache pressure.\n**Program Identifier:** Generation 55 - Patch Name replace_burst_kick_with_lns_recreate - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent Local Search**\n- **Implementation**: The algorithm initializes placements using binary search with multiple sorting heuristics (load, size, density) and packing strategies (BFD, FFD), followed by an iterated local search that targets bottleneck GPUs using steepest descent moves, swaps, and ruin-and-recreate perturbations.\n- **Performance**: It achieves a high combined score of 26.23 with a 100% success rate and fast execution (0.098s), validating the efficiency of the hybrid approach.\n- **Feedback**: The multi-heuristic initialization ensures valid starting solutions even under tight constraints, while the variance-aware local search effectively minimizes peak pressure by iteratively smoothing load imbalances.\n**Program Identifier:** Generation 56 - Patch Name hybrid_ils_lns_refinement - Correct Program: True\n\n**Program Name: Hybrid Binary Search and Guided Local Search Placement**\n- **Implementation**: The algorithm employs binary search with best-fit decreasing heuristics to find a feasible pressure bound, followed by a guided local search to reduce peak pressure via relocation and swapping.\n- **Performance**: Failed completely (score 0.00) due to an implementation bug causing runtime crashes.\n- **Feedback**: The transition between the binary search and local search phases is broken, as the code attempts to access dictionary methods (`.items()`) on a list object, preventing execution.\n**Program Identifier:** Generation 57 - Patch Name flow_guided_search - Correct Program: False\n\n**Program Name: Hybrid Binary Search Packing with Large Neighborhood Search**\n- **Implementation**: The solution initializes via binary search on pressure bounds using multiple sorting heuristics (density, virtual size), followed by Large Neighborhood Search (LNS) that iteratively relieves the bottleneck GPU through moves, swaps, and randomized partial repacking.\n- **Performance**: The approach yielded a high combined score of 26.26 and 100% success rate with rapid execution (0.082s).\n- **Feedback**: The multi-strategy initialization ensures a high-quality starting point, while the LNS phase's specific focus on the highest-pressure GPU and randomized destructive moves effectively breaks local optima to minimize peak pressure.\n**Program Identifier:** Generation 58 - Patch Name bs_random_fallback_and_robust_perturbation - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent ILS**\n- **Implementation**: Utilizes binary search on virtual capacity with multiple Best-Fit Decreasing sorting heuristics (virtual size, density) for initialization, followed by steepest descent refinement with \"ruin and recreate\" kicks.\n- **Performance**: Achieves a strong combined score of 26.26 with 100% success rate and very low latency (0.073s).\n- **Feedback**: The multi-heuristic sorting ensures valid initial placements even for tight constraints, while the localized search effectively balances the bottleneck GPU without comprehensive global optimization overhead.\n**Program Identifier:** Generation 59 - Patch Name robust_init_and_plateau_traversal - Correct Program: True\n\n**Program Name: Robust BFD Binary Search with Guided First-Improvement ILS**\n- **Implementation**: Combines binary search over Best-Fit Decreasing packing with multiple sorting heuristics and randomized fallbacks for robust initialization. Refines the solution using Guided First-Improvement Iterated Local Search (ILS) that prioritizes bottleneck GPUs, uses variance reduction for tie-breaking, and employs burst kicks to escape local optima.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and minimal execution time (0.049s).\n- **Feedback**: The multi-heuristic constructive phase ensures valid initial packings even under tight constraints, while the variance-aware local search effectively optimizes load distribution on solution plateaus where the maximum pressure is momentarily constant.\n**Program Identifier:** Generation 60 - Patch Name bfd_guided_ils - Correct Program: True\n\n**Program Name: Binary Search Initialization with Lexicographical Descent Local Search**\n- **Implementation**: The algorithm initializes using binary search on target pressure with multi-strategy bin packing, then refines via local search minimizing the lexicographically sorted pressure vector using bottleneck-focused moves and swaps. It incorporates a ruin-and-recreate perturbation mechanism with randomized greedy repacking to escape local optima.\n- **Performance**: The solution achieved a high combined score of 26.25 with a 100% success rate and rapid execution time (0.064s).\n- **Feedback**: The binary search initialization provides a strong starting point by approximating the minimax objective, while the lexicographical approach optimizes the broader pressure distribution beyond just the peak. The perturbation strategy successfully resolves stagnation when simple local moves are exhausted.\n**Program Identifier:** Generation 61 - Patch Name init_strat_and_smart_kick - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Variance-Smoothing Iterated Local Search**\n- **Implementation**: Uses binary search on a pressure parameter with multi-heuristic Best-Fit Decreasing for initialization, followed by Iterated Local Search using variance reduction and random burst kicks to escape local optima.\n- **Performance**: Achieved a high score of 26.26 with 100% success rate and fast execution (0.099s).\n- **Feedback**: The \"virtual size\" packing heuristic effectively approximates the objective for initialization, while variance smoothing in the local search successfully balances load to minimize peak pressure.\n**Program Identifier:** Generation 62 - Patch Name density_ils_and_directed_kick - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with LNS Refinement**\n- **Implementation**: The solution combines a binary search using multiple packing heuristics (density, load, size) for initialization with a Large Neighborhood Search (LNS) that optimizes the bottleneck GPU via item moves, swaps, and randomized group repacking.\n- **Performance**: The approach achieved a high combined score of 26.26 and a 100% success rate with an execution time of 0.101s.\n- **Feedback**: The multi-strategy initialization ensures robust feasibility, while the LNS effectively minimizes peak pressure by using variance-reducing acceptance criteria and a perturbation strategy to escape local optima.\n**Program Identifier:** Generation 63 - Patch Name smart_kick_diverse_repack - Correct Program: True\n\n**Program Name: Binary Search Packing with Steepest Descent and Burst Kicks**\n- **Implementation**: Uses binary search with multi-heuristic bin packing for initialization, followed by Iterated Local Search applying steepest descent with variance reduction tie-breaking and random burst kicks to escape local optima.\n- **Performance**: The solution achieved a combined score of 26.26 with a perfect success rate and rapid execution time (0.018s).\n- **Feedback**: The multi-strategy packing ensures strong initial placement, while the variance-aware refinement and burst kicks effectively balance load across GPUs, preventing the solver from stalling in poor local minima.\n**Program Identifier:** Generation 64 - Patch Name steepest_descent_ils_burst - Correct Program: True\n\n**Program Name: Binary Search BFD with Variance-Smoothing Iterated Local Search**\n- **Implementation**: Implements binary search on the max KV pressure using multi-heuristic Best-Fit Decreasing for feasibility checks, followed by an Iterated Local Search that uses load variance reduction as a secondary objective to break ties.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and exceptional speed (0.056s).\n- **Feedback**: The two-stage approach efficiently balances global exploration via binary search with fine-grained local optimization, where variance smoothing helps flatten load distribution to enable further peak reduction.\n**Program Identifier:** Generation 65 - Patch Name perturbed_sorting_and_targeted_ils - Correct Program: True\n\n**Program Name: Multi-Strategy Binary Search with Iterated Local Search**\n- **Implementation**: The algorithm utilizes binary search to find the minimum feasible pressure using multiple Best-Fit Decreasing packing strategies, followed by an Iterated Local Search that refines the solution via bottleneck-focused swaps and a \"Ruin and Recreate\" perturbation mechanism.\n- **Performance**: Achieved a combined score of 26.26 with a max KVPR metric of 25.26, maintaining a 100% success rate and fast execution (0.059s).\n- **Feedback**: The combination of global bound optimization via binary search and local refinement effectively handles diverse model constraints, significantly reducing peak pressure by smoothing out load imbalances.\n**Program Identifier:** Generation 66 - Patch Name randomized_pack_and_diverse_perturbation - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Steepest Descent ILS**\n- **Implementation**: Combines binary search using multi-heuristic Best-Fit Decreasing for initial placement with an Iterated Local Search employing steepest descent and ruin-and-recreate strategies to escape local optima.\n- **Performance**: 0.00 score and 0% success rate due to a critical runtime error (NameError).\n- **Feedback**: The program fails because it attempts to call `_guided_local_search`, which is undefined, instead of the implemented `_steepest_descent_ils`; correcting the function call is essential for execution.\n**Program Identifier:** Generation 67 - Patch Name guided_local_search - Correct Program: False\n\n**Program Name: Hybrid Binary Search Packing with Large Neighborhood Search**\n- **Implementation**: Uses binary search with multiple sorting heuristics (density, size, load) for initial packing, followed by Large Neighborhood Search employing moves, swaps, and randomized repacking to relieve bottleneck GPUs.\n- **Performance**: Achieved a score of 26.26 with 100% success rate and 0.121s execution time.\n- **Feedback**: The multi-strategy initialization ensures a high-quality starting point, while the bottleneck-targeted refinement logic effectively reduces peak pressure through targeted perturbations.\n**Program Identifier:** Generation 68 - Patch Name ordered_first_improvement - Correct Program: True\n\n**Program Name: Robust Binary Search with Multi-Heuristic Packing and Local Search**\n- **Implementation**: The algorithm initializes with binary search using multiple bin-packing heuristics (FFD/BFD with various sorting keys), followed by steepest descent local search with variance tie-breaking and ruin-and-recreate kicks for refinement.\n- **Performance**: It achieved a combined score of 26.26 with a 100% success rate and extremely fast execution time of 0.049s.\n- **Feedback**: The combination of robust initial packing and variance-aware local search effectively balances load, minimizing peak pressure while maintaining high computational efficiency.\n**Program Identifier:** Generation 69 - Patch Name lns_ils - Correct Program: True\n\n**Program Name: Binary Search BFD with Guided Iterated Local Search**\n- **Implementation**: Uses binary search with multi-strategy Best-Fit Decreasing to find an initial allocation by linearizing the pressure constraint, followed by Guided Iterated Local Search targeting bottleneck GPUs via heuristic moves and swaps.\n- **Performance**: Achieved a high score of 26.21 with extremely fast execution (0.055s) and perfect stability.\n- **Feedback**: Linearly transforming the non-linear pressure constraint enabled effective use of standard bin-packing heuristics, while the bottleneck-focused local search efficiently refined the distribution.\n**Program Identifier:** Generation 70 - Patch Name hybrid_bfd_ils_guided - Correct Program: True\n\n**Program Name: Binary Search Packing with Iterated Local Search**\n- **Implementation**: The algorithm employs binary search on the target pressure using multiple best-fit packing strategies, followed by an iterated local search that refines the solution through bottleneck-focused swaps and ruin-and-recreate perturbations.\n- **Performance**: It achieved a high combined score of 26.26 with a 100% success rate and minimal execution time (0.072s).\n- **Feedback**: The combination of diverse packing heuristics during the global search and targeted local optimization effectively minimizes the maximum KV cache pressure across GPUs.\n**Program Identifier:** Generation 71 - Patch Name optimize_pack_and_recreate - Correct Program: True\n\n**Program Name: Binary Search Packing with Large Neighborhood Search Refinement**\n- **Implementation**: Initializes placement using binary search over maximum pressure with multiple Best Fit Decreasing heuristics, then refines via Large Neighborhood Search using bottleneck-focused moves, swaps, and randomized repacking perturbations.\n- **Performance**: Achieved a high score of 26.26 with a 1.0 success rate and fast 0.075s execution time.\n- **Feedback**: The combination of binary search for initial bounding and LNS for fine-tuning effectively minimizes peak pressure, while the perturbation mechanism robustly handles local optima.\n**Program Identifier:** Generation 72 - Patch Name robust_init_and_targeted_kick - Correct Program: True\n\n**Program Name: Binary Search Initialization with Lexicographical Iterated Local Search**\n- **Implementation**: The algorithm initializes using binary search on a linearized pressure constraint with multi-heuristic Best Fit, followed by an Iterated Local Search that minimizes the sorted pressure vector via bottleneck-focused moves and swaps.\n- **Performance**: Achieved a high combined score of 26.26 and 100% success rate with negligible execution time (0.038s).\n- **Feedback**: Transforming the fractional pressure objective into a linear bin-packing constraint proved highly effective for initialization, while the bottleneck-targeted local search efficiently refined the load balance without getting stuck in local optima.\n**Program Identifier:** Generation 73 - Patch Name lexicographical_ils_placement - Correct Program: True\n\n**Program Name: Hybrid Randomized Packing with LNS-Enhanced Variance ILS**\n- **Implementation**: Uses randomized Best Fit Decreasing within a binary search for initialization, followed by Iterated Local Search combining variance-based steepest descent and Large Neighborhood Search (Ruin & Recreate) to relieve bottlenecks.\n- **Performance**: Achieved a high score of 26.26 (KVPR 25.26) with 100% success rate and rapid execution (0.014s).\n- **Feedback**: The targeted \"Ruin & Recreate\" strategy on bottleneck GPUs proved highly effective for escaping local optima, while the variance metric in descent improved overall load balancing.\n**Program Identifier:** Generation 74 - Patch Name hybrid_lns_variance_ils - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with LNS Ruin-Recreate Refinement**\n- **Implementation**: The algorithm initializes using binary search over multiple packing heuristics (BFD/FFD with various sorting keys) to minimize max pressure, followed by Large Neighborhood Search (LNS) combining bottleneck-focused \"ruin and recreate\" with steepest descent moves and swaps.\n- **Performance**: Achieved a high combined score of 26.26 and 100% success rate with exceptional speed (0.017s).\n- **Feedback**: The multi-heuristic initialization ensures high-quality starting solutions, while the LNS refinement effectively balances exploration (randomized ruin) and exploitation (variance-reducing descent) to escape local optima efficiently.\n**Program Identifier:** Generation 75 - Patch Name hybrid_lns_packing - Correct Program: True\n\n**Program Name: Binary Search with Transformed Constraints and Perturbation ILS**\n- **Implementation**: Uses binary search on the objective with transformed bin-packing constraints and multiple sort keys, refining the result via Iterated Local Search with bottleneck-focused swaps and randomized destructive repacking.\n- **Performance**: Achieved a combined score of 26.26 with 0.33s execution time and 100% success rate.\n- **Feedback**: The transformation of the pressure formula into a linear constraint enables effective heuristic packing, while the multi-victim perturbation strategy successfully escapes local optima in high-pressure scenarios.\n**Program Identifier:** Generation 76 - Patch Name optimize_search_speed - Correct Program: True\n\n**Program Name: Binary Search Packing with Variance-Smoothing Local Search**\n- **Implementation:** Combines binary search using multi-heuristic Best-Fit Decreasing for initial placement with Iterated Local Search that optimizes load variance to break plateaus and uses random burst kicks.\n- **Performance:** Achieved a high combined score of 26.26 (KVPR: 25.26) with 100% success and sub-100ms runtime.\n- **Feedback:** The virtual sizing strategy effectively models the non-linear constraint during packing, while variance smoothing proves crucial for refining solutions where the maximum load is hard to decrease directly.\n**Program Identifier:** Generation 77 - Patch Name ils_swap_always_and_multi_pack - Correct Program: True\n\n**Program Name: Binary Search Initialization with Lexicographical Local Search**\n- **Implementation**: The algorithm initializes by solving a transformed bin packing problem via binary search to find a feasible pressure target, followed by lexicographical descent optimization using moves, swaps, and randomized perturbation.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and efficient execution time (0.080s).\n- **Feedback**: Transforming the non-linear pressure objective into a linear bin packing constraint provided a strong initial solution, while the multi-GPU perturbation logic prevented stagnation in local optima during refinement.\n**Program Identifier:** Generation 78 - Patch Name lexicographic_ils_bfd - Correct Program: True\n\n**Program Name: Robust BFD Binary Search with Guided First-Improvement ILS**\n- **Implementation**: This approach combines binary search using Best-Fit Decreasing with multiple sorting heuristics for initialization, followed by a guided Iterated Local Search that prioritizes bottleneck GPUs and utilizes burst kicks to escape local optima.\n- **Performance**: The solution delivered strong results with a score of 26.23 (max_kvpr metric 25.233) and 100% success rate in 0.068s.\n- **Feedback**: The use of diverse sorting keys during packing ensures robust initial feasibility, while the targeted local search efficiently minimizes peak pressure by focusing moves on the highest-load items.\n**Program Identifier:** Generation 79 - Patch Name targeted_redistribution_kick - Correct Program: True\n\n**Program Name: Robust Binary Search with LNS Peak Shaving**\n- **Implementation**: Uses binary search with multi-heuristic Best-Fit Decreasing for initialization, refined by Large Neighborhood Search (LNS) employing steepest descent and ruin-recreate steps to equalize pressure.\n- **Performance**: Achieved a score of 26.26 with 100% success rate and minimal execution time (0.018s).\n- **Feedback**: The multi-heuristic feasibility check robustly handles constrained inputs, and the hybrid local search efficiently shaves peak pressure, resulting in high-quality placements.\n**Program Identifier:** Generation 80 - Patch Name lns_peak_shaving - Correct Program: True\n\n**Program Name: Binary Search Initialization with Lexicographical Descent Local Search**\n- **Implementation**: The algorithm initializes using binary search on a target pressure threshold with multi-strategy bin packing, followed by a local search that optimizes the entire sorted pressure vector using moves, swaps, and randomized perturbations.\n- **Performance**: The solution achieved a high combined score of 26.26 with a max KVPR metric of 25.256 and 100% success rate, indicating highly effective load balancing.\n- **Feedback**: The lexicographical descent strategy is particularly effective because it improves secondary bottlenecks when the global maximum is stalled, preventing the optimizer from converging prematurely on flat plateaus.\n**Program Identifier:** Generation 81 - Patch Name robust_perturbation_and_strategies - Correct Program: True\n\n**Program Name: Hybrid Binary Search with LNS Refinement**\n- **Implementation**: Combines binary search on pressure targets using virtual size bin packing for initialization, followed by Iterated Local Search (ILS) that performs greedy moves, swaps, and randomized perturbation to minimize bottlenecks.\n- **Performance**: The program achieved a score of 0.00 with a 0% success rate due to runtime errors.\n- **Feedback**: The perturbation phase causes a crash by attempting dictionary key access on raw Model objects; the algorithm must maintain metadata wrappers or recompute metrics from attributes during the refinement steps.\n**Program Identifier:** Generation 82 - Patch Name bs_bfd_ils_rebalance - Correct Program: False\n\n**Program Name: Hybrid Binary Search with Analytical Iterated Local Search**\n- **Implementation**: Combines binary search using multiple best-fit packing heuristics with an iterated local search that optimizes bottleneck GPUs via analytical swap/move operations and ruin-and-recreate perturbations.\n- **Performance**: Achieved a high score of 26.26 with 100% success rate and minimal execution time (0.055s).\n- **Feedback**: The strategy effectively balances initial solution quality with fine-grained optimization, leveraging analytical pressure updates to rapidly evaluate moves on the non-linear objective function without full re-computation.\n**Program Identifier:** Generation 83 - Patch Name improved_initialization_and_perturbation - Correct Program: True\n\n**Program Name:** Dual-Initialization ILS with Ejection Chains and Binary Search\n- **Implementation:** The solution selects the best of two initializations\u2014Binary Search transforming the objective into a bin-packing constraint and Greedy MinMax\u2014followed by Iterated Local Search using moves, swaps, and 3-way ejection chains on the bottleneck GPU. A perturbation step repacks the bottleneck and random bins to escape local optima.\n- **Performance:** The algorithm achieved a high combined score of 26.23 and a 100% success rate with an exceptionally fast execution time of 0.017s.\n- **Feedback:** Transforming the min-max pressure objective into a linear bin-packing constraint via binary search proved highly effective for initialization. Focusing local search operations exclusively on the highest-pressure GPU efficiently improved the objective function without wasting resources on non-critical bins.\n**Program Identifier:** Generation 84 - Patch Name minmax_greedy_ejection - Correct Program: True\n\n**Program Name: Robust Binary Search with Regret-Based Large Neighborhood Search**\n- **Implementation**: Utilizes binary search with multi-strategy Best Fit Decreasing for initialization, followed by Large Neighborhood Search employing variance reduction and regret-based ruin-and-recreate perturbation.\n- **Performance**: Achieved a high combined score of 26.26 with 100% success rate and low latency (0.026s).\n- **Feedback**: The regret-based reconstruction effectively handles tight constraints during local search, while the secondary sum-of-squares objective smooths load distribution to escape local optima.\n**Program Identifier:** Generation 85 - Patch Name min_kvpr_bs_balanced_lns - Correct Program: True\n\n**Program Name: Robust Binary Search with Multi-Strategy Packing and Local Search**\n- **Implementation**: Uses binary search on pressure constraints with multiple packing heuristics (BFD/FFD), followed by Steepest Descent Iterated Local Search using Ruin-and-Recreate perturbations.\n- **Performance**: Achieved a strong combined score of 26.26 with 100% success rate and fast execution (0.031s).\n- **Feedback**: The multi-heuristic initialization ensures a high-quality starting solution, while the \"Ruin and Recreate\" mechanism effectively escapes local optima to minimize peak pressure.\n**Program Identifier:** Generation 86 - Patch Name ils_with_lns_kick - Correct Program: True\n\n**Program Name: Binary Search with Iterated Local Search Optimization**\n- **Implementation**: The algorithm utilizes binary search on effective capacity to approximate optimal pressure by transforming the problem into bin packing, followed by an Iterated Local Search that refines the solution via bottleneck-focused moves, swaps, and randomized ruin-and-recreate perturbations.\n- **Performance**: It achieved a top-tier combined score of 26.26 with a perfect success rate and minimal execution time (0.086s).\n- **Feedback**: The strategy of obtaining a tight initial bound via problem transformation and then polishing with targeted local search proves highly effective for minimizing maximum pressure without incurring high computational costs.\n**Program Identifier:** Generation 87 - Patch Name bs_bfd_adaptive_ils - Correct Program: True\n\n**Program Name: Binary Search Packing with Adaptive Ruin & Recreate ILS**\n- **Implementation**: The solution initializes via binary search on a transformed virtual-size bin packing constraint, followed by Iterated Local Search using greedy bottleneck offloading and adaptive, randomized multi-GPU repacking.\n- **Performance**: Achieved a combined score of 26.22 with 100% success rate and fast execution (0.155s).\n- **Feedback**: Linearizing the non-linear pressure constraint enables robust initialization via standard bin packing heuristics, while the adaptive perturbation strategy effectively balances load by targeting specific bottleneck GPUs.\n**Program Identifier:** Generation 88 - Patch Name kv_pressure_min_ils - Correct Program: True\n\n**Program Name: Binary Search BFD with Best-Improvement LNS**\n- **Implementation**: Solves the placement problem using binary search over Best-Fit Decreasing packing with linearized constraints, refined by Iterated Local Search with best-improvement descents and ruin-recreate perturbation.\n- **Performance**: Achieved a strong score of 26.26 with 100% success rate and extremely fast execution (0.010s).\n- **Feedback**: The transformation of the non-linear constraint into a bin-packing check via binary search provides a high-quality initial solution, while the subsequent LNS efficiently polishes bottlenecks.\n**Program Identifier:** Generation 89 - Patch Name robust_multi_source_ils - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with Large Neighborhood Search**\n- **Implementation**: The algorithm initializes via binary search using multiple heuristic sorting strategies (density, virtual size) to minimize peak pressure. It refines this solution using Large Neighborhood Search (LNS) featuring bottleneck-targeted moves/swaps and a \"smart kick\" perturbation that repacks subsets of GPUs to escape local optima.\n- **Performance**: Achieved a combined score of 26.26 with a max_kvpr of 25.26, 100% success rate, and fast execution (0.116s).\n- **Feedback**: The multi-strategy initialization provides a high-quality starting point, while the localized perturbation logic effectively smooths out pressure spikes in the non-linear objective function without incurring high computational costs.\n**Program Identifier:** Generation 90 - Patch Name fix_density_calculation - Correct Program: True\n\n**Program Name: Robust Binary Search with Ruin & Recreate LNS**\n- **Implementation**: The algorithm initializes with a binary search over pressure bounds using multiple packing heuristics (FFD/BFD), then refines the solution via Large Neighborhood Search using steepest descent and randomized \"Ruin & Recreate\" perturbations.\n- **Performance**: Achieved a high score of 26.26 with a 100% success rate and extremely fast execution (0.030s).\n- **Feedback**: The use of diverse sorting strategies during the initial packing phase ensures strong feasibility, while the \"Ruin & Recreate\" mechanism effectively escapes local optima to minimize maximum pressure. The low latency indicates the heuristics are highly computationally efficient.\n**Program Identifier:** Generation 91 - Patch Name lns_steepest_descent_refinement - Correct Program: True\n\n**Program Name: Multi-Heuristic Packing with Large Neighborhood Search Refinement**\n- **Implementation**: Uses binary search on the objective with four distinct Best Fit Decreasing heuristics (virtual size, physical size, density) followed by Large Neighborhood Search (Ruin and Recreate) for refinement.\n- **Performance**: Achieved a high combined score of 26.26 with 100% success rate and very fast execution time (0.021s).\n- **Feedback**: The combination of diverse packing strategies ensures feasibility for tight constraints, while the ruin-and-recreate local search effectively balances loads across GPUs to minimize the maximum pressure.\n**Program Identifier:** Generation 92 - Patch Name bfd_lns_refinement - Correct Program: True\n\n**Program Name: Binary Search Packing with Lexicographical Descent ILS**\n- **Implementation**: The algorithm initializes by transforming the non-linear pressure objective into a linear constraint, solved via binary search and multi-heuristic Best Fit Descending. It refines this solution using Iterated Local Search (ILS) that performs lexicographical descent, specifically targeting moves and swaps on the highest-pressure GPUs to lower the maximum load.\n- **Performance**: Achieved a high inverse KVPR score of 25.23 with extremely fast execution time (0.013s) and 100% success rate.\n- **Feedback**: The transformation of the objective function allows for a highly effective initial packing, while the lexicographical descent ensures the local search consistently reduces the specific bottleneck determining the maximum pressure.\n**Program Identifier:** Generation 93 - Patch Name init_and_local_search_improvements - Correct Program: True\n\n**Program Name: Robust Binary Search Packing with Variance-Aware Local Search**\n- **Implementation**: The solution transforms the non-linear objective into a linear bin-packing problem using binary search with multiple sorting heuristics (BFD/FFD), followed by Iterated Local Search that uses variance reduction (sum of squared pressures) as a tie-breaker.\n- **Performance**: The algorithm achieved a strong score of 26.26 and 100% success rate with negligible runtime (0.011s).\n- **Feedback**: The variance-based tie-breaking mechanism is particularly effective for smoothing load distribution, while the multi-heuristic initial packing ensures valid solutions are found even for tight constraints.\n**Program Identifier:** Generation 94 - Patch Name ils_targeted_first_improvement - Correct Program: True\n\n**Program Name: Robust Binary Search with Burst-Kick Iterated Local Search**\n- **Implementation**: The solution initializes placements using binary search combined with Best-Fit Decreasing using multiple sorting heuristics (Virtual Size, Physical Size, Density), then refines them via steepest descent local search with targeted \"burst kicks\" to relieve bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and exceptional execution speed (0.038s).\n- **Feedback**: The multi-heuristic packing approach ensures robust initial feasibility, while using variance reduction as a tie-breaker in local search and targeted perturbations effectively balances load to minimize peak pressure.\n**Program Identifier:** Generation 95 - Patch Name targeted_burst_local_search - Correct Program: True\n\n**Program Name: Hybrid Binary Search Packing with Smart-Perturbation ILS**\n- **Implementation**: Solves the placement problem using binary search on the pressure target with multi-strategy Best Fit checks, refined by an Iterated Local Search (ILS) that employs bottleneck-focused swaps and targeted repacking perturbations.\n- **Performance**: Achieved a high combined score of 26.26 (Inverse KVPR ~25.3) with very fast execution (0.155s).\n- **Feedback**: The dual approach of establishing tight bounds via binary search followed by local optimization allows the algorithm to quickly find high-quality solutions, while the targeted perturbation strategy effectively escapes local optima.\n**Program Identifier:** Generation 96 - Patch Name ils_first_improvement_sorted - Correct Program: True\n\n**Program Name: Binary Search Packing with Large Neighborhood Search Refinement**\n- **Implementation**: Initializes via binary search on target pressure using multi-strategy Best Fit Decreasing, then refines using Iterated Local Search with bottleneck-focused moves, swaps, and randomized subset repacking.\n- **Performance**: Achieved a high score of 26.26 with 100% success rate and fast execution (0.190s).\n- **Feedback**: The hybrid approach successfully balances global load distribution constraints with local improvements, utilizing diverse sorting keys and targeted repacking to effectively minimize peak KV cache pressure.\n**Program Identifier:** Generation 97 - Patch Name guided_first_improvement_descent - Correct Program: True\n\n**Program Name: Binary Search Packing with LNS Refinement**\n- **Implementation**: Utilizes binary search to minimize KV pressure using Best-Fit/First-Fit packing heuristics for feasibility checks, intended to be refined by Large Neighborhood Search.\n- **Performance**: Zero score (0.00) and 0% success rate due to immediate runtime errors.\n- **Feedback**: The program fails because it calls an undefined function `_hybrid_local_search` instead of the implemented `_lns_refinement`, causing a crash on all test cases.\n**Program Identifier:** Generation 98 - Patch Name hybrid_local_search_and_randomized_packing - Correct Program: False\n\n**Program Name: Robust Binary Search with Large Neighborhood Search Refinement**\n- **Implementation**: The solution combines a binary search over maximum KV pressure using multi-heuristic packing (FFD/BFD) with an Iterated Local Search that employs Steepest Descent and \"Ruin & Recreate\" perturbation to optimize bottleneck GPUs.\n- **Performance**: Achieved a high combined score of 26.26 with a 100% success rate and extremely fast execution (0.035s).\n- **Feedback**: The diverse packing heuristics ensure valid initial solutions even under tight constraints, while the bottleneck-focused local search effectively balances loads to minimize pressure without significant computational overhead.\n**Program Identifier:** Generation 99 - Patch Name none - Correct Program: True",
  "meta_scratch_pad": "Based on the analysis of the latest evaluations (Generations 90-99) and the Current Best Program, here are the actionable optimization insights:\n\n## Successful Algorithmic Patterns\n- **First-Improvement Bottleneck Descent**: The **Current Best Program** achieves the fastest execution time (0.006s) by using a \"First-Improvement\" strategy that specifically targets only the highest-pressure GPU (`src`). Upon finding *any* move or swap that reduces the bottleneck pressure, it immediately applies the change and restarts the search loop, rather than scanning the entire neighborhood for the theoretical best move (Steepest Descent).\n- **Linearized Binary Search Initialization**: A dominant pattern across all high-scoring programs (Current Best, **Gen 91**, **Gen 92**, **Gen 94**, **Gen 99**) is initializing by converting the non-linear pressure objective ($R/S \\le K$) into a linear bin-packing constraint ($R + K \\cdot S \\le K \\cdot C$). This allows standard heuristics like Best-Fit Decreasing to place the solution very close to the global optimum (Score 26.26) before local search begins.\n- **Low-Overhead Random Perturbations**: The **Current Best Program** uses a simple \"patience-based\" random kick mechanism that performs a random move after short stagnation. This proved far superior in terms of speed (0.006s) compared to the complex \"Smart-Perturbation\" or \"Guided Descent\" logic seen in **Gen 90** (0.116s) and **Gen 96** (0.155s), which achieved the same score but with 20x-30x higher latency.\n- **Multi-Heuristic Feasibility Checks**: Programs that employed multiple sorting strategies (Virtual Size, Physical Size, Density) during the binary search phase (**Gen 92**, **Gen 99**, **Current Best**) consistently achieved 100% success rates and the top score. This ensures that if one heuristic fails to pack tight constraints, another can succeed.\n\n## Ineffective Approaches\n- **Complex Deterministic Perturbations**: **Gen 96** (\"Smart-Perturbation ILS\") and **Gen 97** (\"Guided First Improvement\") utilized sophisticated logic to identify \"optimal\" perturbation candidates (e.g., subset repacking). While they achieved the target score (26.26), the overhead of these calculations resulted in runtimes of 0.155s\u20130.190s, making them significantly less efficient than the randomized approach of the Current Best (0.006s).\n- **Rigid Lexicographical Descent**: **Gen 93** employed a strict lexicographical descent strategy for its local search and achieved a lower score (25.23) compared to the standard (26.26). This suggests that overly rigid tie-breaking rules can restrict the search path, preventing the algorithm from finding the global optimum that randomized or variance-aware approaches find easily.\n- **Aggressive Burst/Kick Strategies**: **Gen 95** implemented a \"Burst-Kick\" strategy that likely perturbed the solution too aggressively, resulting in a slightly lower score (26.23) than the gentler single-move perturbations used in the top-performing variants.\n\n## Implementation Insights\n- **Incremental State Management**: The **Current Best Program** maintains flat float arrays (`gpu_s` for size, `gpu_w` for workload) and updates them in-place ($O(1)$) during the local search. This is a critical optimization compared to object-based recalculations, enabling the algorithm to perform thousands of neighborhood checks within milliseconds.\n- **Virtual Size Sorting**: The **Current Best Program** and **Gen 92** implement a specialized sort key for the binary search packing: $VirtualSize = Workload + K \\times Size$. This heuristic effectively linearizes the pressure constraint, ensuring that items are packed in an order that respects the specific target ratio $K$ currently being tested.\n- **Search Space Reduction**: The **Current Best Program** explicitly restricts its local search outer loop to the bottleneck GPU index (`src`). This reduces the complexity of finding a move from $O(N^2)$ (checking all pairs) to $O(N)$ (checking bottleneck vs. others), which is essential for the sub-10ms runtime",
  "meta_recommendations": "Based on the analysis of the Current Best Program and the successful patterns identified in recent evaluations, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Best-Fit Decreasing (BFD) in Packing**\n    Modify the `_pack` function to use a \"Best-Fit\" strategy instead of the current \"First-Fit\" approach. When placing a model during the binary search initialization, select the GPU with the minimum remaining capacity that still fits the item. This reduces memory fragmentation, allowing the algorithm to validate tighter lower bounds ($K$) and starting the local search closer to the global optimum.\n\n2.  **Bottleneck-Targeted Perturbation (Smart Kick)**\n    Update the `_iterated_local_search` random kick mechanism to explicitly target the current bottleneck GPU. Instead of selecting a random source (`s_rnd`), force the source to be the GPU with the highest pressure (`src`) and move an item to a random valid destination. This ensures that every perturbation specifically attempts to break the deadlock causing the current maximum pressure, rather than shuffling non-critical GPUs.\n\n3.  **Workload-Based Sorting Heuristic**",
  "meta_recommendations_history": [
    "Based on the successful \"Binary Search Packing with Iterated Local Search\" pattern of the current best program, here are 5 actionable recommendations for future mutations:\n\n1.  **Incorporate Best-Fit Decreasing (BFD) into Feasibility Checks**: Extend the `_check_feasibility_multi` function to include \"Best-Fit Decreasing\" variants for both Virtual and Physical size sortings. While the current First-Fit approach is fast, Best-Fit often finds tighter packings by placing items in bins with the smallest sufficient residual capacity, potentially validating lower target KVPRs ($K$) during the binary search.\n2.  **Implement Variance Reduction Tie-Breaking**: Modify the local search acceptance logic to resolve ties (moves that don't immediately lower the global maximum) by favoring configurations with lower load variance or sum-of-squares pressure. Smoothing the distribution among non-bottleneck GPUs creates \"slack\" that often allows the bottleneck to be reduced in subsequent iterations, preventing search stagnation.\n3.  **Add a \"Density-Based\" Sorting Heuristic**: Introduce a third sorting strategy in the multi-strategy packing check that orders models by their \"Intensity Density\" (ratio of $\\frac{req\\_rate}{SLO}$ to $model\\_size$). This heuristic provides a fundamentally different packing order than Virtual Size ($w + K \\cdot s$) or Physical Size ($s$), helping to balance high-intensity/small models with low-intensity/large models more effectively.\n4.  **Upgrade to \"Ruin and Recreate\" Perturbation**: Replace the simple single-item random \"kick\" in the `_iterated_local_search` with a \"Ruin and Recreate\" strategy. Randomly empty the bottleneck GPU and 1-2 others, then greedily repack their items. This structural perturbation is more effective at escaping deep local optima than moving a single item.\n5.  **Transition to Simulated Annealing for Refinement**: Replace the strict greedy descent (Hill Climbing) in the refinement phase with a Simulated Annealing schedule. By allowing the algorithm to accept moves that slightly worsen the max pressure (controlled by a cooling temperature), the search can traverse barriers in the solution landscape that strict descent cannot cross.",
    "Based on the success of the Binary Search Packing with Iterated Local Search (ILS) pattern and the analysis of Generations 10-19, here are 5 actionable recommendations for future mutations:\n\n1.  **Upgrade to Best-Fit Decreasing (BFD) Packing**: The current `_check_feasibility_multi` function utilizes First-Fit, which can fragment memory. Modify the `_pack` function to implement **Best-Fit Decreasing**: place the current model into the bin with the *minimum sufficient residual capacity* (for both physical and virtual size dimensions). This minimizes wasted space, potentially validating lower target KVPRs ($K$) during the binary search phase.\n2.  **Implement \"Ruin and Recreate\" Perturbation**: The current single-item \"kick\" is effective but limited in its reach. Replace it with a **Ruin and Recreate** strategy: specifically target the bottleneck GPU and 1-2 random GPUs, remove all their models, and then re-insert them using a randomized greedy heuristic. This structural disruption is far more effective at escaping deep local optima than moving a single item.\n3.  **Add Variance-Based Tie-Breaking**: In the `_iterated_local_search`, the current logic rejects moves that don't strictly lower the global maximum. Modify the acceptance criteria to handle **ties** (moves where the new max pressure equals the old max) by favoring configurations with lower **load variance** or sum-of-squares pressure. Smoothing the non-bottleneck distribution creates the \"slack\" needed to reduce the peak in subsequent steps.\n4.  **Introduce a \"Density\" Sorting Strategy**: Expand the multi-heuristic feasibility check to include a third sorting key: **Intensity Density** (calculated as `(req_rate/slo) / model_size`). While \"Virtual Size\" balances constraints, Density prioritization ensures that small, high-intensity models are packed early, preventing them from becoming difficult \"outliers\" that fail the packing late in the process.\n5.  **Transition to Bottleneck-Focused Simulated Annealing**: Replace the strict greedy descent in the refinement phase with a **Simulated Annealing** schedule targeted specifically at the bottleneck GPU. By accepting moves that slightly worsen the max pressure (controlled by a cooling temperature), the algorithm can traverse solution barriers that the current \"Greedy Descent + Random Kick\" approach cannot easily cross.",
    "Based on the successful \"Binary Search Packing + Iterated Local Search\" pattern of the current best program (Score: 26.26), here are 5 actionable recommendations for future mutations:\n\n1.  **Upgrade to Best-Fit Decreasing (BFD) Packing**: The current `_pack` function utilizes First-Fit, which places models in the first valid GPU, often fragmenting capacity. Modify `_pack` to implement **Best-Fit Decreasing**, which scans all valid GPUs and places the current model into the one with the *minimum sufficient residual virtual capacity*. This tighter packing minimizes waste and can validate lower target KVPRs during the binary search.\n2.  **Implement Variance-Based Tie-Breaking**: The current local search strictly rejects moves unless they lower the global maximum (`max(nk_src, nk_dst) < max_k`). Modify the acceptance criteria to handle **ties** (where new max pressure equals old max) by accepting configurations that lower the **sum of squared pressures** (variance). This allows the algorithm to traverse plateaus and \"smooth\" the load distribution, creating slack for future peak reductions.\n3.  **Intensify Perturbation with \"Burst Kicks\"**: The current single-item random kick is effective but often insufficient to escape deep local optima. Replace it with a **Burst Kick** strategy that performs a sequence of 3-5 random moves or swaps (ignoring feasibility of the objective function) before restarting the optimization phase. This larger state-space jump prevents the greedy descent from immediately reversing the perturbation.\n4.  **Add Intensity-Density Sorting Heuristic**: Expand the `_check_feasibility_multi` function to include a third sorting key: **Intensity Density** (`(req_rate/slo) / model_size`). While \"Virtual Size\" balances constraints, sorting by density ensures that small, high-intensity models are packed early, preventing them from becoming difficult \"outliers\" that fail the packing in later stages when fragmentation is high.\n5.  **Switch to Best-Improvement Descent**: The current local search implements \"First-Improvement\" (executing the first valid move found). Transition to **Best-Improvement** by evaluating all possible moves and swaps for the bottleneck GPU, and then executing the single move that results in the *lowest* new peak pressure. This is more computationally intensive but typically converges to a higher-quality local optimum.",
    "Based on the analysis of the successful \"Binary Search Packing + Iterated Local Search\" pattern in Generation 38 (Score: 26.26), here are 5 actionable recommendations for future mutations:\n\n1.  **Upgrade to Best-Fit Decreasing (BFD) Packing**: The current `_pack` function utilizes First-Fit, which places models in the first valid GPU, often fragmenting capacity. Modify `_pack` to implement **Best-Fit Decreasing**, which scans all valid GPUs and places the current model into the one with the *minimum sufficient residual virtual capacity*. This tighter packing minimizes waste and can validate lower target KVPRs during the binary search initialization.\n2.  **Implement Variance-Based Tie-Breaking**: The current local search strictly rejects moves unless they lower the global maximum (`max_k`). Modify the acceptance criteria to handle **ties** (where `new_max_k == current_max_k`) by accepting configurations that lower the **sum of squared pressures** (variance). This allows the algorithm to traverse plateaus and \"smooth\" the load distribution on non-bottleneck GPUs, creating the slack needed for future peak reductions.\n3.  **Intensify Perturbation with \"Burst Kicks\"**: The current single-item random kick is effective but often insufficient to escape deep local optima (specifically the 26.23 barrier). Replace it with a **Burst Kick** strategy that performs a sequence of 3-5 random moves or swaps (ignoring objective function improvement) before restarting the optimization phase. This larger state-space jump prevents the greedy descent from immediately reversing the perturbation.\n4.  **Add Intensity-Density Sorting Heuristic**: Expand the `_check_feasibility_multi` function to include a third sorting key: **Intensity Density** (`(req_rate/slo) / model_size`). While the current \"Virtual Size\" heuristic balances constraints, sorting by density ensures that small, high-intensity models are packed early, preventing them from becoming difficult \"outliers\" that fail the packing in later stages when fragmentation is high.\n5.  **Apply Heuristic-Guided Candidate Ordering**: Currently, the local search iterates through items on the bottleneck GPU in an arbitrary list order. Optimize the descent by **sorting the bottleneck items** by their pressure contribution (e.g., descending $w$) before attempting moves or swaps. This \"Guided First-Improvement\" strategy focuses computational resources on relocating the most problematic items first, accelerating convergence without the overhead of a full \"Best-Improvement\" search.",
    "Based on the analysis of the successful strategies in Generation 38 and the insights from Generations 40-49, here are 5 actionable recommendations for future program mutations:\n\n1.  **Switch to Best-Fit Decreasing (BFD) Packing**: Modify the `_pack` function to implement Best-Fit Decreasing instead of the current First-Fit approach. By placing models into the GPU with the minimum sufficient residual virtual capacity, BFD reduces memory fragmentation. This allows the binary search initialization to validate tighter lower bounds for $K$, providing a higher-quality starting solution for the local search.\n2.  **Implement Secondary Objective Tie-Breaking**: Enhance the move acceptance logic in the local search to handle plateau traversal. Currently, the algorithm only accepts strictly better peaks. Modify the condition to accept moves where the new peak is **equal** to the current peak if a secondary metric\u2014such as the **sum of squared pressures** (variance) or total pressure\u2014is reduced. This smooths the load on non-bottleneck GPUs, creating necessary slack for subsequent peak reductions.\n3.  **Adopt Multi-Step \"Burst\" Kicks**: Replace the single-item random kick with a **Burst Kick** strategy that performs a sequence of 3-5 random moves or swaps when `patience` is exhausted. Insights show that single perturbations are often immediately reversed by the greedy descent; a larger, blind jump in the state space helps escape deep local optima (specifically the 26.23 score barrier) without the computational overhead of \"smart\" perturbation logic.\n4.  **Heuristic-Guided Descent Ordering**: Optimize the local search inner loop by sorting the items on the bottleneck GPU before attempting moves. Instead of iterating in arbitrary list order, sort items by **descending pressure contribution** ($w$) or size ($s$). This \"Guided First-Improvement\" ensures the algorithm prioritizes relocating the most problematic items first, accelerating convergence towards the optimal 26.26 score.\n5.  **Expand Initialization with Density Sorting**: Add a third sorting heuristic to the `_check_feasibility_multi` function based on **Intensity Density** (Request Rate / Model Size). While \"Virtual Size\" works well generally, sorting by density ensures that small, high-intensity models are packed early. This diversity in initialization increases the likelihood that the binary search lands in a feasible region closer to the global optimum, reducing the work required by the local search.",
    "Based on the analysis of the Current Best Program (Generation 38) and the patterns from Generations 50-59, here are 5 actionable recommendations for future mutations:\n\n1.  **Switch to Best-Fit Decreasing (BFD) in Initialization**\n    The current `_pack` function uses First-Fit, placing items in the first GPU that fits. Replace this with **Best-Fit Decreasing**, which places the item into the GPU with the *minimum sufficient remaining capacity*. BFD minimizes memory fragmentation, allowing the binary search to validate tighter (lower) $K$ bounds and providing a higher-quality starting solution for the local search without increasing computational complexity.\n\n2.  **Implement Heuristic-Guided Greedy Descent**\n    Currently, the local search iterates through items on the bottleneck GPU in arbitrary list order to find moves. Optimize the inner loop by **sorting the bottleneck items by descending workload ($w$)** before attempting moves or swaps. This \"Ordered First-Improvement\" strategy ensures the algorithm attempts to relocate the most problematic (highest pressure contribution) items first, accelerating convergence.\n\n3.  **Incorporate Secondary Objective for Plateau Traversal**\n    The current move acceptance logic strictly requires reducing the global peak (`max(nk_src, nk_dst) < max_k`). Modify this to accept moves where the new peak is **equal** to the current peak if a secondary metric\u2014such as the **sum of pressures** or **variance**\u2014is reduced. This allows the algorithm to traverse plateaus in the fitness landscape, reorganizing non-bottleneck GPUs to create the slack necessary for subsequent peak reductions.\n\n4.  **Adopt Atomic Multi-Step \"Burst\" Kicks**\n    While the single-item random kick is fast, it often fails to escape deep local optima. Replace the single kick with a **\"Burst\" sequence of 3-5 random atomic moves** executed consecutively before re-checking the objective. This maintains the high execution speed of atomic operations (unlike the slower \"Ruin-Recreate\" approach) while providing sufficient perturbation to jump out of the 26.26 score traps.\n\n5.  **Add Density-Based Sorting Strategy**\n    Expand the `_check_feasibility_multi` function by adding a third sorting heuristic based on **Pressure Density** ($w / s$). While the current \"Virtual Size\" and \"Physical Size\" heuristics cover most cases, sorting by density prioritizes items that are small but computationally expensive. This diversity prevents the binary search from getting stuck due to specific item combinations, potentially lowering the initial bound $K$.",
    "Based on the analysis of the Current Best Program (Generation 38) and the global insights from Generations 60-69, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Best-Fit Decreasing (BFD) in Initialization**\n    The current `_pack` function utilizes a First-Fit strategy, placing items in the first GPU that accommodates them. Change this to **Best-Fit Decreasing**, which selects the GPU with the *minimum sufficient remaining capacity* for each item. This reduces memory fragmentation during the binary search phase, potentially validating lower $K$ bounds (tighter pressures) before the local search even begins.\n\n2.  **Sort Bottleneck Items for \"Ordered First-Improvement\"**\n    The current local search iterates through items on the bottleneck GPU in an arbitrary list order. Optimize this by **sorting the bottleneck items by descending workload ($w$)** at the start of the greedy descent loop. This focuses the \"First-Improvement\" strategy on the most problematic items first, approximating the quality of \"Steepest Descent\" without incurring the computational penalty of evaluating every possible move.\n\n3.  **Incorporate Density-Based Sorting in Feasibility Checks**\n    The `_check_feasibility_multi` function currently uses \"Virtual Size\" and \"Physical Size\" heuristics. Add a third heuristic that sorts items by **Pressure Density ($w / s$)**. This addresses edge cases where items are small in size but high in computational demand, preventing the binary search from stalling on specific \"hot\" item combinations and improving the robustness of the initial solution.\n\n4.  **Enable Secondary Objective for Plateau Traversal**\n    The current acceptance criteria strictly requires a reduction in the global peak (`max_k`). Modify the logic to accept moves where the new peak is **equal** to the current peak if a secondary metric\u2014specifically the **sum of workloads** or **pressure variance**\u2014is reduced. This allows the algorithm to reorganize the layout during plateau phases, creating the necessary slack for subsequent peak reductions without relying solely on random kicks.\n\n5.  **Adopt Adaptive \"Burst\" Perturbations**\n    While the single atomic kick is fast, it may fail to escape deep local optima. Implement an **adaptive perturbation strategy**: start with the current single-item random move, but if improvement stalls for multiple consecutive kick cycles, trigger a \"Burst\" of 3-5 random moves. This maintains the speed of the atomic approach for shallow optima while providing the escape velocity of larger perturbations when necessary.",
    "Based on the analysis of the Current Best Program (Generations 70-79) and the identified successful patterns, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Best-Fit Decreasing (BFD) in Packing**\n    The current `_pack` function utilizes a \"First-Fit\" strategy, placing items in the first GPU that fits. Change this to **Best-Fit Decreasing**, which selects the GPU with the *minimum sufficient remaining capacity* for each item. This reduces memory fragmentation during the binary search phase, allowing the algorithm to validate tighter",
    "Based on the analysis of the Current Best Program and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Best-Fit Decreasing (BFD) in Packing**\n    Replace the current \"First-Fit\" logic in the `_pack` function with a \"Best-Fit\" strategy. When placing an item, iterate through all valid GPUs and select the one with the *minimum sufficient remaining capacity* (both physical and virtual). This reduces memory fragmentation during the binary search initialization, allowing the algorithm to validate tighter lower bounds ($K$) than First-Fit.\n\n2.  **Bottleneck-Targeted Perturbation (Smart Kick)**\n    Modify the random kick mechanism to explicitly target the current bottleneck GPU. Instead of selecting a random source GPU (`s_rnd`), force the source to be the GPU with the highest pressure (`src`) and try to move or swap a random item from it to a GPU with high slack. This ensures that every perturbation attempts to break the specific deadlock causing stagnation, rather than shuffling non-critical GPUs.\n\n3.  **Workload-Based Sorting Heuristic**\n    Add a third sorting strategy to `_check_feasibility_multi` that sorts items solely by their workload (`req_rate / slo`) in descending order. While the current \"Virtual Size\" and \"Physical Size\" heuristics cover mixed and memory-bound cases, some constraint landscapes are purely workload-bound; sorting by workload ensures these high-pressure, low-memory items are packed efficiently into the available capacity.\n\n4.  **Priority Sorting for Move Candidates**\n    In the local search phase, before iterating through the items on the bottleneck GPU (`models = placement[src]`), sort them by their pressure contribution (`w`) in descending order. Attempting to move or swap the highest-impact items first aligns with a \"Steepest Descent\" philosophy while maintaining the speed of \"First-Improvement,\" potentially resolving the bottleneck in fewer iterations.\n\n5.  **Slack-Based Search Pruning**\n    Optimize the inner loops of the local search by skipping destination GPUs (`dst`) that are already under high pressure. Add a check (e.g., `if gpu_w[dst] / remaining_mem > current_max_k * 0.95`) to bypass calculations for GPUs that are unlikely to accept new items without becoming new bottlenecks themselves. This reduces the search space $O(N)$ constant factors, yielding more total iterations within the time limit.",
    "Based on the analysis of the Current Best Program and the successful patterns identified in recent evaluations, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Best-Fit Decreasing (BFD) in Packing**\n    Modify the `_pack` function to use a \"Best-Fit\" strategy instead of the current \"First-Fit\" approach. When placing a model during the binary search initialization, select the GPU with the minimum remaining capacity that still fits the item. This reduces memory fragmentation, allowing the algorithm to validate tighter lower bounds ($K$) and starting the local search closer to the global optimum.\n\n2.  **Bottleneck-Targeted Perturbation (Smart Kick)**\n    Update the `_iterated_local_search` random kick mechanism to explicitly target the current bottleneck GPU. Instead of selecting a random source (`s_rnd`), force the source to be the GPU with the highest pressure (`src`) and move an item to a random valid destination. This ensures that every perturbation specifically attempts to break the deadlock causing the current maximum pressure, rather than shuffling non-critical GPUs.\n\n3.  **Workload-Based Sorting Heuristic**"
  ],
  "total_programs_meta_processed": 100
}