<NAME>
robust_init_and_targeted_kick
</NAME>

<DESCRIPTION>
1.  **Refined Binary Search Initialization & Loop**:
    -   Fixes a bug where `init_res` was undefined.
    -   Adds randomized heuristic trials to the initialization phase to find a better upper bound and initial solution, which improves binary search convergence.
    -   Adds a randomized fallback to the feasibility check inside the binary search. If deterministic sort orders fail to fit items into a specific `K` (mid), it tries random permutations. This prevents the binary search from falsely rejecting feasible `K` values due to specific ordering pathologies, leading to a tighter (lower) Max KVPR.
2.  **Targeted Perturbation (Kick)**:
    -   Modifies the perturbation mechanism to explicitly include the **least loaded GPU** and the **bottleneck GPU** in the set of victims to be repacked.
    -   This targeted approach facilitates the movement of load from the bottleneck to the GPU with the most slack, which is statistically more likely to accept items and reduce the overall max pressure compared to selecting purely random partners.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Try multiple sorts to get a good upper bound and initial solution
    best_bs_placement = None
    high_bound = 1000.0

    for key_fn in [lambda x: x['d'], lambda x: x['s'], lambda x: x['w']]:
        res, max_p = pack_heuristic(key_fn)
        if res:
            if max_p < high_bound:
                high_bound = max_p
                best_bs_placement = res

    # Binary Search Loop
    low = low_bound
    high = high_bound
    if high > 999 and init_res is None: high = 10.0 # Heuristic adjustment if no initial found

    for _ in range(20):
        if high - low < 1e-4: break
        mid = (low + high) / 2.0

        feasible = False
        temp_placement = None

        # Strategies: Density, Virtual Size, Physical Size
        sort_keys = [
            lambda x: x['d'],
            lambda x: x['w'] + mid * x['s'],
            lambda x: x['s']
        ]

        for key in sort_keys:
            items_sorted = sorted(m_data, key=key, reverse=True)

            p_alloc = [[] for _ in range(gpu_num)]
            g_l = [0.0] * gpu_num
            g_u = [0.0] * gpu_num
            all_fit = True

            for item in items_sorted:
                best_g = -1
                min_slack = float('inf')

                # Check bins
                for g in range(gpu_num):
                    if g_u[g] + item['s'] > GPU_MEM_SIZE - 1e-6: continue

                    # Constraint: Load + w <= K * (Rem - s)
                    rem_capacity = GPU_MEM_SIZE - g_u[g] - item['s']
                    max_load_allowed = mid * rem_capacity
                    current_proj_load = g_l[g] + item['w']

                    if current_proj_load <= max_load_allowed + 1e-7:
                        # Best Fit Decreasing: Minimize slack
                        # Slack = Capacity_Available_Under_K - Load_Added
                        slack = max_load_allowed - current_proj_load
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g

                if best_g != -1:
                    p_alloc[best_g].append(item['obj'])
                    g_l[best_g] += item['w']
                    g_u[best_g] += item['s']
                else:
                    all_fit = False
                    break

            if all_fit:
                feasible = True
                temp_placement = p_alloc
                break

        if feasible:
            best_bs_placement = temp_placement
            high = mid
        else:
            low = mid

    if best_bs_placement is None:
        if init_res:
             best_bs_placement = init_res
        else:
             raise ValueError("No feasible placement found.")
=======
    # Try multiple sorts to get a good upper bound and initial solution
    best_bs_placement = None
    high_bound = 1000.0

    # Deterministic heuristics
    heuristics = [lambda x: x['d'], lambda x: x['s'], lambda x: x['w']]
    # Randomized heuristics for robustness
    for _ in range(5):
        def rand_key(x): return x['d'] * random.uniform(0.9, 1.1)
        heuristics.append(rand_key)

    for key_fn in heuristics:
        res, max_p = pack_heuristic(key_fn)
        if res:
            if max_p < high_bound:
                high_bound = max_p
                best_bs_placement = res

    # Binary Search Loop
    low = low_bound
    high = high_bound
    if high > 999 and best_bs_placement is None: high = 10.0

    for _ in range(20):
        if high - low < 1e-4: break
        mid = (low + high) / 2.0

        feasible = False
        temp_placement = None

        def check_feasibility(items_list):
            p_alloc = [[] for _ in range(gpu_num)]
            g_l = [0.0] * gpu_num
            g_u = [0.0] * gpu_num

            for item in items_list:
                best_g = -1
                min_slack = float('inf')

                # Check bins
                for g in range(gpu_num):
                    if g_u[g] + item['s'] > GPU_MEM_SIZE - 1e-6: continue

                    rem_capacity = GPU_MEM_SIZE - g_u[g] - item['s']
                    max_load_allowed = mid * rem_capacity
                    current_proj_load = g_l[g] + item['w']

                    if current_proj_load <= max_load_allowed + 1e-7:
                        slack = max_load_allowed - current_proj_load
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g

                if best_g != -1:
                    p_alloc[best_g].append(item['obj'])
                    g_l[best_g] += item['w']
                    g_u[best_g] += item['s']
                else:
                    return None
            return p_alloc

        # Strategies
        sort_keys = [
            lambda x: x['d'],
            lambda x: x['w'] + mid * x['s'],
            lambda x: x['s']
        ]

        # 1. Deterministic
        for key in sort_keys:
            items_sorted = sorted(m_data, key=key, reverse=True)
            res = check_feasibility(items_sorted)
            if res:
                feasible = True
                temp_placement = res
                break

        # 2. Randomized Fallback
        if not feasible:
            base_items = list(m_data)
            for _ in range(5):
                random.shuffle(base_items)
                res = check_feasibility(base_items)
                if res:
                    feasible = True
                    temp_placement = res
                    break

        if feasible:
            best_bs_placement = temp_placement
            high = mid
        else:
            low = mid

    if best_bs_placement is None:
         raise ValueError("No feasible placement found.")
>>>>>>> REPLACE
<<<<<<< SEARCH
        else:
            # 4. Perturbation (Burst Kick with Multi-Try)
            # If stuck, destroy packing of Bottleneck + k Random Partners
            k_partners = min(gpu_num - 1, 3)
            if k_partners == 0: break

            # Probabilistically pick partners
            candidates = [g for g in range(gpu_num) if g != bottleneck]
            victims = [bottleneck] + random.sample(candidates, k_partners)

            repack_items = []
=======
        else:
            # 4. Perturbation (Burst Kick with Multi-Try)
            # If stuck, destroy packing of Bottleneck + Least Loaded + Random Partners
            k_partners = min(gpu_num - 1, 3)
            if k_partners == 0: break

            candidates = [g for g in range(gpu_num) if g != bottleneck]

            # Smart Selection: Always include least loaded to absorb pressure
            min_load_g = min(candidates, key=lambda g: pressures[g])
            victims = [bottleneck, min_load_g]

            # Fill remaining spots with random partners
            rem_candidates = [g for g in candidates if g != min_load_g]
            needed = k_partners - 1
            if needed > 0 and rem_candidates:
                victims += random.sample(rem_candidates, min(len(rem_candidates), needed))

            repack_items = []
>>>>>>> REPLACE
</DIFF>