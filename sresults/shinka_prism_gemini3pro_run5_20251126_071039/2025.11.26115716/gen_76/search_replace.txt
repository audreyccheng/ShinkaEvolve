<NAME>
optimize_search_speed
</NAME>

<DESCRIPTION>
1.  **Refine Binary Search Bounds**: Calculate a tighter lower bound for the binary search using the theoretical minimum pressure (Total Load / Total Free Capacity). This reduces the search space for the binary search phase.
2.  **Switch to Ordered First-Improvement Local Search**: Replace the computationally expensive "Best-Improvement" strategy (which evaluates all possible moves/swaps between the bottleneck and all partners before picking one) with an "Ordered First-Improvement" strategy.
    *   Partners are sorted by pressure (ascending) to prioritize offloading to the least loaded GPUs.
    *   Items on the bottleneck GPU are sorted by workload (descending) to prioritize moving the heaviest items.
    *   The algorithm accepts the *first* valid move or swap that improves the objective, significantly reducing the number of evaluations per iteration and speeding up convergence.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- 2. Binary Search for Optimal K ---
    low = 0.0
    high = upper_bound
    final_placement = init_placement
=======
    # --- 2. Binary Search for Optimal K ---
    # Theoretical lower bound: Total Load / Total Free Capacity
    total_load = sum(d['w'] for d in m_data)
    total_size = sum(d['s'] for d in m_data)
    total_cap = gpu_num * GPU_MEM_SIZE
    low = total_load / (total_cap - total_size) if (total_cap - total_size) > 1e-6 else 0.0
    if low > upper_bound: low = 0.0

    high = upper_bound
    final_placement = init_placement
>>>>>>> REPLACE
<<<<<<< SEARCH
        # --- Descent: Best Improvement ---
        best_move = None
        # (type, partner, idx_bn, idx_pt, nb_l, nb_u, np_l, np_u, max_p, sum_sq)

        bn_items = current_placement[bottleneck]

        for partner in range(gpu_num):
            if partner == bottleneck: continue

            # Efficiently find max pressure excluding BN and Partner
            # We only need to check the global top pressures
            max_others = 0.0
            for g in range(gpu_num):
                if g != bottleneck and g != partner:
                    if pressures[g] > max_others: max_others = pressures[g]

            sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)

            # 1. Move BN -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate/m.slo, m.model_size
                if used[partner] + s >= GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                pb = get_pressure(n_bl, n_bu)
                pp = get_pressure(n_pl, n_pu)

                nm = max(max_others, pb, pp)

                if nm > current_max_p + 1e-9: continue

                nsq = sq_base + pb**2 + pp**2

                better = False
                if nm < current_max_p - 1e-9: better = True
                elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                if better:
                    if best_move is None or nm < best_move[8] - 1e-9 or (abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]):
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, nm, nsq)

            # 2. Swap BN <-> Partner
            pt_items = current_placement[partner]
            for i, m1 in enumerate(bn_items):
                w1, s1 = m1.req_rate/m1.slo, m1.model_size
                for j, m2 in enumerate(pt_items):
                    w2, s2 = m2.req_rate/m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu >= GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu >= GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    pb = get_pressure(n_bl, n_bu)
                    pp = get_pressure(n_pl, n_pu)

                    nm = max(max_others, pb, pp)
                    if nm > current_max_p + 1e-9: continue
                    nsq = sq_base + pb**2 + pp**2

                    better = False
                    if nm < current_max_p - 1e-9: better = True
                    elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                    if better:
                        if best_move is None or nm < best_move[8] - 1e-9 or (abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]):
                            best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, nm, nsq)

        if best_move:
            mtype, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if mtype == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1

            loads[bottleneck], used[bottleneck] = nbl, nbu
            loads[pt], used[pt] = npl, npu
            pressures[bottleneck] = get_pressure(nbl, nbu)
            pressures[pt] = get_pressure(npl, npu)
            continue
=======
        # --- Descent: Ordered First-Improvement ---
        found_improvement = False

        # Identify top pressures excluding bottleneck for efficient max checks
        other_indices = [g for g in range(gpu_num) if g != bottleneck]
        top_others = sorted(other_indices, key=lambda g: pressures[g], reverse=True)[:2]

        # Sort partners by pressure ascending (target least loaded first)
        sorted_partners = sorted(other_indices, key=lambda g: pressures[g])

        # Prepare bottleneck items with data: (index, w, s, obj)
        bn_items = []
        for i, m in enumerate(current_placement[bottleneck]):
            bn_items.append((i, m.req_rate/m.slo, m.model_size, m))
        # Sort by load descending (move heavy items first)
        bn_items.sort(key=lambda x: x[1], reverse=True)

        # 1. Try Moves
        for partner in sorted_partners:
            # Max pressure of rest of world
            if partner == top_others[0]:
                max_rest = pressures[top_others[1]] if len(top_others) > 1 else 0.0
            else:
                max_rest = pressures[top_others[0]] if len(top_others) > 0 else 0.0

            sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)

            for idx, w, s, item_obj in bn_items:
                if used[partner] + s >= GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                pb = get_pressure(n_bl, n_bu)
                pp = get_pressure(n_pl, n_pu)

                nm = max(max_rest, pb, pp)

                if nm > current_max_p + 1e-9: continue

                # Acceptance
                better = False
                if nm < current_max_p - 1e-9:
                    better = True
                elif nm < current_max_p + 1e-9:
                    nsq = sq_base + pb**2 + pp**2
                    if nsq < current_sum_sq - 1e-9:
                        better = True

                if better:
                    current_placement[bottleneck].pop(idx)
                    current_placement[partner].append(item_obj)
                    loads[bottleneck], used[bottleneck] = n_bl, n_bu
                    loads[partner], used[partner] = n_pl, n_pu
                    pressures[bottleneck] = pb
                    pressures[partner] = pp
                    found_improvement = True
                    break
            if found_improvement: break

        # 2. Try Swaps (only if no move found)
        if not found_improvement:
            for partner in sorted_partners:
                if partner == top_others[0]:
                    max_rest = pressures[top_others[1]] if len(top_others) > 1 else 0.0
                else:
                    max_rest = pressures[top_others[0]] if len(top_others) > 0 else 0.0

                sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)
                pt_items = current_placement[partner]

                for idx1, w1, s1, m1 in bn_items:
                    for idx2, m2 in enumerate(pt_items):
                        w2, s2 = m2.req_rate/m2.slo, m2.model_size

                        n_bu = used[bottleneck] - s1 + s2
                        if n_bu >= GPU_MEM_SIZE - 1e-6: continue
                        n_pu = used[partner] - s2 + s1
                        if n_pu >= GPU_MEM_SIZE - 1e-6: continue

                        n_bl = loads[bottleneck] - w1 + w2
                        n_pl = loads[partner] - w2 + w1

                        pb = get_pressure(n_bl, n_bu)
                        pp = get_pressure(n_pl, n_pu)

                        nm = max(max_rest, pb, pp)

                        if nm > current_max_p + 1e-9: continue

                        better = False
                        if nm < current_max_p - 1e-9:
                            better = True
                        elif nm < current_max_p + 1e-9:
                            nsq = sq_base + pb**2 + pp**2
                            if nsq < current_sum_sq - 1e-9:
                                better = True

                        if better:
                            current_placement[bottleneck][idx1] = m2
                            current_placement[partner][idx2] = m1
                            loads[bottleneck], used[bottleneck] = n_bl, n_bu
                            loads[partner], used[partner] = n_pl, n_pu
                            pressures[bottleneck] = pb
                            pressures[partner] = pp
                            found_improvement = True
                            break
                    if found_improvement: break
                if found_improvement: break

        if found_improvement: continue
>>>>>>> REPLACE
</DIFF>