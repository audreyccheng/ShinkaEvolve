<NAME>
randomized_pack_and_diverse_perturbation
</NAME>

<DESCRIPTION>
1.  **Refined Upper Bound**: Calculates upper bounds using Density, Size, and Load strategies and picks the minimum feasible one, tightening the search space.
2.  **Randomized Binary Search Packing**: Adds randomized trials to the `can_pack` function in the binary search phase. Deterministic strategies (Density, Virtual Size, Size, Load) are tried first. If they fail, randomized shuffling with Best Fit Decreasing is tried to avoid false negatives (failing to find a valid packing for a feasible K). This helps the binary search converge to a lower K.
3.  **Diverse Perturbation Strategies**: Enhances the Ruin & Recreate (perturbation) phase in the Local Search. Instead of relying only on a noisy Density sort, it now rotates between noisy Density, Size, and Load sorts. This helps the algorithm escape local optima where different constraints (capacity vs pressure) are the bottleneck.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    ub_d = get_greedy_bound(lambda x: x['d'])
    if ub_d == float('inf'):
        ub_s = get_greedy_bound(lambda x: x['s'])
        high_bound = ub_s if ub_s != float('inf') else 2000.0
    else:
        high_bound = ub_d
=======
    ub_d = get_greedy_bound(lambda x: x['d'])
    ub_s = get_greedy_bound(lambda x: x['s'])
    ub_w = get_greedy_bound(lambda x: x['w'])

    candidates = [b for b in [ub_d, ub_s, ub_w] if b != float('inf')]
    high_bound = min(candidates) if candidates else 2000.0
>>>>>>> REPLACE
<<<<<<< SEARCH
    # Check function
    def can_pack(target_k):
        # We need to pack all items such that (L+w)/(C-U-s) <= K
        # Strategies: Density, Effective Size (w + K*s), Size, Load
        strategies = [
            lambda x: x['w'] + target_k * x['s'],
            lambda x: x['d'],
            lambda x: x['s'],
            lambda x: x['w']
        ]

        for key in strategies:
            items_s = sorted(m_data, key=key, reverse=True)
            bins_l = [0.0]*gpu_num
            bins_u = [0.0]*gpu_num
            bins_items = [[] for _ in range(gpu_num)]
            possible = True

            for item in items_s:
                best_g = -1
                min_slack = float('inf')

                # Check all bins
                for g in range(gpu_num):
                    # Physical constraint
                    if bins_u[g] + item['s'] >= GPU_MEM_SIZE - 1e-6: continue

                    # Pressure constraint
                    rem = GPU_MEM_SIZE - bins_u[g] - item['s']
                    max_load = target_k * rem
                    new_load = bins_l[g] + item['w']

                    if new_load <= max_load + 1e-7:
                        # Best Fit: minimize slack (unused capacity relative to K)
                        slack = max_load - new_load
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g

                if best_g != -1:
                    bins_l[best_g] += item['w']
                    bins_u[best_g] += item['s']
                    bins_items[best_g].append(item['obj'])
                else:
                    possible = False
                    break

            if possible:
                return bins_items
        return None
=======
    # Check function
    def can_pack(target_k):
        # We need to pack all items such that (L+w)/(C-U-s) <= K
        # Strategies: Density, Effective Size (w + K*s), Size, Load
        strategies = [
            lambda x: x['w'] + target_k * x['s'],
            lambda x: x['d'],
            lambda x: x['s'],
            lambda x: x['w']
        ]

        # Deterministic passes
        for key in strategies:
            items_s = sorted(m_data, key=key, reverse=True)
            bins_l = [0.0]*gpu_num
            bins_u = [0.0]*gpu_num
            bins_items = [[] for _ in range(gpu_num)]
            possible = True

            for item in items_s:
                best_g = -1
                min_slack = float('inf')

                # Check all bins
                for g in range(gpu_num):
                    # Physical constraint
                    if bins_u[g] + item['s'] >= GPU_MEM_SIZE - 1e-6: continue

                    # Pressure constraint
                    rem = GPU_MEM_SIZE - bins_u[g] - item['s']
                    max_load = target_k * rem
                    new_load = bins_l[g] + item['w']

                    if new_load <= max_load + 1e-7:
                        # Best Fit: minimize slack (unused capacity relative to K)
                        slack = max_load - new_load
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g

                if best_g != -1:
                    bins_l[best_g] += item['w']
                    bins_u[best_g] += item['s']
                    bins_items[best_g].append(item['obj'])
                else:
                    possible = False
                    break

            if possible:
                return bins_items

        # Randomized passes to reduce false negatives
        # This helps finding a feasible packing for tighter K bounds
        indices = list(range(len(m_data)))
        for _ in range(5):
            rng.shuffle(indices)
            bins_l = [0.0]*gpu_num
            bins_u = [0.0]*gpu_num
            bins_items = [[] for _ in range(gpu_num)]
            possible = True

            for idx in indices:
                item = m_data[idx]
                best_g = -1
                min_slack = float('inf')

                for g in range(gpu_num):
                    if bins_u[g] + item['s'] >= GPU_MEM_SIZE - 1e-6: continue
                    rem = GPU_MEM_SIZE - bins_u[g] - item['s']
                    max_load = target_k * rem
                    new_load = bins_l[g] + item['w']
                    if new_load <= max_load + 1e-7:
                        slack = max_load - new_load
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g

                if best_g != -1:
                    bins_l[best_g] += item['w']
                    bins_u[best_g] += item['s']
                    bins_items[best_g].append(item['obj'])
                else:
                    possible = False
                    break
            if possible:
                return bins_items

        return None
>>>>>>> REPLACE
<<<<<<< SEARCH
        # Recreate Loop (Try a few randomized packings)
        best_local = None
        best_local_max = float('inf')

        for _ in range(5):
            iter_items = list(repack_items)
            # Randomized Density Sort
            iter_items.sort(key=lambda x: ((x.req_rate/x.slo)/(x.model_size+1e-6)) * rng.uniform(0.8, 1.2), reverse=True)

            l_loads = {v: 0.0 for v in victim_list}
            l_used = {v: 0.0 for v in victim_list}
            l_alloc = {v: [] for v in victim_list}
            possible = True

            for item in iter_items:
                w, s = item.req_rate/item.slo, item.model_size
                best_v = -1
                best_sc = float('inf')

                # Best Fit (Minimize pressure)
                for v in victim_list:
                    rem = GPU_MEM_SIZE - l_used[v] - s
                    if rem > 1e-6:
                        p = (l_loads[v] + w) / rem
                        if p < best_sc:
                            best_sc = p
                            best_v = v

                # Fallback
                if best_v == -1:
                    for v in victim_list:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            best_v = v
                            break

                if best_v != -1:
                    l_alloc[best_v].append(item)
                    l_loads[best_v] += w
                    l_used[best_v] += s
                else:
                    possible = False
                    break

            if possible:
                lm = max(get_p(l_loads[v], l_used[v]) for v in victim_list)
                if lm < best_local_max:
                    best_local_max = lm
                    best_local = (l_alloc, l_loads, l_used)
=======
        # Recreate Loop (Try a few randomized packings)
        best_local = None
        best_local_max = float('inf')

        # Strategies: Density, Size, Load (with noise)
        strategies = [
            lambda x: ((x.req_rate/x.slo)/(x.model_size+1e-6)) * rng.uniform(0.8, 1.2),
            lambda x: x.model_size * rng.uniform(0.8, 1.2),
            lambda x: (x.req_rate/x.slo) * rng.uniform(0.8, 1.2)
        ]

        for i in range(9):
            iter_items = list(repack_items)
            iter_items.sort(key=strategies[i%3], reverse=True)

            l_loads = {v: 0.0 for v in victim_list}
            l_used = {v: 0.0 for v in victim_list}
            l_alloc = {v: [] for v in victim_list}
            possible = True

            for item in iter_items:
                w, s = item.req_rate/item.slo, item.model_size
                best_v = -1
                best_sc = float('inf')

                # Best Fit (Minimize pressure)
                for v in victim_list:
                    rem = GPU_MEM_SIZE - l_used[v] - s
                    if rem > 1e-6:
                        p = (l_loads[v] + w) / rem
                        if p < best_sc:
                            best_sc = p
                            best_v = v

                # Fallback
                if best_v == -1:
                    for v in victim_list:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            best_v = v
                            break

                if best_v != -1:
                    l_alloc[best_v].append(item)
                    l_loads[best_v] += w
                    l_used[best_v] += s
                else:
                    possible = False
                    break

            if possible:
                lm = 0.0
                for v in victim_list:
                     p = get_p(l_loads[v], l_used[v])
                     if p > lm: lm = p

                if lm < best_local_max:
                    best_local_max = lm
                    best_local = (l_alloc, l_loads, l_used)
>>>>>>> REPLACE
</DIFF>