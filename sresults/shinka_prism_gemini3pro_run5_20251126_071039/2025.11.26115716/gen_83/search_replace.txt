<NAME>
improved_initialization_and_perturbation
</NAME>

<DESCRIPTION>
1.  **Refined Initialization**: The upper bound for Binary Search is now calculated as the minimum of greedy packings based on Density, Size, and Load (previously only Density and Size). This provides a tighter and more robust starting point.
2.  **Extended Iterations**: Increased `max_iters` for Iterated Local Search from 200 to 500, exploiting the fast execution time to explore the search space more thoroughly.
3.  **Enhanced Perturbation (Ruin & Recreate)**: Replaced the simple randomized density sort in the perturbation phase with a multi-strategy approach. It now attempts to repack victims using Density, Size, and Load sorts (both deterministic and with noise). Crucially, it adds a "Best Fit Physical" fallback to ensure feasibility when the primary "Best Fit Pressure" heuristic fails to place an item, preventing the perturbation from failing and reverting too often in tight scenarios.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    ub_d = get_greedy_bound(lambda x: x['d'])
    if ub_d == float('inf'):
        ub_s = get_greedy_bound(lambda x: x['s'])
        high_bound = ub_s if ub_s != float('inf') else 2000.0
    else:
        high_bound = ub_d
=======
    ub_d = get_greedy_bound(lambda x: x['d'])
    ub_s = get_greedy_bound(lambda x: x['s'])
    ub_w = get_greedy_bound(lambda x: x['w'])

    candidates = [b for b in [ub_d, ub_s, ub_w] if b != float('inf')]
    high_bound = min(candidates) if candidates else 2000.0
>>>>>>> REPLACE
<<<<<<< SEARCH
    max_iters = 200

    for it in range(max_iters):
=======
    max_iters = 500

    for it in range(max_iters):
>>>>>>> REPLACE
<<<<<<< SEARCH
        # Recreate Loop (Try a few randomized packings)
        best_local = None
        best_local_max = float('inf')

        for _ in range(5):
            iter_items = list(repack_items)
            # Randomized Density Sort
            iter_items.sort(key=lambda x: ((x.req_rate/x.slo)/(x.model_size+1e-6)) * rng.uniform(0.8, 1.2), reverse=True)

            l_loads = {v: 0.0 for v in victim_list}
            l_used = {v: 0.0 for v in victim_list}
            l_alloc = {v: [] for v in victim_list}
            possible = True

            for item in iter_items:
                w, s = item.req_rate/item.slo, item.model_size
                best_v = -1
                best_sc = float('inf')

                # Best Fit (Minimize pressure)
                for v in victim_list:
                    rem = GPU_MEM_SIZE - l_used[v] - s
                    if rem > 1e-6:
                        p = (l_loads[v] + w) / rem
                        if p < best_sc:
                            best_sc = p
                            best_v = v

                # Fallback
                if best_v == -1:
                    for v in victim_list:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            best_v = v
                            break

                if best_v != -1:
                    l_alloc[best_v].append(item)
                    l_loads[best_v] += w
                    l_used[best_v] += s
                else:
                    possible = False
                    break

            if possible:
                lm = max(get_p(l_loads[v], l_used[v]) for v in victim_list)
                if lm < best_local_max:
                    best_local_max = lm
                    best_local = (l_alloc, l_loads, l_used)
=======
        # Recreate Loop (Multi-strategy greedy packing)
        best_local = None
        best_local_max = float('inf')

        # Strategies: (sort_key, use_noise)
        # We define sort keys based on model attributes.
        # We try: Density, Size, Load with noise.

        strategies = [
            ('density', lambda x: (x.req_rate/x.slo)/(x.model_size+1e-6)),
            ('size', lambda x: x.model_size),
            ('load', lambda x: x.req_rate/x.slo)
        ]

        # Attempts: Multiple tries with noise + deterministic tries
        attempts = []
        for name, key_fn in strategies:
            for _ in range(3):
                attempts.append((name, key_fn, True))

        # Add deterministic attempts
        attempts.append(('density', strategies[0][1], False))
        attempts.append(('size', strategies[1][1], False))

        for name, key_fn, use_noise in attempts:
            iter_items = list(repack_items)
            if use_noise:
                iter_items.sort(key=lambda x: key_fn(x) * rng.uniform(0.9, 1.1), reverse=True)
            else:
                iter_items.sort(key=key_fn, reverse=True)

            l_loads = {v: 0.0 for v in victim_list}
            l_used = {v: 0.0 for v in victim_list}
            l_alloc = {v: [] for v in victim_list}
            possible = True

            for item in iter_items:
                w, s = item.req_rate/item.slo, item.model_size
                best_v = -1
                best_sc = float('inf')

                # Primary Objective: Minimize Pressure (Best Fit Pressure)
                for v in victim_list:
                    rem = GPU_MEM_SIZE - l_used[v] - s
                    if rem > 1e-6:
                        p = (l_loads[v] + w) / rem
                        if p < best_sc:
                            best_sc = p
                            best_v = v

                # Fallback: Best Fit Physical (Minimize Remaining Capacity) to ensure feasibility
                if best_v == -1:
                    best_rem = float('inf')
                    for v in victim_list:
                        rem = GPU_MEM_SIZE - l_used[v] - s
                        if rem >= -1e-6: # Fit
                            if rem < best_rem:
                                best_rem = rem
                                best_v = v

                if best_v != -1:
                    l_alloc[best_v].append(item)
                    l_loads[best_v] += w
                    l_used[best_v] += s
                else:
                    possible = False
                    break

            if possible:
                lm = max(get_p(l_loads[v], l_used[v]) for v in victim_list)
                if lm < best_local_max:
                    best_local_max = lm
                    best_local = (l_alloc, l_loads, l_used)
>>>>>>> REPLACE
</DIFF>