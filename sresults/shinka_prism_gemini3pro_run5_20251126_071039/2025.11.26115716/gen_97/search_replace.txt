<NAME>
guided_first_improvement_descent
</NAME>

<DESCRIPTION>
Replace Best-Improvement Descent with Guided First-Improvement Descent in the Local Search phase.
Instead of scanning all possible moves to find the absolute best one (which is O(N*G)), we sort move candidates heuristically and accept the first improving move.
- Partners are sorted by pressure (ascending) to target emptiest GPUs first.
- Items on the bottleneck GPU are sorted by workload (descending) to offload the heaviest items first.
- Items on partner GPUs (for swaps) are sorted by workload (ascending) to minimize the load brought back.
This significantly reduces the cost per iteration, allowing us to increase the iteration count (from 250 to 1000), exploring a larger portion of the state space within the time limit.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # ILS Parameters
    iterations = 250

    for _ in range(iterations):
        # 1. Metrics & Global Best Update
        current_max = max(pressures)
        current_sq = sum(p*p for p in pressures)

        if current_max < best_max_p - 1e-8:
            best_max_p = current_max
            best_global_placement = {k: list(v) for k,v in current_placement.items()}

        # 2. Identify Bottleneck
        # Sort GPUs by pressure
        sorted_gpus = sorted(range(gpu_num), key=lambda g: pressures[g], reverse=True)
        bottleneck = sorted_gpus[0]

        # 3. Descent (Best-Improvement in Neighborhood)
        best_move = None
        # (type, partner, idx_bn, idx_pt, n_bl, n_bu, n_pl, n_pu, n_max, n_sq)

        # Precompute top pressures for fast max check
        # We need the max pressure of all GPUs excluding bottleneck and partner
        top_indices = sorted_gpus[:3]

        # Define neighborhood: Bottleneck <-> All Partners
        # Optimization: Filter partners? No, check all to find best relief.
        partners = [g for g in range(gpu_num) if g != bottleneck]

        bn_items = current_placement[bottleneck]

        for partner in partners:
            # Determine max_others
            max_others = 0.0
            for g_idx in top_indices:
                if g_idx != bottleneck and g_idx != partner:
                    max_others = pressures[g_idx]
                    break

            # Base sq sum excluding pair
            base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2

            # A. Try Moving Item: Bottleneck -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate / m.slo, m.model_size

                if used[partner] + s > GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                p_b = get_pressure(n_bl, n_bu)
                p_p = get_pressure(n_pl, n_pu)

                new_max = max(max_others, p_b, p_p)

                # Strict degradation check
                if new_max > current_max + 1e-9: continue

                new_sq = base_sq + p_b**2 + p_p**2

                # Acceptance criteria: Better Max OR (Equal Max AND Better Variance)
                is_better = False
                if new_max < current_max - 1e-9: is_better = True
                elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                if is_better:
                    if best_move is None:
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                    else:
                        # Compare with best_move found so far
                        bm_max, bm_sq = best_move[8], best_move[9]
                        if new_max < bm_max - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                        elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)

            # B. Try Swapping: Bottleneck <-> Partner
            # Only try if we didn't find a very good move, or check anyway?
            # Swaps are expensive O(N*M). Do if partner not too full.
            pt_items = current_placement[partner]
            for i, m1 in enumerate(bn_items):
                w1, s1 = m1.req_rate / m1.slo, m1.model_size
                for j, m2 in enumerate(pt_items):
                    w2, s2 = m2.req_rate / m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu > GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu > GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    p_b = get_pressure(n_bl, n_bu)
                    p_p = get_pressure(n_pl, n_pu)

                    new_max = max(max_others, p_b, p_p)

                    if new_max > current_max + 1e-9: continue
                    new_sq = base_sq + p_b**2 + p_p**2

                    is_better = False
                    if new_max < current_max - 1e-9: is_better = True
                    elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                    if is_better:
                        if best_move is None:
                            best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                        else:
                            bm_max, bm_sq = best_move[8], best_move[9]
                            if new_max < bm_max - 1e-9:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                            elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)

        # Apply Move
        if best_move:
            type_, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if type_ == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1

            loads[bottleneck] = nbl
            used[bottleneck] = nbu
            loads[pt] = npl
            used[pt] = npu
            pressures[bottleneck] = get_pressure(loads[bottleneck], used[bottleneck])
            pressures[pt] = get_pressure(loads[pt], used[pt])

        else:
=======
    # ILS Parameters
    iterations = 1000

    for _ in range(iterations):
        # 1. Metrics & Global Best Update
        current_max = max(pressures)
        current_sq = sum(p*p for p in pressures)

        if current_max < best_max_p - 1e-8:
            best_max_p = current_max
            best_global_placement = {k: list(v) for k,v in current_placement.items()}

        # 2. Identify Bottleneck
        # Sort GPUs by pressure
        sorted_gpus = sorted(range(gpu_num), key=lambda g: pressures[g], reverse=True)
        bottleneck = sorted_gpus[0]

        # 3. Descent (Guided First-Improvement)
        # Sort partners by pressure ascending (target emptiest first)
        partners = sorted([g for g in range(gpu_num) if g != bottleneck], key=lambda g: pressures[g])

        # Sort bottleneck items by load descending (move heaviest first)
        bn_items = []
        for idx, m in enumerate(current_placement[bottleneck]):
            bn_items.append((idx, m))
        bn_items.sort(key=lambda x: x[1].req_rate / x[1].slo, reverse=True)

        found_improvement = False
        top_indices = sorted_gpus[:3]

        for partner in partners:
            # Determine max_others
            max_others = 0.0
            for g_idx in top_indices:
                if g_idx != bottleneck and g_idx != partner:
                    max_others = pressures[g_idx]
                    break

            base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2

            # A. Try Moving Item: Bottleneck -> Partner
            for i, m in bn_items:
                w, s = m.req_rate / m.slo, m.model_size

                if used[partner] + s > GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                p_b = get_pressure(n_bl, n_bu)
                p_p = get_pressure(n_pl, n_pu)

                new_max = max(max_others, p_b, p_p)

                if new_max > current_max + 1e-9: continue
                new_sq = base_sq + p_b**2 + p_p**2

                is_better = False
                if new_max < current_max - 1e-9: is_better = True
                elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                if is_better:
                    item = current_placement[bottleneck].pop(i)
                    current_placement[partner].append(item)
                    loads[bottleneck] = n_bl
                    used[bottleneck] = n_bu
                    loads[partner] = n_pl
                    used[partner] = n_pu
                    pressures[bottleneck] = p_b
                    pressures[partner] = p_p
                    found_improvement = True
                    break

            if found_improvement: break

            # B. Try Swapping: Bottleneck <-> Partner
            # Sort partner items by load ascending (bring back lightest load)
            pt_items = []
            for idx, m in enumerate(current_placement[partner]):
                pt_items.append((idx, m))
            pt_items.sort(key=lambda x: x[1].req_rate / x[1].slo)

            for i, m1 in bn_items:
                w1, s1 = m1.req_rate / m1.slo, m1.model_size
                for j, m2 in pt_items:
                    w2, s2 = m2.req_rate / m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu > GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu > GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    p_b = get_pressure(n_bl, n_bu)
                    p_p = get_pressure(n_pl, n_pu)

                    new_max = max(max_others, p_b, p_p)

                    if new_max > current_max + 1e-9: continue
                    new_sq = base_sq + p_b**2 + p_p**2

                    is_better = False
                    if new_max < current_max - 1e-9: is_better = True
                    elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                    if is_better:
                        item1 = current_placement[bottleneck][i]
                        item2 = current_placement[partner][j]
                        current_placement[bottleneck][i] = item2
                        current_placement[partner][j] = item1
                        loads[bottleneck] = n_bl
                        used[bottleneck] = n_bu
                        loads[partner] = n_pl
                        used[partner] = n_pu
                        pressures[bottleneck] = p_b
                        pressures[partner] = p_p
                        found_improvement = True
                        break
                if found_improvement: break
            if found_improvement: break

        if not found_improvement:
>>>>>>> REPLACE
</DIFF>