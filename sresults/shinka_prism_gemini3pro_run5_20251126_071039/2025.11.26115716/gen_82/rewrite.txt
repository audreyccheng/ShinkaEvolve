# EVOLVE-BLOCK-START
"""Model placement algorithm for minimizing maximum KV cache pressure across GPUs"""

import random
import math

GPU_MEM_SIZE = 80.0  # GB

def compute_model_placement(gpu_num, models):
    """
    Compute a model placement that minimizes the maximum KVPR across all GPUs.
    Combines Binary Search with BFD packing and Large Neighborhood Search (LNS) refinement.
    """

    # --- Preprocessing ---
    m_data = []
    for m in models:
        w = m.req_rate / m.slo if m.slo > 0 else 0
        s = m.model_size
        # Density: pressure per unit size
        d = w / s if s > 1e-6 else 0
        m_data.append({'w': w, 's': s, 'd': d, 'obj': m})

    # --- Helper: Pressure Calculation ---
    def get_pressure(l, u):
        rem = GPU_MEM_SIZE - u
        if rem <= 1e-6:
            return float('inf') if l > 1e-6 else 0.0
        return l / rem

    # --- Phase 1: Binary Search for Initial Solution ---
    
    # Heuristic packing function for initialization and bounds
    def pack_heuristic(sort_key_fn):
        sorted_items = sorted(m_data, key=sort_key_fn, reverse=True)
        placements = [[] for _ in range(gpu_num)]
        loads = [0.0] * gpu_num
        used = [0.0] * gpu_num
        
        for item in sorted_items:
            best_g = -1
            best_p = float('inf')
            
            # Best Fit based on resulting pressure
            for g in range(gpu_num):
                if used[g] + item['s'] > GPU_MEM_SIZE - 1e-6: continue
                
                # Check pressure
                rem = GPU_MEM_SIZE - used[g] - item['s']
                if rem > 1e-6:
                    p = (loads[g] + item['w']) / rem
                else:
                    p = float('inf') if (loads[g] + item['w']) > 0 else 0
                
                if p < best_p:
                    best_p = p
                    best_g = g
            
            if best_g == -1: return None, float('inf')
            
            placements[best_g].append(item['obj'])
            loads[best_g] += item['w']
            used[best_g] += item['s']
            
        max_p = max(get_pressure(loads[g], used[g]) for g in range(gpu_num))
        return placements, max_p

    # Try density and load sort to get a good upper bound
    best_bs_placement = None
    high_bound = 2000.0 # Default loose bound
    
    # Initial heuristic attempt
    res_d, max_d = pack_heuristic(lambda x: x['d'])
    if res_d and max_d < high_bound:
        best_bs_placement = res_d
        high_bound = max_d
        
    res_w, max_w = pack_heuristic(lambda x: x['w'])
    if res_w and max_w < high_bound:
        best_bs_placement = res_w
        high_bound = max_w
    
    # Lower bound estimation
    total_w = sum(x['w'] for x in m_data)
    total_s = sum(x['s'] for x in m_data)
    total_cap = GPU_MEM_SIZE * gpu_num - total_s
    low_bound = total_w / total_cap if total_cap > 1e-6 else 0.0

    # Binary Search Loop
    # We use a fixed number of iterations for speed
    low = low_bound
    high = high_bound
    if high > 1999 and best_bs_placement is None: 
        # If heuristics failed, we might be in a very tight constraint scenario.
        # Just use high bound.
        pass
    
    for _ in range(20): 
        if high - low < 1e-4: break
        mid = (low + high) / 2.0
        
        feasible = False
        temp_placement = None
        
        # Strategies: Density, Virtual Size
        # Virtual Size logic: w + K*s
        strategies = [
            lambda x: x['d'],
            lambda x: x['w'] + mid * x['s'],
        ]
        
        for key in strategies:
            items_sorted = sorted(m_data, key=key, reverse=True)
            
            p_alloc = [[] for _ in range(gpu_num)]
            g_l = [0.0] * gpu_num
            g_u = [0.0] * gpu_num
            all_fit = True
            
            for item in items_sorted:
                best_g = -1
                min_slack = float('inf')
                
                # Check bins
                for g in range(gpu_num):
                    if g_u[g] + item['s'] > GPU_MEM_SIZE - 1e-6: continue
                    
                    # Constraint check: L + w <= K * (C - U - s)
                    # Rearranged: (L + w) + K*(U + s) <= K*C
                    # Virtual Load + Virtual Item Size <= Virtual Capacity
                    
                    # Note: mid is K
                    lhs = (g_l[g] + item['w']) + mid * (g_u[g] + item['s'])
                    rhs = mid * GPU_MEM_SIZE
                    
                    if lhs <= rhs + 1e-7:
                        # Best Fit Decreasing: Minimize slack
                        slack = rhs - lhs
                        if slack < min_slack:
                            min_slack = slack
                            best_g = g
                
                if best_g != -1:
                    p_alloc[best_g].append(item['obj'])
                    g_l[best_g] += item['w']
                    g_u[best_g] += item['s']
                else:
                    all_fit = False
                    break
            
            if all_fit:
                feasible = True
                temp_placement = p_alloc
                break 
        
        if feasible:
            best_bs_placement = temp_placement
            high = mid
        else:
            low = mid

    if best_bs_placement is None:
        # Fallback to whatever we have or fail
        # This shouldn't happen given the loose upper bound unless impossible
        raise ValueError("No feasible placement found.")
        
    # --- Phase 2: Large Neighborhood Search (ILS) ---
    current_placement = {i: list(gpu) for i, gpu in enumerate(best_bs_placement)}
        
    loads = [0.0] * gpu_num
    used = [0.0] * gpu_num
    for g in range(gpu_num):
        for m in current_placement[g]:
            loads[g] += m.req_rate / m.slo
            used[g] += m.model_size
            
    pressures = [get_pressure(loads[g], used[g]) for g in range(gpu_num)]
    
    best_max_p = max(pressures)
    best_global_placement = {k: list(v) for k,v in current_placement.items()}
    
    # ILS Parameters
    iterations = 250
    
    for _ in range(iterations):
        # 1. Metrics & Global Best Update
        current_max = max(pressures)
        current_sq = sum(p*p for p in pressures)
        
        if current_max < best_max_p - 1e-8:
            best_max_p = current_max
            best_global_placement = {k: list(v) for k,v in current_placement.items()}
            
        # 2. Identify Bottleneck
        # Sort GPUs by pressure
        sorted_gpus = sorted(range(gpu_num), key=lambda g: pressures[g], reverse=True)
        bottleneck = sorted_gpus[0]
        
        # 3. Descent (Best-Improvement in Neighborhood)
        best_move = None 
        # (type, partner, idx_bn, idx_pt, n_bl, n_bu, n_pl, n_pu, n_max, n_sq)
        
        # Precompute top pressures to handle 'max_others' logic efficiently
        top_indices = sorted_gpus[:3]
        
        bn_items = current_placement[bottleneck]
        
        # Check all partners
        for partner in range(gpu_num):
            if partner == bottleneck: continue
            
            # Determine max_others
            max_others = 0.0
            for g_idx in top_indices:
                if g_idx != bottleneck and g_idx != partner:
                    max_others = pressures[g_idx]
                    break
            
            base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2

            # A. Try Moving Item: Bottleneck -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate / m.slo, m.model_size
                
                if used[partner] + s > GPU_MEM_SIZE - 1e-6: continue
                
                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s
                
                p_b = get_pressure(n_bl, n_bu)
                p_p = get_pressure(n_pl, n_pu)
                
                new_max = max(max_others, p_b, p_p)
                
                # Strict degradation check
                if new_max > current_max + 1e-9: continue
                
                new_sq = base_sq + p_b**2 + p_p**2
                
                is_better = False
                if new_max < current_max - 1e-9: is_better = True
                elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True
                
                if is_better:
                    if best_move is None:
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                    else:
                        # Compare with best_move found so far
                        bm_max, bm_sq = best_move[8], best_move[9]
                        if new_max < bm_max - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                        elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)

            # B. Try Swapping: Bottleneck <-> Partner
            if current_placement[partner]:
                pt_items = current_placement[partner]
                for i, m1 in enumerate(bn_items):
                    w1, s1 = m1.req_rate / m1.slo, m1.model_size
                    for j, m2 in enumerate(pt_items):
                        w2, s2 = m2.req_rate / m2.slo, m2.model_size
                        
                        n_bu = used[bottleneck] - s1 + s2
                        if n_bu > GPU_MEM_SIZE - 1e-6: continue
                        n_pu = used[partner] - s2 + s1
                        if n_pu > GPU_MEM_SIZE - 1e-6: continue
                        
                        n_bl = loads[bottleneck] - w1 + w2
                        n_pl = loads[partner] - w2 + w1
                        
                        p_b = get_pressure(n_bl, n_bu)
                        p_p = get_pressure(n_pl, n_pu)
                        
                        new_max = max(max_others, p_b, p_p)
                        
                        if new_max > current_max + 1e-9: continue
                        new_sq = base_sq + p_b**2 + p_p**2
                        
                        is_better = False
                        if new_max < current_max - 1e-9: is_better = True
                        elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True
                        
                        if is_better:
                            if best_move is None:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                            else:
                                bm_max, bm_sq = best_move[8], best_move[9]
                                if new_max < bm_max - 1e-9:
                                    best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                                elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                                    best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
        
        # Apply Move
        if best_move:
            type_, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if type_ == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1
            
            loads[bottleneck] = nbl
            used[bottleneck] = nbu
            loads[pt] = npl
            used[pt] = npu
            pressures[bottleneck] = get_pressure(loads[bottleneck], used[bottleneck])
            pressures[pt] = get_pressure(loads[pt], used[pt])
        
        else:
            # 4. Perturbation (Targeted Rebalancing)
            # Strategy: Take Bottleneck + Coolest GPU(s) and rebalance them.
            # This helps smoothen the variance.
            
            # Find coolest GPU (min pressure)
            coolest = -1
            min_val = float('inf')
            for g in range(gpu_num):
                if g != bottleneck and pressures[g] < min_val:
                    min_val = pressures[g]
                    coolest = g
            
            if coolest == -1: break
            
            # Define victims
            victims = [bottleneck, coolest]
            
            # Optionally add one random partner for noise
            others = [g for g in range(gpu_num) if g not in victims]
            if others:
                victims.append(random.choice(others))
                
            # Extract
            repack_items = []
            for v in victims:
                repack_items.extend(current_placement[v])
                current_placement[v] = []
                loads[v] = 0.0
                used[v] = 0.0
                pressures[v] = 0.0
            
            # Repack logic: 
            # We want to minimize Sum of Squared Pressures (Variance) among victims
            # Standard Greedy with noise
            
            # Sort items by density (usually best indicator)
            repack_items.sort(key=lambda x: (x['d']) * random.uniform(0.9, 1.1), reverse=True)
            
            success = True
            for item in repack_items:
                w, s = item['w'], item['s']
                
                best_v = -1
                best_sq = float('inf')
                
                # Check all victims
                for v in victims:
                    if used[v] + s <= GPU_MEM_SIZE - 1e-6:
                        # Hypothetical new state
                        p_new = get_pressure(loads[v] + w, used[v] + s)
                        
                        # Calculate contribution to Sum Squares
                        # We only care about the victim's contribution increase
                        # Actually just picking bin that results in minimal P^2 is equivalent 
                        # to picking bin with minimal new P (since P is monotonic)
                        # So just pick bin that minimizes resulting pressure.
                        if p_new < best_sq:
                            best_sq = p_new
                            best_v = v
                
                if best_v != -1:
                    current_placement[best_v].append(item['obj'])
                    loads[best_v] += w
                    used[best_v] += s
                else:
                    success = False
                    break
            
            if success:
                for v in victims:
                    pressures[v] = get_pressure(loads[v], used[v])
            else:
                # Revert
                current_placement = {k: list(v) for k, v in best_global_placement.items()}
                loads = [0.0]*gpu_num
                used = [0.0]*gpu_num
                for g in range(gpu_num):
                    for m in current_placement[g]:
                        loads[g] += m.req_rate / m.slo
                        used[g] += m.model_size
                pressures = [get_pressure(loads[g], used[g]) for g in range(gpu_num)]
                
    return best_global_placement