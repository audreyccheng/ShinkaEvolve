<NAME>
ordered_first_improvement
</NAME>

<DESCRIPTION>
Switch from Best-Improvement to Ordered First-Improvement in the local search.
Instead of evaluating all moves and picking the best, we evaluate moves in a heuristic order:
1. Partners are sorted by ascending pressure (try moving to emptiest GPUs first).
2. Bottleneck items are sorted by descending workload impact.
We accept the first move that improves the objective (reduces max pressure or reduces variance at same max pressure).
This strategy allows for more updates per second and exploits the structure of the problem (relieving bottleneck by moving heavy items to light GPUs).
Increased iteration count from 250 to 600 to leverage the speedup.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # ILS Parameters
    iterations = 250

    for _ in range(iterations):
        # 1. Metrics & Global Best Update
        current_max = max(pressures)
        current_sq = sum(p*p for p in pressures)

        if current_max < best_max_p - 1e-8:
            best_max_p = current_max
            best_global_placement = {k: list(v) for k,v in current_placement.items()}

        # 2. Identify Bottleneck
        # Sort GPUs by pressure
        sorted_gpus = sorted(range(gpu_num), key=lambda g: pressures[g], reverse=True)
        bottleneck = sorted_gpus[0]

        # 3. Descent (Best-Improvement in Neighborhood)
        best_move = None
        # (type, partner, idx_bn, idx_pt, n_bl, n_bu, n_pl, n_pu, n_max, n_sq)

        # Precompute top pressures for fast max check
        # We need the max pressure of all GPUs excluding bottleneck and partner
        top_indices = sorted_gpus[:3]

        # Define neighborhood: Bottleneck <-> All Partners
        # Optimization: Filter partners? No, check all to find best relief.
        partners = [g for g in range(gpu_num) if g != bottleneck]

        bn_items = current_placement[bottleneck]

        for partner in partners:
            # Determine max_others
            max_others = 0.0
            for g_idx in top_indices:
                if g_idx != bottleneck and g_idx != partner:
                    max_others = pressures[g_idx]
                    break

            # Base sq sum excluding pair
            base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2

            # A. Try Moving Item: Bottleneck -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate / m.slo, m.model_size

                if used[partner] + s > GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                p_b = get_pressure(n_bl, n_bu)
                p_p = get_pressure(n_pl, n_pu)

                new_max = max(max_others, p_b, p_p)

                # Strict degradation check
                if new_max > current_max + 1e-9: continue

                new_sq = base_sq + p_b**2 + p_p**2

                # Acceptance criteria: Better Max OR (Equal Max AND Better Variance)
                is_better = False
                if new_max < current_max - 1e-9: is_better = True
                elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                if is_better:
                    if best_move is None:
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                    else:
                        # Compare with best_move found so far
                        bm_max, bm_sq = best_move[8], best_move[9]
                        if new_max < bm_max - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                        elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)

            # B. Try Swapping: Bottleneck <-> Partner
            # Only try if we didn't find a very good move, or check anyway?
            # Swaps are expensive O(N*M). Do if partner not too full.
            pt_items = current_placement[partner]
            for i, m1 in enumerate(bn_items):
                w1, s1 = m1.req_rate / m1.slo, m1.model_size
                for j, m2 in enumerate(pt_items):
                    w2, s2 = m2.req_rate / m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu > GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu > GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    p_b = get_pressure(n_bl, n_bu)
                    p_p = get_pressure(n_pl, n_pu)

                    new_max = max(max_others, p_b, p_p)

                    if new_max > current_max + 1e-9: continue
                    new_sq = base_sq + p_b**2 + p_p**2

                    is_better = False
                    if new_max < current_max - 1e-9: is_better = True
                    elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                    if is_better:
                        if best_move is None:
                            best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                        else:
                            bm_max, bm_sq = best_move[8], best_move[9]
                            if new_max < bm_max - 1e-9:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)
                            elif abs(new_max - bm_max) < 1e-9 and new_sq < bm_sq - 1e-9:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, new_max, new_sq)

        # Apply Move
        if best_move:
            type_, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if type_ == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1

            loads[bottleneck] = nbl
            used[bottleneck] = nbu
            loads[pt] = npl
            used[pt] = npu
            pressures[bottleneck] = get_pressure(loads[bottleneck], used[bottleneck])
            pressures[pt] = get_pressure(loads[pt], used[pt])

        else:
=======
    # ILS Parameters
    iterations = 600

    for _ in range(iterations):
        # 1. Metrics & Global Best Update
        current_max = max(pressures)
        current_sq = sum(p*p for p in pressures)

        if current_max < best_max_p - 1e-8:
            best_max_p = current_max
            best_global_placement = {k: list(v) for k,v in current_placement.items()}

        # 2. Identify Bottleneck
        # Sort GPUs by pressure
        sorted_gpus = sorted(range(gpu_num), key=lambda g: pressures[g], reverse=True)
        bottleneck = sorted_gpus[0]

        # 3. Descent (Ordered First-Improvement)
        found_improvement = False

        # Precompute top pressures for fast max check
        top_indices = sorted_gpus[:3]

        # Sort partners by ascending pressure (target least loaded first)
        sorted_partners = sorted([g for g in range(gpu_num) if g != bottleneck], key=lambda g: pressures[g])

        # Sort bottleneck items by descending workload impact (target heaviest first)
        bn_items = current_placement[bottleneck]
        bn_item_indices = sorted(range(len(bn_items)), key=lambda i: bn_items[i].req_rate/(bn_items[i].slo if bn_items[i].slo > 0 else 1e-6), reverse=True)

        # A. Try Moving Item: Bottleneck -> Partner
        for partner in sorted_partners:
            # Determine max_others
            max_others = 0.0
            for g_idx in top_indices:
                if g_idx != bottleneck and g_idx != partner:
                    max_others = pressures[g_idx]
                    break

            base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2

            for i in bn_item_indices:
                m = bn_items[i]
                w, s = m.req_rate / m.slo if m.slo > 0 else 0, m.model_size

                if used[partner] + s > GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                p_b = get_pressure(n_bl, n_bu)
                p_p = get_pressure(n_pl, n_pu)

                new_max = max(max_others, p_b, p_p)

                if new_max > current_max + 1e-9: continue

                new_sq = base_sq + p_b**2 + p_p**2

                is_better = False
                if new_max < current_max - 1e-9: is_better = True
                elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                if is_better:
                    # Apply immediately
                    item = current_placement[bottleneck].pop(i)
                    current_placement[partner].append(item)
                    loads[bottleneck] = n_bl
                    used[bottleneck] = n_bu
                    loads[partner] = n_pl
                    used[partner] = n_pu
                    pressures[bottleneck] = p_b
                    pressures[partner] = p_p
                    found_improvement = True
                    break
            if found_improvement: break

        # B. Try Swapping: Bottleneck <-> Partner (only if no move found)
        if not found_improvement:
            for partner in sorted_partners:
                max_others = 0.0
                for g_idx in top_indices:
                    if g_idx != bottleneck and g_idx != partner:
                        max_others = pressures[g_idx]
                        break

                base_sq = current_sq - pressures[bottleneck]**2 - pressures[partner]**2
                pt_items = current_placement[partner]

                for i in bn_item_indices:
                    m1 = bn_items[i]
                    w1, s1 = m1.req_rate / m1.slo if m1.slo > 0 else 0, m1.model_size

                    for j, m2 in enumerate(pt_items):
                        w2, s2 = m2.req_rate / m2.slo if m2.slo > 0 else 0, m2.model_size

                        n_bu = used[bottleneck] - s1 + s2
                        if n_bu > GPU_MEM_SIZE - 1e-6: continue
                        n_pu = used[partner] - s2 + s1
                        if n_pu > GPU_MEM_SIZE - 1e-6: continue

                        n_bl = loads[bottleneck] - w1 + w2
                        n_pl = loads[partner] - w2 + w1

                        p_b = get_pressure(n_bl, n_bu)
                        p_p = get_pressure(n_pl, n_pu)

                        new_max = max(max_others, p_b, p_p)

                        if new_max > current_max + 1e-9: continue

                        new_sq = base_sq + p_b**2 + p_p**2

                        is_better = False
                        if new_max < current_max - 1e-9: is_better = True
                        elif new_max < current_max + 1e-9 and new_sq < current_sq - 1e-9: is_better = True

                        if is_better:
                            # Apply immediately
                            current_placement[bottleneck][i] = m2
                            current_placement[partner][j] = m1
                            loads[bottleneck] = n_bl
                            used[bottleneck] = n_bu
                            loads[partner] = n_pl
                            used[partner] = n_pu
                            pressures[bottleneck] = p_b
                            pressures[partner] = p_p
                            found_improvement = True
                            break
                    if found_improvement: break
                if found_improvement: break

        if not found_improvement:
>>>>>>> REPLACE
</DIFF>