<NAME>
smart_kick_diverse_repack
</NAME>

<DESCRIPTION>
Optimizes the perturbation mechanism (Kick) in two ways to escape local optima more effectively:
1.  **Smart Partner Selection**: Instead of choosing random partners for the bottleneck GPU during the kick, we select partners with the lowest current pressure. This facilitates load balancing by explicitly moving work from the highest pressure GPU to those with the most slack.
2.  **Diverse Repacking**: Within the kick's repacking phase, we now use a mix of sorting strategies (Density, Load, Size, and Random) across multiple trials with noise. This increases the diversity of candidate packings explored, improving the chances of finding a configuration that fits the items better than the previous simple density-based sort.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        else:
            # 4. Perturbation (Burst Kick) with Multiple Trials
            # If stuck, destroy packing of Bottleneck + k Random Partners
            k_partners = min(gpu_num - 1, 3)
            if k_partners == 0: break

            partner_cands = [g for g in range(gpu_num) if g != bottleneck]
            victims = [bottleneck] + random.sample(partner_cands, k_partners)

            # Extract items
            repack_items = []
            for v in victims:
                repack_items.extend(current_placement[v])
                current_placement[v] = []
                loads[v] = 0.0
                used[v] = 0.0
                pressures[v] = 0.0

            # Try multiple repacking attempts
            best_local_config = None
            best_local_max = float('inf')

            for _ in range(10): # 10 trials
                # Randomized Density Sort
                trial_items = list(repack_items)
                random.shuffle(trial_items)
                trial_items.sort(key=lambda x: (x.req_rate/x.slo)/(x.model_size+1e-6) * random.uniform(0.8, 1.2), reverse=True)

                l_loads = {v: 0.0 for v in victims}
                l_used = {v: 0.0 for v in victims}
                l_placement = {v: [] for v in victims}
                possible = True

                for item in trial_items:
                    w, s = item.req_rate / item.slo, item.model_size
                    best_v = -1
                    best_sc = float('inf')

                    # Best Fit (min pressure)
                    for v in victims:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            rem = GPU_MEM_SIZE - l_used[v] - s
                            if rem > 1e-6:
                                sc = (l_loads[v] + w) / rem
                            else:
                                sc = float('inf') if (l_loads[v] + w) > 0 else 0

                            if sc < best_sc:
                                best_sc = sc
                                best_v = v

                    # Fallback to Any Fit if Best Fit fails
                    if best_v == -1:
                        for v in victims:
                             if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                                 best_v = v
                                 break

                    if best_v != -1:
                        l_placement[best_v].append(item)
                        l_loads[best_v] += w
                        l_used[best_v] += s
                    else:
                        possible = False
                        break

                if possible:
                    local_max = max(get_pressure(l_loads[v], l_used[v]) for v in victims)
                    if local_max < best_local_max:
                        best_local_max = local_max
                        best_local_config = (l_placement, l_loads, l_used)
=======
        else:
            # 4. Perturbation (Smart Kick with Diverse Repacking)
            # Pick k partners with lowest pressure to absorb load from bottleneck
            k_partners = min(gpu_num - 1, 3)
            if k_partners == 0: break

            # Sort candidate partners by pressure ascending to find coolest GPUs
            candidates = sorted([g for g in range(gpu_num) if g != bottleneck], key=lambda g: pressures[g])
            # Select from the top 2*k candidates to add some randomness while favoring low pressure
            pool_size = min(len(candidates), k_partners * 2)
            chosen_partners = random.sample(candidates[:pool_size], k_partners)

            victims = [bottleneck] + chosen_partners

            # Extract items
            repack_items = []
            for v in victims:
                repack_items.extend(current_placement[v])
                current_placement[v] = []
                loads[v] = 0.0
                used[v] = 0.0
                pressures[v] = 0.0

            # Try multiple repacking attempts with diverse strategies
            best_local_config = None
            best_local_max = float('inf')

            strategies = [
                lambda x: (x.req_rate/x.slo)/(x.model_size+1e-6), # Density
                lambda x: x.req_rate/x.slo,                       # Load
                lambda x: x.model_size                            # Size
            ]

            for t in range(12): # 12 trials
                trial_items = list(repack_items)

                if t < 9:
                    # Deterministic strategies with multiplicative noise
                    base_key = strategies[t % 3]
                    trial_items.sort(key=lambda x: base_key(x) * random.uniform(0.8, 1.2), reverse=True)
                else:
                    # Pure random shuffle
                    random.shuffle(trial_items)

                l_loads = {v: 0.0 for v in victims}
                l_used = {v: 0.0 for v in victims}
                l_placement = {v: [] for v in victims}
                possible = True

                for item in trial_items:
                    w, s = item.req_rate / item.slo, item.model_size
                    best_v = -1
                    best_sc = float('inf')

                    # Best Fit (min pressure)
                    for v in victims:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            rem = GPU_MEM_SIZE - l_used[v] - s
                            if rem > 1e-6:
                                sc = (l_loads[v] + w) / rem
                            else:
                                sc = float('inf') if (l_loads[v] + w) > 0 else 0

                            if sc < best_sc:
                                best_sc = sc
                                best_v = v

                    # Fallback to Any Fit
                    if best_v == -1:
                        for v in victims:
                             if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                                 best_v = v
                                 break

                    if best_v != -1:
                        l_placement[best_v].append(item)
                        l_loads[best_v] += w
                        l_used[best_v] += s
                    else:
                        possible = False
                        break

                if possible:
                    local_max = max(get_pressure(l_loads[v], l_used[v]) for v in victims)
                    if local_max < best_local_max:
                        best_local_max = local_max
                        best_local_config = (l_placement, l_loads, l_used)
>>>>>>> REPLACE
</DIFF>