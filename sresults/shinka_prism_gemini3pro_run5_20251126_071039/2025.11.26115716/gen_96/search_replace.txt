<NAME>
ils_first_improvement_sorted
</NAME>

<DESCRIPTION>
Switch the Iterated Local Search (ILS) strategy from "Best-Improvement" to "First-Improvement" with intelligent candidate sorting.
1. Sort items on the bottleneck GPU by pressure contribution (Load) descending.
2. Sort partner GPUs by current pressure ascending.
3. Apply the first valid move or swap found that improves the objective, then immediately restart the search.
4. Increase iteration limit to 1000 to leverage the faster iteration speed.
This approach explores the neighborhood more efficiently by prioritizing the most promising moves (moving heavy items to light GPUs) and making many small improvements quickly, rather than evaluating the entire neighborhood for a single best move.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # ILS Parameters
    max_iters = 250

    for iteration in range(max_iters):
        current_max_p = max(pressures)
        current_sum_sq = sum(p*p for p in pressures)

        if current_max_p < best_max_p - 1e-7:
            best_max_p = current_max_p
            best_placement = {k: list(v) for k, v in current_placement.items()}

        # Bottleneck
        bottleneck = -1
        max_val = -1.0
        for g in range(gpu_num):
            if pressures[g] > max_val:
                max_val = pressures[g]
                bottleneck = g

        if bottleneck == -1: break

        # --- Descent: Best Improvement ---
        best_move = None
        # (type, partner, idx_bn, idx_pt, nb_l, nb_u, np_l, np_u, max_p, sum_sq)

        bn_items = current_placement[bottleneck]

        for partner in range(gpu_num):
            if partner == bottleneck: continue

            # Efficiently find max pressure excluding BN and Partner
            # We only need to check the global top pressures
            max_others = 0.0
            for g in range(gpu_num):
                if g != bottleneck and g != partner:
                    if pressures[g] > max_others: max_others = pressures[g]

            sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)

            # 1. Move BN -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate/m.slo, m.model_size
                if used[partner] + s >= GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                pb = get_pressure(n_bl, n_bu)
                pp = get_pressure(n_pl, n_pu)

                nm = max(max_others, pb, pp)

                if nm > current_max_p + 1e-9: continue

                nsq = sq_base + pb**2 + pp**2

                better = False
                if nm < current_max_p - 1e-9: better = True
                elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                if better:
                    if best_move is None or nm < best_move[8] - 1e-9 or (abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]):
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, nm, nsq)

            # 2. Swap BN <-> Partner
            pt_items = current_placement[partner]
            for i, m1 in enumerate(bn_items):
                w1, s1 = m1.req_rate/m1.slo, m1.model_size
                for j, m2 in enumerate(pt_items):
                    w2, s2 = m2.req_rate/m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu >= GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu >= GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    pb = get_pressure(n_bl, n_bu)
                    pp = get_pressure(n_pl, n_pu)

                    nm = max(max_others, pb, pp)
                    if nm > current_max_p + 1e-9: continue
                    nsq = sq_base + pb**2 + pp**2

                    better = False
                    if nm < current_max_p - 1e-9: better = True
                    elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                    if better:
                        if best_move is None or nm < best_move[8] - 1e-9 or (abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]):
                            best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, nm, nsq)

        if best_move:
            mtype, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if mtype == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1

            loads[bottleneck], used[bottleneck] = nbl, nbu
            loads[pt], used[pt] = npl, npu
            pressures[bottleneck] = get_pressure(nbl, nbu)
            pressures[pt] = get_pressure(npl, npu)
            continue
=======
    # ILS Parameters
    max_iters = 1000

    for iteration in range(max_iters):
        current_max_p = max(pressures)
        current_sum_sq = sum(p*p for p in pressures)

        if current_max_p < best_max_p - 1e-7:
            best_max_p = current_max_p
            best_placement = {k: list(v) for k, v in current_placement.items()}

        # Bottleneck
        bottleneck = -1
        max_val = -1.0
        for g in range(gpu_num):
            if pressures[g] > max_val:
                max_val = pressures[g]
                bottleneck = g

        if bottleneck == -1: break

        # --- Descent: First Improvement with Sorted Candidates ---
        # Sort items on bottleneck by load (req_rate/slo) descending
        bn_items = current_placement[bottleneck]
        bn_indices = sorted(range(len(bn_items)), key=lambda idx: bn_items[idx].req_rate/bn_items[idx].slo, reverse=True)

        # Sort partners by pressure ascending
        partners = sorted([g for g in range(gpu_num) if g != bottleneck], key=lambda g: pressures[g])

        found_move = False

        for partner in partners:
            max_others = 0.0
            for g in range(gpu_num):
                if g != bottleneck and g != partner:
                     if pressures[g] > max_others: max_others = pressures[g]

            sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)

            # 1. Try Move BN -> Partner
            for i in bn_indices:
                m = bn_items[i]
                w, s = m.req_rate/m.slo, m.model_size
                if used[partner] + s >= GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                pb = get_pressure(n_bl, n_bu)
                pp = get_pressure(n_pl, n_pu)

                nm = max(max_others, pb, pp)

                better = False
                if nm < current_max_p - 1e-9: better = True
                elif nm < current_max_p + 1e-9:
                    nsq = sq_base + pb**2 + pp**2
                    if nsq < current_sum_sq - 1e-9: better = True

                if better:
                    # Apply Move
                    item = current_placement[bottleneck].pop(i)
                    current_placement[partner].append(item)
                    loads[bottleneck], used[bottleneck] = n_bl, n_bu
                    loads[partner], used[partner] = n_pl, n_pu
                    pressures[bottleneck] = pb
                    pressures[partner] = pp
                    found_move = True
                    break
            if found_move: break

            # 2. Try Swap BN <-> Partner
            pt_items = current_placement[partner]
            pt_indices = sorted(range(len(pt_items)), key=lambda idx: pt_items[idx].req_rate/pt_items[idx].slo)

            for i in bn_indices:
                m1 = bn_items[i]
                w1, s1 = m1.req_rate/m1.slo, m1.model_size
                for j in pt_indices:
                    m2 = pt_items[j]
                    w2, s2 = m2.req_rate/m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu >= GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu >= GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    pb = get_pressure(n_bl, n_bu)
                    pp = get_pressure(n_pl, n_pu)

                    nm = max(max_others, pb, pp)

                    better = False
                    if nm < current_max_p - 1e-9: better = True
                    elif nm < current_max_p + 1e-9:
                        nsq = sq_base + pb**2 + pp**2
                        if nsq < current_sum_sq - 1e-9: better = True

                    if better:
                        # Apply Swap
                        item1 = current_placement[bottleneck][i]
                        item2 = current_placement[partner][j]
                        current_placement[bottleneck][i] = item2
                        current_placement[partner][j] = item1

                        loads[bottleneck], used[bottleneck] = n_bl, n_bu
                        loads[partner], used[partner] = n_pl, n_pu
                        pressures[bottleneck] = pb
                        pressures[partner] = pp
                        found_move = True
                        break
                if found_move: break
            if found_move: break

        if found_move: continue
>>>>>>> REPLACE
</DIFF>