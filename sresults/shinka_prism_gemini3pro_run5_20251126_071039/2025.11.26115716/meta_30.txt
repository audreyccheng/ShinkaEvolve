# INDIVIDUAL PROGRAM SUMMARIES

The following are summaries of individual programs evaluated since the last meta update:

**Program Name: Greedy KVPR Minimization via Rate-SLO Ratio**
- **Implementation**: The algorithm sorts models descending by their request rate divided by SLO and assigns each to the GPU with the lowest current KV cache pressure ratio (weighted rate divided by remaining memory).
- **Performance**: Achieved a high combined score of 21.89 with a 100% success rate, efficiently minimizing the maximum KV cache pressure.
- **Feedback**: Sorting by the intensity metric ($r_j/s_j$) prior to placement ensures that resource-heavy models are distributed optimally early on, preventing bottlenecks.
**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True

**Program Name: Binary Search with First Fit Decreasing Packing**
- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search to find the optimal threshold, validating candidates via First Fit Decreasing (FFD) packing based on a derived "virtual size" metric.
- **Performance**: It achieved a combined score of 26.23 with a 100% success rate and negligible execution time.
- **Feedback**: The approach effectively transforms the continuous minimax optimization problem into a discrete packing feasibility check, allowing the FFD heuristic to efficiently balance loads while strictly adhering to physical memory constraints.
**Program Identifier:** Generation 1 - Patch Name bisect_kvpr_packing - Correct Program: True

**Program Name: Greedy Size-Sorted KVPR Minimization**
- **Implementation**: The solution sorts models by size and load in descending order, then assigns each model to the GPU that results in the minimum local KV cache pressure ratio. It dynamically updates the remaining memory and accumulated request load for each GPU to inform subsequent placement decisions.
- **Performance**: The approach performed exceptionally well, achieving a combined score of 20.43 with a perfect success rate and negligible execution time.
- **Feedback**: Sorting large models first proved critical for adhering to memory constraints, while the greedy local minimization step successfully balanced the ratio of request load to available memory across devices to minimize pressure.
**Program Identifier:** Generation 2 - Patch Name greedy_kvpr_projection - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Packing and Local Search**
- **Implementation**: The solution employs binary search on target pressure using multiple bin packing heuristics (FFD, BFD) on transformed constraints, followed by a local search refinement step to rebalance bottleneck GPUs.
- **Performance**: It achieves a high combined score of 26.23 with a 100% success rate and negligible execution time.
- **Feedback**: The use of diverse packing strategies improves feasibility detection during binary search, while the greedy local search effectively reduces peak pressure by smoothing load imbalances.
**Program Identifier:** Generation 3 - Patch Name bisect_pack_refine - Correct Program: True

**Program Name: Multi-Strategy Binary Search Packing with Iterated Local Search**
- **Implementation**: This algorithm employs binary search over the target pressure using First-Fit Decreasing on both virtual and physical dimensions to construct an initial solution, followed by an Iterated Local Search that utilizes bottleneck-targeted moves, swaps, and random perturbations.
- **Performance**: The solution achieves a strong combined score of 26.26 with a 100% success rate and exceptional speed (0.006s).
- **Feedback**: The use of multiple sorting strategies during the construction phase creates a high-quality baseline, while the perturbation mechanism in the local search effectively escapes local optima to minimize peak pressure without significantly increasing runtime.
**Program Identifier:** Generation 4 - Patch Name bs_multi_pack_ils - Correct Program: True

**Program Name: Binary Search with Multi-Strategy Packing and Local Search Refinement**
- **Implementation**: This approach minimizes maximum KV cache pressure by binary searching on a target ratio, transforming the constraint into a bin packing problem solved via multiple heuristics (FFD, BFD) on virtual sizes. A post-processing local search iteratively moves or swaps models from the highest-pressure GPU to further optimize the result.
- **Performance**: The algorithm achieved a strong combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: Transforming the non-linear objective into a variable-size bin packing problem allowed for efficient approximation, while the multi-heuristic feasibility check and local search refinement ensured a high-quality, balanced distribution.
**Program Identifier:** Generation 5 - Patch Name improved_packing_and_local_search - Correct Program: True

**Program Name: Robust Binary Search Packing with Pressure Relief Local Search**
- **Implementation**: Uses binary search with multiple First-Fit Decreasing heuristics (sorting by virtual size, physical size, load, density) to construct a tight initial packing, followed by iterated local search that targets bottleneck GPUs for moves/swaps and uses forced random moves to escape local optima.
- **Performance**: Achieved a combined score of 26.23 with a metric of 25.233, 100% success rate, and 0.005s execution time.
- **Feedback**: The multi-strategy construction phase ensures a valid starting point even under tight constraints, while the "pressure relief" logic in the local search effectively targets and reduces the maximum KV cache pressure.
**Program Identifier:** Generation 6 - Patch Name iterative_pressure_relief - Correct Program: True

**Program Name: Greedy KVPR Minimization with Size-Descending Sort**
- **Implementation**: The algorithm sorts models by size in descending order and iteratively assigns each to the GPU that results in the lowest immediate KV cache pressure ratio (KVPR). It tracks remaining memory and cumulative load per GPU to dynamically calculate the cost of each potential placement.
- **Performance**: The solution achieved a high combined score of 20.43 with a 100% success rate and negligible execution time.
- **Feedback**: Prioritizing large models first effectively minimizes memory fragmentation, while the greedy assignment strategy successfully balances the load relative to remaining capacity, preventing pressure spikes on individual GPUs.
**Program Identifier:** Generation 7 - Patch Name greedy_resultant_kvpr_size_sort - Correct Program: True

**Program Name: Hybrid Robust Packing with Adaptive Iterated Local Search**
- **Implementation**: Initializes utilizing binary search across four distinct First-Fit Decreasing sorting heuristics (Virtual/Physical size, Load, Density), then refines via Hill Climbing with targeted moves, swaps, and adaptive perturbation kicks on bottleneck GPUs.
- **Performance**: Achieves a strong combined score of 26.23 with extremely fast execution (0.038s), though the 84% success rate indicates occasional inability to find valid initial placements.
- **Feedback**: The use of multiple sorting strategies creates robust starting solutions, and the bottleneck-focused local search effectively minimizes peak pressure, but the packing logic occasionally fails on tighter constraints.
**Program Identifier:** Generation 8 - Patch Name hybrid_robust_packing_adaptive_ils - Correct Program: True

**Program Name: Greedy Resultant KVPR Minimization**
- **Implementation**: The algorithm sorts models by load intensity and iteratively assigns them to the GPU that minimizes the projected KV cache pressure (load divided by remaining memory) for that specific assignment.
- **Performance**: Achieved a high combined score of 22.67 with a max KVPR inverse score of 21.670 and a perfect success rate.
- **Feedback**: Calculating the specific impact on the KVPR metric for every potential placement allows the greedy approach to effectively minimize global maximum pressure, significantly outperforming simple load-balancing or bin-packing heuristics.
**Program Identifier:** Generation 9 - Patch Name projected_kvpr_load_sort - Correct Program: True

**Program Name: Multi-Strategy Packing with Iterated Local Search**
- **Implementation**: This approach combines binary search over four distinct bin-packing heuristics (FFD/BFD on virtual and physical sizes) to generate a high-quality initial placement, followed by an Iterated Local Search that utilizes greedy moves, swaps, and random perturbations to refine the bottleneck GPU.
- **Performance**: It achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.009s).
- **Feedback**: The use of multiple packing strategies ensures a robust initial solution across different constraint landscapes, while the local search effectively fine-tunes load balancing, offering an excellent trade-off between speed and placement quality.
**Program Identifier:** Generation 10 - Patch Name hybrid_ils_multipack_placement - Correct Program: True

**Program Name: Hybrid Packing Search with Ruin & Recreate Refinement**
- **Implementation**: The algorithm employs a binary search for the minimum max KVPR using five distinct FFD/BFD packing heuristics (sorted by virtual size, physical size, or density), followed by Simulated Annealing with a "Ruin & Recreate" operator to break bottlenecks.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.007s).
- **Feedback**: The combination of multiple packing heuristics ensures a robust initial solution, while the targeted destruction and reconstruction of bottleneck assignments in the annealing phase effectively minimizes peak pressure where standard swaps might fail.
**Program Identifier:** Generation 11 - Patch Name hybrid_bfd_ruin_recreate - Correct Program: True

**Program Name: Binary Search with Transformed Best Fit Decreasing**
- **Implementation**: The algorithm minimizes maximum KV pressure by binary searching on a target pressure $K$, transforming the non-linear objective into a linear Bin Packing feasibility check (item size $w + K \cdot s$) solved using a Best Fit Decreasing heuristic.
- **Performance**: The solution achieved a combined score of 26.23 (KVPR metric: 25.233) with a 100% success rate and negligible execution time.
- **Feedback**: Converting the fractional minimax objective into a parameterized linear packing constraint proved highly effective, allowing standard greedy packing heuristics to reliably find near-optimal pressure distributions.
**Program Identifier:** Generation 12 - Patch Name binary_search_packing - Correct Program: True

**Program Name: Binary Search Packing with Local Search Refinement**
- **Implementation**: The algorithm minimizes KV cache pressure by transforming the non-linear objective into a linear bin-packing feasibility check within a binary search, utilizing multiple Best-Fit sorting strategies. It initializes with density-based heuristics and concludes with a hill-climbing local search that iteratively moves or swaps models from the highest-pressure bottleneck GPU.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and exceptional speed (0.001s).
- **Feedback**: The linearization of the fractional pressure constraint enables the effective use of standard bin-packing heuristics, while the multi-strategy approach and local search refinement significantly improve solution quality by avoiding local optima.
**Program Identifier:** Generation 13 - Patch Name binary_search_multi_strategy_packing_with_local_refinement - Correct Program: True

**Program Name: Multi-Strategy Packing with Iterated Local Search**
- **Implementation**: Utilizes binary search with six bin-packing heuristics (FFD/BFD on virtual/physical size and load) to find an initial bound, followed by iterated local search employing greedy moves, swaps, and ruin-and-recreate perturbations.
- **Performance**: Achieved a high combined score of 26.23 and a metric of 25.233 with 100% success rate and fast execution (0.016s).
- **Feedback**: The diverse packing strategies ensure feasibility under tight constraints, while the local search's perturbation mechanism effectively breaks bottlenecks to minimize maximum cache pressure.
**Program Identifier:** Generation 14 - Patch Name robust_ils_with_ruin_recreate - Correct Program: True

**Program Name: Binary Search Packing with Simulated Annealing Refinement**
- **Implementation**: Utilizes binary search over pressure constraints with multi-strategy BFD/FFD packing (sorting by virtual size, physical size, and density) followed by Simulated Annealing with variance-based tie-breaking for final refinement.
- **Performance**: Achieved a combined score of 26.23 with a 100% success rate and negligible execution time (0.002s).
- **Feedback**: The use of diverse packing heuristics ensures a high-quality initial placement, and the variance-aware annealing effectively balances loads; however, the extremely fast runtime suggests the annealing iterations could be increased for further optimization gains.
**Program Identifier:** Generation 15 - Patch Name binary_bfd_sa - Correct Program: True

**Program Name: Binary Search Packing with Ruin-and-Recreate Local Search**
- **Implementation**: Transforms the non-linear objective into a linear bin packing problem via binary search, utilizing multiple sorting heuristics (FFD/BFD) for feasibility checks and refining the result with Ruin-and-Recreate Iterated Local Search.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and fast execution (0.009s).
- **Feedback**: The linearization of the objective allows for efficient global bounds checking, while the multi-heuristic packing and perturbation phases effectively balance loads across GPUs to escape local optima.
**Program Identifier:** Generation 16 - Patch Name robust_bfd_ils_ruin - Correct Program: True

**Program Name: Robust Binary Search with Heuristics and Variance-Penalized Annealing**
- **Implementation**: Utilizes binary search over the pressure threshold with multiple packing heuristics (FFD/BFD on various sort keys) to find a strong initial state, followed by simulated annealing using variance as a tie-breaker.
- **Performance**: Achieved a combined score of 26.26 with a max KVPR score of 25.26 and 0.003s execution time.
- **Feedback**: The multi-heuristic feasibility check ensures tight packing for the initial solution, and the bottleneck-biased annealing efficiently resolves remaining imbalances.
**Program Identifier:** Generation 17 - Patch Name robust_packing_sa - Correct Program: True

**Program Name: Multi-Strategy Binary Search Packing with Local Search Refinement**
- **Implementation**: The algorithm minimizes maximum KV cache pressure using binary search on the objective value, checking feasibility via Best-Fit Decreasing with four distinct sorting strategies (including density and virtual size). It concludes with a hill-climbing local search that iteratively moves or swaps models from the bottleneck GPU to finer-tune the distribution.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and negligible execution time (0.001s).
- **Feedback**: The multi-strategy approach during the feasibility check prevents the packer from getting stuck in local optima, while the post-processing local search effectively corrects minor imbalances that heuristic packing might miss.
**Program Identifier:** Generation 18 - Patch Name improve_strategies_and_localsearch - Correct Program: True

**Program Name: Robust Multi-Heuristic Packing with Iterated Local Search**
- **Implementation**: Uses binary search with six diverse FFD/BFD packing heuristics (sorted by virtual size, physical size, and load) to find an initial solution, followed by iterated local search utilizing steepest descent and random perturbations.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and rapid execution time (0.026s).
- **Feedback**: The combination of multiple packing strategies ensures a high-quality initialization for binary search, while the random kick mechanism in the local search phase effectively mitigates stagnation in local optima.
**Program Identifier:** Generation 19 - Patch Name hybrid_packing_ils - Correct Program: True

**Program Name: Binary Search Packing with Multi-Strategy Sorting and Local Refinement**
- **Implementation**: The algorithm utilizes binary search on the fractional objective to linearize constraints, solving the resulting bin packing problem via best-fit with multiple sorting strategies (density, size, load). A post-processing local search iteratively rebalances bottleneck GPUs by optimizing pairs to further reduce pressure.
- **Performance**: The approach yielded a high score of 26.23 with a 100% success rate and exceptional speed (0.001s).
- **Feedback**: Linearly transforming the pressure constraint allows effective use of standard bin packing heuristics, while the multi-strategy approach and local refinement ensure the solution avoids local optima common in greedy algorithms.
**Program Identifier:** Generation 20 - Patch Name pairwise_rebalance_search - Correct Program: True

**Program Name: Binary Search with Transformed Constraints and Iterated Local Search**
- **Implementation**: The algorithm employs binary search on the pressure target by transforming the fractional objective into a linear constraint, checking feasibility via multi-strategy Best-Fit packing. It refines the solution using Iterated Local Search (ILS) with bottleneck-focused move/swap operations and a ruin-and-recreate perturbation mechanism.
- **Performance**: The solution achieved a high combined score of 26.23 (max_kvpr: 25.233) with a 100% success rate and rapid execution (0.015s).
- **Feedback**: Linearly transforming the non-linear pressure constraint enables the effective use of standard packing heuristics, while the local search phase significantly improves the worst-case GPU utilization by iteratively relieving bottlenecks.
**Program Identifier:** Generation 21 - Patch Name ils_ruin_recreate - Correct Program: True

**Program Name: Linearized Binary Search with Variable Neighborhood Descent**
- **Implementation**: The solution transforms the fractional KV pressure objective into a linear constraint to perform a binary search using multiple Best Fit heuristics, followed by Variable Neighborhood Descent using move, swap, and pairwise-shuffle operators on the bottleneck GPU.
- **Performance**: Achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution time (0.001s).
- **Feedback**: Linearly transforming the pressure constraint allows for a robust initial placement via standard bin packing algorithms, while the targeted ruin-and-recreate local search effectively escapes local optima to further minimize the maximum pressure.
**Program Identifier:** Generation 22 - Patch Name binary_search_vnd_rebalance - Correct Program: True

**Program Name: Binary Search with Linearized Constraints and Variance-Aware Local Search**
- **Implementation**: Uses binary search on the objective by transforming the non-linear pressure formula into linear constraints, employing multiple best-fit strategies, and refines the result using local search with variance reduction.
- **Performance**: Achieved a high combined score of 26.23 with 100% success rate and fast execution (0.022s).
- **Feedback**: The linearization of the objective enabled robust binary search bounds, while using sum-of-squares tie-breaking during local search was critical for fine-tuning load balance across GPUs.
**Program Identifier:** Generation 23 - Patch Name local_search_variance_tiebreaking - Correct Program: True

**Program Name: Multi-Strategy Binary Search with Guided Iterated Local Search**
- **Implementation**: Uses binary search over virtual capacity with varied sorting strategies (FFD/BFD) for initialization, refined by bottleneck-targeted moves, swaps, and a multi-GPU ruin-and-recreate local search.
- **Performance**: Achieved a combined score of 26.23 with 100% success rate and extremely fast execution (0.007s).
- **Feedback**: The approach effectively balances load by specifically targeting the highest-pressure GPU during refinement, while the multi-heuristic initialization ensures robust feasibility handling even in tight constraints.
**Program Identifier:** Generation 24 - Patch Name multistrategy_binsearch_guided_ils - Correct Program: True

**Program Name: Robust Binary Search with Ruin and Recreate LNS Refinement**
- **Implementation**: Uses binary search with multi-heuristic Best Fit Decreasing packing for initialization, followed by Large Neighborhood Search via "Ruin and Recreate" to optimize bottlenecks.
- **Performance**: Achieved a combined score of 26.26 with 100% success and very fast execution (0.03s).
- **Feedback**: The multi-heuristic packing initialization provides a strong starting point, and the targeted Ruin and Recreate strategy efficiently smooths out pressure spikes across GPUs.
**Program Identifier:** Generation 25 - Patch Name robust_lns_packing - Correct Program: True

**Program Name: Binary Search with Multi-Heuristic Packing and Simulated Annealing**
- **Implementation**: Utilizes binary search to minimize max KV pressure by checking feasibility with multiple packing heuristics (FFD/BFD on various sort keys), intended to be refined by a simulated annealing local search.
- **Performance**: Score: 0.00 (Failed); the program fails execution due to a runtime error.
- **Feedback**: The main function calls an undefined `_large_neighborhood_search` instead of the implemented `_simulated_annealing`, causing a crash; fixing this naming error is essential to evaluate the otherwise sophisticated packing logic.
**Program Identifier:** Generation 26 - Patch Name lns_refinement - Correct Program: False

**Program Name: Binary Search Packing with LNS Refinement**
- **Implementation**: The algorithm utilizes binary search to minimize KV cache pressure, employing Best-Fit Decreasing with multiple sorting heuristics (density, virtual size) to verify feasibility at each step. A post-processing Large Neighborhood Search (Ruin and Recreate) iteratively refines the solution by targeting and re-optimizing the bottleneck GPU.
- **Performance**: The solution achieved a combined score of 26.26 with a 100% success rate and extremely fast execution (0.023s).
- **Feedback**: The approach effectively linearizes the pressure constraint into a virtual bin packing problem, allowing robust standard heuristics to find valid solutions quickly, while LNS successfully reduces the maximum pressure in tight configurations.
**Program Identifier:** Generation 27 - Patch Name binary_search_bfd_lns_recreate - Correct Program: True

**Program Name: Robust Binary Search Packing with Simulated Annealing**
- **Implementation**: The solution employs binary search over the KVPR target using multi-heuristic bin packing (FFD/BFD) for initialization, followed by a simulated annealing refinement stage to balance loads.
- **Performance**: Achieved a score of 0.00 with 0% success rate due to a runtime error.
- **Feedback**: The program crashes because it calls an undefined function `_large_neighborhood_search` instead of the implemented `_simulated_annealing_refinement`; fixing this naming mismatch is required for functionality.
**Program Identifier:** Generation 28 - Patch Name lns_ruin_recreate - Correct Program: False

**Program Name: Robust Binary Search with Multi-Strategy Packing and Local Search**
- **Implementation**: This approach combines a binary search for the pressure bound using four sorting heuristics and Best/First-Fit packing with an Iterated Local Search (Ruin & Recreate) for refinement. The local search specifically targets the bottleneck GPU to redistribute load using a greedy best-fit strategy with stochastic acceptance.
- **Performance**: The algorithm achieved a high combined score of 26.23 with a 100% success rate and extremely fast execution time (0.006s).
- **Feedback**: The use of multiple sorting heuristics during the construction phase ensures robust feasibility detection across varied inputs. The subsequent local search effectively optimizes the specific KV pressure metric by escaping local optima through plateau traversal and random walks.
**Program Identifier:** Generation 29 - Patch Name robust_binary_search_with_ils - Correct Program: True

# GLOBAL INSIGHTS SCRATCHPAD

The following are global insights about optimization approaches and their effectiveness:

Based on the detailed analysis of individual program summaries (Generations 20-29) and the provided code for the Current Best Program, here are the actionable optimization insights:

## Successful Algorithmic Patterns
- **Binary Search with Dual-Key Feasibility**: The highest-performing programs (Current Best, Gen 27) verify feasibility during the binary search using a fallback mechanism: they first attempt packing sorted by "Virtual Size" ($w + K \cdot s$), and if that fails, retry sorted by "Physical Size" ($s$). This creates a tighter, more robust lower bound for the objective than single-heuristic approaches.
- **Global Stochastic "Kicks"**: While many programs use local search, the ones achieving the top score of **26.26** (Gen 25, Gen 27) utilize a specific "Ruin and Recreate" or "Kick" strategy. Unlike the descent phase which targets bottlenecks, this perturbation moves models between *random* GPUs (not necessarily the bottleneck) when progress stalls, effectively reshuffling the global state to escape the deep local optimum at 26.23.
- **Bottleneck-Exclusive Descent**: The effective local search pattern (Current Best) explicitly identifies the single GPU with the maximum pressure (`src`) and restricts all deterministic optimization moves (swaps/relocations) to reducing the load on that specific device. This focuses computational resources entirely on the objective function ($min(\max(K))$).

## Ineffective Approaches
- **Deterministic Hill Climbing**: Programs relying on purely greedy iterative improvement (Gen 20, 22, 23, 29) consistently plateaued at a score of **26.23**. Without a mechanism to accept temporary degradation (like the "Kick" in ILS) or traverse plateaus, these algorithms could not bridge the gap to the 26.26 solution.
- **Unverified Complexity**: Generations 26 and 28 attempted to implement Simulated Annealing but failed with 0% success due to `NameError` crashes (calling undefined functions). This highlights that adding algorithmic complexity (SA) increases implementation risk without finding the "simple" stochastic fix (Random Kicks) that actually works.
- **Pure Heuristic Proliferation**: Gen 29 utilized four different sorting heuristics during the packing phase but still only achieved 26.23. Simply adding more constructive heuristics yields diminishing returns compared to implementing a robust post-construction refinement phase.

## Implementation Insights
- **Virtual Size Linearization**: The Current Best Program implements a critical transformation in `_check_feasibility_multi`: `pack_items.sort(key=lambda x: x['w'] + K * x['s'])`. This linear combination of intensity ($w$) and size ($s$) scaled by the target ratio ($K$) allows standard scalar Bin Packing algorithms to solve the 2D vector packing problem effectively.
- **Patience-Based Control Flow**: A specific coding pattern separates the 26.26 scorers from the rest: a `patience` counter (set to 30 in the best code). If the bottleneck GPU is not improved after 30 attempts, the algorithm forces a `_kick`â€”a random move between arbitrary GPUs. This distinct state-machine logic (Optimizing $\to$ Stalled $\to$ Kicking $\to$ Optimizing) is key to performance.
- **Efficient Tie-Breaking**: The local search acceptance criteria in the best code uses `max(nk_src, nk_dst) < max_k - 1e-6`. It does not look for "better average" load, but strictly requires a reduction in the *maximum* pressure, preventing cyclic moves that simply shift the bottleneck around without reducing the peak.

## Performance Analysis
- **The "26.23" vs "26.26" Cliff**: There is a definitive performance wall at 26.23, hit by almost all deterministic binary search approaches (Gen 20-24, 29). The jump to 26.26 is only achieved by programs (Gen 25, 27) that incorporate aggressive, randomized perturbation (LNS/ILS).
- **Execution Speed**: Despite running a Binary Search (approx. 50 calls to packing

# META RECOMMENDATIONS

The following are actionable recommendations for the next program generations:

Based on the successful "Binary Search Packing + Iterated Local Search" pattern of the current best program (Score: 26.26), here are 5 actionable recommendations for future mutations:

1.  **Upgrade to Best-Fit Decreasing (BFD) Packing**: The current `_pack` function utilizes First-Fit, which places models in the first valid GPU, often fragmenting capacity. Modify `_pack` to implement **Best-Fit Decreasing**, which scans all valid GPUs and places the current model into the one with the *minimum sufficient residual virtual capacity*. This tighter packing minimizes waste and can validate lower target KVPRs during the binary search.
2.  **Implement Variance-Based Tie-Breaking**: The current local search strictly rejects moves unless they lower the global maximum (`max(nk_src, nk_dst) < max_k`). Modify the acceptance criteria to handle **ties** (where new max pressure equals old max) by accepting configurations that lower the **sum of squared pressures** (variance). This allows the algorithm to traverse plateaus and "smooth" the load distribution, creating slack for future peak reductions.
3.  **Intensify Perturbation with "Burst Kicks"**: The current single-item random kick is effective but often insufficient to escape deep local optima. Replace it with a **Burst Kick** strategy that performs a sequence of 3-5 random moves or swaps (ignoring feasibility of the objective function) before restarting the optimization phase. This larger state-space jump prevents the greedy descent from immediately reversing the perturbation.
4.  **Add Intensity-Density Sorting Heuristic**: Expand the `_check_feasibility_multi` function to include a third sorting key: **Intensity Density** (`(req_rate/slo) / model_size`). While "Virtual Size" balances constraints, sorting by density ensures that small, high-intensity models are packed early, preventing them from becoming difficult "outliers" that fail the packing in later stages when fragmentation is high.
5.  **Switch to Best-Improvement Descent**: The current local search implements "First-Improvement" (executing the first valid move found). Transition to **Best-Improvement** by evaluating all possible moves and swaps for the bottleneck GPU, and then executing the single move that results in the *lowest* new peak pressure. This is more computationally intensive but typically converges to a higher-quality local optimum.