<NAME>
replace_vnd_with_ils
</NAME>

<DESCRIPTION>
Replaces the Variable Neighborhood Descent (VND) refinement phase with an Iterated Local Search (ILS) strategy. The ILS uses Best-Improvement Descent (exploring all moves/swaps on the bottleneck) combined with Variance-Based Tie-Breaking (accepting moves that reduce pressure variance even if max pressure is unchanged). It also employs a "Burst Kick" perturbation (repacking bottleneck + multiple random partners) to escape local optima. This approach previously achieved higher scores by better navigating the fitness landscape's plateaus.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # --- Part 2: Variable Neighborhood Descent (Local Search) ---

    def get_stats(placements_dict):
        stats = []
        max_p = -1.0
        bn_idx = -1

        for g in range(gpu_num):
            items = placements_dict[g]
            l = sum(m.req_rate / m.slo for m in items)
            u = sum(m.model_size for m in items)
            rem = GPU_MEM_SIZE - u

            p = float('inf')
            if rem > 1e-6:
                p = l / rem
            elif l == 0:
                p = 0.0

            if p > max_p:
                max_p = p
                bn_idx = g

            stats.append({'l': l, 'u': u, 'p': p, 'items': list(items), 'id': g})
        return max_p, bn_idx, stats

    # Iterative improvement
    iter_limit = 150
    for _ in range(iter_limit):
        curr_max, bn, g_stats = get_stats(placement)

        if bn == -1: break

        improved = False
        bn_items = g_stats[bn]['items']

        # Sort targets by pressure (prefer empty/low pressure GPUs)
        targets = sorted(range(gpu_num), key=lambda x: g_stats[x]['p'])

        # Neighborhood 1: Move Item
        # Try moving items from Bottleneck to others
        for m in bn_items:
            w = m.req_rate / m.slo
            s = m.model_size

            # Check source improvement
            src_rem = GPU_MEM_SIZE - (g_stats[bn]['u'] - s)
            if src_rem <= 1e-6: continue
            src_p = (g_stats[bn]['l'] - w) / src_rem
            if src_p >= curr_max - 1e-6: continue

            for dst in targets:
                if dst == bn: continue

                dst_stat = g_stats[dst]
                if dst_stat['u'] + s >= GPU_MEM_SIZE - 1e-6: continue

                dst_p = (dst_stat['l'] + w) / (GPU_MEM_SIZE - (dst_stat['u'] + s))

                # Check global improvement (both source and dest must be < curr_max)
                if dst_p < curr_max - 1e-6:
                    placement[bn].remove(m)
                    placement[dst].append(m)
                    improved = True
                    break
            if improved: break
        if improved: continue

        # Neighborhood 2: Swap Item
        # Try swapping items between Bottleneck and others
        for dst in targets:
            if dst == bn: continue

            dst_items = g_stats[dst]['items']
            for m_bn in bn_items:
                w1, s1 = m_bn.req_rate/m_bn.slo, m_bn.model_size

                for m_dst in dst_items:
                    w2, s2 = m_dst.req_rate/m_dst.slo, m_dst.model_size

                    # New Bottleneck State
                    bn_u = g_stats[bn]['u'] - s1 + s2
                    if bn_u >= GPU_MEM_SIZE - 1e-6: continue
                    bn_p = (g_stats[bn]['l'] - w1 + w2) / (GPU_MEM_SIZE - bn_u)

                    if bn_p >= curr_max - 1e-6: continue

                    # New Dest State
                    dst_u = g_stats[dst]['u'] - s2 + s1
                    if dst_u >= GPU_MEM_SIZE - 1e-6: continue
                    dst_p = (g_stats[dst]['l'] - w2 + w1) / (GPU_MEM_SIZE - dst_u)

                    if dst_p < curr_max - 1e-6:
                        placement[bn].remove(m_bn)
                        placement[bn].append(m_dst)
                        placement[dst].remove(m_dst)
                        placement[dst].append(m_bn)
                        improved = True
                        break
                if improved: break
            if improved: break
        if improved: continue

        # Neighborhood 3: Pairwise Ruin and Recreate (Shuffle)
        # Select Bottleneck and the Lowest Pressure GPU
        partner = targets[0] if targets[0] != bn else targets[1]

        pool = placement[bn] + placement[partner]
        pool_data = []
        for m in pool:
            pool_data.append({'w': m.req_rate/m.slo, 's': m.model_size, 'obj': m})

        # Strategies: standard sorts + random shuffles
        pair_strategies = [
            lambda x: x['w']/x['s'] if x['s'] > 0 else 0,
            lambda x: x['s'],
            'shuffle', 'shuffle', 'shuffle', 'shuffle'
        ]

        best_pair_max = curr_max
        best_cfg = None

        for strat in pair_strategies:
            if strat == 'shuffle':
                rng.shuffle(pool_data)
                curr_sorted = pool_data
            else:
                curr_sorted = sorted(pool_data, key=strat, reverse=True)

            # Simple Best Fit Minimizing Pressure on 2 bins
            l_bins_l = [0.0, 0.0]
            l_bins_u = [0.0, 0.0]
            l_bins_objs = [[], []]
            possible = True

            for item in curr_sorted:
                best_b = -1
                min_p = float('inf')

                for b in [0, 1]:
                    rem = GPU_MEM_SIZE - l_bins_u[b] - item['s']
                    if rem > 1e-6:
                        p = (l_bins_l[b] + item['w']) / rem
                        if p < min_p:
                            min_p = p
                            best_b = b

                if best_b == -1:
                    possible = False
                    break

                l_bins_l[best_b] += item['w']
                l_bins_u[best_b] += item['s']
                l_bins_objs[best_b].append(item['obj'])

            if possible:
                p0 = l_bins_l[0] / (GPU_MEM_SIZE - l_bins_u[0])
                p1 = l_bins_l[1] / (GPU_MEM_SIZE - l_bins_u[1])
                local_max = max(p0, p1)

                if local_max < best_pair_max - 1e-6:
                    best_pair_max = local_max
                    best_cfg = l_bins_objs

        if best_cfg:
            placement[bn] = best_cfg[0]
            placement[partner] = best_cfg[1]
            improved = True

        if not improved: break

    return placement
=======
    # --- Part 2: Iterated Local Search (Refinement) ---

    current_placement = placement

    # Initialize state
    loads = [0.0] * gpu_num
    used = [0.0] * gpu_num
    for g in range(gpu_num):
        for m in current_placement[g]:
            loads[g] += m.req_rate / m.slo
            used[g] += m.model_size

    best_placement = {k: list(v) for k, v in current_placement.items()}

    def get_pressure(l, u):
        rem = GPU_MEM_SIZE - u
        if rem <= 1e-6: return float('inf') if l > 1e-6 else 0.0
        return l / rem

    pressures = [get_pressure(loads[g], used[g]) for g in range(gpu_num)]
    best_max_p = max(pressures)

    # ILS Parameters
    max_iters = 250

    for iteration in range(max_iters):
        current_max_p = max(pressures)
        current_sum_sq = sum(p*p for p in pressures)

        if current_max_p < best_max_p - 1e-7:
            best_max_p = current_max_p
            best_placement = {k: list(v) for k, v in current_placement.items()}

        # Bottleneck identification
        bottleneck = -1
        max_val = -1.0
        for g in range(gpu_num):
            if pressures[g] > max_val:
                max_val = pressures[g]
                bottleneck = g

        if bottleneck == -1: break

        # --- Descent: Best Improvement ---
        best_move = None
        # (type, partner, idx_bn, idx_pt, nb_l, nb_u, np_l, np_u, max_p, sum_sq)

        bn_items = current_placement[bottleneck]

        # Sort pressures to get top few for efficient max checking
        sorted_p_indices = sorted(range(gpu_num), key=lambda i: pressures[i], reverse=True)

        for partner in range(gpu_num):
            if partner == bottleneck: continue

            # Efficient max_others calculation
            max_others = 0.0
            for idx in sorted_p_indices:
                if idx != bottleneck and idx != partner:
                    max_others = pressures[idx]
                    break

            sq_base = current_sum_sq - (pressures[bottleneck]**2 + pressures[partner]**2)

            # 1. Move BN -> Partner
            for i, m in enumerate(bn_items):
                w, s = m.req_rate/m.slo, m.model_size
                if used[partner] + s >= GPU_MEM_SIZE - 1e-6: continue

                n_bl = loads[bottleneck] - w
                n_bu = used[bottleneck] - s
                n_pl = loads[partner] + w
                n_pu = used[partner] + s

                pb = get_pressure(n_bl, n_bu)
                pp = get_pressure(n_pl, n_pu)

                nm = max(max_others, pb, pp)

                # Pruning
                if nm > current_max_p + 1e-9: continue

                nsq = sq_base + pb**2 + pp**2

                better = False
                if nm < current_max_p - 1e-9: better = True
                elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                if better:
                    if best_move is None:
                        best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, nm, nsq)
                    else:
                        if nm < best_move[8] - 1e-9:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, nm, nsq)
                        elif abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]:
                            best_move = ('move', partner, i, -1, n_bl, n_bu, n_pl, n_pu, nm, nsq)

            # 2. Swap BN <-> Partner
            pt_items = current_placement[partner]
            for i, m1 in enumerate(bn_items):
                w1, s1 = m1.req_rate/m1.slo, m1.model_size
                for j, m2 in enumerate(pt_items):
                    w2, s2 = m2.req_rate/m2.slo, m2.model_size

                    n_bu = used[bottleneck] - s1 + s2
                    if n_bu >= GPU_MEM_SIZE - 1e-6: continue
                    n_pu = used[partner] - s2 + s1
                    if n_pu >= GPU_MEM_SIZE - 1e-6: continue

                    n_bl = loads[bottleneck] - w1 + w2
                    n_pl = loads[partner] - w2 + w1

                    pb = get_pressure(n_bl, n_bu)
                    pp = get_pressure(n_pl, n_pu)

                    nm = max(max_others, pb, pp)
                    if nm > current_max_p + 1e-9: continue
                    nsq = sq_base + pb**2 + pp**2

                    better = False
                    if nm < current_max_p - 1e-9: better = True
                    elif nm < current_max_p + 1e-9 and nsq < current_sum_sq - 1e-9: better = True

                    if better:
                        if best_move is None:
                            best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, nm, nsq)
                        else:
                            if nm < best_move[8] - 1e-9:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, nm, nsq)
                            elif abs(nm - best_move[8]) < 1e-9 and nsq < best_move[9]:
                                best_move = ('swap', partner, i, j, n_bl, n_bu, n_pl, n_pu, nm, nsq)

        if best_move:
            mtype, pt, i, j, nbl, nbu, npl, npu, _, _ = best_move
            if mtype == 'move':
                item = current_placement[bottleneck].pop(i)
                current_placement[pt].append(item)
            else:
                item1 = current_placement[bottleneck][i]
                item2 = current_placement[pt][j]
                current_placement[bottleneck][i] = item2
                current_placement[pt][j] = item1

            loads[bottleneck], used[bottleneck] = nbl, nbu
            loads[pt], used[pt] = npl, npu
            pressures[bottleneck] = get_pressure(nbl, nbu)
            pressures[pt] = get_pressure(npl, npu)
            continue

        # --- Smart Perturbation (Burst Kick) ---
        victims = {bottleneck}

        candidates = [g for g in range(gpu_num) if g not in victims]
        if candidates:
            # Pick up to 2 random partners
            k = min(len(candidates), 2)
            victims.update(rng.sample(candidates, k))

        victim_list = list(victims)

        # Extract items
        repack_items = []
        for v in victim_list:
            repack_items.extend(current_placement[v])
            current_placement[v] = []
            loads[v] = 0.0
            used[v] = 0.0
            pressures[v] = 0.0

        # Try multiple random greedy packings
        best_local_config = None
        best_local_max = float('inf')

        for _ in range(5):
            iter_items = list(repack_items)
            # Randomized Density Sort
            iter_items.sort(key=lambda x: ((x.req_rate/x.slo)/(x.model_size+1e-6)) * rng.uniform(0.8, 1.2), reverse=True)

            l_loads = {v: 0.0 for v in victim_list}
            l_used = {v: 0.0 for v in victim_list}
            l_placement = {v: [] for v in victim_list}
            possible = True

            for item in iter_items:
                w, s = item.req_rate / item.slo, item.model_size
                best_v = -1
                best_score = float('inf')

                # Best Fit minimizing pressure
                for v in victim_list:
                    rem = GPU_MEM_SIZE - l_used[v] - s
                    if rem > 1e-6:
                        p = (l_loads[v] + w) / rem
                        if p < best_score:
                            best_score = p
                            best_v = v

                if best_v == -1:
                    # Fallback
                    for v in victim_list:
                        if l_used[v] + s <= GPU_MEM_SIZE - 1e-6:
                            best_v = v
                            break

                if best_v != -1:
                    l_placement[best_v].append(item)
                    l_loads[best_v] += w
                    l_used[best_v] += s
                else:
                    possible = False
                    break

            if possible:
                local_max = max(get_pressure(l_loads[v], l_used[v]) for v in victim_list)
                if local_max < best_local_max:
                    best_local_max = local_max
                    best_local_config = (l_placement, l_loads, l_used)

        if best_local_config:
            l_place, l_l, l_u = best_local_config
            for v in victim_list:
                current_placement[v] = l_place[v]
                loads[v] = l_l[v]
                used[v] = l_u[v]
                pressures[v] = get_pressure(loads[v], used[v])
        else:
            # Revert to global best
            current_placement = {k: list(v) for k, v in best_placement.items()}
            # Recompute state
            loads = [0.0]*gpu_num
            used = [0.0]*gpu_num
            for g in range(gpu_num):
                for m in current_placement[g]:
                    loads[g] += m.req_rate / m.slo
                    used[g] += m.model_size
            pressures = [get_pressure(loads[g], used[g]) for g in range(gpu_num)]

            # If failing repeatedly at perturbation, exit early
            if iteration > max_iters * 0.95: break

    return best_placement
>>>>>>> REPLACE
</DIFF>